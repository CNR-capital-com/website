/******/ var __webpack_modules__ = ({

/***/ 921:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*jshint node:true */
/* globals define */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

*/



/**
The following batches are equivalent:

var beautify_js = require('js-beautify');
var beautify_js = require('js-beautify').js;
var beautify_js = require('js-beautify').js_beautify;

var beautify_css = require('js-beautify').css;
var beautify_css = require('js-beautify').css_beautify;

var beautify_html = require('js-beautify').html;
var beautify_html = require('js-beautify').html_beautify;

All methods returned accept two arguments, the source string and an options object.
**/

function get_beautify(js_beautify, css_beautify, html_beautify) {
  // the default is js
  var beautify = function(src, config) {
    return js_beautify.js_beautify(src, config);
  };

  // short aliases
  beautify.js = js_beautify.js_beautify;
  beautify.css = css_beautify.css_beautify;
  beautify.html = html_beautify.html_beautify;

  // legacy aliases
  beautify.js_beautify = js_beautify.js_beautify;
  beautify.css_beautify = css_beautify.css_beautify;
  beautify.html_beautify = html_beautify.html_beautify;

  return beautify;
}

if (true) {
  // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
    __webpack_require__(94),
    __webpack_require__(838),
    __webpack_require__(600)
  ], __WEBPACK_AMD_DEFINE_RESULT__ = (function(js_beautify, css_beautify, html_beautify) {
    return get_beautify(js_beautify, css_beautify, html_beautify);
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

/***/ }),

/***/ 838:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 CSS Beautifier
---------------

    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)

    Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>
        https://beautifier.io/

    Usage:
        css_beautify(source_text);
        css_beautify(source_text, options);

    The options are (default in brackets):
        indent_size (4)                         — indentation size,
        indent_char (space)                     — character to indent with,
        selector_separator_newline (true)       - separate selectors with newline or
                                                  not (e.g. "a,\nbr" or "a, br")
        end_with_newline (false)                - end with a newline
        newline_between_rules (true)            - add a new line after every css rule
        space_around_selector_separator (false) - ensure space around selector separators:
                                                  '>', '+', '~' (e.g. "a>b" -> "a > b")
    e.g

    css_beautify(css_source_text, {
      'indent_size': 1,
      'indent_char': '\t',
      'selector_separator': ' ',
      'end_with_newline': false,
      'newline_between_rules': true,
      'space_around_selector_separator': true
    });
*/

// http://www.w3.org/TR/CSS21/syndata.html#tokenization
// http://www.w3.org/TR/css3-syntax/

(function() {

/* GENERATED_BUILD_OUTPUT */
var legacy_beautify_css;
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module) {

/*jshint node:true */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

module.exports.Output = Output;


/***/ }),
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

module.exports.Options = Options;
module.exports.normalizeOpts = _normalizeOpts;
module.exports.mergeOpts = _mergeOpts;


/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

module.exports.InputScanner = InputScanner;


/***/ }),
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


module.exports.Directives = Directives;


/***/ }),
/* 14 */,
/* 15 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_30126__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Beautifier = (__nested_webpack_require_30126__(16).Beautifier),
  Options = (__nested_webpack_require_30126__(17).Options);

function css_beautify(source_text, options) {
  var beautifier = new Beautifier(source_text, options);
  return beautifier.beautify();
}

module.exports = css_beautify;
module.exports.defaultOptions = function() {
  return new Options();
};


/***/ }),
/* 16 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_31754__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Options = (__nested_webpack_require_31754__(17).Options);
var Output = (__nested_webpack_require_31754__(2).Output);
var InputScanner = (__nested_webpack_require_31754__(8).InputScanner);
var Directives = (__nested_webpack_require_31754__(13).Directives);

var directives_core = new Directives(/\/\*/, /\*\//);

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

// tokenizer
var whitespaceChar = /\s/;
var whitespacePattern = /(?:\s|\n)+/g;
var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;

function Beautifier(source_text, options) {
  this._source_text = source_text || '';
  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  this._options = new Options(options);
  this._ch = null;
  this._input = null;

  // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule
  this.NESTED_AT_RULE = {
    "page": true,
    "font-face": true,
    "keyframes": true,
    // also in CONDITIONAL_GROUP_RULE below
    "media": true,
    "supports": true,
    "document": true
  };
  this.CONDITIONAL_GROUP_RULE = {
    "media": true,
    "supports": true,
    "document": true
  };
  this.NON_SEMICOLON_NEWLINE_PROPERTY = [
    "grid-template-areas",
    "grid-template"
  ];

}

Beautifier.prototype.eatString = function(endChars) {
  var result = '';
  this._ch = this._input.next();
  while (this._ch) {
    result += this._ch;
    if (this._ch === "\\") {
      result += this._input.next();
    } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
      break;
    }
    this._ch = this._input.next();
  }
  return result;
};

// Skips any white space in the source text from the current position.
// When allowAtLeastOneNewLine is true, will output new lines for each
// newline character found; if the user has preserve_newlines off, only
// the first newline will be output
Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
  var result = whitespaceChar.test(this._input.peek());
  var newline_count = 0;
  while (whitespaceChar.test(this._input.peek())) {
    this._ch = this._input.next();
    if (allowAtLeastOneNewLine && this._ch === '\n') {
      if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
        newline_count++;
        this._output.add_new_line(true);
      }
    }
  }
  return result;
};

// Nested pseudo-class if we are insideRule
// and the next special character found opens
// a new block
Beautifier.prototype.foundNestedPseudoClass = function() {
  var openParen = 0;
  var i = 1;
  var ch = this._input.peek(i);
  while (ch) {
    if (ch === "{") {
      return true;
    } else if (ch === '(') {
      // pseudoclasses can contain ()
      openParen += 1;
    } else if (ch === ')') {
      if (openParen === 0) {
        return false;
      }
      openParen -= 1;
    } else if (ch === ";" || ch === "}") {
      return false;
    }
    i++;
    ch = this._input.peek(i);
  }
  return false;
};

Beautifier.prototype.print_string = function(output_string) {
  this._output.set_indent(this._indentLevel);
  this._output.non_breaking_space = true;
  this._output.add_token(output_string);
};

Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
  if (isAfterSpace) {
    this._output.space_before_token = true;
  }
};

Beautifier.prototype.indent = function() {
  this._indentLevel++;
};

Beautifier.prototype.outdent = function() {
  if (this._indentLevel > 0) {
    this._indentLevel--;
  }
};

/*_____________________--------------------_____________________*/

Beautifier.prototype.beautify = function() {
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text || '')) {
      eol = source_text.match(lineBreak)[0];
    }
  }


  // HACK: newline parsing inconsistent. This brute force normalizes the this._input.
  source_text = source_text.replace(allLineBreaks, '\n');

  // reset
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._output = new Output(this._options, baseIndentString);
  this._input = new InputScanner(source_text);
  this._indentLevel = 0;
  this._nestedLevel = 0;

  this._ch = null;
  var parenLevel = 0;

  var insideRule = false;
  // This is the value side of a property value pair (blue in the following ex)
  // label { content: blue }
  var insidePropertyValue = false;
  var enteringConditionalGroup = false;
  var insideNonNestedAtRule = false;
  var insideScssMap = false;
  var topCharacter = this._ch;
  var insideNonSemiColonValues = false;
  var whitespace;
  var isAfterSpace;
  var previous_ch;

  while (true) {
    whitespace = this._input.read(whitespacePattern);
    isAfterSpace = whitespace !== '';
    previous_ch = topCharacter;
    this._ch = this._input.next();
    if (this._ch === '\\' && this._input.hasNext()) {
      this._ch += this._input.next();
    }
    topCharacter = this._ch;

    if (!this._ch) {
      break;
    } else if (this._ch === '/' && this._input.peek() === '*') {
      // /* css comment */
      // Always start block comments on a new line.
      // This handles scenarios where a block comment immediately
      // follows a property definition on the same line or where
      // minified code is being beautified.
      this._output.add_new_line();
      this._input.back();

      var comment = this._input.read(block_comment_pattern);

      // Handle ignore directive
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }

      this.print_string(comment);

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);

      // Block comments are followed by a new line so they don't
      // share a line with other properties
      this._output.add_new_line();
    } else if (this._ch === '/' && this._input.peek() === '/') {
      // // single line comment
      // Preserves the space before a comment
      // on the same line as a rule
      this._output.space_before_token = true;
      this._input.back();
      this.print_string(this._input.read(comment_pattern));

      // Ensures any new lines following the comment are preserved
      this.eatWhitespace(true);
    } else if (this._ch === '$') {
      this.preserveSingleSpace(isAfterSpace);

      this.print_string(this._ch);

      // strip trailing space, if present, for hash property checks
      var variable = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

      if (variable.match(/[ :]$/)) {
        // we have a variable or pseudo-class, add it and insert one space before continuing
        variable = this.eatString(": ").replace(/\s+$/, '');
        this.print_string(variable);
        this._output.space_before_token = true;
      }

      // might be sass variable
      if (parenLevel === 0 && variable.indexOf(':') !== -1) {
        insidePropertyValue = true;
        this.indent();
      }
    } else if (this._ch === '@') {
      this.preserveSingleSpace(isAfterSpace);

      // deal with less property mixins @{...}
      if (this._input.peek() === '{') {
        this.print_string(this._ch + this.eatString('}'));
      } else {
        this.print_string(this._ch);

        // strip trailing space, if present, for hash property checks
        var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);

        if (variableOrRule.match(/[ :]$/)) {
          // we have a variable or pseudo-class, add it and insert one space before continuing
          variableOrRule = this.eatString(": ").replace(/\s+$/, '');
          this.print_string(variableOrRule);
          this._output.space_before_token = true;
        }

        // might be less variable
        if (parenLevel === 0 && variableOrRule.indexOf(':') !== -1) {
          insidePropertyValue = true;
          this.indent();

          // might be a nesting at-rule
        } else if (variableOrRule in this.NESTED_AT_RULE) {
          this._nestedLevel += 1;
          if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
            enteringConditionalGroup = true;
          }

          // might be a non-nested at-rule
        } else if (parenLevel === 0 && !insidePropertyValue) {
          insideNonNestedAtRule = true;
        }
      }
    } else if (this._ch === '#' && this._input.peek() === '{') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch + this.eatString('}'));
    } else if (this._ch === '{') {
      if (insidePropertyValue) {
        insidePropertyValue = false;
        this.outdent();
      }

      // non nested at rule becomes nested
      insideNonNestedAtRule = false;

      // when entering conditional groups, only rulesets are allowed
      if (enteringConditionalGroup) {
        enteringConditionalGroup = false;
        insideRule = (this._indentLevel >= this._nestedLevel);
      } else {
        // otherwise, declarations are also allowed
        insideRule = (this._indentLevel >= this._nestedLevel - 1);
      }
      if (this._options.newline_between_rules && insideRule) {
        if (this._output.previous_line && this._output.previous_line.item(-1) !== '{') {
          this._output.ensure_empty_line_above('/', ',');
        }
      }

      this._output.space_before_token = true;

      // The difference in print_string and indent order is necessary to indent the '{' correctly
      if (this._options.brace_style === 'expand') {
        this._output.add_new_line();
        this.print_string(this._ch);
        this.indent();
        this._output.set_indent(this._indentLevel);
      } else {
        // inside mixin and first param is object
        if (previous_ch === '(') {
          this._output.space_before_token = false;
        } else if (previous_ch !== ',') {
          this.indent();
        }
        this.print_string(this._ch);
      }

      this.eatWhitespace(true);
      this._output.add_new_line();
    } else if (this._ch === '}') {
      this.outdent();
      this._output.add_new_line();
      if (previous_ch === '{') {
        this._output.trim(true);
      }

      if (insidePropertyValue) {
        this.outdent();
        insidePropertyValue = false;
      }
      this.print_string(this._ch);
      insideRule = false;
      if (this._nestedLevel) {
        this._nestedLevel--;
      }

      this.eatWhitespace(true);
      this._output.add_new_line();

      if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
        if (this._input.peek() !== '}') {
          this._output.add_new_line(true);
        }
      }
      if (this._input.peek() === ')') {
        this._output.trim(true);
        if (this._options.brace_style === "expand") {
          this._output.add_new_line(true);
        }
      }
    } else if (this._ch === ":") {

      for (var i = 0; i < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i++) {
        if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i])) {
          insideNonSemiColonValues = true;
          break;
        }
      }

      if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideNonNestedAtRule && parenLevel === 0) {
        // 'property: value' delimiter
        // which could be in a conditional group query

        this.print_string(':');
        if (!insidePropertyValue) {
          insidePropertyValue = true;
          this._output.space_before_token = true;
          this.eatWhitespace(true);
          this.indent();
        }
      } else {
        // sass/less parent reference don't use a space
        // sass nested pseudo-class don't use a space

        // preserve space before pseudoclasses/pseudoelements, as it means "in any child"
        if (this._input.lookBack(" ")) {
          this._output.space_before_token = true;
        }
        if (this._input.peek() === ":") {
          // pseudo-element
          this._ch = this._input.next();
          this.print_string("::");
        } else {
          // pseudo-class
          this.print_string(':');
        }
      }
    } else if (this._ch === '"' || this._ch === '\'') {
      var preserveQuoteSpace = previous_ch === '"' || previous_ch === '\'';
      this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
      this.print_string(this._ch + this.eatString(this._ch));
      this.eatWhitespace(true);
    } else if (this._ch === ';') {
      insideNonSemiColonValues = false;
      if (parenLevel === 0) {
        if (insidePropertyValue) {
          this.outdent();
          insidePropertyValue = false;
        }
        insideNonNestedAtRule = false;
        this.print_string(this._ch);
        this.eatWhitespace(true);

        // This maintains single line comments on the same
        // line. Block comments are also affected, but
        // a new line is always output before one inside
        // that section
        if (this._input.peek() !== '/') {
          this._output.add_new_line();
        }
      } else {
        this.print_string(this._ch);
        this.eatWhitespace(true);
        this._output.space_before_token = true;
      }
    } else if (this._ch === '(') { // may be a url
      if (this._input.lookBack("url")) {
        this.print_string(this._ch);
        this.eatWhitespace();
        parenLevel++;
        this.indent();
        this._ch = this._input.next();
        if (this._ch === ')' || this._ch === '"' || this._ch === '\'') {
          this._input.back();
        } else if (this._ch) {
          this.print_string(this._ch + this.eatString(')'));
          if (parenLevel) {
            parenLevel--;
            this.outdent();
          }
        }
      } else {
        var space_needed = false;
        if (this._input.lookBack("with")) {
          // look back is not an accurate solution, we need tokens to confirm without whitespaces
          space_needed = true;
        }
        this.preserveSingleSpace(isAfterSpace || space_needed);
        this.print_string(this._ch);

        // handle scss/sass map
        if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
          this._output.add_new_line();
          insideScssMap = true;
        } else {
          this.eatWhitespace();
          parenLevel++;
          this.indent();
        }
      }
    } else if (this._ch === ')') {
      if (parenLevel) {
        parenLevel--;
        this.outdent();
      }
      if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
        insideScssMap = false;
        this.outdent();
        this._output.add_new_line();
      }
      this.print_string(this._ch);
    } else if (this._ch === ',') {
      this.print_string(this._ch);
      this.eatWhitespace(true);
      if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideNonNestedAtRule) {
        this._output.add_new_line();
      } else {
        this._output.space_before_token = true;
      }
    } else if ((this._ch === '>' || this._ch === '+' || this._ch === '~') && !insidePropertyValue && parenLevel === 0) {
      //handle combinator spacing
      if (this._options.space_around_combinator) {
        this._output.space_before_token = true;
        this.print_string(this._ch);
        this._output.space_before_token = true;
      } else {
        this.print_string(this._ch);
        this.eatWhitespace();
        // squash extra whitespace
        if (this._ch && whitespaceChar.test(this._ch)) {
          this._ch = '';
        }
      }
    } else if (this._ch === ']') {
      this.print_string(this._ch);
    } else if (this._ch === '[') {
      this.preserveSingleSpace(isAfterSpace);
      this.print_string(this._ch);
    } else if (this._ch === '=') { // no whitespace before or after
      this.eatWhitespace();
      this.print_string('=');
      if (whitespaceChar.test(this._ch)) {
        this._ch = '';
      }
    } else if (this._ch === '!' && !this._input.lookBack("\\")) { // !important
      this._output.space_before_token = true;
      this.print_string(this._ch);
    } else {
      var preserveAfterSpace = previous_ch === '"' || previous_ch === '\'';
      this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
      this.print_string(this._ch);

      if (!this._output.just_added_newline() && this._input.peek() === '\n' && insideNonSemiColonValues) {
        this._output.add_new_line();
      }
    }
  }

  var sweetCode = this._output.get_code(eol);

  return sweetCode;
};

module.exports.Beautifier = Beautifier;


/***/ }),
/* 17 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_49864__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var BaseOptions = (__nested_webpack_require_49864__(6).Options);

function Options(options) {
  BaseOptions.call(this, options, 'css');

  this.selector_separator_newline = this._get_boolean('selector_separator_newline', true);
  this.newline_between_rules = this._get_boolean('newline_between_rules', true);
  var space_around_selector_separator = this._get_boolean('space_around_selector_separator');
  this.space_around_combinator = this._get_boolean('space_around_combinator') || space_around_selector_separator;

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);
  this.brace_style = 'collapse';
  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] !== 'expand') {
      // default to collapse, as only collapse|expand is implemented for now
      this.brace_style = 'collapse';
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }
}
Options.prototype = new BaseOptions();



module.exports.Options = Options;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_52344__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_52344__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_52344__(15);
/******/ 	legacy_beautify_css = __nested_webpack_exports__;
/******/ 	
/******/ })()
;
var css_beautify = legacy_beautify_css;
/* Footer */
if (true) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return {
            css_beautify: css_beautify
        };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

}());


/***/ }),

/***/ 600:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.


 Style HTML
---------------

  Written by Nochum Sossonko, (nsossonko@hotmail.com)

  Based on code initially developed by: Einar Lielmanis, <einar@beautifier.io>
    https://beautifier.io/

  Usage:
    style_html(html_source);

    style_html(html_source, options);

  The options are:
    indent_inner_html (default false)  — indent <head> and <body> sections,
    indent_size (default 4)          — indentation size,
    indent_char (default space)      — character to indent with,
    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)
    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
    inline (defaults to inline tags) - list of tags to be considered inline tags
    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted
    content_unformatted (defaults to ["pre", "textarea"] tags) - list of tags, whose content shouldn't be reformatted
    indent_scripts (default normal)  - "keep"|"separate"|"normal"
    preserve_newlines (default true) - whether existing line breaks before elements should be preserved
                                        Only works before elements, not inside tags or for text.
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk
    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}
    end_with_newline (false)          - end with a newline
    extra_liners (default [head,body,/html]) -List of tags that should have an extra newline before them.

    e.g.

    style_html(html_source, {
      'indent_inner_html': false,
      'indent_size': 2,
      'indent_char': ' ',
      'wrap_line_length': 78,
      'brace_style': 'expand',
      'preserve_newlines': true,
      'max_preserve_newlines': 5,
      'indent_handlebars': false,
      'extra_liners': ['/html']
    });
*/

(function() {

/* GENERATED_BUILD_OUTPUT */
var legacy_beautify_html;
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ (function(module) {

/*jshint node:true */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

module.exports.Output = Output;


/***/ }),
/* 3 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Token(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


module.exports.Token = Token;


/***/ }),
/* 4 */,
/* 5 */,
/* 6 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

module.exports.Options = Options;
module.exports.normalizeOpts = _normalizeOpts;
module.exports.mergeOpts = _mergeOpts;


/***/ }),
/* 7 */,
/* 8 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

module.exports.InputScanner = InputScanner;


/***/ }),
/* 9 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_30287__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var InputScanner = (__nested_webpack_require_30287__(8).InputScanner);
var Token = (__nested_webpack_require_30287__(3).Token);
var TokenStream = (__nested_webpack_require_30287__(10).TokenStream);
var WhitespacePattern = (__nested_webpack_require_30287__(11).WhitespacePattern);

var TOKEN = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer = function(input_string, options) {
  this._input = new InputScanner(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern(this._input);
};

Tokenizer.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream();

  this._reset();

  var current;
  var previous = new Token(TOKEN.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream();

  while (previous.type !== TOKEN.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer.prototype._reset = function() {};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN.EOF, '');
  }
};

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._create_token = function(type, text) {
  var token = new Token(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;


/***/ }),
/* 10 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function TokenStream(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream.prototype.restart = function() {
  this.__position = 0;
};

TokenStream.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

module.exports.TokenStream = TokenStream;


/***/ }),
/* 11 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_36707__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Pattern = (__nested_webpack_require_36707__(12).Pattern);

function WhitespacePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern.prototype = new Pattern();

WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern.prototype._create = function() {
  return new WhitespacePattern(this._input, this);
};

WhitespacePattern.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



module.exports.WhitespacePattern = WhitespacePattern;


/***/ }),
/* 12 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Pattern(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype._create = function() {
  return new Pattern(this._input, this);
};

Pattern.prototype._update = function() {};

module.exports.Pattern = Pattern;


/***/ }),
/* 13 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


module.exports.Directives = Directives;


/***/ }),
/* 14 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_45694__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Pattern = (__nested_webpack_require_45694__(12).Pattern);


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false,
  smarty: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
  };
}
TemplatablePattern.prototype = new Pattern();

TemplatablePattern.prototype._create = function() {
  return new TemplatablePattern(this._input, this);
};

TemplatablePattern.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    // The starting pattern for django is more complex because it has different
    // patterns for value, comment, and other sections
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }
  if (!this._disabled.smarty) {
    items.push(this.__patterns.smarty._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
    if (!this._disabled.smarty) {
      // smarty cannot be enabled with django or handlebars enabled
      if (this._disabled.django && this._disabled.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.smarty_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty_literal.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty.read();
      }
    }
  }
  return resulting_string;
};


module.exports.TemplatablePattern = TemplatablePattern;


/***/ }),
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_53240__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Beautifier = (__nested_webpack_require_53240__(19).Beautifier),
  Options = (__nested_webpack_require_53240__(20).Options);

function style_html(html_source, options, js_beautify, css_beautify) {
  var beautifier = new Beautifier(html_source, options, js_beautify, css_beautify);
  return beautifier.beautify();
}

module.exports = style_html;
module.exports.defaultOptions = function() {
  return new Options();
};


/***/ }),
/* 19 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_54918__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Options = (__nested_webpack_require_54918__(20).Options);
var Output = (__nested_webpack_require_54918__(2).Output);
var Tokenizer = (__nested_webpack_require_54918__(21).Tokenizer);
var TOKEN = (__nested_webpack_require_54918__(21).TOKEN);

var lineBreak = /\r\n|[\r\n]/;
var allLineBreaks = /\r\n|[\r\n]/g;

var Printer = function(options, base_indent_string) { //handles input/output and some other printing functions

  this.indent_level = 0;
  this.alignment_size = 0;
  this.max_preserve_newlines = options.max_preserve_newlines;
  this.preserve_newlines = options.preserve_newlines;

  this._output = new Output(options, base_indent_string);

};

Printer.prototype.current_line_has_match = function(pattern) {
  return this._output.current_line.has_match(pattern);
};

Printer.prototype.set_space_before_token = function(value, non_breaking) {
  this._output.space_before_token = value;
  this._output.non_breaking_space = non_breaking;
};

Printer.prototype.set_wrap_point = function() {
  this._output.set_indent(this.indent_level, this.alignment_size);
  this._output.set_wrap_point();
};


Printer.prototype.add_raw_token = function(token) {
  this._output.add_raw_token(token);
};

Printer.prototype.print_preserved_newlines = function(raw_token) {
  var newlines = 0;
  if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
    newlines = raw_token.newlines ? 1 : 0;
  }

  if (this.preserve_newlines) {
    newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
  }
  for (var n = 0; n < newlines; n++) {
    this.print_newline(n > 0);
  }

  return newlines !== 0;
};

Printer.prototype.traverse_whitespace = function(raw_token) {
  if (raw_token.whitespace_before || raw_token.newlines) {
    if (!this.print_preserved_newlines(raw_token)) {
      this._output.space_before_token = true;
    }
    return true;
  }
  return false;
};

Printer.prototype.previous_token_wrapped = function() {
  return this._output.previous_token_wrapped;
};

Printer.prototype.print_newline = function(force) {
  this._output.add_new_line(force);
};

Printer.prototype.print_token = function(token) {
  if (token.text) {
    this._output.set_indent(this.indent_level, this.alignment_size);
    this._output.add_token(token.text);
  }
};

Printer.prototype.indent = function() {
  this.indent_level++;
};

Printer.prototype.get_full_indent = function(level) {
  level = this.indent_level + (level || 0);
  if (level < 1) {
    return '';
  }

  return this._output.get_indent_string(level);
};

var get_type_attribute = function(start_token) {
  var result = null;
  var raw_token = start_token.next;

  // Search attributes for a type attribute
  while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
    if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === 'type') {
      if (raw_token.next && raw_token.next.type === TOKEN.EQUALS &&
        raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
        result = raw_token.next.next.text;
      }
      break;
    }
    raw_token = raw_token.next;
  }

  return result;
};

var get_custom_beautifier_name = function(tag_check, raw_token) {
  var typeAttribute = null;
  var result = null;

  if (!raw_token.closed) {
    return null;
  }

  if (tag_check === 'script') {
    typeAttribute = 'text/javascript';
  } else if (tag_check === 'style') {
    typeAttribute = 'text/css';
  }

  typeAttribute = get_type_attribute(raw_token) || typeAttribute;

  // For script and style tags that have a type attribute, only enable custom beautifiers for matching values
  // For those without a type attribute use default;
  if (typeAttribute.search('text/css') > -1) {
    result = 'css';
  } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
    result = 'javascript';
  } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
    result = 'html';
  } else if (typeAttribute.search(/test\/null/) > -1) {
    // Test only mime-type for testing the beautifier when null is passed as beautifing function
    result = 'null';
  }

  return result;
};

function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}

function TagFrame(parent, parser_token, indent_level) {
  this.parent = parent || null;
  this.tag = parser_token ? parser_token.tag_name : '';
  this.indent_level = indent_level || 0;
  this.parser_token = parser_token || null;
}

function TagStack(printer) {
  this._printer = printer;
  this._current_frame = null;
}

TagStack.prototype.get_parser_token = function() {
  return this._current_frame ? this._current_frame.parser_token : null;
};

TagStack.prototype.record_tag = function(parser_token) { //function to record a tag and its parent in this.tags Object
  var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
  this._current_frame = new_frame;
};

TagStack.prototype._try_pop_frame = function(frame) { //function to retrieve the opening tag to the corresponding closer
  var parser_token = null;

  if (frame) {
    parser_token = frame.parser_token;
    this._printer.indent_level = frame.indent_level;
    this._current_frame = frame.parent;
  }

  return parser_token;
};

TagStack.prototype._get_frame = function(tag_list, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._current_frame;

  while (frame) { //till we reach '' (the initial value);
    if (tag_list.indexOf(frame.tag) !== -1) { //if this is it use it
      break;
    } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
      frame = null;
      break;
    }
    frame = frame.parent;
  }

  return frame;
};

TagStack.prototype.try_pop = function(tag, stop_list) { //function to retrieve the opening tag to the corresponding closer
  var frame = this._get_frame([tag], stop_list);
  return this._try_pop_frame(frame);
};

TagStack.prototype.indent_to_tag = function(tag_list) {
  var frame = this._get_frame(tag_list);
  if (frame) {
    this._printer.indent_level = frame.indent_level;
  }
};

function Beautifier(source_text, options, js_beautify, css_beautify) {
  //Wrapper function to invoke all the necessary constructors and deal with the output.
  this._source_text = source_text || '';
  options = options || {};
  this._js_beautify = js_beautify;
  this._css_beautify = css_beautify;
  this._tag_stack = null;

  // Allow the setting of language/file-type specific options
  // with inheritance of overall settings
  var optionHtml = new Options(options, 'html');

  this._options = optionHtml;

  this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, 'force'.length) === 'force';
  this._is_wrap_attributes_force_expand_multiline = (this._options.wrap_attributes === 'force-expand-multiline');
  this._is_wrap_attributes_force_aligned = (this._options.wrap_attributes === 'force-aligned');
  this._is_wrap_attributes_aligned_multiple = (this._options.wrap_attributes === 'aligned-multiple');
  this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, 'preserve'.length) === 'preserve';
  this._is_wrap_attributes_preserve_aligned = (this._options.wrap_attributes === 'preserve-aligned');
}

Beautifier.prototype.beautify = function() {

  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var source_text = this._source_text;
  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && lineBreak.test(source_text)) {
      eol = source_text.match(lineBreak)[0];
    }
  }

  // HACK: newline parsing inconsistent. This brute force normalizes the input.
  source_text = source_text.replace(allLineBreaks, '\n');

  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  var last_token = {
    text: '',
    type: ''
  };

  var last_tag_token = new TagOpenParserToken();

  var printer = new Printer(this._options, baseIndentString);
  var tokens = new Tokenizer(source_text, this._options).tokenize();

  this._tag_stack = new TagStack(printer);

  var parser_token = null;
  var raw_token = tokens.next();
  while (raw_token.type !== TOKEN.EOF) {

    if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
      parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token, tokens);
      last_tag_token = parser_token;
    } else if ((raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE) ||
      (raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete)) {
      parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, last_token);
    } else if (raw_token.type === TOKEN.TAG_CLOSE) {
      parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
    } else if (raw_token.type === TOKEN.TEXT) {
      parser_token = this._handle_text(printer, raw_token, last_tag_token);
    } else {
      // This should never happen, but if it does. Print the raw token
      printer.add_raw_token(raw_token);
    }

    last_token = parser_token;

    raw_token = tokens.next();
  }
  var sweet_code = printer._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };
  printer.alignment_size = 0;
  last_tag_token.tag_complete = true;

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    if (last_tag_token.tag_start_char === '<') {
      printer.set_space_before_token(raw_token.text[0] === '/', true); // space before />, no space before >
      if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
        printer.print_newline(false);
      }
    }
    printer.print_token(raw_token);

  }

  if (last_tag_token.indent_content &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.indent();

    // only indent once per opened tag
    last_tag_token.indent_content = false;
  }

  if (!last_tag_token.is_inline_element &&
    !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
    printer.set_wrap_point();
  }

  return parser_token;
};

Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, last_token) {
  var wrapped = last_tag_token.has_wrapped_attrs;
  var parser_token = {
    text: raw_token.text,
    type: raw_token.type
  };

  printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== '', true);
  if (last_tag_token.is_unformatted) {
    printer.add_raw_token(raw_token);
  } else if (last_tag_token.tag_start_char === '{' && raw_token.type === TOKEN.TEXT) {
    // For the insides of handlebars allow newlines or a single space between open and contents
    if (printer.print_preserved_newlines(raw_token)) {
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
    } else {
      printer.print_token(raw_token);
    }
  } else {
    if (raw_token.type === TOKEN.ATTRIBUTE) {
      printer.set_space_before_token(true);
    } else if (raw_token.type === TOKEN.EQUALS) { //no space before =
      printer.set_space_before_token(false);
    } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) { //no space before value
      printer.set_space_before_token(false);
    }

    if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === '<') {
      if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
        printer.traverse_whitespace(raw_token);
        wrapped = wrapped || raw_token.newlines !== 0;
      }

      // Wrap for 'force' options, and if the number of attributes is at least that specified in 'wrap_attributes_min_attrs':
      // 1. always wrap the second and beyond attributes
      // 2. wrap the first attribute only if 'force-expand-multiline' is specified
      if (this._is_wrap_attributes_force &&
        last_tag_token.attr_count >= this._options.wrap_attributes_min_attrs &&
        (last_token.type !== TOKEN.TAG_OPEN || // ie. second attribute and beyond
          this._is_wrap_attributes_force_expand_multiline)) {
        printer.print_newline(false);
        wrapped = true;
      }
    }
    printer.print_token(raw_token);
    wrapped = wrapped || printer.previous_token_wrapped();
    last_tag_token.has_wrapped_attrs = wrapped;
  }
  return parser_token;
};

Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
  var parser_token = {
    text: raw_token.text,
    type: 'TK_CONTENT'
  };
  if (last_tag_token.custom_beautifier_name) { //check if we need to format javascript
    this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
  } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
    printer.add_raw_token(raw_token);
  } else {
    printer.traverse_whitespace(raw_token);
    printer.print_token(raw_token);
  }
  return parser_token;
};

Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
  var local = this;
  if (raw_token.text !== '') {

    var text = raw_token.text,
      _beautifier,
      script_indent_level = 1,
      pre = '',
      post = '';
    if (last_tag_token.custom_beautifier_name === 'javascript' && typeof this._js_beautify === 'function') {
      _beautifier = this._js_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'css' && typeof this._css_beautify === 'function') {
      _beautifier = this._css_beautify;
    } else if (last_tag_token.custom_beautifier_name === 'html') {
      _beautifier = function(html_source, options) {
        var beautifier = new Beautifier(html_source, options, local._js_beautify, local._css_beautify);
        return beautifier.beautify();
      };
    }

    if (this._options.indent_scripts === "keep") {
      script_indent_level = 0;
    } else if (this._options.indent_scripts === "separate") {
      script_indent_level = -printer.indent_level;
    }

    var indentation = printer.get_full_indent(script_indent_level);

    // if there is at least one empty line at the end of this text, strip it
    // we'll be adding one back after the text but before the containing tag.
    text = text.replace(/\n[ \t]*$/, '');

    // Handle the case where content is wrapped in a comment or cdata.
    if (last_tag_token.custom_beautifier_name !== 'html' &&
      text[0] === '<' && text.match(/^(<!--|<!\[CDATA\[)/)) {
      var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text);

      // if we start to wrap but don't finish, print raw
      if (!matched) {
        printer.add_raw_token(raw_token);
        return;
      }

      pre = indentation + matched[1] + '\n';
      text = matched[4];
      if (matched[5]) {
        post = indentation + matched[5];
      }

      // if there is at least one empty line at the end of this text, strip it
      // we'll be adding one back after the text but before the containing tag.
      text = text.replace(/\n[ \t]*$/, '');

      if (matched[2] || matched[3].indexOf('\n') !== -1) {
        // if the first line of the non-comment text has spaces
        // use that as the basis for indenting in null case.
        matched = matched[3].match(/[ \t]+$/);
        if (matched) {
          raw_token.whitespace_before = matched[0];
        }
      }
    }

    if (text) {
      if (_beautifier) {

        // call the Beautifier if avaliable
        var Child_options = function() {
          this.eol = '\n';
        };
        Child_options.prototype = this._options.raw_options;
        var child_options = new Child_options();
        text = _beautifier(indentation + text, child_options);
      } else {
        // simply indent the string otherwise
        var white = raw_token.whitespace_before;
        if (white) {
          text = text.replace(new RegExp('\n(' + white + ')?', 'g'), '\n');
        }

        text = indentation + text.replace(/\n/g, '\n' + indentation);
      }
    }

    if (pre) {
      if (!text) {
        text = pre + post;
      } else {
        text = pre + text + '\n' + post;
      }
    }

    printer.print_newline(false);
    if (text) {
      raw_token.text = text;
      raw_token.whitespace_before = '';
      raw_token.newlines = 0;
      printer.add_raw_token(raw_token);
      printer.print_newline(true);
    }
  }
};

Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token, tokens) {
  var parser_token = this._get_tag_open_token(raw_token);

  if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) &&
    !last_tag_token.is_empty_element &&
    raw_token.type === TOKEN.TAG_OPEN && !parser_token.is_start_tag) {
    // End element tags for unformatted or content_unformatted elements
    // are printed raw to keep any newlines inside them exactly the same.
    printer.add_raw_token(raw_token);
    parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
  } else {
    printer.traverse_whitespace(raw_token);
    this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
    if (!parser_token.is_inline_element) {
      printer.set_wrap_point();
    }
    printer.print_token(raw_token);
  }

  // count the number of attributes
  if (parser_token.is_start_tag && this._is_wrap_attributes_force) {
    var peek_index = 0;
    var peek_token;
    do {
      peek_token = tokens.peek(peek_index);
      if (peek_token.type === TOKEN.ATTRIBUTE) {
        parser_token.attr_count += 1;
      }
      peek_index += 1;
    } while (peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
  }

  //indent attributes an auto, forced, aligned or forced-align line-wrap
  if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
    parser_token.alignment_size = raw_token.text.length + 1;
  }

  if (!parser_token.tag_complete && !parser_token.is_unformatted) {
    printer.alignment_size = parser_token.alignment_size;
  }

  return parser_token;
};

var TagOpenParserToken = function(parent, raw_token) {
  this.parent = parent || null;
  this.text = '';
  this.type = 'TK_TAG_OPEN';
  this.tag_name = '';
  this.is_inline_element = false;
  this.is_unformatted = false;
  this.is_content_unformatted = false;
  this.is_empty_element = false;
  this.is_start_tag = false;
  this.is_end_tag = false;
  this.indent_content = false;
  this.multiline_content = false;
  this.custom_beautifier_name = null;
  this.start_tag_token = null;
  this.attr_count = 0;
  this.has_wrapped_attrs = false;
  this.alignment_size = 0;
  this.tag_complete = false;
  this.tag_start_char = '';
  this.tag_check = '';

  if (!raw_token) {
    this.tag_complete = true;
  } else {
    var tag_check_match;

    this.tag_start_char = raw_token.text[0];
    this.text = raw_token.text;

    if (this.tag_start_char === '<') {
      tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';
    } else {
      tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
      this.tag_check = tag_check_match ? tag_check_match[1] : '';

      // handle "{{#> myPartial}}" or "{{~#> myPartial}}"
      if ((raw_token.text.startsWith('{{#>') || raw_token.text.startsWith('{{~#>')) && this.tag_check[0] === '>') {
        if (this.tag_check === '>' && raw_token.next !== null) {
          this.tag_check = raw_token.next.text.split(' ')[0];
        } else {
          this.tag_check = raw_token.text.split('>')[1];
        }
      }
    }

    this.tag_check = this.tag_check.toLowerCase();

    if (raw_token.type === TOKEN.COMMENT) {
      this.tag_complete = true;
    }

    this.is_start_tag = this.tag_check.charAt(0) !== '/';
    this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
    this.is_end_tag = !this.is_start_tag ||
      (raw_token.closed && raw_token.closed.text === '/>');

    // if whitespace handler ~ included (i.e. {{~#if true}}), handlebars tags start at pos 3 not pos 2
    var handlebar_starts = 2;
    if (this.tag_start_char === '{' && this.text.length >= 3) {
      if (this.text.charAt(2) === '~') {
        handlebar_starts = 3;
      }
    }

    // handlebars tags that don't start with # or ^ are single_tags, and so also start and end.
    this.is_end_tag = this.is_end_tag ||
      (this.tag_start_char === '{' && (this.text.length < 3 || (/[^#\^]/.test(this.text.charAt(handlebar_starts)))));
  }
};

Beautifier.prototype._get_tag_open_token = function(raw_token) { //function to get a full tag and parse its type
  var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);

  parser_token.alignment_size = this._options.wrap_attributes_indent_size;

  parser_token.is_end_tag = parser_token.is_end_tag ||
    in_array(parser_token.tag_check, this._options.void_elements);

  parser_token.is_empty_element = parser_token.tag_complete ||
    (parser_token.is_start_tag && parser_token.is_end_tag);

  parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
  parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
  parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || (this._options.inline_custom_elements && parser_token.tag_name.includes("-")) || parser_token.tag_start_char === '{';

  return parser_token;
};

Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {

  if (!parser_token.is_empty_element) {
    if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
      parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name); //remove it and all ancestors
    } else { // it's a start-tag
      // check if this tag is starting an element that has optional end element
      // and do an ending needed
      if (this._do_optional_end_element(parser_token)) {
        if (!parser_token.is_inline_element) {
          printer.print_newline(false);
        }
      }

      this._tag_stack.record_tag(parser_token); //push it on the tag stack

      if ((parser_token.tag_name === 'script' || parser_token.tag_name === 'style') &&
        !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
        parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
      }
    }
  }

  if (in_array(parser_token.tag_check, this._options.extra_liners)) { //check if this double needs an extra line
    printer.print_newline(false);
    if (!printer._output.just_added_blankline()) {
      printer.print_newline(true);
    }
  }

  if (parser_token.is_empty_element) { //if this tag name is a single tag type (either in the list or has a closing /)

    // if you hit an else case, reset the indent level if you are inside an:
    // 'if', 'unless', or 'each' block.
    if (parser_token.tag_start_char === '{' && parser_token.tag_check === 'else') {
      this._tag_stack.indent_to_tag(['if', 'unless', 'each']);
      parser_token.indent_content = true;
      // Don't add a newline if opening {{#if}} tag is on the current line
      var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
      if (!foundIfOnCurrentLine) {
        printer.print_newline(false);
      }
    }

    // Don't add a newline before elements that should remain where they are.
    if (parser_token.tag_name === '!--' && last_token.type === TOKEN.TAG_CLOSE &&
      last_tag_token.is_end_tag && parser_token.text.indexOf('\n') === -1) {
      //Do nothing. Leave comments on same line.
    } else {
      if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
        printer.print_newline(false);
      }
      this._calcluate_parent_multiline(printer, parser_token);
    }
  } else if (parser_token.is_end_tag) { //this tag is a double tag so check for tag-ending
    var do_end_expand = false;

    // deciding whether a block is multiline should not be this hard
    do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
    do_end_expand = do_end_expand || (!parser_token.is_inline_element &&
      !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) &&
      !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) &&
      last_token.type !== 'TK_CONTENT'
    );

    if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
      do_end_expand = false;
    }

    if (do_end_expand) {
      printer.print_newline(false);
    }
  } else { // it's a start-tag
    parser_token.indent_content = !parser_token.custom_beautifier_name;

    if (parser_token.tag_start_char === '<') {
      if (parser_token.tag_name === 'html') {
        parser_token.indent_content = this._options.indent_inner_html;
      } else if (parser_token.tag_name === 'head') {
        parser_token.indent_content = this._options.indent_head_inner_html;
      } else if (parser_token.tag_name === 'body') {
        parser_token.indent_content = this._options.indent_body_inner_html;
      }
    }

    if (!(parser_token.is_inline_element || parser_token.is_unformatted) &&
      (last_token.type !== 'TK_CONTENT' || parser_token.is_content_unformatted)) {
      printer.print_newline(false);
    }

    this._calcluate_parent_multiline(printer, parser_token);
  }
};

Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
  if (parser_token.parent && printer._output.just_added_newline() &&
    !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
    parser_token.parent.multiline_content = true;
  }
};

//To be used for <p> tag special case:
var p_closers = ['address', 'article', 'aside', 'blockquote', 'details', 'div', 'dl', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'];
var p_parent_excludes = ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video'];

Beautifier.prototype._do_optional_end_element = function(parser_token) {
  var result = null;
  // NOTE: cases of "if there is no more content in the parent element"
  // are handled automatically by the beautifier.
  // It assumes parent or ancestor close tag closes all children.
  // https://www.w3.org/TR/html5/syntax.html#optional-tags
  if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
    return;

  }

  if (parser_token.tag_name === 'body') {
    // A head element’s end tag may be omitted if the head element is not immediately followed by a space character or a comment.
    result = result || this._tag_stack.try_pop('head');

    //} else if (parser_token.tag_name === 'body') {
    // DONE: A body element’s end tag may be omitted if the body element is not immediately followed by a comment.

  } else if (parser_token.tag_name === 'li') {
    // An li element’s end tag may be omitted if the li element is immediately followed by another li element or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('li', ['ol', 'ul', 'menu']);

  } else if (parser_token.tag_name === 'dd' || parser_token.tag_name === 'dt') {
    // A dd element’s end tag may be omitted if the dd element is immediately followed by another dd element or a dt element, or if there is no more content in the parent element.
    // A dt element’s end tag may be omitted if the dt element is immediately followed by another dt element or a dd element.
    result = result || this._tag_stack.try_pop('dt', ['dl']);
    result = result || this._tag_stack.try_pop('dd', ['dl']);


  } else if (parser_token.parent.tag_name === 'p' && p_closers.indexOf(parser_token.tag_name) !== -1) {
    // IMPORTANT: this else-if works because p_closers has no overlap with any other element we look for in this method
    // check for the parent element is an HTML element that is not an <a>, <audio>, <del>, <ins>, <map>, <noscript>, or <video> element,  or an autonomous custom element.
    // To do this right, this needs to be coded as an inclusion of the inverse of the exclusion above.
    // But to start with (if we ignore "autonomous custom elements") the exclusion would be fine.
    var p_parent = parser_token.parent.parent;
    if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
      result = result || this._tag_stack.try_pop('p');
    }
  } else if (parser_token.tag_name === 'rp' || parser_token.tag_name === 'rt') {
    // An rt element’s end tag may be omitted if the rt element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    // An rp element’s end tag may be omitted if the rp element is immediately followed by an rt or rp element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('rt', ['ruby', 'rtc']);
    result = result || this._tag_stack.try_pop('rp', ['ruby', 'rtc']);

  } else if (parser_token.tag_name === 'optgroup') {
    // An optgroup element’s end tag may be omitted if the optgroup element is immediately followed by another optgroup element, or if there is no more content in the parent element.
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('optgroup', ['select']);
    //result = result || this._tag_stack.try_pop('option', ['select']);

  } else if (parser_token.tag_name === 'option') {
    // An option element’s end tag may be omitted if the option element is immediately followed by another option element, or if it is immediately followed by an optgroup element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('option', ['select', 'datalist', 'optgroup']);

  } else if (parser_token.tag_name === 'colgroup') {
    // DONE: A colgroup element’s end tag may be omitted if the colgroup element is not immediately followed by a space character or a comment.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);

  } else if (parser_token.tag_name === 'thead') {
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);

    //} else if (parser_token.tag_name === 'caption') {
    // DONE: A caption element’s end tag may be omitted if the caption element is not immediately followed by a space character or a comment.

  } else if (parser_token.tag_name === 'tbody' || parser_token.tag_name === 'tfoot') {
    // A thead element’s end tag may be omitted if the thead element is immediately followed by a tbody or tfoot element.
    // A tbody element’s end tag may be omitted if the tbody element is immediately followed by a tbody or tfoot element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('thead', ['table']);
    result = result || this._tag_stack.try_pop('tbody', ['table']);

    //} else if (parser_token.tag_name === 'tfoot') {
    // DONE: A tfoot element’s end tag may be omitted if there is no more content in the parent element.

  } else if (parser_token.tag_name === 'tr') {
    // A tr element’s end tag may be omitted if the tr element is immediately followed by another tr element, or if there is no more content in the parent element.
    // A colgroup element's end tag may be ommitted if a thead, tfoot, tbody, or tr element is started.
    // A caption element's end tag may be ommitted if a colgroup, thead, tfoot, tbody, or tr element is started.
    result = result || this._tag_stack.try_pop('caption', ['table']);
    result = result || this._tag_stack.try_pop('colgroup', ['table']);
    result = result || this._tag_stack.try_pop('tr', ['table', 'thead', 'tbody', 'tfoot']);

  } else if (parser_token.tag_name === 'th' || parser_token.tag_name === 'td') {
    // A td element’s end tag may be omitted if the td element is immediately followed by a td or th element, or if there is no more content in the parent element.
    // A th element’s end tag may be omitted if the th element is immediately followed by a td or th element, or if there is no more content in the parent element.
    result = result || this._tag_stack.try_pop('td', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
    result = result || this._tag_stack.try_pop('th', ['table', 'thead', 'tbody', 'tfoot', 'tr']);
  }

  // Start element omission not handled currently
  // A head element’s start tag may be omitted if the element is empty, or if the first thing inside the head element is an element.
  // A tbody element’s start tag may be omitted if the first thing inside the tbody element is a tr element, and if the element is not immediately preceded by a tbody, thead, or tfoot element whose end tag has been omitted. (It can’t be omitted if the element is empty.)
  // A colgroup element’s start tag may be omitted if the first thing inside the colgroup element is a col element, and if the element is not immediately preceded by another colgroup element whose end tag has been omitted. (It can’t be omitted if the element is empty.)

  // Fix up the parent of the parser token
  parser_token.parent = this._tag_stack.get_parser_token();

  return result;
};

module.exports.Beautifier = Beautifier;


/***/ }),
/* 20 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_91062__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var BaseOptions = (__nested_webpack_require_91062__(6).Options);

function Options(options) {
  BaseOptions.call(this, options, 'html');
  if (this.templating.length === 1 && this.templating[0] === 'auto') {
    this.templating = ['django', 'erb', 'handlebars', 'php'];
  }

  this.indent_inner_html = this._get_boolean('indent_inner_html');
  this.indent_body_inner_html = this._get_boolean('indent_body_inner_html', true);
  this.indent_head_inner_html = this._get_boolean('indent_head_inner_html', true);

  this.indent_handlebars = this._get_boolean('indent_handlebars', true);
  this.wrap_attributes = this._get_selection('wrap_attributes',
    ['auto', 'force', 'force-aligned', 'force-expand-multiline', 'aligned-multiple', 'preserve', 'preserve-aligned']);
  this.wrap_attributes_min_attrs = this._get_number('wrap_attributes_min_attrs', 2);
  this.wrap_attributes_indent_size = this._get_number('wrap_attributes_indent_size', this.indent_size);
  this.extra_liners = this._get_array('extra_liners', ['head', 'body', '/html']);

  // Block vs inline elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Block-level_elements
  // https://developer.mozilla.org/en-US/docs/Web/HTML/Inline_elements
  // https://www.w3.org/TR/html5/dom.html#phrasing-content
  this.inline = this._get_array('inline', [
    'a', 'abbr', 'area', 'audio', 'b', 'bdi', 'bdo', 'br', 'button', 'canvas', 'cite',
    'code', 'data', 'datalist', 'del', 'dfn', 'em', 'embed', 'i', 'iframe', 'img',
    'input', 'ins', 'kbd', 'keygen', 'label', 'map', 'mark', 'math', 'meter', 'noscript',
    'object', 'output', 'progress', 'q', 'ruby', 's', 'samp', /* 'script', */ 'select', 'small',
    'span', 'strong', 'sub', 'sup', 'svg', 'template', 'textarea', 'time', 'u', 'var',
    'video', 'wbr', 'text',
    // obsolete inline tags
    'acronym', 'big', 'strike', 'tt'
  ]);
  this.inline_custom_elements = this._get_boolean('inline_custom_elements', true);
  this.void_elements = this._get_array('void_elements', [
    // HTLM void elements - aka self-closing tags - aka singletons
    // https://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements
    'area', 'base', 'br', 'col', 'embed', 'hr', 'img', 'input', 'keygen',
    'link', 'menuitem', 'meta', 'param', 'source', 'track', 'wbr',
    // NOTE: Optional tags are too complex for a simple list
    // they are hard coded in _do_optional_end_element

    // Doctype and xml elements
    '!doctype', '?xml',

    // obsolete tags
    // basefont: https://www.computerhope.com/jargon/h/html-basefont-tag.htm
    // isndex: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/isindex
    'basefont', 'isindex'
  ]);
  this.unformatted = this._get_array('unformatted', []);
  this.content_unformatted = this._get_array('content_unformatted', [
    'pre', 'textarea'
  ]);
  this.unformatted_content_delimiter = this._get_characters('unformatted_content_delimiter');
  this.indent_scripts = this._get_selection('indent_scripts', ['normal', 'keep', 'separate']);

}
Options.prototype = new BaseOptions();



module.exports.Options = Options;


/***/ }),
/* 21 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_95429__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var BaseTokenizer = (__nested_webpack_require_95429__(9).Tokenizer);
var BASETOKEN = (__nested_webpack_require_95429__(9).TOKEN);
var Directives = (__nested_webpack_require_95429__(13).Directives);
var TemplatablePattern = (__nested_webpack_require_95429__(14).TemplatablePattern);
var Pattern = (__nested_webpack_require_95429__(12).Pattern);

var TOKEN = {
  TAG_OPEN: 'TK_TAG_OPEN',
  TAG_CLOSE: 'TK_TAG_CLOSE',
  ATTRIBUTE: 'TK_ATTRIBUTE',
  EQUALS: 'TK_EQUALS',
  VALUE: 'TK_VALUE',
  COMMENT: 'TK_COMMENT',
  TEXT: 'TK_TEXT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};

var directives_core = new Directives(/<\!--/, /-->/);

var Tokenizer = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);
  this._current_tag_name = '';

  // Words end at whitespace or when a tag starts
  // if we are indenting handlebars, they are considered tags
  var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
  var pattern_reader = new Pattern(this._input);

  this.__patterns = {
    word: templatable_reader.until(/[\n\r\t <]/),
    single_quote: templatable_reader.until_after(/'/),
    double_quote: templatable_reader.until_after(/"/),
    attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
    element_name: templatable_reader.until(/[\n\r\t >\/]/),

    handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
    handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
    handlebars_open: pattern_reader.until(/[\n\r\t }]/),
    handlebars_raw_close: pattern_reader.until(/}}/),
    comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
    cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
    // https://en.wikipedia.org/wiki/Conditional_comment
    conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
    processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
  };

  if (this._options.indent_handlebars) {
    this.__patterns.word = this.__patterns.word.exclude('handlebars');
  }

  this._unformatted_content_delimiter = null;

  if (this._options.unformatted_content_delimiter) {
    var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
    this.__patterns.unformatted_content_delimiter =
      pattern_reader.matching(literal_regexp)
      .until_after(literal_regexp);
  }
};
Tokenizer.prototype = new BaseTokenizer();

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false; //current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN.TAG_OPEN;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) {
  return current_token.type === TOKEN.TAG_CLOSE &&
    (open_token && (
      ((current_token.text === '>' || current_token.text === '/>') && open_token.text[0] === '<') ||
      (current_token.text === '}}' && open_token.text[0] === '{' && open_token.text[1] === '{')));
};

Tokenizer.prototype._reset = function() {
  this._current_tag_name = '';
};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN.EOF, '');
  }

  token = token || this._read_open_handlebars(c, open_token);
  token = token || this._read_attribute(c, previous_token, open_token);
  token = token || this._read_close(c, open_token);
  token = token || this._read_raw_content(c, previous_token, open_token);
  token = token || this._read_content_word(c);
  token = token || this._read_comment_or_cdata(c);
  token = token || this._read_processing(c);
  token = token || this._read_open(c, open_token);
  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

  return token;
};

Tokenizer.prototype._read_comment_or_cdata = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    // We treat all comments as literals, even more than preformatted tags
    // we only look for the appropriate closing marker
    if (peek1 === '!') {
      resulting_string = this.__patterns.comment.read();

      // only process directive on html comments
      if (resulting_string) {
        directives = directives_core.get_directives(resulting_string);
        if (directives && directives.ignore === 'start') {
          resulting_string += directives_core.readIgnored(this._input);
        }
      } else {
        resulting_string = this.__patterns.cdata.read();
      }
    }

    if (resulting_string) {
      token = this._create_token(TOKEN.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer.prototype._read_processing = function(c) { // jshint unused:false
  var token = null;
  var resulting_string = null;
  var directives = null;

  if (c === '<') {
    var peek1 = this._input.peek(1);
    if (peek1 === '!' || peek1 === '?') {
      resulting_string = this.__patterns.conditional_comment.read();
      resulting_string = resulting_string || this.__patterns.processing.read();
    }

    if (resulting_string) {
      token = this._create_token(TOKEN.COMMENT, resulting_string);
      token.directives = directives;
    }
  }

  return token;
};

Tokenizer.prototype._read_open = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (c === '<') {

      resulting_string = this._input.next();
      if (this._input.peek() === '/') {
        resulting_string += this._input.next();
      }
      resulting_string += this.__patterns.element_name.read();
      token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
    }
  }
  return token;
};

Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (!open_token) {
    if (this._options.indent_handlebars && c === '{' && this._input.peek(1) === '{') {
      if (this._input.peek(2) === '!') {
        resulting_string = this.__patterns.handlebars_comment.read();
        resulting_string = resulting_string || this.__patterns.handlebars.read();
        token = this._create_token(TOKEN.COMMENT, resulting_string);
      } else {
        resulting_string = this.__patterns.handlebars_open.read();
        token = this._create_token(TOKEN.TAG_OPEN, resulting_string);
      }
    }
  }
  return token;
};


Tokenizer.prototype._read_close = function(c, open_token) {
  var resulting_string = null;
  var token = null;
  if (open_token) {
    if (open_token.text[0] === '<' && (c === '>' || (c === '/' && this._input.peek(1) === '>'))) {
      resulting_string = this._input.next();
      if (c === '/') { //  for close tag "/>"
        resulting_string += this._input.next();
      }
      token = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
    } else if (open_token.text[0] === '{' && c === '}' && this._input.peek(1) === '}') {
      this._input.next();
      this._input.next();
      token = this._create_token(TOKEN.TAG_CLOSE, '}}');
    }
  }

  return token;
};

Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
  var token = null;
  var resulting_string = '';
  if (open_token && open_token.text[0] === '<') {

    if (c === '=') {
      token = this._create_token(TOKEN.EQUALS, this._input.next());
    } else if (c === '"' || c === "'") {
      var content = this._input.next();
      if (c === '"') {
        content += this.__patterns.double_quote.read();
      } else {
        content += this.__patterns.single_quote.read();
      }
      token = this._create_token(TOKEN.VALUE, content);
    } else {
      resulting_string = this.__patterns.attribute.read();

      if (resulting_string) {
        if (previous_token.type === TOKEN.EQUALS) {
          token = this._create_token(TOKEN.VALUE, resulting_string);
        } else {
          token = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
        }
      }
    }
  }
  return token;
};

Tokenizer.prototype._is_content_unformatted = function(tag_name) {
  // void_elements have no content and so cannot have unformatted content
  // script and style tags should always be read as unformatted content
  // finally content_unformatted and unformatted element contents are unformatted
  return this._options.void_elements.indexOf(tag_name) === -1 &&
    (this._options.content_unformatted.indexOf(tag_name) !== -1 ||
      this._options.unformatted.indexOf(tag_name) !== -1);
};


Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) { // jshint unused:false
  var resulting_string = '';
  if (open_token && open_token.text[0] === '{') {
    resulting_string = this.__patterns.handlebars_raw_close.read();
  } else if (previous_token.type === TOKEN.TAG_CLOSE &&
    previous_token.opened.text[0] === '<' && previous_token.text[0] !== '/') {
    // ^^ empty tag has no content 
    var tag_name = previous_token.opened.text.substr(1).toLowerCase();
    if (tag_name === 'script' || tag_name === 'style') {
      // Script and style tags are allowed to have comments wrapping their content
      // or just have regular content.
      var token = this._read_comment_or_cdata(c);
      if (token) {
        token.type = TOKEN.TEXT;
        return token;
      }
      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    } else if (this._is_content_unformatted(tag_name)) {

      resulting_string = this._input.readUntil(new RegExp('</' + tag_name + '[\\n\\r\\t ]*?>', 'ig'));
    }
  }

  if (resulting_string) {
    return this._create_token(TOKEN.TEXT, resulting_string);
  }

  return null;
};

Tokenizer.prototype._read_content_word = function(c) {
  var resulting_string = '';
  if (this._options.unformatted_content_delimiter) {
    if (c === this._options.unformatted_content_delimiter[0]) {
      resulting_string = this.__patterns.unformatted_content_delimiter.read();
    }
  }

  if (!resulting_string) {
    resulting_string = this.__patterns.word.read();
  }
  if (resulting_string) {
    return this._create_token(TOKEN.TEXT, resulting_string);
  }
};

module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_107323__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_107323__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_107323__(18);
/******/ 	legacy_beautify_html = __nested_webpack_exports__;
/******/ 	
/******/ })()
;
var style_html = legacy_beautify_html;
/* Footer */
if (true) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, __webpack_require__(94), __webpack_require__(838)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(requireamd) {
        var js_beautify = __webpack_require__(94);
        var css_beautify = __webpack_require__(838);

        return {
            html_beautify: function(html_source, options) {
                return style_html(html_source, options, js_beautify.js_beautify, css_beautify.css_beautify);
            }
        };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else { var css_beautify, js_beautify; }

}());


/***/ }),

/***/ 94:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* AUTO-GENERATED. DO NOT MODIFY. */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 JS Beautifier
---------------


  Written by Einar Lielmanis, <einar@beautifier.io>
      https://beautifier.io/

  Originally converted to javascript by Vital, <vital76@gmail.com>
  "End braces on own line" added by Chris J. Shull, <chrisjshull@gmail.com>
  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@beautifier.io>


  Usage:
    js_beautify(js_source_text);
    js_beautify(js_source_text, options);

  The options are:
    indent_size (default 4)          - indentation size,
    indent_char (default space)      - character to indent with,
    preserve_newlines (default true) - whether existing line breaks should be preserved,
    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,

    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.

            jslint_happy        !jslint_happy
            ---------------------------------
            function ()         function()

            switch () {         switch() {
            case 1:               case 1:
              break;                break;
            }                   }

    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, "function()" vs "function ()",
          NOTE: This option is overridden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)

    brace_style (default "collapse") - "collapse" | "expand" | "end-expand" | "none" | any of the former + ",preserve-inline"
            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.
            preserve-inline will try to preserve inline blocks of curly braces

    space_before_conditional (default true) - should the space before conditional statement be added, "if(true)" vs "if (true)",

    unescape_strings (default false) - should printable characters in strings encoded in \xNN notation be unescaped, "example" vs "\x65\x78\x61\x6d\x70\x6c\x65"

    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.
          NOTE: This is not a hard limit. Lines will continue until a point where a newline would
                be preserved if it were present.

    end_with_newline (default false)  - end output with a newline


    e.g

    js_beautify(js_source_text, {
      'indent_size': 1,
      'indent_char': '\t'
    });

*/

(function() {

/* GENERATED_BUILD_OUTPUT */
var legacy_beautify_js;
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_4000__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Beautifier = (__nested_webpack_require_4000__(1).Beautifier),
  Options = (__nested_webpack_require_4000__(5).Options);

function js_beautify(js_source_text, options) {
  var beautifier = new Beautifier(js_source_text, options);
  return beautifier.beautify();
}

module.exports = js_beautify;
module.exports.defaultOptions = function() {
  return new Options();
};


/***/ }),
/* 1 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_5629__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Output = (__nested_webpack_require_5629__(2).Output);
var Token = (__nested_webpack_require_5629__(3).Token);
var acorn = __nested_webpack_require_5629__(4);
var Options = (__nested_webpack_require_5629__(5).Options);
var Tokenizer = (__nested_webpack_require_5629__(7).Tokenizer);
var line_starters = (__nested_webpack_require_5629__(7).line_starters);
var positionable_operators = (__nested_webpack_require_5629__(7).positionable_operators);
var TOKEN = (__nested_webpack_require_5629__(7).TOKEN);


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}

function ltrim(s) {
  return s.replace(/^\s+/g, '');
}

function generateMapFromStrings(list) {
  var result = {};
  for (var x = 0; x < list.length; x++) {
    // make the mapped names underscored instead of dash
    result[list[x].replace(/-/g, '_')] = list[x];
  }
  return result;
}

function reserved_word(token, word) {
  return token && token.type === TOKEN.RESERVED && token.text === word;
}

function reserved_array(token, words) {
  return token && token.type === TOKEN.RESERVED && in_array(token.text, words);
}
// Unsure of what they mean, but they work. Worth cleaning up in future.
var special_words = ['case', 'return', 'do', 'if', 'throw', 'else', 'await', 'break', 'continue', 'async'];

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

// Generate map from array
var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);

var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];

var MODE = {
  BlockStatement: 'BlockStatement', // 'BLOCK'
  Statement: 'Statement', // 'STATEMENT'
  ObjectLiteral: 'ObjectLiteral', // 'OBJECT',
  ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',
  ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',
  Conditional: 'Conditional', //'(COND-EXPRESSION)',
  Expression: 'Expression' //'(EXPRESSION)'
};

function remove_redundant_indentation(output, frame) {
  // This implementation is effective but has some issues:
  //     - can cause line wrap to happen too soon due to indent removal
  //           after wrap points are calculated
  // These issues are minor compared to ugly indentation.

  if (frame.multiline_frame ||
    frame.mode === MODE.ForInitializer ||
    frame.mode === MODE.Conditional) {
    return;
  }

  // remove one indent from each line inside this section
  output.remove_indent(frame.start_line_index);
}

// we could use just string.split, but
// IE doesn't like returning empty strings
function split_linebreaks(s) {
  //return s.split(/\x0d\x0a|\x0a/);

  s = s.replace(acorn.allLineBreaks, '\n');
  var out = [],
    idx = s.indexOf("\n");
  while (idx !== -1) {
    out.push(s.substring(0, idx));
    s = s.substring(idx + 1);
    idx = s.indexOf("\n");
  }
  if (s.length) {
    out.push(s);
  }
  return out;
}

function is_array(mode) {
  return mode === MODE.ArrayLiteral;
}

function is_expression(mode) {
  return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
}

function all_lines_start_with(lines, c) {
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trim();
    if (line.charAt(0) !== c) {
      return false;
    }
  }
  return true;
}

function each_line_matches_indent(lines, indent) {
  var i = 0,
    len = lines.length,
    line;
  for (; i < len; i++) {
    line = lines[i];
    // allow empty lines to pass through
    if (line && line.indexOf(indent) !== 0) {
      return false;
    }
  }
  return true;
}


function Beautifier(source_text, options) {
  options = options || {};
  this._source_text = source_text || '';

  this._output = null;
  this._tokens = null;
  this._last_last_text = null;
  this._flags = null;
  this._previous_flags = null;

  this._flag_store = null;
  this._options = new Options(options);
}

Beautifier.prototype.create_flags = function(flags_base, mode) {
  var next_indent_level = 0;
  if (flags_base) {
    next_indent_level = flags_base.indentation_level;
    if (!this._output.just_added_newline() &&
      flags_base.line_indent_level > next_indent_level) {
      next_indent_level = flags_base.line_indent_level;
    }
  }

  var next_flags = {
    mode: mode,
    parent: flags_base,
    last_token: flags_base ? flags_base.last_token : new Token(TOKEN.START_BLOCK, ''), // last token text
    last_word: flags_base ? flags_base.last_word : '', // last TOKEN.WORD passed
    declaration_statement: false,
    declaration_assignment: false,
    multiline_frame: false,
    inline_frame: false,
    if_block: false,
    else_block: false,
    class_start_block: false, // class A { INSIDE HERE } or class B extends C { INSIDE HERE }
    do_block: false,
    do_while: false,
    import_block: false,
    in_case_statement: false, // switch(..){ INSIDE HERE }
    in_case: false, // we're on the exact line with "case 0:"
    case_body: false, // the indented case-action block
    case_block: false, // the indented case-action block is wrapped with {}
    indentation_level: next_indent_level,
    alignment: 0,
    line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
    start_line_index: this._output.get_line_number(),
    ternary_depth: 0
  };
  return next_flags;
};

Beautifier.prototype._reset = function(source_text) {
  var baseIndentString = source_text.match(/^[\t ]*/)[0];

  this._last_last_text = ''; // pre-last token text
  this._output = new Output(this._options, baseIndentString);

  // If testing the ignore directive, start with output disable set to true
  this._output.raw = this._options.test_output_raw;


  // Stack of parsing/formatting states, including MODE.
  // We tokenize, parse, and output in an almost purely a forward-only stream of token input
  // and formatted output.  This makes the beautifier less accurate than full parsers
  // but also far more tolerant of syntax errors.
  //
  // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type
  // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later
  // encounter a ":", we'll switch to to MODE.ObjectLiteral.  If we then see a ";",
  // most full parsers would die, but the beautifier gracefully falls back to
  // MODE.BlockStatement and continues on.
  this._flag_store = [];
  this.set_mode(MODE.BlockStatement);
  var tokenizer = new Tokenizer(source_text, this._options);
  this._tokens = tokenizer.tokenize();
  return source_text;
};

Beautifier.prototype.beautify = function() {
  // if disabled, return the input unchanged.
  if (this._options.disabled) {
    return this._source_text;
  }

  var sweet_code;
  var source_text = this._reset(this._source_text);

  var eol = this._options.eol;
  if (this._options.eol === 'auto') {
    eol = '\n';
    if (source_text && acorn.lineBreak.test(source_text || '')) {
      eol = source_text.match(acorn.lineBreak)[0];
    }
  }

  var current_token = this._tokens.next();
  while (current_token) {
    this.handle_token(current_token);

    this._last_last_text = this._flags.last_token.text;
    this._flags.last_token = current_token;

    current_token = this._tokens.next();
  }

  sweet_code = this._output.get_code(eol);

  return sweet_code;
};

Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
  if (current_token.type === TOKEN.START_EXPR) {
    this.handle_start_expr(current_token);
  } else if (current_token.type === TOKEN.END_EXPR) {
    this.handle_end_expr(current_token);
  } else if (current_token.type === TOKEN.START_BLOCK) {
    this.handle_start_block(current_token);
  } else if (current_token.type === TOKEN.END_BLOCK) {
    this.handle_end_block(current_token);
  } else if (current_token.type === TOKEN.WORD) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN.RESERVED) {
    this.handle_word(current_token);
  } else if (current_token.type === TOKEN.SEMICOLON) {
    this.handle_semicolon(current_token);
  } else if (current_token.type === TOKEN.STRING) {
    this.handle_string(current_token);
  } else if (current_token.type === TOKEN.EQUALS) {
    this.handle_equals(current_token);
  } else if (current_token.type === TOKEN.OPERATOR) {
    this.handle_operator(current_token);
  } else if (current_token.type === TOKEN.COMMA) {
    this.handle_comma(current_token);
  } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
    this.handle_block_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN.COMMENT) {
    this.handle_comment(current_token, preserve_statement_flags);
  } else if (current_token.type === TOKEN.DOT) {
    this.handle_dot(current_token);
  } else if (current_token.type === TOKEN.EOF) {
    this.handle_eof(current_token);
  } else if (current_token.type === TOKEN.UNKNOWN) {
    this.handle_unknown(current_token, preserve_statement_flags);
  } else {
    this.handle_unknown(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
  var newlines = current_token.newlines;
  var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);

  if (current_token.comments_before) {
    var comment_token = current_token.comments_before.next();
    while (comment_token) {
      // The cleanest handling of inline comments is to treat them as though they aren't there.
      // Just continue formatting and the behavior should be logical.
      // Also ignore unknown tokens.  Again, this should result in better behavior.
      this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
      this.handle_token(comment_token, preserve_statement_flags);
      comment_token = current_token.comments_before.next();
    }
  }

  if (keep_whitespace) {
    for (var i = 0; i < newlines; i += 1) {
      this.print_newline(i > 0, preserve_statement_flags);
    }
  } else {
    if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
      newlines = this._options.max_preserve_newlines;
    }

    if (this._options.preserve_newlines) {
      if (newlines > 1) {
        this.print_newline(false, preserve_statement_flags);
        for (var j = 1; j < newlines; j += 1) {
          this.print_newline(true, preserve_statement_flags);
        }
      }
    }
  }

};

var newline_restricted_tokens = ['async', 'break', 'continue', 'return', 'throw', 'yield'];

Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
  force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;

  // Never wrap the first token on a line
  if (this._output.just_added_newline()) {
    return;
  }

  var shouldPreserveOrForce = (this._options.preserve_newlines && current_token.newlines) || force_linewrap;
  var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) ||
    in_array(current_token.text, positionable_operators);

  if (operatorLogicApplies) {
    var shouldPrintOperatorNewline = (
        in_array(this._flags.last_token.text, positionable_operators) &&
        in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)
      ) ||
      in_array(current_token.text, positionable_operators);
    shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
  }

  if (shouldPreserveOrForce) {
    this.print_newline(false, true);
  } else if (this._options.wrap_line_length) {
    if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
      // These tokens should never have a newline inserted
      // between them and the following expression.
      return;
    }
    this._output.set_wrap_point();
  }
};

Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
  if (!preserve_statement_flags) {
    if (this._flags.last_token.text !== ';' && this._flags.last_token.text !== ',' && this._flags.last_token.text !== '=' && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) {
      var next_token = this._tokens.peek();
      while (this._flags.mode === MODE.Statement &&
        !(this._flags.if_block && reserved_word(next_token, 'else')) &&
        !this._flags.do_block) {
        this.restore_mode();
      }
    }
  }

  if (this._output.add_new_line(force_newline)) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.print_token_line_indentation = function(current_token) {
  if (this._output.just_added_newline()) {
    if (this._options.keep_array_indentation &&
      current_token.newlines &&
      (current_token.text === '[' || is_array(this._flags.mode))) {
      this._output.current_line.set_indent(-1);
      this._output.current_line.push(current_token.whitespace_before);
      this._output.space_before_token = false;
    } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
      this._flags.line_indent_level = this._flags.indentation_level;
    }
  }
};

Beautifier.prototype.print_token = function(current_token) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    return;
  }

  if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA &&
    this._output.just_added_newline()) {
    if (this._output.previous_line.last() === ',') {
      var popped = this._output.previous_line.pop();
      // if the comma was already at the start of the line,
      // pull back onto that line and reprint the indentation
      if (this._output.previous_line.is_empty()) {
        this._output.previous_line.push(popped);
        this._output.trim(true);
        this._output.current_line.pop();
        this._output.trim();
      }

      // add the comma in front of the next token
      this.print_token_line_indentation(current_token);
      this._output.add_token(',');
      this._output.space_before_token = true;
    }
  }

  this.print_token_line_indentation(current_token);
  this._output.non_breaking_space = true;
  this._output.add_token(current_token.text);
  if (this._output.previous_token_wrapped) {
    this._flags.multiline_frame = true;
  }
};

Beautifier.prototype.indent = function() {
  this._flags.indentation_level += 1;
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};

Beautifier.prototype.deindent = function() {
  if (this._flags.indentation_level > 0 &&
    ((!this._flags.parent) || this._flags.indentation_level > this._flags.parent.indentation_level)) {
    this._flags.indentation_level -= 1;
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.set_mode = function(mode) {
  if (this._flags) {
    this._flag_store.push(this._flags);
    this._previous_flags = this._flags;
  } else {
    this._previous_flags = this.create_flags(null, mode);
  }

  this._flags = this.create_flags(this._previous_flags, mode);
  this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
};


Beautifier.prototype.restore_mode = function() {
  if (this._flag_store.length > 0) {
    this._previous_flags = this._flags;
    this._flags = this._flag_store.pop();
    if (this._previous_flags.mode === MODE.Statement) {
      remove_redundant_indentation(this._output, this._previous_flags);
    }
    this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
  }
};

Beautifier.prototype.start_of_object_property = function() {
  return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || (reserved_array(this._flags.last_token, ['get', 'set'])));
};

Beautifier.prototype.start_of_statement = function(current_token) {
  var start = false;
  start = start || reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD;
  start = start || reserved_word(this._flags.last_token, 'do');
  start = start || (!(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement)) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
  start = start || reserved_word(this._flags.last_token, 'else') &&
    !(reserved_word(current_token, 'if') && !current_token.comments_before);
  start = start || (this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional));
  start = start || (this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement &&
    !this._flags.in_case &&
    !(current_token.text === '--' || current_token.text === '++') &&
    this._last_last_text !== 'function' &&
    current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED);
  start = start || (this._flags.mode === MODE.ObjectLiteral && (
    (this._flags.last_token.text === ':' && this._flags.ternary_depth === 0) || reserved_array(this._flags.last_token, ['get', 'set'])));

  if (start) {
    this.set_mode(MODE.Statement);
    this.indent();

    this.handle_whitespace_and_comments(current_token, true);

    // Issue #276:
    // If starting a new statement with [if, for, while, do], push to a new line.
    // if (a) if (b) if(c) d(); else e(); else f();
    if (!this.start_of_object_property()) {
      this.allow_wrap_or_preserved_newline(current_token,
        reserved_array(current_token, ['do', 'for', 'if', 'while']));
    }
    return true;
  }
  return false;
};

Beautifier.prototype.handle_start_expr = function(current_token) {
  // The conditional starts the statement if appropriate.
  if (!this.start_of_statement(current_token)) {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_mode = MODE.Expression;
  if (current_token.text === '[') {

    if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ')') {
      // this is array index specifier, break immediately
      // a[x], fn()[x]
      if (reserved_array(this._flags.last_token, line_starters)) {
        this._output.space_before_token = true;
      }
      this.print_token(current_token);
      this.set_mode(next_mode);
      this.indent();
      if (this._options.space_in_paren) {
        this._output.space_before_token = true;
      }
      return;
    }

    next_mode = MODE.ArrayLiteral;
    if (is_array(this._flags.mode)) {
      if (this._flags.last_token.text === '[' ||
        (this._flags.last_token.text === ',' && (this._last_last_text === ']' || this._last_last_text === '}'))) {
        // ], [ goes to new line
        // }, [ goes to new line
        if (!this._options.keep_array_indentation) {
          this.print_newline();
        }
      }
    }

    if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
      this._output.space_before_token = true;
    }
  } else {
    if (this._flags.last_token.type === TOKEN.RESERVED) {
      if (this._flags.last_token.text === 'for') {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.ForInitializer;
      } else if (in_array(this._flags.last_token.text, ['if', 'while', 'switch'])) {
        this._output.space_before_token = this._options.space_before_conditional;
        next_mode = MODE.Conditional;
      } else if (in_array(this._flags.last_word, ['await', 'async'])) {
        // Should be a space between await and an IIFE, or async and an arrow function
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'import' && current_token.whitespace_before === '') {
        this._output.space_before_token = false;
      } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === 'catch') {
        this._output.space_before_token = true;
      }
    } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      // Support of this kind of newline preservation.
      // a = (b &&
      //     (c || d));
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if (this._flags.last_token.type === TOKEN.WORD) {
      this._output.space_before_token = false;

      // function name() vs function name ()
      // function* name() vs function* name ()
      // async name() vs async name ()
      // In ES6, you can also define the method properties of an object
      // var obj = {a: function() {}}
      // It can be abbreviated
      // var obj = {a() {}}
      // var obj = { a() {}} vs var obj = { a () {}}
      // var obj = { * a() {}} vs var obj = { * a () {}}
      var peek_back_two = this._tokens.peek(-3);
      if (this._options.space_after_named_function && peek_back_two) {
        // peek starts at next character so -1 is current token
        var peek_back_three = this._tokens.peek(-4);
        if (reserved_array(peek_back_two, ['async', 'function']) ||
          (peek_back_two.text === '*' && reserved_array(peek_back_three, ['async', 'function']))) {
          this._output.space_before_token = true;
        } else if (this._flags.mode === MODE.ObjectLiteral) {
          if ((peek_back_two.text === '{' || peek_back_two.text === ',') ||
            (peek_back_two.text === '*' && (peek_back_three.text === '{' || peek_back_three.text === ','))) {
            this._output.space_before_token = true;
          }
        } else if (this._flags.parent && this._flags.parent.class_start_block) {
          this._output.space_before_token = true;
        }
      }
    } else {
      // Support preserving wrapped arrow function expressions
      // a.b('c',
      //     () => d.e
      // )
      this.allow_wrap_or_preserved_newline(current_token);
    }

    // function() vs function ()
    // yield*() vs yield* ()
    // function*() vs function* ()
    if ((this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === 'function' || this._flags.last_word === 'typeof')) ||
      (this._flags.last_token.text === '*' &&
        (in_array(this._last_last_text, ['function', 'yield']) ||
          (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
      this._output.space_before_token = this._options.space_after_anon_function;
    }
  }

  if (this._flags.last_token.text === ';' || this._flags.last_token.type === TOKEN.START_BLOCK) {
    this.print_newline();
  } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === '.' || this._flags.last_token.type === TOKEN.COMMA) {
    // do nothing on (( and )( and ][ and ]( and .(
    // TODO: Consider whether forcing this is required.  Review failing tests when removed.
    this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
  }

  this.print_token(current_token);
  this.set_mode(next_mode);
  if (this._options.space_in_paren) {
    this._output.space_before_token = true;
  }

  // In all cases, if we newline while inside an expression it should be indented.
  this.indent();
};

Beautifier.prototype.handle_end_expr = function(current_token) {
  // statements inside expressions are not valid syntax, but...
  // statements must all be closed when their container closes
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  this.handle_whitespace_and_comments(current_token);

  if (this._flags.multiline_frame) {
    this.allow_wrap_or_preserved_newline(current_token,
      current_token.text === ']' && is_array(this._flags.mode) && !this._options.keep_array_indentation);
  }

  if (this._options.space_in_paren) {
    if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
      // () [] no inner space in empty parens like these, ever, ref #320
      this._output.trim();
      this._output.space_before_token = false;
    } else {
      this._output.space_before_token = true;
    }
  }
  this.deindent();
  this.print_token(current_token);
  this.restore_mode();

  remove_redundant_indentation(this._output, this._previous_flags);

  // do {} while () // no statement required after
  if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
    this._previous_flags.mode = MODE.Expression;
    this._flags.do_block = false;
    this._flags.do_while = false;

  }
};

Beautifier.prototype.handle_start_block = function(current_token) {
  this.handle_whitespace_and_comments(current_token);

  // Check if this is should be treated as a ObjectLiteral
  var next_token = this._tokens.peek();
  var second_token = this._tokens.peek(1);
  if (this._flags.last_word === 'switch' && this._flags.last_token.type === TOKEN.END_EXPR) {
    this.set_mode(MODE.BlockStatement);
    this._flags.in_case_statement = true;
  } else if (this._flags.case_body) {
    this.set_mode(MODE.BlockStatement);
  } else if (second_token && (
      (in_array(second_token.text, [':', ',']) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED])) ||
      (in_array(next_token.text, ['get', 'set', '...']) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))
    )) {
    // We don't support TypeScript,but we didn't break it for a very long time.
    // We'll try to keep not breaking it.
    if (in_array(this._last_last_text, ['class', 'interface']) && !in_array(second_token.text, [':', ','])) {
      this.set_mode(MODE.BlockStatement);
    } else {
      this.set_mode(MODE.ObjectLiteral);
    }
  } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === '=>') {
    // arrow function: (param1, paramN) => { statements }
    this.set_mode(MODE.BlockStatement);
  } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) ||
    reserved_array(this._flags.last_token, ['return', 'throw', 'import', 'default'])
  ) {
    // Detecting shorthand function syntax is difficult by scanning forward,
    //     so check the surrounding context.
    // If the block is being returned, imported, export default, passed as arg,
    //     assigned with = or assigned in a nested object, treat as an ObjectLiteral.
    this.set_mode(MODE.ObjectLiteral);
  } else {
    this.set_mode(MODE.BlockStatement);
  }

  if (this._flags.last_token) {
    if (reserved_array(this._flags.last_token.previous, ['class', 'extends'])) {
      this._flags.class_start_block = true;
    }
  }

  var empty_braces = !next_token.comments_before && next_token.text === '}';
  var empty_anonymous_function = empty_braces && this._flags.last_word === 'function' &&
    this._flags.last_token.type === TOKEN.END_EXPR;

  if (this._options.brace_preserve_inline) // check for inline, set inline_frame if so
  {
    // search forward for a newline wanted inside this block
    var index = 0;
    var check_token = null;
    this._flags.inline_frame = true;
    do {
      index += 1;
      check_token = this._tokens.peek(index - 1);
      if (check_token.newlines) {
        this._flags.inline_frame = false;
        break;
      }
    } while (check_token.type !== TOKEN.EOF &&
      !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
  }

  if ((this._options.brace_style === "expand" ||
      (this._options.brace_style === "none" && current_token.newlines)) &&
    !this._flags.inline_frame) {
    if (this._flags.last_token.type !== TOKEN.OPERATOR &&
      (empty_anonymous_function ||
        this._flags.last_token.type === TOKEN.EQUALS ||
        (reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== 'else'))) {
      this._output.space_before_token = true;
    } else {
      this.print_newline(false, true);
    }
  } else { // collapse || inline_frame
    if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
      if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
        this._output.space_before_token = true;
      }

      if (this._flags.last_token.type === TOKEN.COMMA || (this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame)) {
        this.allow_wrap_or_preserved_newline(current_token);
        this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
        this._flags.multiline_frame = false;
      }
    }
    if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
      if (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.SEMICOLON]) && !this._flags.inline_frame) {
        this.print_newline();
      } else {
        this._output.space_before_token = true;
      }
    }
  }
  this.print_token(current_token);
  this.indent();

  // Except for specific cases, open braces are followed by a new line.
  if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
    this.print_newline();
  }
};

Beautifier.prototype.handle_end_block = function(current_token) {
  // statements must all be closed when their container closes
  this.handle_whitespace_and_comments(current_token);

  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }

  var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;

  if (this._flags.inline_frame && !empty_braces) { // try inline_frame (only set if this._options.braces-preserve-inline) first
    this._output.space_before_token = true;
  } else if (this._options.brace_style === "expand") {
    if (!empty_braces) {
      this.print_newline();
    }
  } else {
    // skip {}
    if (!empty_braces) {
      if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
        // we REALLY need a newline here, but newliner would skip that
        this._options.keep_array_indentation = false;
        this.print_newline();
        this._options.keep_array_indentation = true;

      } else {
        this.print_newline();
      }
    }
  }
  this.restore_mode();
  this.print_token(current_token);
};

Beautifier.prototype.handle_word = function(current_token) {
  if (current_token.type === TOKEN.RESERVED) {
    if (in_array(current_token.text, ['set', 'get']) && this._flags.mode !== MODE.ObjectLiteral) {
      current_token.type = TOKEN.WORD;
    } else if (current_token.text === 'import' && in_array(this._tokens.peek().text, ['(', '.'])) {
      current_token.type = TOKEN.WORD;
    } else if (in_array(current_token.text, ['as', 'from']) && !this._flags.import_block) {
      current_token.type = TOKEN.WORD;
    } else if (this._flags.mode === MODE.ObjectLiteral) {
      var next_token = this._tokens.peek();
      if (next_token.text === ':') {
        current_token.type = TOKEN.WORD;
      }
    }
  }

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    if (reserved_array(this._flags.last_token, ['var', 'let', 'const']) && current_token.type === TOKEN.WORD) {
      this._flags.declaration_statement = true;
    }
  } else if (current_token.newlines && !is_expression(this._flags.mode) &&
    (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === '--' || this._flags.last_token.text === '++')) &&
    this._flags.last_token.type !== TOKEN.EQUALS &&
    (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ['var', 'let', 'const', 'set', 'get']))) {
    this.handle_whitespace_and_comments(current_token);
    this.print_newline();
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.do_block && !this._flags.do_while) {
    if (reserved_word(current_token, 'while')) {
      // do {} ## while ()
      this._output.space_before_token = true;
      this.print_token(current_token);
      this._output.space_before_token = true;
      this._flags.do_while = true;
      return;
    } else {
      // do {} should always have while as the next word.
      // if we don't see the expected while, recover
      this.print_newline();
      this._flags.do_block = false;
    }
  }

  // if may be followed by else, or not
  // Bare/inline ifs are tricky
  // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();
  if (this._flags.if_block) {
    if (!this._flags.else_block && reserved_word(current_token, 'else')) {
      this._flags.else_block = true;
    } else {
      while (this._flags.mode === MODE.Statement) {
        this.restore_mode();
      }
      this._flags.if_block = false;
      this._flags.else_block = false;
    }
  }

  if (this._flags.in_case_statement && reserved_array(current_token, ['case', 'default'])) {
    this.print_newline();
    if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
      // switch cases following one another
      this.deindent();
    }
    this._flags.case_body = false;

    this.print_token(current_token);
    this._flags.in_case = true;
    return;
  }

  if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
    if (!this.start_of_object_property() && !(
        // start of object property is different for numeric values with +/- prefix operators
        in_array(this._flags.last_token.text, ['+', '-']) && this._last_last_text === ':' && this._flags.parent.mode === MODE.ObjectLiteral)) {
      this.allow_wrap_or_preserved_newline(current_token);
    }
  }

  if (reserved_word(current_token, 'function')) {
    if (in_array(this._flags.last_token.text, ['}', ';']) ||
      (this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ['(', '[', '{', ':', '=', ',']) || this._flags.last_token.type === TOKEN.OPERATOR))) {
      // make sure there is a nice clean space of at least one blank line
      // before a new function definition
      if (!this._output.just_added_blankline() && !current_token.comments_before) {
        this.print_newline();
        this.print_newline(true);
      }
    }
    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
      if (reserved_array(this._flags.last_token, ['get', 'set', 'new', 'export']) ||
        reserved_array(this._flags.last_token, newline_restricted_tokens)) {
        this._output.space_before_token = true;
      } else if (reserved_word(this._flags.last_token, 'default') && this._last_last_text === 'export') {
        this._output.space_before_token = true;
      } else if (this._flags.last_token.text === 'declare') {
        // accomodates Typescript declare function formatting
        this._output.space_before_token = true;
      } else {
        this.print_newline();
      }
    } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === '=') {
      // foo = function
      this._output.space_before_token = true;
    } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode))) {
      // (function
    } else {
      this.print_newline();
    }

    this.print_token(current_token);
    this._flags.last_word = current_token.text;
    return;
  }

  var prefix = 'NONE';

  if (this._flags.last_token.type === TOKEN.END_BLOCK) {

    if (this._previous_flags.inline_frame) {
      prefix = 'SPACE';
    } else if (!reserved_array(current_token, ['else', 'catch', 'finally', 'from'])) {
      prefix = 'NEWLINE';
    } else {
      if (this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) {
        prefix = 'NEWLINE';
      } else {
        prefix = 'SPACE';
        this._output.space_before_token = true;
      }
    }
  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
    // TODO: Should this be for STATEMENT as well?
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN.STRING) {
    prefix = 'NEWLINE';
  } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD ||
    (this._flags.last_token.text === '*' &&
      (in_array(this._last_last_text, ['function', 'yield']) ||
        (this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ['{', ',']))))) {
    prefix = 'SPACE';
  } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
    if (this._flags.inline_frame) {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }
  } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
    this._output.space_before_token = true;
    prefix = 'NEWLINE';
  }

  if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
    if (this._flags.inline_frame || this._flags.last_token.text === 'else' || this._flags.last_token.text === 'export') {
      prefix = 'SPACE';
    } else {
      prefix = 'NEWLINE';
    }

  }

  if (reserved_array(current_token, ['else', 'catch', 'finally'])) {
    if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) ||
        this._options.brace_style === "expand" ||
        this._options.brace_style === "end-expand" ||
        (this._options.brace_style === "none" && current_token.newlines)) &&
      !this._flags.inline_frame) {
      this.print_newline();
    } else {
      this._output.trim(true);
      var line = this._output.current_line;
      // If we trimmed and there's something other than a close block before us
      // put a newline back in.  Handles '} // comment' scenario.
      if (line.last() !== '}') {
        this.print_newline();
      }
      this._output.space_before_token = true;
    }
  } else if (prefix === 'NEWLINE') {
    if (reserved_array(this._flags.last_token, special_words)) {
      // no newline between 'return nnn'
      this._output.space_before_token = true;
    } else if (this._flags.last_token.text === 'declare' && reserved_array(current_token, ['var', 'let', 'const'])) {
      // accomodates Typescript declare formatting
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
      if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ['var', 'let', 'const'])) && this._flags.last_token.text !== ':') {
        // no need to force newline on 'var': for (var x = 0...)
        if (reserved_word(current_token, 'if') && reserved_word(current_token.previous, 'else')) {
          // no newline for } else if {
          this._output.space_before_token = true;
        } else {
          this.print_newline();
        }
      }
    } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ')') {
      this.print_newline();
    }
  } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === ',' && this._last_last_text === '}') {
    this.print_newline(); // }, in lists get a newline treatment
  } else if (prefix === 'SPACE') {
    this._output.space_before_token = true;
  }
  if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
    this._output.space_before_token = true;
  }
  this.print_token(current_token);
  this._flags.last_word = current_token.text;

  if (current_token.type === TOKEN.RESERVED) {
    if (current_token.text === 'do') {
      this._flags.do_block = true;
    } else if (current_token.text === 'if') {
      this._flags.if_block = true;
    } else if (current_token.text === 'import') {
      this._flags.import_block = true;
    } else if (this._flags.import_block && reserved_word(current_token, 'from')) {
      this._flags.import_block = false;
    }
  }
};

Beautifier.prototype.handle_semicolon = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // Semicolon can be the start (and end) of a statement
    this._output.space_before_token = false;
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  var next_token = this._tokens.peek();
  while (this._flags.mode === MODE.Statement &&
    !(this._flags.if_block && reserved_word(next_token, 'else')) &&
    !this._flags.do_block) {
    this.restore_mode();
  }

  // hacky but effective for the moment
  if (this._flags.import_block) {
    this._flags.import_block = false;
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_string = function(current_token) {
  if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === '' && (current_token.previous.text === ')' || this._flags.last_token.type === TOKEN.WORD)) {
    //Conditional for detectign backtick strings
  } else if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
    // One difference - strings want at least a space before
    this._output.space_before_token = true;
  } else {
    this.handle_whitespace_and_comments(current_token);
    if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
      this._output.space_before_token = true;
    } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
      if (!this.start_of_object_property()) {
        this.allow_wrap_or_preserved_newline(current_token);
      }
    } else if ((current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === ']' || current_token.previous.text === ')') && current_token.newlines === 0)) {
      this._output.space_before_token = true;
    } else {
      this.print_newline();
    }
  }
  this.print_token(current_token);
};

Beautifier.prototype.handle_equals = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    this.handle_whitespace_and_comments(current_token);
  }

  if (this._flags.declaration_statement) {
    // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done
    this._flags.declaration_assignment = true;
  }
  this._output.space_before_token = true;
  this.print_token(current_token);
  this._output.space_before_token = true;
};

Beautifier.prototype.handle_comma = function(current_token) {
  this.handle_whitespace_and_comments(current_token, true);

  this.print_token(current_token);
  this._output.space_before_token = true;
  if (this._flags.declaration_statement) {
    if (is_expression(this._flags.parent.mode)) {
      // do not break on comma, for(var a = 1, b = 2)
      this._flags.declaration_assignment = false;
    }

    if (this._flags.declaration_assignment) {
      this._flags.declaration_assignment = false;
      this.print_newline(false, true);
    } else if (this._options.comma_first) {
      // for comma-first, we want to allow a newline before the comma
      // to turn into a newline after the comma, which we will fixup later
      this.allow_wrap_or_preserved_newline(current_token);
    }
  } else if (this._flags.mode === MODE.ObjectLiteral ||
    (this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral)) {
    if (this._flags.mode === MODE.Statement) {
      this.restore_mode();
    }

    if (!this._flags.inline_frame) {
      this.print_newline();
    }
  } else if (this._options.comma_first) {
    // EXPR or DO_BLOCK
    // for comma-first, we want to allow a newline before the comma
    // to turn into a newline after the comma, which we will fixup later
    this.allow_wrap_or_preserved_newline(current_token);
  }
};

Beautifier.prototype.handle_operator = function(current_token) {
  var isGeneratorAsterisk = current_token.text === '*' &&
    (reserved_array(this._flags.last_token, ['function', 'yield']) ||
      (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]))
    );
  var isUnary = in_array(current_token.text, ['-', '+']) && (
    in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) ||
    in_array(this._flags.last_token.text, line_starters) ||
    this._flags.last_token.text === ','
  );

  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    var preserve_statement_flags = !isGeneratorAsterisk;
    this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
  }

  // hack for actionscript's import .*;
  if (current_token.text === '*' && this._flags.last_token.type === TOKEN.DOT) {
    this.print_token(current_token);
    return;
  }

  if (current_token.text === '::') {
    // no spaces around exotic namespacing syntax operator
    this.print_token(current_token);
    return;
  }

  if (in_array(current_token.text, ['-', '+']) && this.start_of_object_property()) {
    // numeric value with +/- symbol in front as a property
    this.print_token(current_token);
    return;
  }

  // Allow line wrapping between operators when operator_position is
  //   set to before or preserve
  if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
    this.allow_wrap_or_preserved_newline(current_token);
  }

  if (current_token.text === ':' && this._flags.in_case) {
    this.print_token(current_token);

    this._flags.in_case = false;
    this._flags.case_body = true;
    if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
      this.indent();
      this.print_newline();
      this._flags.case_block = false;
    } else {
      this._flags.case_block = true;
      this._output.space_before_token = true;
    }
    return;
  }

  var space_before = true;
  var space_after = true;
  var in_ternary = false;
  if (current_token.text === ':') {
    if (this._flags.ternary_depth === 0) {
      // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.
      space_before = false;
    } else {
      this._flags.ternary_depth -= 1;
      in_ternary = true;
    }
  } else if (current_token.text === '?') {
    this._flags.ternary_depth += 1;
  }

  // let's handle the operator_position option prior to any conflicting logic
  if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
    var isColon = current_token.text === ':';
    var isTernaryColon = (isColon && in_ternary);
    var isOtherColon = (isColon && !in_ternary);

    switch (this._options.operator_position) {
      case OPERATOR_POSITION.before_newline:
        // if the current token is : and it's not a ternary statement then we set space_before to false
        this._output.space_before_token = !isOtherColon;

        this.print_token(current_token);

        if (!isColon || isTernaryColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.after_newline:
        // if the current token is anything but colon, or (via deduction) it's a colon and in a ternary statement,
        //   then print a newline.

        this._output.space_before_token = true;

        if (!isColon || isTernaryColon) {
          if (this._tokens.peek().newlines) {
            this.print_newline(false, true);
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else {
          this._output.space_before_token = false;
        }

        this.print_token(current_token);

        this._output.space_before_token = true;
        return;

      case OPERATOR_POSITION.preserve_newline:
        if (!isOtherColon) {
          this.allow_wrap_or_preserved_newline(current_token);
        }

        // if we just added a newline, or the current token is : and it's not a ternary statement,
        //   then we set space_before to false
        space_before = !(this._output.just_added_newline() || isOtherColon);

        this._output.space_before_token = space_before;
        this.print_token(current_token);
        this._output.space_before_token = true;
        return;
    }
  }

  if (isGeneratorAsterisk) {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = false;
    var next_token = this._tokens.peek();
    space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
  } else if (current_token.text === '...') {
    this.allow_wrap_or_preserved_newline(current_token);
    space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
    space_after = false;
  } else if (in_array(current_token.text, ['--', '++', '!', '~']) || isUnary) {
    // unary operators (and binary +/- pretending to be unary) special cases
    if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
      this.allow_wrap_or_preserved_newline(current_token);
    }

    space_before = false;
    space_after = false;

    // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1
    // if there is a newline between -- or ++ and anything else we should preserve it.
    if (current_token.newlines && (current_token.text === '--' || current_token.text === '++' || current_token.text === '~')) {
      var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
      if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
        this.restore_mode();
      }
      this.print_newline(new_line_needed, true);
    }

    if (this._flags.last_token.text === ';' && is_expression(this._flags.mode)) {
      // for (;; ++i)
      //        ^^^
      space_before = true;
    }

    if (this._flags.last_token.type === TOKEN.RESERVED) {
      space_before = true;
    } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
      space_before = !(this._flags.last_token.text === ']' && (current_token.text === '--' || current_token.text === '++'));
    } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
      // a++ + ++b;
      // a - -b
      space_before = in_array(current_token.text, ['--', '-', '++', '+']) && in_array(this._flags.last_token.text, ['--', '-', '++', '+']);
      // + and - are not unary when preceeded by -- or ++ operator
      // a-- + b
      // a * +b
      // a - -b
      if (in_array(current_token.text, ['+', '-']) && in_array(this._flags.last_token.text, ['--', '++'])) {
        space_after = true;
      }
    }


    if (((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame) || this._flags.mode === MODE.Statement) &&
      (this._flags.last_token.text === '{' || this._flags.last_token.text === ';')) {
      // { foo; --i }
      // foo(); --bar;
      this.print_newline();
    }
  }

  this._output.space_before_token = this._output.space_before_token || space_before;
  this.print_token(current_token);
  this._output.space_before_token = space_after;
};

Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
  if (this._output.raw) {
    this._output.add_raw_token(current_token);
    if (current_token.directives && current_token.directives.preserve === 'end') {
      // If we're testing the raw output behavior, do not allow a directive to turn it off.
      this._output.raw = this._options.test_output_raw;
    }
    return;
  }

  if (current_token.directives) {
    this.print_newline(false, preserve_statement_flags);
    this.print_token(current_token);
    if (current_token.directives.preserve === 'start') {
      this._output.raw = true;
    }
    this.print_newline(false, true);
    return;
  }

  // inline block
  if (!acorn.newline.test(current_token.text) && !current_token.newlines) {
    this._output.space_before_token = true;
    this.print_token(current_token);
    this._output.space_before_token = true;
    return;
  } else {
    this.print_block_commment(current_token, preserve_statement_flags);
  }
};

Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
  var lines = split_linebreaks(current_token.text);
  var j; // iterator for this case
  var javadoc = false;
  var starless = false;
  var lastIndent = current_token.whitespace_before;
  var lastIndentLength = lastIndent.length;

  // block comment starts with a new line
  this.print_newline(false, preserve_statement_flags);

  // first line always indented
  this.print_token_line_indentation(current_token);
  this._output.add_token(lines[0]);
  this.print_newline(false, preserve_statement_flags);


  if (lines.length > 1) {
    lines = lines.slice(1);
    javadoc = all_lines_start_with(lines, '*');
    starless = each_line_matches_indent(lines, lastIndent);

    if (javadoc) {
      this._flags.alignment = 1;
    }

    for (j = 0; j < lines.length; j++) {
      if (javadoc) {
        // javadoc: reformat and re-indent
        this.print_token_line_indentation(current_token);
        this._output.add_token(ltrim(lines[j]));
      } else if (starless && lines[j]) {
        // starless: re-indent non-empty content, avoiding trim
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[j].substring(lastIndentLength));
      } else {
        // normal comments output raw
        this._output.current_line.set_indent(-1);
        this._output.add_token(lines[j]);
      }

      // for comments on their own line or  more than one line, make sure there's a new line after
      this.print_newline(false, preserve_statement_flags);
    }

    this._flags.alignment = 0;
  }
};


Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
  if (current_token.newlines) {
    this.print_newline(false, preserve_statement_flags);
  } else {
    this._output.trim(true);
  }

  this._output.space_before_token = true;
  this.print_token(current_token);
  this.print_newline(false, preserve_statement_flags);
};

Beautifier.prototype.handle_dot = function(current_token) {
  if (this.start_of_statement(current_token)) {
    // The conditional starts the statement if appropriate.
  } else {
    this.handle_whitespace_and_comments(current_token, true);
  }

  if (this._flags.last_token.text.match('^[0-9]+$')) {
    this._output.space_before_token = true;
  }

  if (reserved_array(this._flags.last_token, special_words)) {
    this._output.space_before_token = false;
  } else {
    // allow preserved newlines before dots in general
    // force newlines on dots after close paren when break_chained - for bar().baz()
    this.allow_wrap_or_preserved_newline(current_token,
      this._flags.last_token.text === ')' && this._options.break_chained_methods);
  }

  // Only unindent chained method dot if this dot starts a new line.
  // Otherwise the automatic extra indentation removal will handle the over indent
  if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
    this.deindent();
  }

  this.print_token(current_token);
};

Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
  this.print_token(current_token);

  if (current_token.text[current_token.text.length - 1] === '\n') {
    this.print_newline(false, preserve_statement_flags);
  }
};

Beautifier.prototype.handle_eof = function(current_token) {
  // Unwind any open statements
  while (this._flags.mode === MODE.Statement) {
    this.restore_mode();
  }
  this.handle_whitespace_and_comments(current_token);
};

module.exports.Beautifier = Beautifier;


/***/ }),
/* 2 */
/***/ (function(module) {

/*jshint node:true */
/*
  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function OutputLine(parent) {
  this.__parent = parent;
  this.__character_count = 0;
  // use indent_count as a marker for this.__lines that have preserved indentation
  this.__indent_count = -1;
  this.__alignment_count = 0;
  this.__wrap_point_index = 0;
  this.__wrap_point_character_count = 0;
  this.__wrap_point_indent_count = -1;
  this.__wrap_point_alignment_count = 0;

  this.__items = [];
}

OutputLine.prototype.clone_empty = function() {
  var line = new OutputLine(this.__parent);
  line.set_indent(this.__indent_count, this.__alignment_count);
  return line;
};

OutputLine.prototype.item = function(index) {
  if (index < 0) {
    return this.__items[this.__items.length + index];
  } else {
    return this.__items[index];
  }
};

OutputLine.prototype.has_match = function(pattern) {
  for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
    if (this.__items[lastCheckedOutput].match(pattern)) {
      return true;
    }
  }
  return false;
};

OutputLine.prototype.set_indent = function(indent, alignment) {
  if (this.is_empty()) {
    this.__indent_count = indent || 0;
    this.__alignment_count = alignment || 0;
    this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
  }
};

OutputLine.prototype._set_wrap_point = function() {
  if (this.__parent.wrap_line_length) {
    this.__wrap_point_index = this.__items.length;
    this.__wrap_point_character_count = this.__character_count;
    this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
    this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
  }
};

OutputLine.prototype._should_wrap = function() {
  return this.__wrap_point_index &&
    this.__character_count > this.__parent.wrap_line_length &&
    this.__wrap_point_character_count > this.__parent.next_line.__character_count;
};

OutputLine.prototype._allow_wrap = function() {
  if (this._should_wrap()) {
    this.__parent.add_new_line();
    var next = this.__parent.current_line;
    next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
    next.__items = this.__items.slice(this.__wrap_point_index);
    this.__items = this.__items.slice(0, this.__wrap_point_index);

    next.__character_count += this.__character_count - this.__wrap_point_character_count;
    this.__character_count = this.__wrap_point_character_count;

    if (next.__items[0] === " ") {
      next.__items.splice(0, 1);
      next.__character_count -= 1;
    }
    return true;
  }
  return false;
};

OutputLine.prototype.is_empty = function() {
  return this.__items.length === 0;
};

OutputLine.prototype.last = function() {
  if (!this.is_empty()) {
    return this.__items[this.__items.length - 1];
  } else {
    return null;
  }
};

OutputLine.prototype.push = function(item) {
  this.__items.push(item);
  var last_newline_index = item.lastIndexOf('\n');
  if (last_newline_index !== -1) {
    this.__character_count = item.length - last_newline_index;
  } else {
    this.__character_count += item.length;
  }
};

OutputLine.prototype.pop = function() {
  var item = null;
  if (!this.is_empty()) {
    item = this.__items.pop();
    this.__character_count -= item.length;
  }
  return item;
};


OutputLine.prototype._remove_indent = function() {
  if (this.__indent_count > 0) {
    this.__indent_count -= 1;
    this.__character_count -= this.__parent.indent_size;
  }
};

OutputLine.prototype._remove_wrap_indent = function() {
  if (this.__wrap_point_indent_count > 0) {
    this.__wrap_point_indent_count -= 1;
  }
};
OutputLine.prototype.trim = function() {
  while (this.last() === ' ') {
    this.__items.pop();
    this.__character_count -= 1;
  }
};

OutputLine.prototype.toString = function() {
  var result = '';
  if (this.is_empty()) {
    if (this.__parent.indent_empty_lines) {
      result = this.__parent.get_indent_string(this.__indent_count);
    }
  } else {
    result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
    result += this.__items.join('');
  }
  return result;
};

function IndentStringCache(options, baseIndentString) {
  this.__cache = [''];
  this.__indent_size = options.indent_size;
  this.__indent_string = options.indent_char;
  if (!options.indent_with_tabs) {
    this.__indent_string = new Array(options.indent_size + 1).join(options.indent_char);
  }

  // Set to null to continue support for auto detection of base indent
  baseIndentString = baseIndentString || '';
  if (options.indent_level > 0) {
    baseIndentString = new Array(options.indent_level + 1).join(this.__indent_string);
  }

  this.__base_string = baseIndentString;
  this.__base_string_length = baseIndentString.length;
}

IndentStringCache.prototype.get_indent_size = function(indent, column) {
  var result = this.__base_string_length;
  column = column || 0;
  if (indent < 0) {
    result = 0;
  }
  result += indent * this.__indent_size;
  result += column;
  return result;
};

IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
  var result = this.__base_string;
  column = column || 0;
  if (indent_level < 0) {
    indent_level = 0;
    result = '';
  }
  column += indent_level * this.__indent_size;
  this.__ensure_cache(column);
  result += this.__cache[column];
  return result;
};

IndentStringCache.prototype.__ensure_cache = function(column) {
  while (column >= this.__cache.length) {
    this.__add_column();
  }
};

IndentStringCache.prototype.__add_column = function() {
  var column = this.__cache.length;
  var indent = 0;
  var result = '';
  if (this.__indent_size && column >= this.__indent_size) {
    indent = Math.floor(column / this.__indent_size);
    column -= indent * this.__indent_size;
    result = new Array(indent + 1).join(this.__indent_string);
  }
  if (column) {
    result += new Array(column + 1).join(' ');
  }

  this.__cache.push(result);
};

function Output(options, baseIndentString) {
  this.__indent_cache = new IndentStringCache(options, baseIndentString);
  this.raw = false;
  this._end_with_newline = options.end_with_newline;
  this.indent_size = options.indent_size;
  this.wrap_line_length = options.wrap_line_length;
  this.indent_empty_lines = options.indent_empty_lines;
  this.__lines = [];
  this.previous_line = null;
  this.current_line = null;
  this.next_line = new OutputLine(this);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
  // initialize
  this.__add_outputline();
}

Output.prototype.__add_outputline = function() {
  this.previous_line = this.current_line;
  this.current_line = this.next_line.clone_empty();
  this.__lines.push(this.current_line);
};

Output.prototype.get_line_number = function() {
  return this.__lines.length;
};

Output.prototype.get_indent_string = function(indent, column) {
  return this.__indent_cache.get_indent_string(indent, column);
};

Output.prototype.get_indent_size = function(indent, column) {
  return this.__indent_cache.get_indent_size(indent, column);
};

Output.prototype.is_empty = function() {
  return !this.previous_line && this.current_line.is_empty();
};

Output.prototype.add_new_line = function(force_newline) {
  // never newline at the start of file
  // otherwise, newline only if we didn't just add one or we're forced
  if (this.is_empty() ||
    (!force_newline && this.just_added_newline())) {
    return false;
  }

  // if raw output is enabled, don't print additional newlines,
  // but still return True as though you had
  if (!this.raw) {
    this.__add_outputline();
  }
  return true;
};

Output.prototype.get_code = function(eol) {
  this.trim(true);

  // handle some edge cases where the last tokens
  // has text that ends with newline(s)
  var last_item = this.current_line.pop();
  if (last_item) {
    if (last_item[last_item.length - 1] === '\n') {
      last_item = last_item.replace(/\n+$/g, '');
    }
    this.current_line.push(last_item);
  }

  if (this._end_with_newline) {
    this.__add_outputline();
  }

  var sweet_code = this.__lines.join('\n');

  if (eol !== '\n') {
    sweet_code = sweet_code.replace(/[\n]/g, eol);
  }
  return sweet_code;
};

Output.prototype.set_wrap_point = function() {
  this.current_line._set_wrap_point();
};

Output.prototype.set_indent = function(indent, alignment) {
  indent = indent || 0;
  alignment = alignment || 0;

  // Next line stores alignment values
  this.next_line.set_indent(indent, alignment);

  // Never indent your first output indent at the start of the file
  if (this.__lines.length > 1) {
    this.current_line.set_indent(indent, alignment);
    return true;
  }

  this.current_line.set_indent();
  return false;
};

Output.prototype.add_raw_token = function(token) {
  for (var x = 0; x < token.newlines; x++) {
    this.__add_outputline();
  }
  this.current_line.set_indent(-1);
  this.current_line.push(token.whitespace_before);
  this.current_line.push(token.text);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = false;
};

Output.prototype.add_token = function(printable_token) {
  this.__add_space_before_token();
  this.current_line.push(printable_token);
  this.space_before_token = false;
  this.non_breaking_space = false;
  this.previous_token_wrapped = this.current_line._allow_wrap();
};

Output.prototype.__add_space_before_token = function() {
  if (this.space_before_token && !this.just_added_newline()) {
    if (!this.non_breaking_space) {
      this.set_wrap_point();
    }
    this.current_line.push(' ');
  }
};

Output.prototype.remove_indent = function(index) {
  var output_length = this.__lines.length;
  while (index < output_length) {
    this.__lines[index]._remove_indent();
    index++;
  }
  this.current_line._remove_wrap_indent();
};

Output.prototype.trim = function(eat_newlines) {
  eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;

  this.current_line.trim();

  while (eat_newlines && this.__lines.length > 1 &&
    this.current_line.is_empty()) {
    this.__lines.pop();
    this.current_line = this.__lines[this.__lines.length - 1];
    this.current_line.trim();
  }

  this.previous_line = this.__lines.length > 1 ?
    this.__lines[this.__lines.length - 2] : null;
};

Output.prototype.just_added_newline = function() {
  return this.current_line.is_empty();
};

Output.prototype.just_added_blankline = function() {
  return this.is_empty() ||
    (this.current_line.is_empty() && this.previous_line.is_empty());
};

Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
  var index = this.__lines.length - 2;
  while (index >= 0) {
    var potentialEmptyLine = this.__lines[index];
    if (potentialEmptyLine.is_empty()) {
      break;
    } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 &&
      potentialEmptyLine.item(-1) !== ends_with) {
      this.__lines.splice(index + 1, 0, new OutputLine(this));
      this.previous_line = this.__lines[this.__lines.length - 2];
      break;
    }
    index--;
  }
};

module.exports.Output = Output;


/***/ }),
/* 3 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Token(type, text, newlines, whitespace_before) {
  this.type = type;
  this.text = text;

  // comments_before are
  // comments that have a new line before them
  // and may or may not have a newline after
  // this is a set of comments before
  this.comments_before = null; /* inline comment*/


  // this.comments_after =  new TokenStream(); // no new line before and newline after
  this.newlines = newlines || 0;
  this.whitespace_before = whitespace_before || '';
  this.parent = null;
  this.next = null;
  this.previous = null;
  this.opened = null;
  this.closed = null;
  this.directives = null;
}


module.exports.Token = Token;


/***/ }),
/* 4 */
/***/ (function(__unused_webpack_module, exports) {

/* jshint node: true, curly: false */
// Parts of this section of code is taken from acorn.
//
// Acorn was written by Marijn Haverbeke and released under an MIT
// license. The Unicode regexps (for identifiers and whitespace) were
// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/marijnh/acorn.git

// ## Character categories




// acorn used char codes to squeeze the last bit of performance out
// Beautifier is okay without that, so we're using regex
// permit # (23), $ (36), and @ (64). @ is used in ES7 decorators.
// 65 through 91 are uppercase letters.
// permit _ (95).
// 97 through 123 are lowercase letters.
var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";

// inside an identifier @ is not allowed but 0-9 are.
var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
//var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
//var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

var unicodeEscapeOrCodePoint = "\\\\u[0-9a-fA-F]{4}|\\\\u\\{[0-9a-fA-F]+\\}";
var identifierStart = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
var identifierChars = "(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";

exports.identifier = new RegExp(identifierStart + identifierChars, 'g');
exports.identifierStart = new RegExp(identifierStart);
exports.identifierMatch = new RegExp("(?:" + unicodeEscapeOrCodePoint + "|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/; // jshint ignore:line

// Whether a single character denotes a newline.

exports.newline = /[\n\r\u2028\u2029]/;

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

// in javascript, these two differ
// in python they are the same, different methods are called on them
exports.lineBreak = new RegExp('\r\n|' + exports.newline.source);
exports.allLineBreaks = new RegExp(exports.lineBreak.source, 'g');


/***/ }),
/* 5 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_87818__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var BaseOptions = (__nested_webpack_require_87818__(6).Options);

var validPositionValues = ['before-newline', 'after-newline', 'preserve-newline'];

function Options(options) {
  BaseOptions.call(this, options, 'js');

  // compatibility, re
  var raw_brace_style = this.raw_options.brace_style || null;
  if (raw_brace_style === "expand-strict") { //graceful handling of deprecated option
    this.raw_options.brace_style = "expand";
  } else if (raw_brace_style === "collapse-preserve-inline") { //graceful handling of deprecated option
    this.raw_options.brace_style = "collapse,preserve-inline";
  } else if (this.raw_options.braces_on_own_line !== undefined) { //graceful handling of deprecated option
    this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
    // } else if (!raw_brace_style) { //Nothing exists to set it
    //   raw_brace_style = "collapse";
  }

  //preserve-inline in delimited string will trigger brace_preserve_inline, everything
  //else is considered a brace_style and the last one only will have an effect

  var brace_style_split = this._get_selection_list('brace_style', ['collapse', 'expand', 'end-expand', 'none', 'preserve-inline']);

  this.brace_preserve_inline = false; //Defaults in case one or other was not specified in meta-option
  this.brace_style = "collapse";

  for (var bs = 0; bs < brace_style_split.length; bs++) {
    if (brace_style_split[bs] === "preserve-inline") {
      this.brace_preserve_inline = true;
    } else {
      this.brace_style = brace_style_split[bs];
    }
  }

  this.unindent_chained_methods = this._get_boolean('unindent_chained_methods');
  this.break_chained_methods = this._get_boolean('break_chained_methods');
  this.space_in_paren = this._get_boolean('space_in_paren');
  this.space_in_empty_paren = this._get_boolean('space_in_empty_paren');
  this.jslint_happy = this._get_boolean('jslint_happy');
  this.space_after_anon_function = this._get_boolean('space_after_anon_function');
  this.space_after_named_function = this._get_boolean('space_after_named_function');
  this.keep_array_indentation = this._get_boolean('keep_array_indentation');
  this.space_before_conditional = this._get_boolean('space_before_conditional', true);
  this.unescape_strings = this._get_boolean('unescape_strings');
  this.e4x = this._get_boolean('e4x');
  this.comma_first = this._get_boolean('comma_first');
  this.operator_position = this._get_selection('operator_position', validPositionValues);

  // For testing of beautify preserve:start directive
  this.test_output_raw = this._get_boolean('test_output_raw');

  // force this._options.space_after_anon_function to true if this._options.jslint_happy
  if (this.jslint_happy) {
    this.space_after_anon_function = true;
  }

}
Options.prototype = new BaseOptions();



module.exports.Options = Options;


/***/ }),
/* 6 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Options(options, merge_child_field) {
  this.raw_options = _mergeOpts(options, merge_child_field);

  // Support passing the source text back with no change
  this.disabled = this._get_boolean('disabled');

  this.eol = this._get_characters('eol', 'auto');
  this.end_with_newline = this._get_boolean('end_with_newline');
  this.indent_size = this._get_number('indent_size', 4);
  this.indent_char = this._get_characters('indent_char', ' ');
  this.indent_level = this._get_number('indent_level');

  this.preserve_newlines = this._get_boolean('preserve_newlines', true);
  this.max_preserve_newlines = this._get_number('max_preserve_newlines', 32786);
  if (!this.preserve_newlines) {
    this.max_preserve_newlines = 0;
  }

  this.indent_with_tabs = this._get_boolean('indent_with_tabs', this.indent_char === '\t');
  if (this.indent_with_tabs) {
    this.indent_char = '\t';

    // indent_size behavior changed after 1.8.6
    // It used to be that indent_size would be
    // set to 1 for indent_with_tabs. That is no longer needed and
    // actually doesn't make sense - why not use spaces? Further,
    // that might produce unexpected behavior - tabs being used
    // for single-column alignment. So, when indent_with_tabs is true
    // and indent_size is 1, reset indent_size to 4.
    if (this.indent_size === 1) {
      this.indent_size = 4;
    }
  }

  // Backwards compat with 1.3.x
  this.wrap_line_length = this._get_number('wrap_line_length', this._get_number('max_char'));

  this.indent_empty_lines = this._get_boolean('indent_empty_lines');

  // valid templating languages ['django', 'erb', 'handlebars', 'php', 'smarty']
  // For now, 'auto' = all off for javascript, all on for html (and inline javascript).
  // other values ignored
  this.templating = this._get_selection_list('templating', ['auto', 'none', 'django', 'erb', 'handlebars', 'php', 'smarty'], ['auto']);
}

Options.prototype._get_array = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || [];
  if (typeof option_value === 'object') {
    if (option_value !== null && typeof option_value.concat === 'function') {
      result = option_value.concat();
    }
  } else if (typeof option_value === 'string') {
    result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
  }
  return result;
};

Options.prototype._get_boolean = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = option_value === undefined ? !!default_value : !!option_value;
  return result;
};

Options.prototype._get_characters = function(name, default_value) {
  var option_value = this.raw_options[name];
  var result = default_value || '';
  if (typeof option_value === 'string') {
    result = option_value.replace(/\\r/, '\r').replace(/\\n/, '\n').replace(/\\t/, '\t');
  }
  return result;
};

Options.prototype._get_number = function(name, default_value) {
  var option_value = this.raw_options[name];
  default_value = parseInt(default_value, 10);
  if (isNaN(default_value)) {
    default_value = 0;
  }
  var result = parseInt(option_value, 10);
  if (isNaN(result)) {
    result = default_value;
  }
  return result;
};

Options.prototype._get_selection = function(name, selection_list, default_value) {
  var result = this._get_selection_list(name, selection_list, default_value);
  if (result.length !== 1) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result[0];
};


Options.prototype._get_selection_list = function(name, selection_list, default_value) {
  if (!selection_list || selection_list.length === 0) {
    throw new Error("Selection list cannot be empty.");
  }

  default_value = default_value || [selection_list[0]];
  if (!this._is_valid_selection(default_value, selection_list)) {
    throw new Error("Invalid Default Value!");
  }

  var result = this._get_array(name, default_value);
  if (!this._is_valid_selection(result, selection_list)) {
    throw new Error(
      "Invalid Option Value: The option '" + name + "' can contain only the following values:\n" +
      selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
  }

  return result;
};

Options.prototype._is_valid_selection = function(result, selection_list) {
  return result.length && selection_list.length &&
    !result.some(function(item) { return selection_list.indexOf(item) === -1; });
};


// merges child options up with the parent options object
// Example: obj = {a: 1, b: {a: 2}}
//          mergeOpts(obj, 'b')
//
//          Returns: {a: 2}
function _mergeOpts(allOptions, childFieldName) {
  var finalOpts = {};
  allOptions = _normalizeOpts(allOptions);
  var name;

  for (name in allOptions) {
    if (name !== childFieldName) {
      finalOpts[name] = allOptions[name];
    }
  }

  //merge in the per type settings for the childFieldName
  if (childFieldName && allOptions[childFieldName]) {
    for (name in allOptions[childFieldName]) {
      finalOpts[name] = allOptions[childFieldName][name];
    }
  }
  return finalOpts;
}

function _normalizeOpts(options) {
  var convertedOpts = {};
  var key;

  for (key in options) {
    var newKey = key.replace(/-/g, "_");
    convertedOpts[newKey] = options[key];
  }
  return convertedOpts;
}

module.exports.Options = Options;
module.exports.normalizeOpts = _normalizeOpts;
module.exports.mergeOpts = _mergeOpts;


/***/ }),
/* 7 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_98714__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var InputScanner = (__nested_webpack_require_98714__(8).InputScanner);
var BaseTokenizer = (__nested_webpack_require_98714__(9).Tokenizer);
var BASETOKEN = (__nested_webpack_require_98714__(9).TOKEN);
var Directives = (__nested_webpack_require_98714__(13).Directives);
var acorn = __nested_webpack_require_98714__(4);
var Pattern = (__nested_webpack_require_98714__(12).Pattern);
var TemplatablePattern = (__nested_webpack_require_98714__(14).TemplatablePattern);


function in_array(what, arr) {
  return arr.indexOf(what) !== -1;
}


var TOKEN = {
  START_EXPR: 'TK_START_EXPR',
  END_EXPR: 'TK_END_EXPR',
  START_BLOCK: 'TK_START_BLOCK',
  END_BLOCK: 'TK_END_BLOCK',
  WORD: 'TK_WORD',
  RESERVED: 'TK_RESERVED',
  SEMICOLON: 'TK_SEMICOLON',
  STRING: 'TK_STRING',
  EQUALS: 'TK_EQUALS',
  OPERATOR: 'TK_OPERATOR',
  COMMA: 'TK_COMMA',
  BLOCK_COMMENT: 'TK_BLOCK_COMMENT',
  COMMENT: 'TK_COMMENT',
  DOT: 'TK_DOT',
  UNKNOWN: 'TK_UNKNOWN',
  START: BASETOKEN.START,
  RAW: BASETOKEN.RAW,
  EOF: BASETOKEN.EOF
};


var directives_core = new Directives(/\/\*/, /\*\//);

var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;

var digit = /[0-9]/;

// Dot "." must be distinguished from "..." and decimal
var dot_pattern = /[^\d\.]/;

var positionable_operators = (
  ">>> === !== &&= ??= ||= " +
  "<< && >= ** != == <= >> || ?? |> " +
  "< / - + > : & % ? ^ | *").split(' ');

// IMPORTANT: this must be sorted longest to shortest or tokenizing many not work.
// Also, you must update possitionable operators separately from punct
var punct =
  ">>>= " +
  "... >>= <<= === >>> !== **= &&= ??= ||= " +
  "=> ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> " +
  "= ! ? > < : / ^ - + * & % ~ |";

punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
// ?. but not if followed by a number 
punct = '\\?\\.(?!\\d) ' + punct;
punct = punct.replace(/ /g, '|');

var punct_pattern = new RegExp(punct);

// words which should always start on new line.
var line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export'.split(',');
var reserved_words = line_starters.concat(['do', 'in', 'of', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof', 'yield', 'async', 'await', 'from', 'as', 'class', 'extends']);
var reserved_word_pattern = new RegExp('^(?:' + reserved_words.join('|') + ')$');

// var template_pattern = /(?:(?:<\?php|<\?=)[\s\S]*?\?>)|(?:<%[\s\S]*?%>)/g;

var in_html_comment;

var Tokenizer = function(input_string, options) {
  BaseTokenizer.call(this, input_string, options);

  this._patterns.whitespace = this._patterns.whitespace.matching(
    /\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source,
    /\u2028\u2029/.source);

  var pattern_reader = new Pattern(this._input);
  var templatable = new TemplatablePattern(this._input)
    .read_options(this._options);

  this.__patterns = {
    template: templatable,
    identifier: templatable.starting_with(acorn.identifier).matching(acorn.identifierMatch),
    number: pattern_reader.matching(number_pattern),
    punct: pattern_reader.matching(punct_pattern),
    // comment ends just before nearest linefeed or end of file
    comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
    //  /* ... */ comment ends with nearest */ or end of file
    block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
    html_comment_start: pattern_reader.matching(/<!--/),
    html_comment_end: pattern_reader.matching(/-->/),
    include: pattern_reader.starting_with(/#include/).until_after(acorn.lineBreak),
    shebang: pattern_reader.starting_with(/#!/).until_after(acorn.lineBreak),
    xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
    single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
    double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
    template_text: templatable.until(/[`\\$]/),
    template_expression: templatable.until(/[`}\\]/)
  };

};
Tokenizer.prototype = new BaseTokenizer();

Tokenizer.prototype._is_comment = function(current_token) {
  return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
};

Tokenizer.prototype._is_opening = function(current_token) {
  return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) {
  return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) &&
    (open_token && (
      (current_token.text === ']' && open_token.text === '[') ||
      (current_token.text === ')' && open_token.text === '(') ||
      (current_token.text === '}' && open_token.text === '{')));
};

Tokenizer.prototype._reset = function() {
  in_html_comment = false;
};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  var token = null;
  this._readWhitespace();
  var c = this._input.peek();

  if (c === null) {
    return this._create_token(TOKEN.EOF, '');
  }

  token = token || this._read_non_javascript(c);
  token = token || this._read_string(c);
  token = token || this._read_pair(c, this._input.peek(1)); // Issue #2062 hack for record type '#{'
  token = token || this._read_word(previous_token);
  token = token || this._read_singles(c);
  token = token || this._read_comment(c);
  token = token || this._read_regexp(c, previous_token);
  token = token || this._read_xml(c, previous_token);
  token = token || this._read_punctuation();
  token = token || this._create_token(TOKEN.UNKNOWN, this._input.next());

  return token;
};

Tokenizer.prototype._read_word = function(previous_token) {
  var resulting_string;
  resulting_string = this.__patterns.identifier.read();
  if (resulting_string !== '') {
    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');
    if (!(previous_token.type === TOKEN.DOT ||
        (previous_token.type === TOKEN.RESERVED && (previous_token.text === 'set' || previous_token.text === 'get'))) &&
      reserved_word_pattern.test(resulting_string)) {
      if ((resulting_string === 'in' || resulting_string === 'of') &&
        (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) { // hack for 'in' and 'of' operators
        return this._create_token(TOKEN.OPERATOR, resulting_string);
      }
      return this._create_token(TOKEN.RESERVED, resulting_string);
    }
    return this._create_token(TOKEN.WORD, resulting_string);
  }

  resulting_string = this.__patterns.number.read();
  if (resulting_string !== '') {
    return this._create_token(TOKEN.WORD, resulting_string);
  }
};

Tokenizer.prototype._read_singles = function(c) {
  var token = null;
  if (c === '(' || c === '[') {
    token = this._create_token(TOKEN.START_EXPR, c);
  } else if (c === ')' || c === ']') {
    token = this._create_token(TOKEN.END_EXPR, c);
  } else if (c === '{') {
    token = this._create_token(TOKEN.START_BLOCK, c);
  } else if (c === '}') {
    token = this._create_token(TOKEN.END_BLOCK, c);
  } else if (c === ';') {
    token = this._create_token(TOKEN.SEMICOLON, c);
  } else if (c === '.' && dot_pattern.test(this._input.peek(1))) {
    token = this._create_token(TOKEN.DOT, c);
  } else if (c === ',') {
    token = this._create_token(TOKEN.COMMA, c);
  }

  if (token) {
    this._input.next();
  }
  return token;
};

Tokenizer.prototype._read_pair = function(c, d) {
  var token = null;
  if (c === '#' && d === '{') {
    token = this._create_token(TOKEN.START_BLOCK, c + d);
  }

  if (token) {
    this._input.next();
    this._input.next();
  }
  return token;
};

Tokenizer.prototype._read_punctuation = function() {
  var resulting_string = this.__patterns.punct.read();

  if (resulting_string !== '') {
    if (resulting_string === '=') {
      return this._create_token(TOKEN.EQUALS, resulting_string);
    } else if (resulting_string === '?.') {
      return this._create_token(TOKEN.DOT, resulting_string);
    } else {
      return this._create_token(TOKEN.OPERATOR, resulting_string);
    }
  }
};

Tokenizer.prototype._read_non_javascript = function(c) {
  var resulting_string = '';

  if (c === '#') {
    if (this._is_first_token()) {
      resulting_string = this.__patterns.shebang.read();

      if (resulting_string) {
        return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
      }
    }

    // handles extendscript #includes
    resulting_string = this.__patterns.include.read();

    if (resulting_string) {
      return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + '\n');
    }

    c = this._input.next();

    // Spidermonkey-specific sharp variables for circular references. Considered obsolete.
    var sharp = '#';
    if (this._input.hasNext() && this._input.testChar(digit)) {
      do {
        c = this._input.next();
        sharp += c;
      } while (this._input.hasNext() && c !== '#' && c !== '=');
      if (c === '#') {
        //
      } else if (this._input.peek() === '[' && this._input.peek(1) === ']') {
        sharp += '[]';
        this._input.next();
        this._input.next();
      } else if (this._input.peek() === '{' && this._input.peek(1) === '}') {
        sharp += '{}';
        this._input.next();
        this._input.next();
      }
      return this._create_token(TOKEN.WORD, sharp);
    }

    this._input.back();

  } else if (c === '<' && this._is_first_token()) {
    resulting_string = this.__patterns.html_comment_start.read();
    if (resulting_string) {
      while (this._input.hasNext() && !this._input.testChar(acorn.newline)) {
        resulting_string += this._input.next();
      }
      in_html_comment = true;
      return this._create_token(TOKEN.COMMENT, resulting_string);
    }
  } else if (in_html_comment && c === '-') {
    resulting_string = this.__patterns.html_comment_end.read();
    if (resulting_string) {
      in_html_comment = false;
      return this._create_token(TOKEN.COMMENT, resulting_string);
    }
  }

  return null;
};

Tokenizer.prototype._read_comment = function(c) {
  var token = null;
  if (c === '/') {
    var comment = '';
    if (this._input.peek(1) === '*') {
      // peek for comment /* ... */
      comment = this.__patterns.block_comment.read();
      var directives = directives_core.get_directives(comment);
      if (directives && directives.ignore === 'start') {
        comment += directives_core.readIgnored(this._input);
      }
      comment = comment.replace(acorn.allLineBreaks, '\n');
      token = this._create_token(TOKEN.BLOCK_COMMENT, comment);
      token.directives = directives;
    } else if (this._input.peek(1) === '/') {
      // peek for comment // ...
      comment = this.__patterns.comment.read();
      token = this._create_token(TOKEN.COMMENT, comment);
    }
  }
  return token;
};

Tokenizer.prototype._read_string = function(c) {
  if (c === '`' || c === "'" || c === '"') {
    var resulting_string = this._input.next();
    this.has_char_escapes = false;

    if (c === '`') {
      resulting_string += this._read_string_recursive('`', true, '${');
    } else {
      resulting_string += this._read_string_recursive(c);
    }

    if (this.has_char_escapes && this._options.unescape_strings) {
      resulting_string = unescape_string(resulting_string);
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();
    }

    resulting_string = resulting_string.replace(acorn.allLineBreaks, '\n');

    return this._create_token(TOKEN.STRING, resulting_string);
  }

  return null;
};

Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
  // regex and xml can only appear in specific locations during parsing
  return (previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||
    (previous_token.type === TOKEN.END_EXPR && previous_token.text === ')' &&
      previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ['if', 'while', 'for'])) ||
    (in_array(previous_token.type, [TOKEN.COMMENT, TOKEN.START_EXPR, TOKEN.START_BLOCK, TOKEN.START,
      TOKEN.END_BLOCK, TOKEN.OPERATOR, TOKEN.EQUALS, TOKEN.EOF, TOKEN.SEMICOLON, TOKEN.COMMA
    ]));
};

Tokenizer.prototype._read_regexp = function(c, previous_token) {

  if (c === '/' && this._allow_regexp_or_xml(previous_token)) {
    // handle regexp
    //
    var resulting_string = this._input.next();
    var esc = false;

    var in_char_class = false;
    while (this._input.hasNext() &&
      ((esc || in_char_class || this._input.peek() !== c) &&
        !this._input.testChar(acorn.newline))) {
      resulting_string += this._input.peek();
      if (!esc) {
        esc = this._input.peek() === '\\';
        if (this._input.peek() === '[') {
          in_char_class = true;
        } else if (this._input.peek() === ']') {
          in_char_class = false;
        }
      } else {
        esc = false;
      }
      this._input.next();
    }

    if (this._input.peek() === c) {
      resulting_string += this._input.next();

      // regexps may have modifiers /regexp/MOD , so fetch those, too
      // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.
      resulting_string += this._input.read(acorn.identifier);
    }
    return this._create_token(TOKEN.STRING, resulting_string);
  }
  return null;
};

Tokenizer.prototype._read_xml = function(c, previous_token) {

  if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
    var xmlStr = '';
    var match = this.__patterns.xml.read_match();
    // handle e4x xml literals
    //
    if (match) {
      // Trim root tag to attempt to
      var rootTag = match[2].replace(/^{\s+/, '{').replace(/\s+}$/, '}');
      var isCurlyRoot = rootTag.indexOf('{') === 0;
      var depth = 0;
      while (match) {
        var isEndTag = !!match[1];
        var tagName = match[2];
        var isSingletonTag = (!!match[match.length - 1]) || (tagName.slice(0, 8) === "![CDATA[");
        if (!isSingletonTag &&
          (tagName === rootTag || (isCurlyRoot && tagName.replace(/^{\s+/, '{').replace(/\s+}$/, '}')))) {
          if (isEndTag) {
            --depth;
          } else {
            ++depth;
          }
        }
        xmlStr += match[0];
        if (depth <= 0) {
          break;
        }
        match = this.__patterns.xml.read_match();
      }
      // if we didn't close correctly, keep unformatted.
      if (!match) {
        xmlStr += this._input.match(/[\s\S]*/g)[0];
      }
      xmlStr = xmlStr.replace(acorn.allLineBreaks, '\n');
      return this._create_token(TOKEN.STRING, xmlStr);
    }
  }

  return null;
};

function unescape_string(s) {
  // You think that a regex would work for this
  // return s.replace(/\\x([0-9a-f]{2})/gi, function(match, val) {
  //         return String.fromCharCode(parseInt(val, 16));
  //     })
  // However, dealing with '\xff', '\\xff', '\\\xff' makes this more fun.
  var out = '',
    escaped = 0;

  var input_scan = new InputScanner(s);
  var matched = null;

  while (input_scan.hasNext()) {
    // Keep any whitespace, non-slash characters
    // also keep slash pairs.
    matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);

    if (matched) {
      out += matched[0];
    }

    if (input_scan.peek() === '\\') {
      input_scan.next();
      if (input_scan.peek() === 'x') {
        matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
      } else if (input_scan.peek() === 'u') {
        matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
        if (!matched) {
          matched = input_scan.match(/u\{([0-9A-Fa-f]+)\}/g);
        }
      } else {
        out += '\\';
        if (input_scan.hasNext()) {
          out += input_scan.next();
        }
        continue;
      }

      // If there's some error decoding, return the original string
      if (!matched) {
        return s;
      }

      escaped = parseInt(matched[1], 16);

      if (escaped > 0x7e && escaped <= 0xff && matched[0].indexOf('x') === 0) {
        // we bail out on \x7f..\xff,
        // leaving whole string escaped,
        // as it's probably completely binary
        return s;
      } else if (escaped >= 0x00 && escaped < 0x20) {
        // leave 0x00...0x1f escaped
        out += '\\' + matched[0];
      } else if (escaped > 0x10FFFF) {
        // If the escape sequence is out of bounds, keep the original sequence and continue conversion
        out += '\\' + matched[0];
      } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {
        // single-quote, apostrophe, backslash - escape these
        out += '\\' + String.fromCharCode(escaped);
      } else {
        out += String.fromCharCode(escaped);
      }
    }
  }

  return out;
}

// handle string
//
Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
  var current_char;
  var pattern;
  if (delimiter === '\'') {
    pattern = this.__patterns.single_quote;
  } else if (delimiter === '"') {
    pattern = this.__patterns.double_quote;
  } else if (delimiter === '`') {
    pattern = this.__patterns.template_text;
  } else if (delimiter === '}') {
    pattern = this.__patterns.template_expression;
  }

  var resulting_string = pattern.read();
  var next = '';
  while (this._input.hasNext()) {
    next = this._input.next();
    if (next === delimiter ||
      (!allow_unescaped_newlines && acorn.newline.test(next))) {
      this._input.back();
      break;
    } else if (next === '\\' && this._input.hasNext()) {
      current_char = this._input.peek();

      if (current_char === 'x' || current_char === 'u') {
        this.has_char_escapes = true;
      } else if (current_char === '\r' && this._input.peek(1) === '\n') {
        this._input.next();
      }
      next += this._input.next();
    } else if (start_sub) {
      if (start_sub === '${' && next === '$' && this._input.peek() === '{') {
        next += this._input.next();
      }

      if (start_sub === next) {
        if (delimiter === '`') {
          next += this._read_string_recursive('}', allow_unescaped_newlines, '`');
        } else {
          next += this._read_string_recursive('`', allow_unescaped_newlines, '${');
        }
        if (this._input.hasNext()) {
          next += this._input.next();
        }
      }
    }
    next += pattern.read();
    resulting_string += next;
  }

  return resulting_string;
};

module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;
module.exports.positionable_operators = positionable_operators.slice();
module.exports.line_starters = line_starters.slice();


/***/ }),
/* 8 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var regexp_has_sticky = RegExp.prototype.hasOwnProperty('sticky');

function InputScanner(input_string) {
  this.__input = input_string || '';
  this.__input_length = this.__input.length;
  this.__position = 0;
}

InputScanner.prototype.restart = function() {
  this.__position = 0;
};

InputScanner.prototype.back = function() {
  if (this.__position > 0) {
    this.__position -= 1;
  }
};

InputScanner.prototype.hasNext = function() {
  return this.__position < this.__input_length;
};

InputScanner.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__input.charAt(this.__position);
    this.__position += 1;
  }
  return val;
};

InputScanner.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__input_length) {
    val = this.__input.charAt(index);
  }
  return val;
};

// This is a JavaScript only helper function (not in python)
// Javascript doesn't have a match method
// and not all implementation support "sticky" flag.
// If they do not support sticky then both this.match() and this.test() method
// must get the match and check the index of the match.
// If sticky is supported and set, this method will use it.
// Otherwise it will check that global is set, and fall back to the slower method.
InputScanner.prototype.__match = function(pattern, index) {
  pattern.lastIndex = index;
  var pattern_match = pattern.exec(this.__input);

  if (pattern_match && !(regexp_has_sticky && pattern.sticky)) {
    if (pattern_match.index !== index) {
      pattern_match = null;
    }
  }

  return pattern_match;
};

InputScanner.prototype.test = function(pattern, index) {
  index = index || 0;
  index += this.__position;

  if (index >= 0 && index < this.__input_length) {
    return !!this.__match(pattern, index);
  } else {
    return false;
  }
};

InputScanner.prototype.testChar = function(pattern, index) {
  // test one character regex match
  var val = this.peek(index);
  pattern.lastIndex = 0;
  return val !== null && pattern.test(val);
};

InputScanner.prototype.match = function(pattern) {
  var pattern_match = this.__match(pattern, this.__position);
  if (pattern_match) {
    this.__position += pattern_match[0].length;
  } else {
    pattern_match = null;
  }
  return pattern_match;
};

InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
  var val = '';
  var match;
  if (starting_pattern) {
    match = this.match(starting_pattern);
    if (match) {
      val += match[0];
    }
  }
  if (until_pattern && (match || !starting_pattern)) {
    val += this.readUntil(until_pattern, until_after);
  }
  return val;
};

InputScanner.prototype.readUntil = function(pattern, until_after) {
  var val = '';
  var match_index = this.__position;
  pattern.lastIndex = this.__position;
  var pattern_match = pattern.exec(this.__input);
  if (pattern_match) {
    match_index = pattern_match.index;
    if (until_after) {
      match_index += pattern_match[0].length;
    }
  } else {
    match_index = this.__input_length;
  }

  val = this.__input.substring(this.__position, match_index);
  this.__position = match_index;
  return val;
};

InputScanner.prototype.readUntilAfter = function(pattern) {
  return this.readUntil(pattern, true);
};

InputScanner.prototype.get_regexp = function(pattern, match_from) {
  var result = null;
  var flags = 'g';
  if (match_from && regexp_has_sticky) {
    flags = 'y';
  }
  // strings are converted to regexp
  if (typeof pattern === "string" && pattern !== '') {
    // result = new RegExp(pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), flags);
    result = new RegExp(pattern, flags);
  } else if (pattern) {
    result = new RegExp(pattern.source, flags);
  }
  return result;
};

InputScanner.prototype.get_literal_regexp = function(literal_string) {
  return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
};

/* css beautifier legacy helpers */
InputScanner.prototype.peekUntilAfter = function(pattern) {
  var start = this.__position;
  var val = this.readUntilAfter(pattern);
  this.__position = start;
  return val;
};

InputScanner.prototype.lookBack = function(testVal) {
  var start = this.__position - 1;
  return start >= testVal.length && this.__input.substring(start - testVal.length, start)
    .toLowerCase() === testVal;
};

module.exports.InputScanner = InputScanner;


/***/ }),
/* 9 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_124576__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var InputScanner = (__nested_webpack_require_124576__(8).InputScanner);
var Token = (__nested_webpack_require_124576__(3).Token);
var TokenStream = (__nested_webpack_require_124576__(10).TokenStream);
var WhitespacePattern = (__nested_webpack_require_124576__(11).WhitespacePattern);

var TOKEN = {
  START: 'TK_START',
  RAW: 'TK_RAW',
  EOF: 'TK_EOF'
};

var Tokenizer = function(input_string, options) {
  this._input = new InputScanner(input_string);
  this._options = options || {};
  this.__tokens = null;

  this._patterns = {};
  this._patterns.whitespace = new WhitespacePattern(this._input);
};

Tokenizer.prototype.tokenize = function() {
  this._input.restart();
  this.__tokens = new TokenStream();

  this._reset();

  var current;
  var previous = new Token(TOKEN.START, '');
  var open_token = null;
  var open_stack = [];
  var comments = new TokenStream();

  while (previous.type !== TOKEN.EOF) {
    current = this._get_next_token(previous, open_token);
    while (this._is_comment(current)) {
      comments.add(current);
      current = this._get_next_token(previous, open_token);
    }

    if (!comments.isEmpty()) {
      current.comments_before = comments;
      comments = new TokenStream();
    }

    current.parent = open_token;

    if (this._is_opening(current)) {
      open_stack.push(open_token);
      open_token = current;
    } else if (open_token && this._is_closing(current, open_token)) {
      current.opened = open_token;
      open_token.closed = current;
      open_token = open_stack.pop();
      current.parent = open_token;
    }

    current.previous = previous;
    previous.next = current;

    this.__tokens.add(current);
    previous = current;
  }

  return this.__tokens;
};


Tokenizer.prototype._is_first_token = function() {
  return this.__tokens.isEmpty();
};

Tokenizer.prototype._reset = function() {};

Tokenizer.prototype._get_next_token = function(previous_token, open_token) { // jshint unused:false
  this._readWhitespace();
  var resulting_string = this._input.read(/.+/g);
  if (resulting_string) {
    return this._create_token(TOKEN.RAW, resulting_string);
  } else {
    return this._create_token(TOKEN.EOF, '');
  }
};

Tokenizer.prototype._is_comment = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_opening = function(current_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._is_closing = function(current_token, open_token) { // jshint unused:false
  return false;
};

Tokenizer.prototype._create_token = function(type, text) {
  var token = new Token(type, text,
    this._patterns.whitespace.newline_count,
    this._patterns.whitespace.whitespace_before_token);
  return token;
};

Tokenizer.prototype._readWhitespace = function() {
  return this._patterns.whitespace.read();
};



module.exports.Tokenizer = Tokenizer;
module.exports.TOKEN = TOKEN;


/***/ }),
/* 10 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function TokenStream(parent_token) {
  // private
  this.__tokens = [];
  this.__tokens_length = this.__tokens.length;
  this.__position = 0;
  this.__parent_token = parent_token;
}

TokenStream.prototype.restart = function() {
  this.__position = 0;
};

TokenStream.prototype.isEmpty = function() {
  return this.__tokens_length === 0;
};

TokenStream.prototype.hasNext = function() {
  return this.__position < this.__tokens_length;
};

TokenStream.prototype.next = function() {
  var val = null;
  if (this.hasNext()) {
    val = this.__tokens[this.__position];
    this.__position += 1;
  }
  return val;
};

TokenStream.prototype.peek = function(index) {
  var val = null;
  index = index || 0;
  index += this.__position;
  if (index >= 0 && index < this.__tokens_length) {
    val = this.__tokens[index];
  }
  return val;
};

TokenStream.prototype.add = function(token) {
  if (this.__parent_token) {
    token.parent = this.__parent_token;
  }
  this.__tokens.push(token);
  this.__tokens_length += 1;
};

module.exports.TokenStream = TokenStream;


/***/ }),
/* 11 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_130996__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Pattern = (__nested_webpack_require_130996__(12).Pattern);

function WhitespacePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  if (parent) {
    this._line_regexp = this._input.get_regexp(parent._line_regexp);
  } else {
    this.__set_whitespace_patterns('', '');
  }

  this.newline_count = 0;
  this.whitespace_before_token = '';
}
WhitespacePattern.prototype = new Pattern();

WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
  whitespace_chars += '\\t ';
  newline_chars += '\\n\\r';

  this._match_pattern = this._input.get_regexp(
    '[' + whitespace_chars + newline_chars + ']+', true);
  this._newline_regexp = this._input.get_regexp(
    '\\r\\n|[' + newline_chars + ']');
};

WhitespacePattern.prototype.read = function() {
  this.newline_count = 0;
  this.whitespace_before_token = '';

  var resulting_string = this._input.read(this._match_pattern);
  if (resulting_string === ' ') {
    this.whitespace_before_token = ' ';
  } else if (resulting_string) {
    var matches = this.__split(this._newline_regexp, resulting_string);
    this.newline_count = matches.length - 1;
    this.whitespace_before_token = matches[this.newline_count];
  }

  return resulting_string;
};

WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
  var result = this._create();
  result.__set_whitespace_patterns(whitespace_chars, newline_chars);
  result._update();
  return result;
};

WhitespacePattern.prototype._create = function() {
  return new WhitespacePattern(this._input, this);
};

WhitespacePattern.prototype.__split = function(regexp, input_string) {
  regexp.lastIndex = 0;
  var start_index = 0;
  var result = [];
  var next_match = regexp.exec(input_string);
  while (next_match) {
    result.push(input_string.substring(start_index, next_match.index));
    start_index = next_match.index + next_match[0].length;
    next_match = regexp.exec(input_string);
  }

  if (start_index < input_string.length) {
    result.push(input_string.substring(start_index, input_string.length));
  } else {
    result.push('');
  }

  return result;
};



module.exports.WhitespacePattern = WhitespacePattern;


/***/ }),
/* 12 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Pattern(input_scanner, parent) {
  this._input = input_scanner;
  this._starting_pattern = null;
  this._match_pattern = null;
  this._until_pattern = null;
  this._until_after = false;

  if (parent) {
    this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
    this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
    this._until_pattern = this._input.get_regexp(parent._until_pattern);
    this._until_after = parent._until_after;
  }
}

Pattern.prototype.read = function() {
  var result = this._input.read(this._starting_pattern);
  if (!this._starting_pattern || result) {
    result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
  }
  return result;
};

Pattern.prototype.read_match = function() {
  return this._input.match(this._match_pattern);
};

Pattern.prototype.until_after = function(pattern) {
  var result = this._create();
  result._until_after = true;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.until = function(pattern) {
  var result = this._create();
  result._until_after = false;
  result._until_pattern = this._input.get_regexp(pattern);
  result._update();
  return result;
};

Pattern.prototype.starting_with = function(pattern) {
  var result = this._create();
  result._starting_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype.matching = function(pattern) {
  var result = this._create();
  result._match_pattern = this._input.get_regexp(pattern, true);
  result._update();
  return result;
};

Pattern.prototype._create = function() {
  return new Pattern(this._input, this);
};

Pattern.prototype._update = function() {};

module.exports.Pattern = Pattern;


/***/ }),
/* 13 */
/***/ (function(module) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



function Directives(start_block_pattern, end_block_pattern) {
  start_block_pattern = typeof start_block_pattern === 'string' ? start_block_pattern : start_block_pattern.source;
  end_block_pattern = typeof end_block_pattern === 'string' ? end_block_pattern : end_block_pattern.source;
  this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, 'g');
  this.__directive_pattern = / (\w+)[:](\w+)/g;

  this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, 'g');
}

Directives.prototype.get_directives = function(text) {
  if (!text.match(this.__directives_block_pattern)) {
    return null;
  }

  var directives = {};
  this.__directive_pattern.lastIndex = 0;
  var directive_match = this.__directive_pattern.exec(text);

  while (directive_match) {
    directives[directive_match[1]] = directive_match[2];
    directive_match = this.__directive_pattern.exec(text);
  }

  return directives;
};

Directives.prototype.readIgnored = function(input) {
  return input.readUntilAfter(this.__directives_end_ignore_pattern);
};


module.exports.Directives = Directives;


/***/ }),
/* 14 */
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_139983__) {

/*jshint node:true */
/*

  The MIT License (MIT)

  Copyright (c) 2007-2018 Einar Lielmanis, Liam Newman, and contributors.

  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/



var Pattern = (__nested_webpack_require_139983__(12).Pattern);


var template_names = {
  django: false,
  erb: false,
  handlebars: false,
  php: false,
  smarty: false
};

// This lets templates appear anywhere we would do a readUntil
// The cost is higher but it is pay to play.
function TemplatablePattern(input_scanner, parent) {
  Pattern.call(this, input_scanner, parent);
  this.__template_pattern = null;
  this._disabled = Object.assign({}, template_names);
  this._excluded = Object.assign({}, template_names);

  if (parent) {
    this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
    this._excluded = Object.assign(this._excluded, parent._excluded);
    this._disabled = Object.assign(this._disabled, parent._disabled);
  }
  var pattern = new Pattern(input_scanner);
  this.__patterns = {
    handlebars_comment: pattern.starting_with(/{{!--/).until_after(/--}}/),
    handlebars_unescaped: pattern.starting_with(/{{{/).until_after(/}}}/),
    handlebars: pattern.starting_with(/{{/).until_after(/}}/),
    php: pattern.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
    erb: pattern.starting_with(/<%[^%]/).until_after(/[^%]%>/),
    // django coflicts with handlebars a bit.
    django: pattern.starting_with(/{%/).until_after(/%}/),
    django_value: pattern.starting_with(/{{/).until_after(/}}/),
    django_comment: pattern.starting_with(/{#/).until_after(/#}/),
    smarty: pattern.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
    smarty_comment: pattern.starting_with(/{\*/).until_after(/\*}/),
    smarty_literal: pattern.starting_with(/{literal}/).until_after(/{\/literal}/)
  };
}
TemplatablePattern.prototype = new Pattern();

TemplatablePattern.prototype._create = function() {
  return new TemplatablePattern(this._input, this);
};

TemplatablePattern.prototype._update = function() {
  this.__set_templated_pattern();
};

TemplatablePattern.prototype.disable = function(language) {
  var result = this._create();
  result._disabled[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read_options = function(options) {
  var result = this._create();
  for (var language in template_names) {
    result._disabled[language] = options.templating.indexOf(language) === -1;
  }
  result._update();
  return result;
};

TemplatablePattern.prototype.exclude = function(language) {
  var result = this._create();
  result._excluded[language] = true;
  result._update();
  return result;
};

TemplatablePattern.prototype.read = function() {
  var result = '';
  if (this._match_pattern) {
    result = this._input.read(this._starting_pattern);
  } else {
    result = this._input.read(this._starting_pattern, this.__template_pattern);
  }
  var next = this._read_template();
  while (next) {
    if (this._match_pattern) {
      next += this._input.read(this._match_pattern);
    } else {
      next += this._input.readUntil(this.__template_pattern);
    }
    result += next;
    next = this._read_template();
  }

  if (this._until_after) {
    result += this._input.readUntilAfter(this._until_pattern);
  }
  return result;
};

TemplatablePattern.prototype.__set_templated_pattern = function() {
  var items = [];

  if (!this._disabled.php) {
    items.push(this.__patterns.php._starting_pattern.source);
  }
  if (!this._disabled.handlebars) {
    items.push(this.__patterns.handlebars._starting_pattern.source);
  }
  if (!this._disabled.erb) {
    items.push(this.__patterns.erb._starting_pattern.source);
  }
  if (!this._disabled.django) {
    items.push(this.__patterns.django._starting_pattern.source);
    // The starting pattern for django is more complex because it has different
    // patterns for value, comment, and other sections
    items.push(this.__patterns.django_value._starting_pattern.source);
    items.push(this.__patterns.django_comment._starting_pattern.source);
  }
  if (!this._disabled.smarty) {
    items.push(this.__patterns.smarty._starting_pattern.source);
  }

  if (this._until_pattern) {
    items.push(this._until_pattern.source);
  }
  this.__template_pattern = this._input.get_regexp('(?:' + items.join('|') + ')');
};

TemplatablePattern.prototype._read_template = function() {
  var resulting_string = '';
  var c = this._input.peek();
  if (c === '<') {
    var peek1 = this._input.peek(1);
    //if we're in a comment, do something special
    // We treat all comments as literals, even more than preformatted tags
    // we just look for the appropriate close tag
    if (!this._disabled.php && !this._excluded.php && peek1 === '?') {
      resulting_string = resulting_string ||
        this.__patterns.php.read();
    }
    if (!this._disabled.erb && !this._excluded.erb && peek1 === '%') {
      resulting_string = resulting_string ||
        this.__patterns.erb.read();
    }
  } else if (c === '{') {
    if (!this._disabled.handlebars && !this._excluded.handlebars) {
      resulting_string = resulting_string ||
        this.__patterns.handlebars_comment.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars_unescaped.read();
      resulting_string = resulting_string ||
        this.__patterns.handlebars.read();
    }
    if (!this._disabled.django) {
      // django coflicts with handlebars a bit.
      if (!this._excluded.django && !this._excluded.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.django_value.read();
      }
      if (!this._excluded.django) {
        resulting_string = resulting_string ||
          this.__patterns.django_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.django.read();
      }
    }
    if (!this._disabled.smarty) {
      // smarty cannot be enabled with django or handlebars enabled
      if (this._disabled.django && this._disabled.handlebars) {
        resulting_string = resulting_string ||
          this.__patterns.smarty_comment.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty_literal.read();
        resulting_string = resulting_string ||
          this.__patterns.smarty.read();
      }
    }
  }
  return resulting_string;
};


module.exports.TemplatablePattern = TemplatablePattern;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_147658__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_147658__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __nested_webpack_exports__ = __nested_webpack_require_147658__(0);
/******/ 	legacy_beautify_js = __nested_webpack_exports__;
/******/ 	
/******/ })()
;
var js_beautify = legacy_beautify_js;
/* Footer */
if (true) {
    // Add support for AMD ( https://github.com/amdjs/amdjs-api/wiki/AMD#defineamd-property- )
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
        return { js_beautify: js_beautify };
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

}());



/***/ }),

/***/ 410:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Backbone.Undo.js v0.2
 * 
 * Copyright (c)2013 Oliver Sartun
 * Released under the MIT License
 *
 * Documentation and full license available at
 * https://github.com/osartun/Backbone.Undo.js
 */


(function (factory) {
	if (true) {
		// AMD support
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(50), __webpack_require__(316)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
})(function (_, Backbone) {

	var core_slice = Array.prototype.slice;

	/**
	 * As call is faster than apply, this is a faster version of apply as it uses call.
	 * 
	 * @param  {Function} fn 	The function to execute 
	 * @param  {Object}   ctx 	The context the function should be called in
	 * @param  {Array}    args 	The array of arguments that should be applied to the function
	 * @return Forwards whatever the called function returns
	 */
	function apply (fn, ctx, args) {
		return args.length <= 4 ?
			fn.call(ctx, args[0], args[1], args[2], args[3]) :
			fn.apply(ctx, args);
	}

	/**
	 * Uses slice on an array or an array-like object.
	 * 
	 * @param  {Array|Object} 	arr 	The array or array-like object.
	 * @param  {Number} 		[index]	The index from where the array should be sliced. Default is 0.
	 * @return {Array} The sliced array
	 */
	function slice (arr, index) {
		return core_slice.call(arr, index);
	}

	/**
	 * Checks if an object has one or more specific keys. The keys 
	 * don't have to be an owned property.
	 * You can call this function either this way:
	 * hasKeys(obj, ["a", "b", "c"])
	 * or this way:
	 * hasKeys(obj, "a", "b", "c")
	 * 
	 * @param  {Object}  	obj 	The object to check on
	 * @param  {Array}  	keys 	The keys to check for
	 * @return {Boolean} True, if the object has all those keys
	 */
	function hasKeys (obj, keys) {
		if (obj == null) return false;
		if (!_.isArray(keys)) {
			keys = slice(arguments, 1);
		}
		return _.all(keys, function (key) {
			return key in obj;
		});
	}

	/**
	 * Returns a number that is unique per call stack. The number gets 
	 * changed after the call stack has been completely processed.
	 * 
	 * @return {number} MagicFusionIndex
	 */
	var getMagicFusionIndex = (function () {
		// If you add several models to a collection or set several
		// attributes on a model all in sequence and yet all for
		// example in one function, then several Undo-Actions are
		// generated.
		// If you want to undo your last action only the last model
		// would be removed from the collection or the last set
		// attribute would be changed back to its previous value.
		// To prevent that we have to figure out a way to combine
		// all those actions that happened "at the same time". 
		// Timestamps aren't exact enough. A complex routine could 
		// run several milliseconds and in that time produce a lot 
		// of actions with different timestamps.
		// Instead we take advantage of the single-threadedness of
		// JavaScript:

		var callstackWasIndexed = false, magicFusionIndex = -1;
		function indexCycle() {
			magicFusionIndex++;
			callstackWasIndexed = true;
			_.defer(function () {
				// Here comes the magic. With a Timeout of 0 
				// milliseconds this function gets called whenever
				// the current callstack is completed
				callstackWasIndexed = false;
			})
		}
		return function () {
			if (!callstackWasIndexed) {
				indexCycle();
			}
			return magicFusionIndex;
		}
	})();

	/**
	 * To prevent binding a listener several times to one 
	 * object, we register the objects in an ObjectRegistry
	 *
	 * @constructor
	 */
	function ObjectRegistry () {
		// This uses two different ways of storing
		// objects: In case the object has a cid
		// (which Backbone objects typically have)
		// it uses this cid as an index. That way
		// the Array's length attribute doesn't 
		// change and the object isn't an item 
		// in the array, but an object-property.
		// Otherwise it's added to the Array as an
		// item.
		// That way we can use the fast property-
		// lookup and only have to fall back to 
		// iterating over the array in case 
		// non-Backbone-objects are registered.
		this.registeredObjects = [];
		// To return a list of all registered 
		// objects in the 'get' method we have to
		// store the objects that have a cid in
		// an additional array. 
		this.cidIndexes = [];
	}
	ObjectRegistry.prototype = {
		/**
		 * Returns whether the object is already registered in this ObjectRegistry or not.
		 * 
		 * @this 	{ObjectRegistry}
		 * @param  	{Object} 		 obj 	The object to check
		 * @return 	{Boolean} True if the object is already registered
		 */
		isRegistered: function (obj) {
			// This is where we get a performance boost 
			// by using the two different ways of storing 
			// objects.
			return obj && obj.cid ? this.registeredObjects[obj.cid] : _.contains(this.registeredObjects, obj);
		},
		/**
		 * Registers an object in this ObjectRegistry.
		 * 
		 * @this 	{ObjectRegistry}
		 * @param  	{Object} 		 obj 	The object to register
		 * @return 	{undefined}
		 */
		register: function (obj) {
			if (!this.isRegistered(obj)) {
				if (obj && obj.cid) {
					this.registeredObjects[obj.cid] = obj;
					this.cidIndexes.push(obj.cid);
				} else {
					this.registeredObjects.push(obj);
				}
				return true;
			}
			return false;
		},
		/**
		 * Unregisters an object from this ObjectRegistry.
		 * 
		 * @this {ObjectRegistry}
		 * @param  {Object} obj The object to unregister
		 * @return {undefined}
		 */
		unregister: function (obj) {
			if (this.isRegistered(obj)) {
				if (obj && obj.cid) {
					delete this.registeredObjects[obj.cid];
					this.cidIndexes.splice(_.indexOf(this.cidIndexes, obj.cid), 1);
				} else {
					var i = _.indexOf(this.registeredObjects, obj);
					this.registeredObjects.splice(i, 1);
				}
				return true;
			}
			return false;
		},
		/**
		 * Returns an array of all objects that are currently in this ObjectRegistry.
		 * 
		 * @return {Array} An array of all the objects which are currently in the ObjectRegistry
		 */
		get: function () {
			return (_.map(this.cidIndexes, function (cid) {return this.registeredObjects[cid];}, this)).concat(this.registeredObjects);
		}
	}

	/**
	 * Binds or unbinds the "all"-listener for one or more objects.
	 * 
	 * @param  {String}   which 	Either "on" or "off"
	 * @param  {Object[]} objects 	Array of the objects on which the "all"-listener should be bound / unbound to
	 * @param  {Function} [fn] 		The function that should be bound / unbound. Optional in case of "off"
	 * @param  {Object}   [ctx] 	The context the function should be called in
	 * @return {undefined}
	 */
	function onoff(which, objects, fn, ctx) {
		for (var i = 0, l = objects.length, obj; i < l; i++) {
			obj = objects[i];
			if (!obj) continue;
			if (which === "on") {
				if (!ctx.objectRegistry.register(obj)) {
					// register returned false, so obj was already registered
					continue;
				}
			} else {
				if (!ctx.objectRegistry.unregister(obj)) {
					// unregister returned false, so obj wasn't registered
					continue;
				}
			}
			if (_.isFunction(obj[which])) {
				obj[which]("all", fn, ctx);
			}
		}
	}

	/**
	 * Calls the undo/redo-function for a specific action.
	 * 
	 * @param  {String} which 	Either "undo" or "redo"
	 * @param  {Object} action 	The Action's attributes
	 * @return {undefined}
	 */
	function actionUndoRedo (which, action) {
		var type = action.type, undoTypes = action.undoTypes, fn = !undoTypes[type] || undoTypes[type][which];
		if (_.isFunction(fn)) {
			fn(action.object, action.before, action.after, action.options);
		}
	}

	/**
	 * The main undo/redo function.
	 *
	 * @param  {String} 		which 	    Either "undo" or "redo"
	 * @param  {UndoManager} 	manager	    The UndoManager-instance on which an "undo"/"redo"-Event is triggered afterwards
	 * @param  {UndoStack} 		stack 	    The UndoStack on which we perform
	 * @param  {Boolean} 		magic 	    If true, undoes / redoes all actions with the same magicFusionIndex
	 * @param  {Boolean} 		everything  If true, undoes / redoes every action that had been tracked
	 * @return {undefined}
	 */
	function managerUndoRedo (which, manager, stack, magic, everything) {
		if (stack.isCurrentlyUndoRedoing || 
			(which === "undo" && stack.pointer === -1) ||
			(which === "redo" && stack.pointer === stack.length - 1)) {
			// We're either currently in an undo- / redo-process or 
			// we reached the end of the stack
			return;
		}
		stack.isCurrentlyUndoRedoing = true;
		var action, actions, isUndo = which === "undo";
		if (everything) {
			// Undo / Redo all steps until you reach the stack's beginning / end
			actions = isUndo && stack.pointer === stack.length - 1 || // If at the stack's end calling undo
					  !isUndo && stack.pointer === -1 ? // or at the stack's beginning calling redo
					  _.clone(stack.models) : // => Take all the models. Otherwise:
					  core_slice.apply(stack.models, isUndo ? [0, stack.pointer] : [stack.pointer, stack.length - 1]);
		} else {
			// Undo / Redo only one step
			action = stack.at(isUndo ? stack.pointer : stack.pointer + 1);
			actions = magic ? stack.where({"magicFusionIndex": action.get("magicFusionIndex")}) : [action];
		}
		
		stack.pointer += (isUndo ? -1 : 1) * actions.length;
		while (action = isUndo ? actions.pop() : actions.shift()) {
			// Here we're calling the Action's undo / redo method
			action[which]();
		}
		stack.isCurrentlyUndoRedoing = false;

		manager.trigger(which, manager);
	}

	/**
	 * Checks whether an UndoAction should be created or not. Therefore it checks
	 * whether a "condition" property is set in the undoTypes-object of the specific
	 * event type. If not, it returns true. If it's set and a boolean, it returns it.
	 * If it's a function, it returns its result, converting it into a boolean. 
	 * Otherwise it returns true.
	 * 
	 * @param  {Object} 	undoTypesType 	The object within the UndoTypes that holds the function for this event type (i.e. "change")
	 * @param  {Arguments} 	args       		The arguments the "condition" function is called with
	 * @return {Boolean} 	True, if an UndoAction should be created
	 */
	function validateUndoActionCreation (undoTypesType, args) {
		var condition = undoTypesType.condition, type = typeof condition;
		return type === "function" ? !!apply(condition, undoTypesType, args) :
			type === "boolean" ? condition : true;
	}

	/**
	 * Adds an Undo-Action to the stack.
	 * 
	 * @param {UndoStack} 		stack 		The undostack the action should be added to.
	 * @param {String} 			type 		The event type (i.e. "change")
	 * @param {Arguments} 		args 		The arguments passed to the undoTypes' "on"-handler
	 * @param {OwnedUndoTypes} 	undoTypes 	The undoTypes-object which has the "on"-handler
	 * @return {undefined}
	 */
	function addToStack(stack, type, args, undoTypes) {
		if (stack.track && !stack.isCurrentlyUndoRedoing && type in undoTypes &&
			validateUndoActionCreation(undoTypes[type], args)) {
			// An UndoAction should be created
			var res = apply(undoTypes[type]["on"], undoTypes[type], args), diff;
			if (hasKeys(res, "object", "before", "after")) {
				res.type = type;
				res.magicFusionIndex = getMagicFusionIndex();
				res.undoTypes = undoTypes;
				if (stack.pointer < stack.length - 1) {
					// New Actions must always be added to the end of the stack.
					// If the pointer is not pointed to the last action in the
					// stack, presumably because actions were undone before, then
					// all following actions must be discarded
					var diff = stack.length - stack.pointer - 1;
					while (diff--) {
						stack.pop();
					}
				}
				stack.pointer = stack.length;
				stack.add(res);
				if (stack.length > stack.maximumStackLength) {
					stack.shift();
					stack.pointer--;
				}
			}
		}
	}


	/**
	 * Predefined UndoTypes object with default handlers for the most common events.
	 * @type {Object}
	 */
	var UndoTypes = {
		"add": {
			"undo": function (collection, ignore, model, options) {
				// Undo add = remove
				collection.remove(model, options);
			},
			"redo": function (collection, ignore, model, options) {
				// Redo add = add
				if (options.index) {
					options.at = options.index;
				}
				collection.add(model, options);
			},
			"on": function (model, collection, options) {
				return {
					object: collection,
					before: undefined,
					after: model,
					options: _.clone(options)
				};
			}
		},
		"remove": {
			"undo": function (collection, model, ignore, options) {
				if ("index" in options) {
					options.at = options.index;
				}
				collection.add(model, options);
			},
			"redo": function (collection, model, ignore, options) {
				collection.remove(model, options);
			},
			"on": function (model, collection, options) {
				return {
					object: collection,
					before: model,
					after: undefined,
					options: _.clone(options)
				};
			}
		},
		"change": {
			"undo": function (model, before, after, options) {
				if (_.isEmpty(before)) {
					_.each(_.keys(after), model.unset, model);
				} else {
					model.set(before);
					if (options && options.unsetData && options.unsetData.before && options.unsetData.before.length) {
						_.each(options.unsetData.before, model.unset, model);
					}
				}
			},
			"redo": function (model, before, after, options) {
				if (_.isEmpty(after)) {
					_.each(_.keys(before), model.unset, model);
				} else {
					model.set(after);
					if (options && options.unsetData && options.unsetData.after && options.unsetData.after.length) {
						_.each(options.unsetData.after, model.unset, model);
					}
				}
			},
			"on": function (model, options) {
				var
				afterAttributes = model.changedAttributes(),
				keysAfter = _.keys(afterAttributes),
				previousAttributes = _.pick(model.previousAttributes(), keysAfter),
				keysPrevious = _.keys(previousAttributes),
				unsetData = (options || (options = {})).unsetData = {
					after: [],
					before: []
				};

				if (keysAfter.length != keysPrevious.length) {
					// There are new attributes or old attributes have been unset
					if (keysAfter.length > keysPrevious.length) {
						// New attributes have been added
						_.each(keysAfter, function (val) {
							if (!(val in previousAttributes)) {
								unsetData.before.push(val);
							}
						}, this);
					} else {
						// Old attributes have been unset
						_.each(keysPrevious, function (val) {
							if (!(val in afterAttributes)) {
								unsetData.after.push(val);
							}
						})
					}
				}
				return {
					object: model,
					before: previousAttributes,
					after: afterAttributes,
					options: _.clone(options)
				};
			}
		},
		"reset": {
			"undo": function (collection, before, after) {
				collection.reset(before);
			},
			"redo": function (collection, before, after) {
				collection.reset(after);
			},
			"on": function (collection, options) {
				return {
					object: collection,
					before: options.previousModels,
					after: _.clone(collection.models)
				};
			}
		}
	};

	/**
	 * Every UndoManager instance has an own undoTypes object
	 * which is an instance of OwnedUndoTypes. OwnedUndoTypes' 
	 * prototype is the global UndoTypes object. Changes to the 
	 * global UndoTypes object take effect on every instance of
	 * UndoManager as the object is its prototype. And yet every 
	 * local UndoTypes object can be changed individually.
	 *
	 * @constructor
	 */
	function OwnedUndoTypes () {}
	OwnedUndoTypes.prototype = UndoTypes;

	/**
	 * Adds, changes or removes an undo-type from an UndoTypes-object.
	 * You can call it this way:
	 * manipulateUndoType (1, "reset", {"on": function () {}}, undoTypes)
	 * or this way to perform bulk actions:
	 * manipulateUndoType (1, {"reset": {"on": function () {}}}, undoTypes)
	 * In case of removing undo-types you can pass an Array for performing
	 * bulk actions:
	 * manipulateUndoType(2, ["reset", "change"], undoTypes)
	 * 
	 * @param  {Number} 				  manipType 		Indicates the kind of action to execute: 0 for add, 1 for change, 2 for remove
	 * @param  {String|Object|Array} 	  undoType 			The type of undoType that should be added/changed/removed. Can be an object / array to perform bulk actions
	 * @param  {Object} 				  [fns] 			Object with the functions to add / change. Is optional in case you passed an object as undoType that contains these functions
	 * @param  {OwnedUndoTypes|UndoTypes} undoTypesInstance The undoTypes object to act on
	 * @return {undefined}
	 */
	function manipulateUndoType (manipType, undoType, fns, undoTypesInstance) {
		// manipType, passed by the calling function
		// 0: add
		// 1: change
		// 2: remove
		if (typeof undoType === "object") {
			// bulk action. Iterate over this data.
			return _.each(undoType, function (val, key) {
					if (manipType === 2) { // remove
						// undoType is an array
						manipulateUndoType (manipType, val, fns, undoTypesInstance);
					} else {
						// undoType is an object
						manipulateUndoType (manipType, key, val, fns);
					}
				})
		}

		switch (manipType) {
			case 0: // add
				if (hasKeys(fns, "undo", "redo", "on") && _.all(_.pick(fns, "undo", "redo", "on"), _.isFunction)) {
					undoTypesInstance[undoType] = fns;
				} 
			break;
			case 1: // change
				if (undoTypesInstance[undoType] && _.isObject(fns)) {
					// undoTypeInstance[undoType] may be a prototype's property
					// So, if we did this _.extend(undoTypeInstance[undoType], fns)
					// we would extend the object on the prototype which means
					// that this change would have a global effect
					// Instead we just want to manipulate this instance. That's why
					// we're doing this:
					undoTypesInstance[undoType] = _.extend({}, undoTypesInstance[undoType], fns);
				} 
			break;
			case 2: // remove
				delete undoTypesInstance[undoType]; 
			break;
		}
		return this;
	}

	/**
	 * Instantiating "Action" creates the UndoActions that 
	 * are collected in an UndoStack. It holds all relevant 
	 * data to undo / redo an action and has an undo / redo 
	 * method.
	 */
	var Action = Backbone.Model.extend({
		defaults: {
			type: null, // "add", "change", "reset", etc.
			object: null, // The object on which the action occurred
			before: null, // The previous values which were changed with this action
			after: null, // The values after this action
			magicFusionIndex: null // The magicFusionIndex helps to combine 
			// all actions that occurred "at the same time" to undo/redo them altogether
		},
		/**
		 * Undoes this action.
		 * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the "undo"-handler that should be used
		 * @return {undefined}
		 */
		undo: function (undoTypes) {
			actionUndoRedo("undo", this.attributes);
		},
		/**
		 * Redoes this action.
		 * @param  {OwnedUndoTypes|UndoTypes} undoTypes The undoTypes object which contains the "redo"-handler that should be used
		 * @return {undefined}
		 */
		redo: function (undoTypes) {
			actionUndoRedo("redo", this.attributes);
		}
	}),
	/**
	 * An UndoStack is a collection of UndoActions in 
	 * chronological order.
	 */
	UndoStack = Backbone.Collection.extend({
		model: Action,
		pointer: -1, // The pointer indicates the index where we are located within the stack. We start at -1
		track: false,
		isCurrentlyUndoRedoing: false,
		maximumStackLength: Infinity,
		setMaxLength: function (val) {
			this.maximumStackLength = val;
		}
	}),
	/**
	 * An instance of UndoManager can keep track of 
	 * changes to objects and helps to undo them.
	 */
	UndoManager = Backbone.Model.extend({
		defaults: {
			maximumStackLength: Infinity,
			track: false
		},
		/**
		 * The constructor function.
		 * @param  {attr} 		[attr] Object with parameters. The available parameters are:
		 *                         	   - maximumStackLength {number} 	Set the undo-stack's maximum size
		 *                             - track 				{boolean}	Start tracking changes right away
		 * @return {undefined}
		 */
		initialize: function (attr) {
			this.stack = new UndoStack;
			this.objectRegistry = new ObjectRegistry();
			this.undoTypes = new OwnedUndoTypes();

			// sync the maximumStackLength attribute with our stack
			this.stack.setMaxLength(this.get("maximumStackLength"));
			this.on("change:maximumStackLength", function (model, value) {
				this.stack.setMaxLength(value);
			}, this);

			// Start tracking, if attr.track == true
			if (attr && attr.track) {
				this.startTracking();
			}

			// Register objects passed in the "register" attribute
			if (attr && attr.register) {
				if (_.isArray(attr.register) || _.isArguments(attr.register)) {
					apply(this.register, this, attr.register);
				} else {
					this.register(attr.register);
				}
			}
		},
		/**
		 * Starts tracking. Changes of registered objects won't be processed until you've called this function
		 * @return {undefined}
		 */
		startTracking: function () {
			this.set("track", true);
			this.stack.track = true;
		},
		/**
		 * Stops tracking. Afterwards changes of registered objects won't be processed.
		 * @return {undefined}
		 */
		stopTracking: function () {
			this.set("track", false);
			this.stack.track = false;
		},
		/**
		 * Return the state of the tracking
		 * @return {boolean}
		 */
		isTracking: function () {
			return this.get("track");
		},
		/**
		 * This is the "all"-handler which is bound to registered 
		 * objects. It creates an UndoAction from the event and adds 
		 * it to the stack.
		 * 
		 * @param  {String} 	type 	The event type
		 * @return {undefined}
		 */
		_addToStack: function (type) {
			addToStack(this.stack, type, slice(arguments, 1), this.undoTypes);
		},
		/**
		 * Registers one or more objects to track their changes.
		 * @param {...Object} 	obj 	The object or objects of which changes should be tracked
		 * @return {undefined}
		 */
		register: function () {
			onoff("on", arguments, this._addToStack, this);
		},
		/**
		 * Unregisters one or more objects.
		 * @param {...Object} 	obj 	The object or objects of which changes shouldn't be tracked any longer
		 * @return {undefined}
		 */
		unregister: function () {
			onoff("off", arguments, this._addToStack, this);
		},
		/**
		 * Unregisters all previously registered objects.
		 * @return {undefined}
		 */
		unregisterAll: function () {
			apply(this.unregister, this, this.objectRegistry.get());
		},
		/**
		 * Undoes the last action or the last set of actions in case 'magic' is true.
		 * @param {Boolean} 	[magic] 	If true, all actions that happened basically at the same time are undone together
		 * @return {undefined}
		 */
		undo: function (magic) {
			managerUndoRedo("undo", this, this.stack, magic);
		},

		/**
		 * Undoes all actions ever tracked by the undo manager
		 * @return {undefined}
		 */
		undoAll: function () {
			managerUndoRedo("undo", this, this.stack, false, true);
		},

		/**
		 * Redoes a previously undone action or a set of actions.
		 * @param {Boolean} 	[magic] 	If true, all actions that happened basically at the same time are redone together
		 * @return {undefined}
		 */
		redo: function (magic) {
			managerUndoRedo("redo", this, this.stack, magic);
		},

		/**
		 * Redoes all actions ever tracked by the undo manager
		 * @return {undefined}
		 */
		redoAll: function () {
			managerUndoRedo("redo", this, this.stack, false, true);
		},
		/**
		 * Checks if there's an action in the stack that can be undone / redone
		 * @param  {String} 	type 	Either "undo" or "redo"
		 * @return {Boolean} True if there is a set of actions which can be undone / redone
		 */
		isAvailable: function (type) {
			var s = this.stack, l = s.length;

			switch (type) {
				case "undo": return l > 0 && s.pointer > -1;
				case "redo": return l > 0 && s.pointer < l - 1;
				default: return false;
			}
		},
		/**
		 * Sets the stack-reference to the stack of another undoManager.
		 * @param  {UndoManager} 	undoManager 	The undoManager whose stack-reference is set to this stack
		 * @return {undefined}
		 */
		merge: function (undoManager) {
			// This sets the stack-reference to the stack of another 
			// undoManager so that the stack of this other undoManager 
			// is used by two different managers.
			// This enables to set up a main-undoManager and besides it
			// several others for special, exceptional cases (by using
			// instance-based custom UndoTypes). Models / collections 
			// which need this special treatment are only registered at 
			// those special undoManagers. Those special ones are then 
			// merged into the main-undoManager to write on its stack. 
			// That way it's easier to manage exceptional cases.
			var args = _.isArray(undoManager) ? undoManager : slice(arguments), manager;
			while (manager = args.pop()) {
				if (manager instanceof UndoManager &&
					manager.stack instanceof UndoStack) {
					// set the stack reference to our stack
					manager.stack = this.stack;
				}
			}
		},
		/**
		 * Add an UndoType to this specific UndoManager-instance.
		 * @param {String} type The event this UndoType is made for
		 * @param {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties "undo", "redo" and "on". Can have the property "condition".
		 * @return {undefined}
		 */
		addUndoType: function (type, fns) {
			manipulateUndoType(0, type, fns, this.undoTypes);
		},
		/**
		 * Overwrite properties of an existing UndoType for this specific UndoManager-instance.
		 * @param  {String} type The event the UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.
		 * @return {undefined}
		 */
		changeUndoType: function (type, fns) {
			manipulateUndoType(1, type, fns, this.undoTypes);
		},
		/**
		 * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.
		 * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.
		 * @return {undefined}
		 */
		removeUndoType: function (type) {
			manipulateUndoType(2, type, undefined, this.undoTypes);
		},

		/**
		 * Removes all actions from the stack.
		 * @return {undefined}
		 */
		clear: function() {
			this.stack.reset();
			this.stack.pointer = -1;
		}
	});

	_.extend(UndoManager, {
		/**
		 * Change the UndoManager's default attributes
		 * @param  {Object} defaultAttributes An object with the new default values.
		 * @return {undefined}
		 */
		defaults: function (defaultAttributes) {
			_.extend(UndoManager.prototype.defaults, defaultAttributes);
		},
		/**
		 * Add an UndoType to the global UndoTypes-object.
		 * @param  {String} type The event this UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. Must have the properties "undo", "redo" and "on". Can have the property "condition".
		 * @return {undefined}
		 */
		"addUndoType": function (type, fns) {
			manipulateUndoType(0, type, fns, UndoTypes);
		},
		/**
		 * Overwrite properties of an existing UndoType in the global UndoTypes-object.
		 * @param  {String} type The event the UndoType is made for
		 * @param  {Object} fns  An object of functions that are called to generate the data for an UndoAction or to process it. It extends the existing object.
		 * @return {undefined}
		 */
		"changeUndoType": function (type, fns) {
			manipulateUndoType(1, type, fns, UndoTypes)
		},
		/**
		 * Remove one or more UndoTypes of this specific UndoManager-instance to fall back to the global UndoTypes.
		 * @param  {String|Array} type The event the UndoType that should be removed is made for. You can also pass an array of events.
		 * @return {undefined}
		 */
		"removeUndoType": function (type) {
			manipulateUndoType(2, type, undefined, UndoTypes);
		}
	})

	return Backbone.UndoManager = UndoManager;

});


/***/ }),

/***/ 316:
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Backbone.js 1.4.1

//     (c) 2010-2022 Jeremy Ashkenas and DocumentCloud
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(factory) {

  // Establish the root object, `window` (`self`) in the browser, or `global` on the server.
  // We use `self` instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof __webpack_require__.g == 'object' && __webpack_require__.g.global === __webpack_require__.g && __webpack_require__.g;

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(50), __webpack_require__(815), exports], __WEBPACK_AMD_DEFINE_RESULT__ = (function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else { var _, $; }

})(function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create a local reference to a common array method we'll want to use later.
  var slice = Array.prototype.slice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.4.1';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... this will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // a custom event channel. You may bind a callback to an event with `on` or
  // remove with `off`; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {};

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // A private global variable to share between listeners and listenees.
  var _listening;

  // Iterates over the standard `event, callback` (as well as the fancy multiple
  // space-separated events `"change blur", callback` and jQuery-style event
  // maps `{event: callback}`).
  var eventsApi = function(iteratee, events, name, callback, opts) {
    var i = 0, names;
    if (name && typeof name === 'object') {
      // Handle event maps.
      if (callback !== void 0 && 'context' in opts && opts.context === void 0) opts.context = callback;
      for (names = _.keys(name); i < names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } else if (name && eventSplitter.test(name)) {
      // Handle space-separated event names by delegating them individually.
      for (names = name.split(eventSplitter); i < names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } else {
      // Finally, standard events.
      events = iteratee(events, name, callback, opts);
    }
    return events;
  };

  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  Events.on = function(name, callback, context) {
    this._events = eventsApi(onApi, this._events || {}, name, callback, {
      context: context,
      ctx: this,
      listening: _listening
    });

    if (_listening) {
      var listeners = this._listeners || (this._listeners = {});
      listeners[_listening.id] = _listening;
      // Allow the listening to use a counter, instead of tracking
      // callbacks for library interop
      _listening.interop = false;
    }

    return this;
  };

  // Inversion-of-control versions of `on`. Tell *this* object to listen to
  // an event in another object... keeping track of what it's listening to
  // for easier unbinding later.
  Events.listenTo = function(obj, name, callback) {
    if (!obj) return this;
    var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
    var listeningTo = this._listeningTo || (this._listeningTo = {});
    var listening = _listening = listeningTo[id];

    // This object is not listening to any other events on `obj` yet.
    // Setup the necessary references to track the listening callbacks.
    if (!listening) {
      this._listenId || (this._listenId = _.uniqueId('l'));
      listening = _listening = listeningTo[id] = new Listening(this, obj);
    }

    // Bind callbacks on obj.
    var error = tryCatchOn(obj, name, callback, this);
    _listening = void 0;

    if (error) throw error;
    // If the target obj is not Backbone.Events, track events manually.
    if (listening.interop) listening.on(name, callback);

    return this;
  };

  // The reducing API that adds a callback to the `events` object.
  var onApi = function(events, name, callback, options) {
    if (callback) {
      var handlers = events[name] || (events[name] = []);
      var context = options.context, ctx = options.ctx, listening = options.listening;
      if (listening) listening.count++;

      handlers.push({callback: callback, context: context, ctx: context || ctx, listening: listening});
    }
    return events;
  };

  // An try-catch guarded #on function, to prevent poisoning the global
  // `_listening` variable.
  var tryCatchOn = function(obj, name, callback, context) {
    try {
      obj.on(name, callback, context);
    } catch (e) {
      return e;
    }
  };

  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  Events.off = function(name, callback, context) {
    if (!this._events) return this;
    this._events = eventsApi(offApi, this._events, name, callback, {
      context: context,
      listeners: this._listeners
    });

    return this;
  };

  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  Events.stopListening = function(obj, name, callback) {
    var listeningTo = this._listeningTo;
    if (!listeningTo) return this;

    var ids = obj ? [obj._listenId] : _.keys(listeningTo);
    for (var i = 0; i < ids.length; i++) {
      var listening = listeningTo[ids[i]];

      // If listening doesn't exist, this object is not currently
      // listening to obj. Break out early.
      if (!listening) break;

      listening.obj.off(name, callback, this);
      if (listening.interop) listening.off(name, callback);
    }
    if (_.isEmpty(listeningTo)) this._listeningTo = void 0;

    return this;
  };

  // The reducing API that removes a callback from the `events` object.
  var offApi = function(events, name, callback, options) {
    if (!events) return;

    var context = options.context, listeners = options.listeners;
    var i = 0, names;

    // Delete all event listeners and "drop" events.
    if (!name && !context && !callback) {
      for (names = _.keys(listeners); i < names.length; i++) {
        listeners[names[i]].cleanup();
      }
      return;
    }

    names = name ? [name] : _.keys(events);
    for (; i < names.length; i++) {
      name = names[i];
      var handlers = events[name];

      // Bail out if there are no events stored.
      if (!handlers) break;

      // Find any remaining events.
      var remaining = [];
      for (var j = 0; j < handlers.length; j++) {
        var handler = handlers[j];
        if (
          callback && callback !== handler.callback &&
            callback !== handler.callback._callback ||
              context && context !== handler.context
        ) {
          remaining.push(handler);
        } else {
          var listening = handler.listening;
          if (listening) listening.off(name, callback);
        }
      }

      // Replace events if there are any remaining.  Otherwise, clean up.
      if (remaining.length) {
        events[name] = remaining;
      } else {
        delete events[name];
      }
    }

    return events;
  };

  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, its listener will be removed. If multiple events
  // are passed in using the space-separated syntax, the handler will fire
  // once for each event, not once for a combination of all events.
  Events.once = function(name, callback, context) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, this.off.bind(this));
    if (typeof name === 'string' && context == null) callback = void 0;
    return this.on(events, callback, context);
  };

  // Inversion-of-control versions of `once`.
  Events.listenToOnce = function(obj, name, callback) {
    // Map the event into a `{event: once}` object.
    var events = eventsApi(onceMap, {}, name, callback, this.stopListening.bind(this, obj));
    return this.listenTo(obj, events);
  };

  // Reduces the event callbacks into a map of `{event: onceWrapper}`.
  // `offer` unbinds the `onceWrapper` after it has been called.
  var onceMap = function(map, name, callback, offer) {
    if (callback) {
      var once = map[name] = _.once(function() {
        offer(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
    }
    return map;
  };

  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  Events.trigger = function(name) {
    if (!this._events) return this;

    var length = Math.max(0, arguments.length - 1);
    var args = Array(length);
    for (var i = 0; i < length; i++) args[i] = arguments[i + 1];

    eventsApi(triggerApi, this._events, name, void 0, args);
    return this;
  };

  // Handles triggering the appropriate event callbacks.
  var triggerApi = function(objEvents, name, callback, args) {
    if (objEvents) {
      var events = objEvents[name];
      var allEvents = objEvents.all;
      if (events && allEvents) allEvents = allEvents.slice();
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    return objEvents;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  // A listening class that tracks and cleans up memory bindings
  // when all callbacks have been offed.
  var Listening = function(listener, obj) {
    this.id = listener._listenId;
    this.listener = listener;
    this.obj = obj;
    this.interop = true;
    this.count = 0;
    this._events = void 0;
  };

  Listening.prototype.on = Events.on;

  // Offs a callback (or several).
  // Uses an optimized counter if the listenee uses Backbone.Events.
  // Otherwise, falls back to manual tracking to support events
  // library interop.
  Listening.prototype.off = function(name, callback) {
    var cleanup;
    if (this.interop) {
      this._events = eventsApi(offApi, this._events, name, callback, {
        context: void 0,
        listeners: void 0
      });
      cleanup = !this._events;
    } else {
      this.count--;
      cleanup = this.count === 0;
    }
    if (cleanup) this.cleanup();
  };

  // Cleans up memory bindings between the listener and the listenee.
  Listening.prototype.cleanup = function() {
    delete this.listener._listeningTo[this.obj._listenId];
    if (!this.interop) delete this.obj._listeners[this.id];
  };

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    this.cid = _.uniqueId(this.cidPrefix);
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    var defaults = _.result(this, 'defaults');
    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // The prefix is used to create the client id which is used to identify models locally.
    // You may want to override this if you're experiencing name clashes with model ids.
    cidPrefix: 'c',

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Model.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Special-cased proxy to underscore's `_.matches` method.
    matches: function(attrs) {
      return !!_.iteratee(attrs, this)(this.attributes);
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      var unset      = options.unset;
      var silent     = options.silent;
      var changes    = [];
      var changing   = this._changing;
      this._changing = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }

      var current = this.attributes;
      var changed = this.changed;
      var prev    = this._previousAttributes;

      // For each `set` attribute, update or delete the current value.
      for (var attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } else {
          delete changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Update the `id`.
      if (this.idAttribute in attrs) {
        var prevId = this.id;
        this.id = this.get(this.idAttribute);
        this.trigger('changeId', this, prevId, options);
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0; i < changes.length; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      var changed = {};
      var hasChanged;
      for (var attr in diff) {
        var val = diff[attr];
        if (_.isEqual(old[attr], val)) continue;
        changed[attr] = val;
        hasChanged = true;
      }
      return hasChanged ? changed : false;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server, merging the response with the model's
    // local attributes. Any changed attributes will trigger a "change" event.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (!model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      // Handle both `"key", value` and `{key: value}` -style arguments.
      var attrs;
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true, parse: true}, options);
      var wait = options.wait;

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !wait) {
        if (!this.set(attrs, options)) return false;
      } else if (!this._validate(attrs, options)) {
        return false;
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      var model = this;
      var success = options.success;
      var attributes = this.attributes;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = options.parse ? model.parse(resp, options) : resp;
        if (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        if (serverAttrs && !model.set(serverAttrs, options)) return false;
        if (success) success.call(options.context, model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      // Set temporary attributes if `{wait: true}` to properly find new ids.
      if (attrs && wait) this.attributes = _.extend({}, attributes, attrs);

      var method = this.isNew() ? 'create' : options.patch ? 'patch' : 'update';
      if (method === 'patch' && !options.attrs) options.attrs = attrs;
      var xhr = this.sync(method, this, options);

      // Restore attributes.
      this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;
      var wait = options.wait;

      var destroy = function() {
        model.stopListening();
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (wait) destroy();
        if (success) success.call(options.context, model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      var xhr = false;
      if (this.isNew()) {
        _.defer(options.success);
      } else {
        wrapError(this, options);
        xhr = this.sync('delete', this, options);
      }
      if (!wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      var id = this.get(this.idAttribute);
      return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend({}, options, {validate: true}));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analogous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Splices `insert` into `array` at index `at`.
  var splice = function(array, insert, at) {
    at = Math.min(Math.max(at, 0), array.length);
    var tail = Array(array.length - at);
    var length = insert.length;
    var i;
    for (i = 0; i < tail.length; i++) tail[i] = array[i + at];
    for (i = 0; i < length; i++) array[i + at] = insert[i];
    for (i = 0; i < tail.length; i++) array[i + length + at] = tail[i];
  };

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,


    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Collection.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model) { return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set. `models` may be Backbone
    // Models or raw JavaScript objects to be converted to Models, or any
    // combination of the two.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      options = _.extend({}, options);
      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();
      var removed = this._removeModels(models, options);
      if (!options.silent && removed.length) {
        options.changes = {added: [], merged: [], removed: removed};
        this.trigger('update', this, options);
      }
      return singular ? removed[0] : removed;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      if (models == null) return;

      options = _.extend({}, setOptions, options);
      if (options.parse && !this._isModel(models)) {
        models = this.parse(models, options) || [];
      }

      var singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      var at = options.at;
      if (at != null) at = +at;
      if (at > this.length) at = this.length;
      if (at < 0) at += this.length + 1;

      var set = [];
      var toAdd = [];
      var toMerge = [];
      var toRemove = [];
      var modelMap = {};

      var add = options.add;
      var merge = options.merge;
      var remove = options.remove;

      var sort = false;
      var sortable = this.comparator && at == null && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      var model, i;
      for (i = 0; i < models.length; i++) {
        model = models[i];

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        var existing = this.get(model);
        if (existing) {
          if (merge && model !== existing) {
            var attrs = this._isModel(model) ? model.attributes : model;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            toMerge.push(existing);
            if (sortable && !sort) sort = existing.hasChanged(sortAttr);
          }
          if (!modelMap[existing.cid]) {
            modelMap[existing.cid] = true;
            set.push(existing);
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(model, options);
          if (model) {
            toAdd.push(model);
            this._addReference(model, options);
            modelMap[model.cid] = true;
            set.push(model);
          }
        }
      }

      // Remove stale models.
      if (remove) {
        for (i = 0; i < this.length; i++) {
          model = this.models[i];
          if (!modelMap[model.cid]) toRemove.push(model);
        }
        if (toRemove.length) this._removeModels(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      var orderChanged = false;
      var replace = !sortable && add && remove;
      if (set.length && replace) {
        orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
          return m !== set[index];
        });
        this.models.length = 0;
        splice(this.models, set, 0);
        this.length = this.models.length;
      } else if (toAdd.length) {
        if (sortable) sort = true;
        splice(this.models, toAdd, at == null ? this.length : at);
        this.length = this.models.length;
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort/update events.
      if (!options.silent) {
        for (i = 0; i < toAdd.length; i++) {
          if (at != null) options.index = at + i;
          model = toAdd[i];
          model.trigger('add', model, this, options);
        }
        if (sort || orderChanged) this.trigger('sort', this, options);
        if (toAdd.length || toRemove.length || toMerge.length) {
          options.changes = {
            added: toAdd,
            removed: toRemove,
            merged: toMerge
          };
          this.trigger('update', this, options);
        }
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options = options ? _.clone(options) : {};
      for (var i = 0; i < this.models.length; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      return this.remove(model, options);
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      return this.remove(model, options);
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id, cid, model object with id or cid
    // properties, or an attributes object that is transformed through modelId.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] ||
        this._byId[this.modelId(this._isModel(obj) ? obj.attributes : obj, obj.idAttribute)] ||
        obj.cid && this._byId[obj.cid];
    },

    // Returns `true` if the model is in the collection.
    has: function(obj) {
      return this.get(obj) != null;
    },

    // Get the model at the given index.
    at: function(index) {
      if (index < 0) index += this.length;
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      return this[first ? 'find' : 'filter'](attrs);
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      var comparator = this.comparator;
      if (!comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      var length = comparator.length;
      if (_.isFunction(comparator)) comparator = comparator.bind(this);

      // Run sort based on type of `comparator`.
      if (length === 1 || _.isString(comparator)) {
        this.models = this.sortBy(comparator);
      } else {
        this.models.sort(comparator);
      }
      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return this.map(attr + '');
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = _.extend({parse: true}, options);
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success.call(options.context, collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      var wait = options.wait;
      model = this._prepareModel(model, options);
      if (!model) return false;
      if (!wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(m, resp, callbackOpts) {
        if (wait) collection.add(m, callbackOpts);
        if (success) success.call(callbackOpts.context, m, resp, callbackOpts);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models, {
        model: this.model,
        comparator: this.comparator
      });
    },

    // Define how to uniquely identify models in the collection.
    modelId: function(attrs, idAttribute) {
      return attrs[idAttribute || this.model.prototype.idAttribute || 'id'];
    },

    // Get an iterator of all models in this collection.
    values: function() {
      return new CollectionIterator(this, ITERATOR_VALUES);
    },

    // Get an iterator of all model IDs in this collection.
    keys: function() {
      return new CollectionIterator(this, ITERATOR_KEYS);
    },

    // Get an iterator of all [ID, model] tuples in this collection.
    entries: function() {
      return new CollectionIterator(this, ITERATOR_KEYSVALUES);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (this._isModel(attrs)) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = this;

      var model;
      if (this.model.prototype) {
        model = new this.model(attrs, options);
      } else {
        // ES class methods didn't have prototype
        model = this.model(attrs, options);
      }

      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method called by both remove and set.
    _removeModels: function(models, options) {
      var removed = [];
      for (var i = 0; i < models.length; i++) {
        var model = this.get(models[i]);
        if (!model) continue;

        var index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;

        // Remove references before triggering 'remove' event to prevent an
        // infinite loop. #3693
        delete this._byId[model.cid];
        var id = this.modelId(model.attributes, model.idAttribute);
        if (id != null) delete this._byId[id];

        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }

        removed.push(model);
        this._removeReference(model, options);
      }
      return removed;
    },

    // Method for checking whether an object should be considered a model for
    // the purposes of adding to the collection.
    _isModel: function(model) {
      return model instanceof Model;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      var id = this.modelId(model.attributes, model.idAttribute);
      if (id != null) this._byId[id] = model;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      delete this._byId[model.cid];
      var id = this.modelId(model.attributes, model.idAttribute);
      if (id != null) delete this._byId[id];
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if (model) {
        if ((event === 'add' || event === 'remove') && collection !== this) return;
        if (event === 'destroy') this.remove(model, options);
        if (event === 'changeId') {
          var prevId = this.modelId(model.previousAttributes(), model.idAttribute);
          var id = this.modelId(model.attributes, model.idAttribute);
          if (prevId != null) delete this._byId[prevId];
          if (id != null) this._byId[id] = model;
        }
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Defining an @@iterator method implements JavaScript's Iterable protocol.
  // In modern ES2015 browsers, this value is found at Symbol.iterator.
  /* global Symbol */
  var $$iterator = typeof Symbol === 'function' && Symbol.iterator;
  if ($$iterator) {
    Collection.prototype[$$iterator] = Collection.prototype.values;
  }

  // CollectionIterator
  // ------------------

  // A CollectionIterator implements JavaScript's Iterator protocol, allowing the
  // use of `for of` loops in modern browsers and interoperation between
  // Backbone.Collection and other JavaScript functions and third-party libraries
  // which can operate on Iterables.
  var CollectionIterator = function(collection, kind) {
    this._collection = collection;
    this._kind = kind;
    this._index = 0;
  };

  // This "enum" defines the three possible kinds of values which can be emitted
  // by a CollectionIterator that correspond to the values(), keys() and entries()
  // methods on Collection, respectively.
  var ITERATOR_VALUES = 1;
  var ITERATOR_KEYS = 2;
  var ITERATOR_KEYSVALUES = 3;

  // All Iterators should themselves be Iterable.
  if ($$iterator) {
    CollectionIterator.prototype[$$iterator] = function() {
      return this;
    };
  }

  CollectionIterator.prototype.next = function() {
    if (this._collection) {

      // Only continue iterating if the iterated collection is long enough.
      if (this._index < this._collection.length) {
        var model = this._collection.at(this._index);
        this._index++;

        // Construct a value depending on what kind of values should be iterated.
        var value;
        if (this._kind === ITERATOR_VALUES) {
          value = model;
        } else {
          var id = this._collection.modelId(model.attributes, model.idAttribute);
          if (this._kind === ITERATOR_KEYS) {
            value = id;
          } else { // ITERATOR_KEYSVALUES
            value = [id, model];
          }
        }
        return {value: value, done: false};
      }

      // Once exhausted, remove the reference to the collection so future
      // calls to the next method always return done.
      this._collection = void 0;
    }

    return {value: void 0, done: true};
  };

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this.preinitialize.apply(this, arguments);
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be set as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the View
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this._removeElement();
      this.stopListening();
      return this;
    },

    // Remove this view's element from the document and all event listeners
    // attached to it. Exposed for subclasses using an alternative DOM
    // manipulation API.
    _removeElement: function() {
      this.$el.remove();
    },

    // Change the view's element (`this.el` property) and re-delegate the
    // view's events on the new element.
    setElement: function(element) {
      this.undelegateEvents();
      this._setElement(element);
      this.delegateEvents();
      return this;
    },

    // Creates the `this.el` and `this.$el` references for this view using the
    // given `el`. `el` can be a CSS selector or an HTML string, a jQuery
    // context or an element. Subclasses can override this to utilize an
    // alternative DOM manipulation API and are only required to set the
    // `this.el` property.
    _setElement: function(el) {
      this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
      this.el = this.$el[0];
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    delegateEvents: function(events) {
      events || (events = _.result(this, 'events'));
      if (!events) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[method];
        if (!method) continue;
        var match = key.match(delegateEventSplitter);
        this.delegate(match[1], match[2], method.bind(this));
      }
      return this;
    },

    // Add a single event listener to the view's element (or a child element
    // using `selector`). This only works for delegate-able events: not `focus`,
    // `blur`, and not `change`, `submit`, and `reset` in Internet Explorer.
    delegate: function(eventName, selector, listener) {
      this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Clears all callbacks previously bound to the view by `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      if (this.$el) this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // A finer-grained `undelegateEvents` for removing a single delegated event.
    // `selector` and `listener` are both optional.
    undelegate: function(eventName, selector, listener) {
      this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
      return this;
    },

    // Produces a DOM element to be assigned to your view. Exposed for
    // subclasses using an alternative DOM manipulation API.
    _createElement: function(tagName) {
      return document.createElement(tagName);
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        this.setElement(this._createElement(_.result(this, 'tagName')));
        this._setAttributes(attrs);
      } else {
        this.setElement(_.result(this, 'el'));
      }
    },

    // Set attributes from a hash on this view's element.  Exposed for
    // subclasses using an alternative DOM manipulation API.
    _setAttributes: function(attributes) {
      this.$el.attr(attributes);
    }

  });

  // Proxy Backbone class methods to Underscore functions, wrapping the model's
  // `attributes` object or collection's `models` array behind the scenes.
  //
  // collection.filter(function(model) { return model.get('age') > 10 });
  // collection.each(this.addView);
  //
  // `Function#apply` can be slow so we use the method's arg count, if we know it.
  var addMethod = function(base, length, method, attribute) {
    switch (length) {
      case 1: return function() {
        return base[method](this[attribute]);
      };
      case 2: return function(value) {
        return base[method](this[attribute], value);
      };
      case 3: return function(iteratee, context) {
        return base[method](this[attribute], cb(iteratee, this), context);
      };
      case 4: return function(iteratee, defaultVal, context) {
        return base[method](this[attribute], cb(iteratee, this), defaultVal, context);
      };
      default: return function() {
        var args = slice.call(arguments);
        args.unshift(this[attribute]);
        return base[method].apply(base, args);
      };
    }
  };

  var addUnderscoreMethods = function(Class, base, methods, attribute) {
    _.each(methods, function(length, method) {
      if (base[method]) Class.prototype[method] = addMethod(base, length, method, attribute);
    });
  };

  // Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
  var cb = function(iteratee, instance) {
    if (_.isFunction(iteratee)) return iteratee;
    if (_.isObject(iteratee) && !instance._isModel(iteratee)) return modelMatcher(iteratee);
    if (_.isString(iteratee)) return function(model) { return model.get(iteratee); };
    return iteratee;
  };
  var modelMatcher = function(attrs) {
    var matcher = _.matches(attrs);
    return function(model) {
      return matcher(model.attributes);
    };
  };

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var collectionMethods = {forEach: 3, each: 3, map: 3, collect: 3, reduce: 0,
    foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3,
    select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3,
    contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3,
    head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3,
    without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3,
    isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3,
    sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3};


  // Underscore methods that we want to implement on the Model, mapped to the
  // number of arguments they take.
  var modelMethods = {keys: 1, values: 1, pairs: 1, invert: 1, pick: 0,
    omit: 0, chain: 1, isEmpty: 1};

  // Mix in each Underscore method as a proxy to `Collection#models`.

  _.each([
    [Collection, collectionMethods, 'models'],
    [Model, modelMethods, 'attributes']
  ], function(config) {
    var Base = config[0],
        methods = config[1],
        attribute = config[2];

    Base.mixin = function(obj) {
      var mappings = _.reduce(_.functions(obj), function(memo, name) {
        memo[name] = 0;
        return memo;
      }, {});
      addUnderscoreMethods(Base, obj, mappings, attribute);
    };

    addUnderscoreMethods(Base, _, methods, attribute);
  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // Pass along `textStatus` and `errorThrown` from jQuery.
    var error = options.error;
    options.error = function(xhr, textStatus, errorThrown) {
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      if (error) error.call(options.context, xhr, textStatus, errorThrown);
    };

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch': 'PATCH',
    'delete': 'DELETE',
    'read': 'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    this.preinitialize.apply(this, arguments);
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // preinitialize is an empty function by default. You can override it with a function
    // or object.  preinitialize will run before any instantiation logic is run in the Router.
    preinitialize: function(){},

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        if (router.execute(callback, args, name) !== false) {
          router.trigger.apply(router, ['route:' + name].concat(args));
          router.trigger('route', name, args);
          Backbone.history.trigger('route', router, name, args);
        }
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args, name) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
      .replace(optionalParam, '(?:$1)?')
      .replace(namedParam, function(match, optional) {
        return optional ? match : '([^/?]+)';
      })
      .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    this.checkUrl = this.checkUrl.bind(this);

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      var path = this.location.pathname.replace(/[^\/]$/, '$&/');
      return path === this.root && !this.getSearch();
    },

    // Does the pathname match the root?
    matchRoot: function() {
      var path = this.decodeFragment(this.location.pathname);
      var rootPath = path.slice(0, this.root.length - 1) + '/';
      return rootPath === this.root;
    },

    // Unicode characters in `location.pathname` are percent encoded so they're
    // decoded for comparison. `%25` should not be decoded since it may be part
    // of an encoded parameter.
    decodeFragment: function(fragment) {
      return decodeURI(fragment.replace(/%25/g, '%2525'));
    },

    // In IE6, the hash fragment and search params are incorrect if the
    // fragment contains `?`.
    getSearch: function() {
      var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
      return match ? match[0] : '';
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the pathname and search params, without the root.
    getPath: function() {
      var path = this.decodeFragment(
        this.location.pathname + this.getSearch()
      ).slice(this.root.length - 1);
      return path.charAt(0) === '/' ? path.slice(1) : path;
    },

    // Get the cross-browser normalized URL fragment from the path or hash.
    getFragment: function(fragment) {
      if (fragment == null) {
        if (this._usePushState || !this._wantsHashChange) {
          fragment = this.getPath();
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error('Backbone.history has already been started');
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasHashChange   = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
      this._useHashChange   = this._wantsHashChange && this._hasHashChange;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.history && this.history.pushState);
      this._usePushState    = this._wantsPushState && this._hasPushState;
      this.fragment         = this.getFragment();

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          var rootPath = this.root.slice(0, -1) || '/';
          this.location.replace(rootPath + '#' + this.getPath());
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot()) {
          this.navigate(this.getHash(), {replace: true});
        }

      }

      // Proxy an iframe to handle location events if the browser doesn't
      // support the `hashchange` event, HTML5 history, or the user wants
      // `hashChange` but not `pushState`.
      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
        this.iframe = document.createElement('iframe');
        this.iframe.src = 'javascript:0';
        this.iframe.style.display = 'none';
        this.iframe.tabIndex = -1;
        var body = document.body;
        // Using `appendChild` will throw on IE < 9 if the document is not ready.
        var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = '#' + this.fragment;
      }

      // Add a cross-platform `addEventListener` shim for older browsers.
      var addEventListener = window.addEventListener || function(eventName, listener) {
        return attachEvent('on' + eventName, listener);
      };

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._usePushState) {
        addEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        addEventListener('hashchange', this.checkUrl, false);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      // Add a cross-platform `removeEventListener` shim for older browsers.
      var removeEventListener = window.removeEventListener || function(eventName, listener) {
        return detachEvent('on' + eventName, listener);
      };

      // Remove window listeners.
      if (this._usePushState) {
        removeEventListener('popstate', this.checkUrl, false);
      } else if (this._useHashChange && !this.iframe) {
        removeEventListener('hashchange', this.checkUrl, false);
      }

      // Clean up the iframe if necessary.
      if (this.iframe) {
        document.body.removeChild(this.iframe);
        this.iframe = null;
      }

      // Some environments will throw when clearing an undefined interval.
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();

      // If the user pressed the back button, the iframe's hash will have
      // changed and we should use that for comparison.
      if (current === this.fragment && this.iframe) {
        current = this.getHash(this.iframe.contentWindow);
      }

      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      // If the root doesn't match, no routes can match either.
      if (!this.matchRoot()) return false;
      fragment = this.fragment = this.getFragment(fragment);
      return _.some(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      // Normalize the fragment.
      fragment = this.getFragment(fragment || '');

      // Don't include a trailing slash on the root.
      var rootPath = this.root;
      if (fragment === '' || fragment.charAt(0) === '?') {
        rootPath = rootPath.slice(0, -1) || '/';
      }
      var url = rootPath + fragment;

      // Strip the fragment of the query and hash for matching.
      fragment = fragment.replace(pathStripper, '');

      // Decode for matching.
      var decodedFragment = this.decodeFragment(fragment);

      if (this.fragment === decodedFragment) return;
      this.fragment = decodedFragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._usePushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
          var iWindow = this.iframe.contentWindow;

          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          this._updateHash(iWindow.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function and add the prototype properties.
    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error.call(options.context, model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;
});


/***/ }),

/***/ 728:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(847);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ModuleModel = /** @class */ (function (_super) {
    __extends(ModuleModel, _super);
    function ModuleModel(module, attributes, options) {
        var _this = _super.call(this, attributes, options) || this;
        _this._module = module;
        return _this;
    }
    Object.defineProperty(ModuleModel.prototype, "module", {
        get: function () {
            return this._module;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleModel.prototype, "config", {
        get: function () {
            return this._module.config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleModel.prototype, "em", {
        get: function () {
            return this._module.em;
        },
        enumerable: false,
        configurable: true
    });
    return ModuleModel;
}(_common__WEBPACK_IMPORTED_MODULE_0__/* .Model */ .Hn));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ModuleModel);


/***/ }),

/***/ 201:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   q: () => (/* binding */ CanvasSpotBuiltInTypes)
/* harmony export */ });
/* harmony import */ var _abstract__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(728);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var CanvasSpotBuiltInTypes;
(function (CanvasSpotBuiltInTypes) {
    CanvasSpotBuiltInTypes["Select"] = "select";
    CanvasSpotBuiltInTypes["Hover"] = "hover";
    CanvasSpotBuiltInTypes["Spacing"] = "spacing";
    CanvasSpotBuiltInTypes["Target"] = "target";
    CanvasSpotBuiltInTypes["Resize"] = "resize";
})(CanvasSpotBuiltInTypes || (CanvasSpotBuiltInTypes = {}));
/**
 * Canvas spots are elements drawn on top of the canvas. They can be used to represent anything you
 * might need but the most common use case of canvas spots is rendering information and managing
 * components rendered in the canvas.
 * Read here for more information about [Canvas Spots](https://grapesjs.com/docs/modules/Canvas.html#canvas-spots)
 *
 * [Component]: component.html
 *
 * @property {String} id Spot ID.
 * @property {String} type Spot type.
 * @property {[Component]} [component] Component to which the spot will be attached.
 * @property {ComponentView} [componentView] ComponentView to which the spot will be attached.
 * @property {Object} [boxRect] Fixed box rect of the spot, eg. `{ width: 100, height: 100, x: 0, y: 0 }`.
 *
 */
var CanvasSpot = /** @class */ (function (_super) {
    __extends(CanvasSpot, _super);
    function CanvasSpot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CanvasSpot.prototype.defaults = function () {
        return {
            id: '',
            type: '',
        };
    };
    Object.defineProperty(CanvasSpot.prototype, "type", {
        get: function () {
            return this.get('type') || '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasSpot.prototype, "component", {
        get: function () {
            var _a;
            var cmp = this.get('component');
            return cmp || ((_a = this.get('componentView')) === null || _a === void 0 ? void 0 : _a.model);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasSpot.prototype, "componentView", {
        get: function () {
            var _a;
            var cmpView = this.get('componentView');
            return cmpView || ((_a = this.get('component')) === null || _a === void 0 ? void 0 : _a.getView());
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasSpot.prototype, "el", {
        get: function () {
            var _a;
            return (_a = this.componentView) === null || _a === void 0 ? void 0 : _a.el;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get the box rect of the spot.
     * @param {Object} [opts={}]
     * @returns {Object} The box rect object
     * @example
     * canvasSpot.getBoxRect();
     * // { width: 100, height: 50, x: 0, y: 0 }
     */
    CanvasSpot.prototype.getBoxRect = function (opts) {
        var _a = this, el = _a.el, em = _a.em;
        var cvView = em.Canvas.getCanvasView();
        var boxRect = this.get('boxRect');
        if (boxRect) {
            return boxRect;
        }
        else if (el && cvView) {
            return cvView.getElBoxRect(el, opts);
        }
        return {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
        };
    };
    /**
     * Get the style object of the spot.
     * @param {Object} [opts={}]
     * @returns {CSSStyleDeclaration} [opts]
     * @example
     * canvasSpot.getStyle();
     * // { width: '100px', height: '...', ... }
     */
    CanvasSpot.prototype.getStyle = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = opts.boxRect || this.getBoxRect(opts), width = _a.width, height = _a.height, x = _a.x, y = _a.y;
        return {
            width: "".concat(width, "px"),
            height: "".concat(height, "px"),
            top: '0',
            left: '0',
            position: 'absolute',
            translate: "".concat(x, "px ").concat(y, "px"),
        };
    };
    /**
     * Check the spot type.
     * @param {String} type
     * @returns {Boolean}
     * @example
     * canvasSpot.isType('select');
     */
    CanvasSpot.prototype.isType = function (type) {
        return this.type === type;
    };
    return CanvasSpot;
}(_abstract__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasSpot);


/***/ }),

/***/ 266:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        ed.Components.clear();
        ed.Css.clear();
    },
});


/***/ }),

/***/ 142:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _utils_Dragger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(250);
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.bindAll)(this, 'onKeyUp', 'enableDragger', 'disableDragger');
        this.editor = ed;
        this.canvasModel = this.canvas.getCanvasView().model;
        this.toggleMove(1);
    },
    stop: function (ed) {
        this.toggleMove();
        this.disableDragger();
    },
    onKeyUp: function (ev) {
        if ((0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__/* .getKeyChar */ .sN)(ev) === ' ') {
            this.editor.stopCommand(this.id);
        }
    },
    enableDragger: function (ev) {
        this.toggleDragger(1, ev);
    },
    disableDragger: function (ev) {
        this.toggleDragger(0, ev);
    },
    toggleDragger: function (enable, ev) {
        var _a = this, canvasModel = _a.canvasModel, em = _a.em;
        var dragger = this.dragger;
        var methodCls = enable ? 'add' : 'remove';
        this.getCanvas().classList[methodCls]("".concat(this.ppfx, "is__grabbing"));
        if (!dragger) {
            dragger = new _utils_Dragger__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z({
                getPosition: function () {
                    return {
                        x: canvasModel.get('x'),
                        y: canvasModel.get('y'),
                    };
                },
                setPosition: function (_a) {
                    var x = _a.x, y = _a.y;
                    canvasModel.set({ x: x, y: y });
                },
                onStart: function (ev, dragger) {
                    em.trigger('canvas:move:start', dragger);
                },
                onDrag: function (ev, dragger) {
                    em.trigger('canvas:move', dragger);
                },
                onEnd: function (ev, dragger) {
                    em.trigger('canvas:move:end', dragger);
                },
            });
            this.dragger = dragger;
        }
        enable ? dragger.start(ev) : dragger.stop();
    },
    toggleMove: function (enable) {
        var ppfx = this.ppfx;
        var methodCls = enable ? 'add' : 'remove';
        var methodEv = enable ? 'on' : 'off';
        var methodsEv = { on: _utils_dom__WEBPACK_IMPORTED_MODULE_1__.on, off: _utils_dom__WEBPACK_IMPORTED_MODULE_1__/* .off */ .S1 };
        var canvas = this.getCanvas();
        var classes = ["".concat(ppfx, "is__grab")];
        !enable && classes.push("".concat(ppfx, "is__grabbing"));
        classes.forEach(function (cls) { return canvas.classList[methodCls](cls); });
        methodsEv[methodEv](document, 'keyup', this.onKeyUp);
        methodsEv[methodEv](canvas, 'mousedown', this.enableDragger);
        methodsEv[methodEv](document, 'mouseup', this.disableDragger);
    },
});


/***/ }),

/***/ 458:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defineCommand: () => (/* binding */ defineCommand)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(847);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

function defineCommand(def) {
    return def;
}
var CommandAbstract = /** @class */ (function (_super) {
    __extends(CommandAbstract, _super);
    function CommandAbstract(o) {
        var _this = _super.call(this, 0) || this;
        _this.config = o || {};
        _this.em = _this.config.em || {};
        var pfx = _this.config.stylePrefix;
        _this.pfx = pfx;
        _this.ppfx = _this.config.pStylePrefix;
        _this.hoverClass = "".concat(pfx, "hover");
        _this.badgeClass = "".concat(pfx, "badge");
        _this.plhClass = "".concat(pfx, "placeholder");
        _this.freezClass = "".concat(_this.ppfx, "freezed");
        _this.canvas = _this.em.Canvas;
        _this.init(_this.config);
        return _this;
    }
    /**
     * On frame scroll callback
     * @param  {[type]} e [description]
     * @return {[type]}   [description]
     */
    CommandAbstract.prototype.onFrameScroll = function (e) { };
    /**
     * Returns canval element
     * @return {HTMLElement}
     */
    CommandAbstract.prototype.getCanvas = function () {
        return this.canvas.getElement();
    };
    /**
     * Get canvas body element
     * @return {HTMLElement}
     */
    CommandAbstract.prototype.getCanvasBody = function () {
        return this.canvas.getBody();
    };
    /**
     * Get canvas wrapper element
     * @return {HTMLElement}
     */
    CommandAbstract.prototype.getCanvasTools = function () {
        return this.canvas.getToolsEl();
    };
    /**
     * Get the offset of the element
     * @param  {HTMLElement} el
     * @return {Object}
     */
    CommandAbstract.prototype.offset = function (el) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top + el.ownerDocument.body.scrollTop,
            left: rect.left + el.ownerDocument.body.scrollLeft,
        };
    };
    /**
     * Callback triggered after initialize
     * @param  {Object}  o   Options
     * @private
     * */
    CommandAbstract.prototype.init = function (o) { };
    /**
     * Method that run command
     * @param  {Object}  editor Editor instance
     * @param  {Object}  [options={}] Options
     * @private
     * */
    CommandAbstract.prototype.callRun = function (editor, options) {
        if (options === void 0) { options = {}; }
        var id = this.id;
        editor.trigger("run:".concat(id, ":before"), options);
        if (options && options.abort) {
            editor.trigger("abort:".concat(id), options);
            return;
        }
        var sender = options.sender || editor;
        var result = this.run(editor, sender, options);
        editor.trigger("run:".concat(id), result, options);
        editor.trigger('run', id, result, options);
        return result;
    };
    /**
     * Method that run command
     * @param  {Object}  editor Editor instance
     * @param  {Object}  [options={}] Options
     * @private
     * */
    CommandAbstract.prototype.callStop = function (editor, options) {
        if (options === void 0) { options = {}; }
        var id = this.id;
        var sender = options.sender || editor;
        editor.trigger("stop:".concat(id, ":before"), options);
        var result = this.stop(editor, sender, options);
        editor.trigger("stop:".concat(id), result, options);
        editor.trigger('stop', id, result, options);
        return result;
    };
    /**
     * Stop current command
     */
    CommandAbstract.prototype.stopCommand = function (opts) {
        this.em.Commands.stop(this.id, opts);
    };
    /**
     * Method that run command
     * @param  {Object}  em     Editor model
     * @param  {Object}  sender  Button sender
     * @private
     * */
    CommandAbstract.prototype.run = function (em, sender, options) { };
    /**
     * Method that stop command
     * @param  {Object}  em Editor model
     * @param  {Object}  sender  Button sender
     * @private
     * */
    CommandAbstract.prototype.stop = function (em, sender, options) { };
    return CommandAbstract;
}(_common__WEBPACK_IMPORTED_MODULE_0__/* .Model */ .Hn));
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CommandAbstract);


/***/ }),

/***/ 463:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

var command = {
    run: function (ed, s, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var toSelect = [];
        var components = opts.component || ed.getSelectedAll();
        components = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isArray)(components) ? __spreadArray([], components, true) : [components];
        components.filter(Boolean).forEach(function (component) {
            var _a, _b;
            if (!component.get('removable')) {
                toSelect.push(component);
                return _this.em.logWarning('The element is not removable', {
                    component: component,
                });
            }
            var cmp = ((_b = (_a = component.delegate) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, component)) || component;
            cmp.remove();
        });
        ed.select(toSelect);
        return components;
    },
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (command);


/***/ }),

/***/ 474:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _utils_Dragger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(250);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var evName = 'dmode';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor, sender, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.bindAll)(this, 'setPosition', 'onStart', 'onDrag', 'onEnd', 'getPosition', 'getGuidesStatic', 'renderGuide', 'getGuidesTarget');
        var target = opts.target, event = opts.event, mode = opts.mode, _a = opts.dragger, dragger = _a === void 0 ? {} : _a;
        var el = target.getEl();
        var config = __assign({ doc: el.ownerDocument, onStart: this.onStart, onEnd: this.onEnd, onDrag: this.onDrag, getPosition: this.getPosition, setPosition: this.setPosition, guidesStatic: function () { return _this.guidesStatic; }, guidesTarget: function () { return _this.guidesTarget; } }, dragger);
        this.setupGuides();
        this.opts = opts;
        this.editor = editor;
        this.em = editor.getModel();
        this.target = target;
        this.isTran = mode == 'translate';
        this.guidesContainer = this.getGuidesContainer();
        this.guidesTarget = this.getGuidesTarget();
        this.guidesStatic = this.getGuidesStatic();
        var drg = this.dragger;
        if (!drg) {
            drg = new _utils_Dragger__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .Z(config);
            this.dragger = drg;
        }
        else {
            drg.setOptions(config);
        }
        event && drg.start(event);
        this.toggleDrag(1);
        this.em.trigger("".concat(evName, ":start"), this.getEventOpts());
        return drg;
    },
    getEventOpts: function () {
        return {
            mode: this.opts.mode,
            target: this.target,
            guidesTarget: this.guidesTarget,
            guidesStatic: this.guidesStatic,
        };
    },
    stop: function () {
        this.toggleDrag();
    },
    setupGuides: function () {
        (this.guides || []).forEach(function (item) {
            var guide = item.guide;
            guide && guide.parentNode.removeChild(guide);
        });
        this.guides = [];
    },
    getGuidesContainer: function () {
        var _this = this;
        var guidesEl = this.guidesEl;
        if (!guidesEl) {
            var _a = this, editor = _a.editor, em = _a.em, opts_1 = _a.opts;
            var pfx = editor.getConfig().stylePrefix;
            var elInfoX = document.createElement('div');
            var elInfoY = document.createElement('div');
            var guideContent = "<div class=\"".concat(pfx, "guide-info__line ").concat(pfx, "danger-bg\">\n        <div class=\"").concat(pfx, "guide-info__content ").concat(pfx, "danger-color\"></div>\n      </div>");
            guidesEl = document.createElement('div');
            guidesEl.className = "".concat(pfx, "guides");
            elInfoX.className = "".concat(pfx, "guide-info ").concat(pfx, "guide-info__x");
            elInfoY.className = "".concat(pfx, "guide-info ").concat(pfx, "guide-info__y");
            elInfoX.innerHTML = guideContent;
            elInfoY.innerHTML = guideContent;
            guidesEl.appendChild(elInfoX);
            guidesEl.appendChild(elInfoY);
            editor.Canvas.getGlobalToolsEl().appendChild(guidesEl);
            this.guidesEl = guidesEl;
            this.elGuideInfoX = elInfoX;
            this.elGuideInfoY = elInfoY;
            this.elGuideInfoContentX = elInfoX.querySelector(".".concat(pfx, "guide-info__content"));
            this.elGuideInfoContentY = elInfoY.querySelector(".".concat(pfx, "guide-info__content"));
            em.on('canvas:update frame:scroll', (0,underscore__WEBPACK_IMPORTED_MODULE_0__.debounce)(function () {
                var _a;
                _this.updateGuides();
                opts_1.debug && ((_a = _this.guides) === null || _a === void 0 ? void 0 : _a.forEach(function (item) { return _this.renderGuide(item); }));
            }, 200));
        }
        return guidesEl;
    },
    getGuidesStatic: function () {
        var _this = this;
        var result = [];
        var el = this.target.getEl();
        var _a = el.parentNode, parentNode = _a === void 0 ? {} : _a;
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(parentNode.children, function (item) { return (result = result.concat(el !== item ? _this.getElementGuides(item) : [])); });
        return result.concat(this.getElementGuides(parentNode));
    },
    getGuidesTarget: function () {
        return this.getElementGuides(this.target.getEl());
    },
    updateGuides: function (guides) {
        var _this = this;
        var lastEl;
        var lastPos;
        (guides || this.guides).forEach(function (item) {
            var origin = item.origin;
            var pos = lastEl === origin ? lastPos : _this.getElementPos(origin);
            lastEl = origin;
            lastPos = pos;
            (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(_this.getGuidePosUpdate(item, pos), function (val, key) { return (item[key] = val); });
            item.originRect = pos;
        });
    },
    getGuidePosUpdate: function (item, rect) {
        var result = {};
        var top = rect.top, height = rect.height, left = rect.left, width = rect.width;
        switch (item.type) {
            case 't':
                result.y = top;
                break;
            case 'b':
                result.y = top + height;
                break;
            case 'l':
                result.x = left;
                break;
            case 'r':
                result.x = left + width;
                break;
            case 'x':
                result.x = left + width / 2;
                break;
            case 'y':
                result.y = top + height / 2;
                break;
        }
        return result;
    },
    renderGuide: function (item) {
        if (item === void 0) { item = {}; }
        var el = item.guide || document.createElement('div');
        var un = 'px';
        var guideSize = item.active ? 2 : 1;
        var numEl = el.children[0];
        el.style = "position: absolute; background-color: ".concat(item.active ? 'green' : 'red', ";");
        if (!el.children.length) {
            numEl = document.createElement('div');
            numEl.style = 'position: absolute; color: red; padding: 5px; top: 0; left: 0;';
            el.appendChild(numEl);
        }
        if (item.y) {
            el.style.width = '100%';
            el.style.height = "".concat(guideSize).concat(un);
            el.style.top = "".concat(item.y).concat(un);
            el.style.left = 0;
        }
        else {
            el.style.width = "".concat(guideSize).concat(un);
            el.style.height = '100%';
            el.style.left = "".concat(item.x).concat(un);
            el.style.top = "0".concat(un);
        }
        !item.guide && this.guidesContainer.appendChild(el);
        return el;
    },
    getElementPos: function (el) {
        return this.editor.Canvas.getElementPos(el, { noScroll: 1 });
    },
    getElementGuides: function (el) {
        var _this = this;
        var opts = this.opts;
        var originRect = this.getElementPos(el);
        var top = originRect.top, height = originRect.height, left = originRect.left, width = originRect.width;
        // @ts-ignore
        var guides = [
            { type: 't', y: top }, // Top
            { type: 'b', y: top + height }, // Bottom
            { type: 'l', x: left }, // Left
            { type: 'r', x: left + width }, // Right
            { type: 'x', x: left + width / 2 }, // Mid x
            { type: 'y', y: top + height / 2 }, // Mid y
        ].map(function (item) { return (__assign(__assign({}, item), { origin: el, originRect: originRect, guide: opts.debug && _this.renderGuide(item) })); });
        guides.forEach(function (item) { var _a; return (_a = _this.guides) === null || _a === void 0 ? void 0 : _a.push(item); });
        return guides;
    },
    getTranslate: function (transform, axis) {
        if (axis === void 0) { axis = 'x'; }
        var result = 0;
        (transform || '').split(' ').forEach(function (item) {
            var itemStr = item.trim();
            var fn = "translate".concat(axis.toUpperCase(), "(");
            if (itemStr.indexOf(fn) === 0)
                result = parseFloat(itemStr.replace(fn, ''));
        });
        return result;
    },
    setTranslate: function (transform, axis, value) {
        var fn = "translate".concat(axis.toUpperCase(), "(");
        var val = "".concat(fn).concat(value, ")");
        var result = (transform || '')
            .split(' ')
            .map(function (item) {
            var itemStr = item.trim();
            if (itemStr.indexOf(fn) === 0)
                item = val;
            return item;
        })
            .join(' ');
        if (result.indexOf(fn) < 0)
            result += " ".concat(val);
        return result;
    },
    getPosition: function () {
        var _a = this, target = _a.target, isTran = _a.isTran;
        var _b = target.getStyle(), left = _b.left, top = _b.top, transform = _b.transform;
        var x = 0;
        var y = 0;
        if (isTran) {
            x = this.getTranslate(transform);
            y = this.getTranslate(transform, 'y');
        }
        else {
            x = parseFloat(left || 0);
            y = parseFloat(top || 0);
        }
        return { x: x, y: y };
    },
    setPosition: function (_a) {
        var x = _a.x, y = _a.y, end = _a.end, position = _a.position, width = _a.width, height = _a.height;
        var _b = this, target = _b.target, isTran = _b.isTran, em = _b.em;
        var unit = 'px';
        var __p = !end; // Indicate if partial change
        var left = "".concat(parseInt(x, 10)).concat(unit);
        var top = "".concat(parseInt(y, 10)).concat(unit);
        var styleUp = {};
        if (isTran) {
            var transform = target.getStyle()['transform'] || '';
            transform = this.setTranslate(transform, 'x', left);
            transform = this.setTranslate(transform, 'y', top);
            styleUp = { transform: transform, __p: __p };
            target.addStyle(styleUp, { avoidStore: !end });
        }
        else {
            var adds_1 = { position: position, width: width, height: height };
            var style_1 = { left: left, top: top, __p: __p };
            (0,underscore__WEBPACK_IMPORTED_MODULE_0__.keys)(adds_1).forEach(function (add) {
                var prop = adds_1[add];
                if (prop)
                    style_1[add] = prop;
            });
            styleUp = style_1;
            target.addStyle(styleUp, { avoidStore: !end });
        }
        em === null || em === void 0 ? void 0 : em.Styles.__emitCmpStyleUpdate(styleUp, { components: em.getSelected() });
    },
    _getDragData: function () {
        var target = this.target;
        return {
            target: target,
            parent: target.parent(),
            index: target.index(),
        };
    },
    onStart: function (event) {
        var _a = this, target = _a.target, editor = _a.editor, isTran = _a.isTran, opts = _a.opts;
        var center = opts.center, onStart = opts.onStart;
        var Canvas = editor.Canvas;
        var style = target.getStyle();
        var position = 'absolute';
        var relPos = [position, 'relative'];
        onStart && onStart(this._getDragData());
        if (isTran)
            return;
        if (style.position !== position) {
            var _b = Canvas.offset(target.getEl()), left = _b.left, top_1 = _b.top, width = _b.width, height = _b.height;
            var parent_1 = target.parent();
            var parentRel = void 0;
            // Check for the relative parent
            do {
                var pStyle = parent_1.getStyle();
                parentRel = relPos.indexOf(pStyle.position) >= 0 ? parent_1 : null;
                parent_1 = parent_1.parent();
            } while (parent_1 && !parentRel);
            // Center the target to the pointer position (used in Droppable for Blocks)
            if (center) {
                var _c = Canvas.getMouseRelativeCanvas(event), x = _c.x, y = _c.y;
                left = x;
                top_1 = y;
            }
            else if (parentRel) {
                var offsetP = Canvas.offset(parentRel.getEl());
                left = left - offsetP.left;
                top_1 = top_1 - offsetP.top;
            }
            this.setPosition({
                x: left,
                y: top_1,
                width: "".concat(width, "px"),
                height: "".concat(height, "px"),
                position: position,
            });
        }
    },
    onDrag: function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a = this, guidesTarget = _a.guidesTarget, opts = _a.opts;
        var onDrag = opts.onDrag;
        this.updateGuides(guidesTarget);
        opts.debug && guidesTarget.forEach(function (item) { return _this.renderGuide(item); });
        opts.guidesInfo && this.renderGuideInfo(guidesTarget.filter(function (item) { return item.active; }));
        onDrag && onDrag(this._getDragData());
    },
    onEnd: function (ev, dragger, opt) {
        if (opt === void 0) { opt = {}; }
        var _a = this, editor = _a.editor, opts = _a.opts, id = _a.id;
        var onEnd = opts.onEnd;
        onEnd && onEnd(ev, opt, __assign(__assign({ event: ev }, opt), this._getDragData()));
        editor.stopCommand(id);
        this.hideGuidesInfo();
        this.em.trigger("".concat(evName, ":end"), this.getEventOpts());
    },
    hideGuidesInfo: function () {
        var _this = this;
        ['X', 'Y'].forEach(function (item) {
            var guide = _this["elGuideInfo".concat(item)];
            if (guide)
                guide.style.display = 'none';
        });
    },
    /**
     * Render guides with spacing information
     */
    renderGuideInfo: function (guides) {
        var _this = this;
        if (guides === void 0) { guides = []; }
        var guidesStatic = this.guidesStatic;
        this.hideGuidesInfo();
        guides.forEach(function (item) {
            var origin = item.origin, x = item.x;
            var rectOrigin = _this.getElementPos(origin);
            var axis = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(x) ? 'y' : 'x';
            var isY = axis === 'y';
            var origEdge1 = rectOrigin[isY ? 'left' : 'top'];
            var origEdge1Raw = rectOrigin.rect[isY ? 'left' : 'top'];
            var origEdge2 = isY ? origEdge1 + rectOrigin.width : origEdge1 + rectOrigin.height;
            var origEdge2Raw = isY ? origEdge1Raw + rectOrigin.rect.width : origEdge1Raw + rectOrigin.rect.height;
            var elGuideInfo = _this["elGuideInfo".concat(axis.toUpperCase())];
            var elGuideInfoCnt = _this["elGuideInfoContent".concat(axis.toUpperCase())];
            var guideInfoStyle = elGuideInfo.style;
            // Find the nearest element
            var res = guidesStatic === null || guidesStatic === void 0 ? void 0 : guidesStatic.filter(function (stat) { return stat.type === item.type; }).map(function (stat) {
                var _a = stat.originRect, left = _a.left, width = _a.width, top = _a.top, height = _a.height;
                var statEdge1 = isY ? left : top;
                var statEdge2 = isY ? left + width : top + height;
                return {
                    gap: statEdge2 < origEdge1 ? origEdge1 - statEdge2 : statEdge1 - origEdge2,
                    guide: stat,
                };
            }).filter(function (item) { return item.gap > 0; }).sort(function (a, b) { return a.gap - b.gap; }).map(function (item) { return item.guide; })[0];
            if (res) {
                var _a = res.originRect, left = _a.left, width = _a.width, top_2 = _a.top, height = _a.height, rect = _a.rect;
                var isEdge1 = isY ? left < rectOrigin.left : top_2 < rectOrigin.top;
                var statEdge1 = isY ? left : top_2;
                var statEdge1Raw = isY ? rect.left : rect.top;
                var statEdge2 = isY ? left + width : top_2 + height;
                var statEdge2Raw = isY ? rect.left + rect.width : rect.top + rect.height;
                var posFirst = isY ? item.y : item.x;
                var posSecond = isEdge1 ? statEdge2 : origEdge2;
                var pos2 = "".concat(posFirst, "px");
                var size = isEdge1 ? origEdge1 - statEdge2 : statEdge1 - origEdge2;
                var sizeRaw = isEdge1 ? origEdge1Raw - statEdge2Raw : statEdge1Raw - origEdge2Raw;
                guideInfoStyle.display = '';
                guideInfoStyle[isY ? 'top' : 'left'] = pos2;
                guideInfoStyle[isY ? 'left' : 'top'] = "".concat(posSecond, "px");
                guideInfoStyle[isY ? 'width' : 'height'] = "".concat(size, "px");
                elGuideInfoCnt.innerHTML = "".concat(Math.round(sizeRaw), "px");
                _this.em.trigger("".concat(evName, ":active"), __assign(__assign({}, _this.getEventOpts()), { guide: item, guidesStatic: guidesStatic, matched: res, posFirst: posFirst, posSecond: posSecond, size: size, sizeRaw: sizeRaw, elGuideInfo: elGuideInfo, elGuideInfoCnt: elGuideInfoCnt }));
            }
        });
    },
    toggleDrag: function (enable) {
        var _a = this, ppfx = _a.ppfx, editor = _a.editor;
        var methodCls = enable ? 'add' : 'remove';
        var classes = ["".concat(ppfx, "is__grabbing")];
        var Canvas = editor.Canvas;
        var body = Canvas.getBody();
        classes.forEach(function (cls) { return body.classList[methodCls](cls); });
        Canvas[enable ? 'startAutoscroll' : 'stopAutoscroll']();
    },
});


/***/ }),

/***/ 866:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        if (!ed.Canvas.hasFocus())
            return;
        var toSelect = [];
        ed.getSelectedAll().forEach(function (component) {
            var coll = component.components();
            var next = coll && coll.filter(function (c) { return c.get('selectable'); })[0];
            next && toSelect.push(next);
        });
        toSelect.length && ed.select(toSelect);
    },
});


/***/ }),

/***/ 594:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed, snd, opts) {
        if (opts === void 0) { opts = {}; }
        if (!ed.Canvas.hasFocus() && !opts.force)
            return;
        var toSelect = [];
        ed.getSelectedAll().forEach(function (component) {
            var next = component.parent();
            // Recurse through the parent() chain until a selectable parent is found
            while (next && !next.get('selectable')) {
                next = next.parent();
            }
            next && toSelect.push(next);
        });
        toSelect.length && ed.select(toSelect);
    },
});


/***/ }),

/***/ 656:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        if (!ed.Canvas.hasFocus())
            return;
        var toSelect = [];
        ed.getSelectedAll().forEach(function (cmp) {
            var parent = cmp.parent();
            if (!parent)
                return;
            var len = parent.components().length;
            var incr = 0;
            var at = 0;
            var next;
            // Get the next selectable component
            do {
                incr++;
                at = cmp.index() + incr;
                next = at <= len ? parent.getChildAt(at) : null;
            } while (next && !next.get('selectable'));
            toSelect.push(next || cmp);
        });
        toSelect.length && ed.select(toSelect);
    },
});


/***/ }),

/***/ 768:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        if (!ed.Canvas.hasFocus())
            return;
        var toSelect = [];
        ed.getSelectedAll().forEach(function (cmp) {
            var parent = cmp.parent();
            if (!parent)
                return;
            var incr = 0;
            var at = 0;
            var next;
            // Get the first selectable component
            do {
                incr++;
                at = cmp.index() - incr;
                next = at >= 0 ? parent.getChildAt(at) : null;
            } while (next && !next.get('selectable'));
            toSelect.push(next || cmp);
        });
        toSelect.length && ed.select(toSelect);
    },
});


/***/ }),

/***/ 570:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed, s, opts) {
        if (opts === void 0) { opts = {}; }
        var target = opts.target;
        var toRemove = [];
        if (!target.get('styles'))
            return toRemove;
        // Find all components in the project, of the target component type
        var type = target.get('type');
        var wrappers = ed.Pages.getAllWrappers();
        var len = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.flatten)(wrappers.map(function (wrp) { return wrp.findType(type); })).length;
        // Remove component related styles only if there are no more components
        // of that type in the project
        if (!len) {
            var rules = ed.CssComposer.getAll();
            toRemove = rules.filter(function (rule) { return rule.get('group') === "cmp:".concat(type); });
            rules.remove(toRemove);
        }
        return toRemove;
    },
});


/***/ }),

/***/ 282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed) {
        var em = ed.getModel();
        var models = __spreadArray([], ed.getSelectedAll(), true).map(function (md) { var _a, _b; return ((_b = (_a = md.delegate) === null || _a === void 0 ? void 0 : _a.copy) === null || _b === void 0 ? void 0 : _b.call(_a, md)) || md; }).filter(Boolean);
        models.length && em.set('clipboard', models);
    },
});


/***/ }),

<<<<<<< HEAD
/***/ 905:
=======
/***/ 457:
>>>>>>> script-module
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
<<<<<<< HEAD
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(968);
=======
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(491);
>>>>>>> script-module

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor, sender, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        sender && sender.set && sender.set('active', 0);
        var config = editor.getConfig();
        var modal = editor.Modal;
        var pfx = config.stylePrefix;
        this.cm = editor.CodeManager || null;
        if (!this.editors) {
            var oHtmlEd = this.buildEditor('htmlmixed', 'hopscotch', 'HTML');
            var oCsslEd = this.buildEditor('css', 'hopscotch', 'CSS');
            this.htmlEditor = oHtmlEd.model;
            this.cssEditor = oCsslEd.model;
            var editors = (0,_utils_dom__WEBPACK_IMPORTED_MODULE_0__/* .createEl */ .ut)('div', { class: "".concat(pfx, "export-dl") });
            editors.appendChild(oHtmlEd.el);
            editors.appendChild(oCsslEd.el);
            this.editors = editors;
        }
        modal
            .open({
            title: config.textViewCode,
            content: this.editors,
        })
            .getModel()
            .once('change:open', function () { return editor.stopCommand("".concat(_this.id)); });
        this.htmlEditor.setContent(editor.getHtml(opts.optsHtml));
        this.cssEditor.setContent(editor.getCss(opts.optsCss));
    },
    stop: function (editor) {
        var modal = editor.Modal;
        modal && modal.close();
    },
    buildEditor: function (codeName, theme, label) {
        var cm = this.em.CodeManager;
        var model = cm.createViewer({
            label: label,
            codeName: codeName,
            theme: theme,
        });
        var el = new cm.EditorView({
            model: model,
            config: cm.getConfig(),
        }).render().el;
        return { model: model, el: el };
    },
});


/***/ }),

/***/ 212:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    /**
     * Check if fullscreen mode is enabled
     * @return {Boolean}
     */
    isEnabled: function () {
        var d = document;
        // @ts-ignore
        if (d.fullscreenElement || d.webkitFullscreenElement || d.mozFullScreenElement) {
            return true;
        }
        return false;
    },
    /**
     * Enable fullscreen mode and return browser prefix
     * @param  {HTMLElement} el
     * @return {string}
     */
    enable: function (el) {
        var pfx = '';
        if (el.requestFullscreen) {
            el.requestFullscreen();
        }
        else if (el.webkitRequestFullscreen) {
            pfx = 'webkit';
            el.webkitRequestFullscreen();
        }
        else if (el.mozRequestFullScreen) {
            pfx = 'moz';
            el.mozRequestFullScreen();
        }
        else if (el.msRequestFullscreen) {
            el.msRequestFullscreen();
        }
        return pfx;
    },
    /**
     * Disable fullscreen mode
     */
    disable: function () {
        var d = document;
        if (this.isEnabled()) {
            if (d.exitFullscreen)
                d.exitFullscreen();
            else if (d.webkitExitFullscreen)
                d.webkitExitFullscreen();
            else if (d.mozCancelFullScreen)
                d.mozCancelFullScreen();
            else if (d.msExitFullscreen)
                d.msExitFullscreen();
        }
    },
    /**
     * Triggered when the state of the fullscreen is changed. Inside detects if
     * it's enabled
     * @param  {strinf} pfx Browser prefix
     * @param  {Event} e
     */
    fsChanged: function (pfx) {
        if (!this.isEnabled()) {
            this.stopCommand({ sender: this.sender });
            document.removeEventListener("".concat(pfx || '', "fullscreenchange"), this.fsChanged);
        }
    },
    run: function (editor, sender, opts) {
        if (opts === void 0) { opts = {}; }
        this.sender = sender;
        var target = opts.target;
        var targetEl = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isElement)(target) ? target : document.querySelector(target);
        var pfx = this.enable(targetEl || editor.getContainer());
        this.fsChanged = this.fsChanged.bind(this, pfx);
        document.addEventListener(pfx + 'fullscreenchange', this.fsChanged);
        editor.trigger('change:canvasOffset');
    },
    stop: function (editor, sender) {
        if (sender && sender.set)
            sender.set('active', false);
        this.disable();
        if (editor)
            editor.trigger('change:canvasOffset');
    },
});


/***/ }),

/***/ 907:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(815);
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(968);
/* harmony import */ var _SelectComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(938);
/* harmony import */ var _SelectPosition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(477);





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _SelectPosition__WEBPACK_IMPORTED_MODULE_1__["default"], _SelectComponent__WEBPACK_IMPORTED_MODULE_2__["default"], {
    init: function (o) {
        _SelectComponent__WEBPACK_IMPORTED_MODULE_2__["default"].init.apply(this, arguments);
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.bindAll)(this, 'initSorter', 'rollback', 'onEndMove');
        this.opt = o;
        this.hoverClass = this.ppfx + 'highlighter-warning';
        this.badgeClass = this.ppfx + 'badge-warning';
        this.noSelClass = this.ppfx + 'no-select';
    },
    enable: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        _SelectComponent__WEBPACK_IMPORTED_MODULE_2__["default"].enable.apply(this, args);
        this.getBadgeEl().addClass(this.badgeClass);
        this.getHighlighterEl().addClass(this.hoverClass);
        var wp = this.$wrapper;
        wp.css('cursor', 'move');
        wp.on('mousedown', this.initSorter);
        // Avoid strange moving behavior
        wp.addClass(this.noSelClass);
    },
    /**
     * Overwrite for doing nothing
     * @private
     */
    toggleClipboard: function () { },
    /**
     * Delegate sorting
     * @param  {Event} e
     * @private
     * */
    initSorter: function (e) {
        var el = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])(e.target).data('model');
        var drag = el.get('draggable');
        if (!drag)
            return;
        // Avoid badge showing on move
        this.cacheEl = null;
        this.startSelectPosition(e.target, this.frameEl.contentDocument);
        this.sorter.draggable = drag;
        this.sorter.onEndMove = this.onEndMove.bind(this);
        this.stopSelectComponent();
        this.$wrapper.off('mousedown', this.initSorter);
        (0,_utils_dom__WEBPACK_IMPORTED_MODULE_4__.on)(this.getContentWindow(), 'keydown', this.rollback);
    },
    /**
     * Init sorter from model
     * @param  {Object} model
     * @private
     */
    initSorterFromModel: function (model) {
        var drag = model.get('draggable');
        if (!drag)
            return;
        // Avoid badge showing on move
        this.cacheEl = null;
        // @ts-ignore
        var el = model.view.el;
        this.startSelectPosition(el, this.frameEl.contentDocument);
        this.sorter.draggable = drag;
        this.sorter.onEndMove = this.onEndMoveFromModel.bind(this);
        /*
        this.sorter.setDragHelper(el);
        var dragHelper = this.sorter.dragHelper;
        dragHelper.className = this.ppfx + 'drag-helper';
        dragHelper.innerHTML = '';
        dragHelper.backgroundColor = 'white';
        */
        this.stopSelectComponent();
        (0,_utils_dom__WEBPACK_IMPORTED_MODULE_4__.on)(this.getContentWindow(), 'keydown', this.rollback);
    },
    /**
     * Init sorter from models
     * @param  {Object} model
     * @private
     */
    initSorterFromModels: function (models) {
        // TODO: if one only check for `draggable`
        // Avoid badge showing on move
        this.cacheEl = null;
        var lastModel = models[models.length - 1];
        var frameView = this.em.getCurrentFrame();
        var el = lastModel.getEl(frameView === null || frameView === void 0 ? void 0 : frameView.model);
        var doc = el.ownerDocument;
        this.startSelectPosition(el, doc, { onStart: this.onStart });
        this.sorter.draggable = lastModel.get('draggable');
        this.sorter.toMove = models;
        this.sorter.onMoveClb = this.onDrag;
        this.sorter.onEndMove = this.onEndMoveFromModel.bind(this);
        this.stopSelectComponent();
        (0,_utils_dom__WEBPACK_IMPORTED_MODULE_4__.on)(this.getContentWindow(), 'keydown', this.rollback);
    },
    onEndMoveFromModel: function () {
        (0,_utils_dom__WEBPACK_IMPORTED_MODULE_4__/* .off */ .S1)(this.getContentWindow(), 'keydown', this.rollback);
    },
    /**
     * Callback after sorting
     * @private
     */
    onEndMove: function () {
        this.enable();
        (0,_utils_dom__WEBPACK_IMPORTED_MODULE_4__/* .off */ .S1)(this.getContentWindow(), 'keydown', this.rollback);
    },
    /**
     * Say what to do after the component was selected (selectComponent)
     * @param {Event} e
     * @param {Object} Selected element
     * @private
     * */
    onSelect: function (e, el) { },
    /**
     * Used to bring the previous situation before start moving the component
     * @param {Event} e
     * @param {Boolean} Indicates if rollback in anycase
     * @private
     * */
    rollback: function (e, force) {
        var key = e.which || e.keyCode;
        if (key == 27 || force) {
            this.sorter.moved = false;
            this.sorter.endMove();
        }
        return;
    },
    /**
     * Returns badge element
     * @return {HTMLElement}
     * @private
     */
    getBadgeEl: function () {
        if (!this.$badge)
            this.$badge = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])(this.getBadge());
        return this.$badge;
    },
    /**
     * Returns highlighter element
     * @return {HTMLElement}
     * @private
     */
    getHighlighterEl: function () {
        if (!this.$hl)
            this.$hl = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])(this.canvas.getHighlighter());
        return this.$hl;
    },
    stop: function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // @ts-ignore
        _SelectComponent__WEBPACK_IMPORTED_MODULE_2__["default"].stop.apply(this, args);
        this.getBadgeEl().removeClass(this.badgeClass);
        this.getHighlighterEl().removeClass(this.hoverClass);
        var wp = this.$wrapper;
        wp.css('cursor', '').unbind().removeClass(this.noSelClass);
    },
}));


/***/ }),

/***/ 963:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    open: function (content) {
        var _this = this;
        var _a = this, editor = _a.editor, title = _a.title, config = _a.config, am = _a.am;
        var custom = config.custom;
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(custom.open)) {
            return custom.open(am.__customData());
        }
        var Modal = editor.Modal;
        Modal.open({ title: title, content: content }).onceClose(function () { return editor.stopCommand(_this.id); });
    },
    close: function () {
        var custom = this.config.custom;
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(custom.close)) {
            return custom.close(this.am.__customData());
        }
        var Modal = this.editor.Modal;
        Modal && Modal.close();
    },
    run: function (editor, sender, opts) {
        if (opts === void 0) { opts = {}; }
        var am = editor.AssetManager;
        var config = am.getConfig();
        var _a = opts.types, types = _a === void 0 ? [] : _a, accept = opts.accept, select = opts.select;
        this.title = opts.modalTitle || editor.t('assetManager.modalTitle') || '';
        this.editor = editor;
        this.config = config;
        this.am = am;
        am.setTarget(opts.target);
        am.onClick(opts.onClick);
        am.onDblClick(opts.onDblClick);
        am.onSelect(opts.onSelect);
        am.__behaviour({
            select: select,
            types: types,
            options: opts,
        });
        if (config.custom) {
            this.rendered = this.rendered || (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__/* .createEl */ .ut)('div');
            this.rendered.className = "".concat(config.stylePrefix, "custom-wrp");
            am.__behaviour({ container: this.rendered });
            am.__trgCustom();
        }
        else {
            if (!this.rendered || types) {
                var assets = am.getAll().filter(function (i) { return i; });
                if (types && types.length) {
                    assets = assets.filter(function (a) { return types.indexOf(a.get('type')) !== -1; });
                }
                am.render(assets);
                this.rendered = am.getContainer();
            }
            if (accept) {
                var uploadEl = this.rendered.querySelector("input#".concat(config.stylePrefix, "uploadFile"));
                uploadEl && uploadEl.setAttribute('accept', accept);
            }
        }
        this.open(this.rendered);
        return this;
    },
    stop: function (editor) {
        this.editor = editor;
        this.close(this.rendered);
    },
});


/***/ }),

/***/ 268:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    open: function () {
        var _a = this, container = _a.container, editor = _a.editor, bm = _a.bm, config = _a.config;
        var custom = config.custom, appendTo = config.appendTo;
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(custom.open)) {
            return custom.open(bm.__customData());
        }
        if (this.firstRender && !appendTo) {
            var id = 'views-container';
            var pn = editor.Panels;
            var panels = pn.getPanel(id) || pn.addPanel({ id: id });
            panels.set('appendContent', container).trigger('change:appendContent');
            if (!custom)
                container.appendChild(bm.render());
        }
        if (container)
            container.style.display = 'block';
    },
    close: function () {
        var _a = this, container = _a.container, config = _a.config;
        var custom = config.custom;
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(custom.close)) {
            return custom.close(this.bm.__customData());
        }
        if (container)
            container.style.display = 'none';
    },
    run: function (editor) {
        var bm = editor.Blocks;
        this.config = bm.getConfig();
        this.firstRender = !this.container;
        this.container = this.container || (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__/* .createEl */ .ut)('div');
        this.editor = editor;
        this.bm = bm;
        var container = this.container;
        bm.__behaviour({
            container: container,
        });
        if (this.config.custom) {
            bm.__trgCustom();
        }
        this.open();
    },
    stop: function () {
        this.close();
    },
});


/***/ }),

/***/ 556:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor) {
        var lm = editor.LayerManager;
        var pn = editor.Panels;
        var lmConfig = lm.getConfig();
        if (lmConfig.appendTo)
            return;
        if (!this.layers) {
            var id = 'views-container';
            var layers = document.createElement('div');
            // @ts-ignore
            var panels = pn.getPanel(id) || pn.addPanel({ id: id });
            if (lmConfig.custom) {
                lm.__trgCustom({ container: layers });
            }
            else {
                layers.appendChild(lm.render());
            }
            panels.set('appendContent', layers).trigger('change:appendContent');
            this.layers = layers;
        }
        this.layers.style.display = 'block';
    },
    stop: function () {
        var layers = this.layers;
        layers && (layers.style.display = 'none');
    },
});


/***/ }),

/***/ 120:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor) {
        var pm = editor.Pages;
        var pn = editor.Panels;
        var lmConfig = pm.getConfig();
        if (lmConfig.appendTo)
            return;
        if (!this.layers) {
            var id = 'views-container';
            var layers = document.createElement('div');
            var panels = pn.getPanel(id) || pn.addPanel({ id: id });
            layers.appendChild(pm.render());
            panels.set('appendContent', layers).trigger('change:appendContent');
            this.layers = layers;
        }
        this.layers.style.display = 'block';
    },
    stop: function () {
        var layers = this.layers;
        layers && (layers.style.display = 'none');
    },
});


/***/ }),

/***/ 462:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(815);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor, sender) {
        this.sender = sender;
        if (!this.$cnt) {
            var config = editor.getConfig();
            var Panels = editor.Panels, DeviceManager = editor.DeviceManager, SelectorManager = editor.SelectorManager, StyleManager = editor.StyleManager;
            var trgEvCnt = 'change:appendContent';
            var $cnt = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            var $cntInner = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            var $cntSlm = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            var $cntSm = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            this.$cnt = $cnt;
            this.$cntInner = $cntInner;
            $cntInner.append($cntSlm);
            $cntInner.append($cntSm);
            $cnt.append($cntInner);
            // Device Manager
            if (DeviceManager && config.showDevices) {
                var devicePanel = Panels.addPanel({ id: 'devices-c' });
                var dvEl = DeviceManager.render();
                devicePanel.set('appendContent', dvEl).trigger(trgEvCnt);
            }
            // Selector Manager container
            var slmConfig = SelectorManager.getConfig();
            if (slmConfig.custom) {
                SelectorManager.__trgCustom({ container: $cntSlm.get(0) });
            }
            else if (!slmConfig.appendTo) {
                $cntSlm.append(SelectorManager.render([]));
            }
            // Style Manager
            this.sm = StyleManager;
            var smConfig = StyleManager.getConfig();
            var pfx = smConfig.stylePrefix;
            this.$header = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])("<div class=\"".concat(pfx, "header\">").concat(editor.t('styleManager.empty'), "</div>"));
            $cnt.append(this.$header);
            if (smConfig.custom) {
                StyleManager.__trgCustom({ container: $cntSm.get(0) });
            }
            else if (!smConfig.appendTo) {
                $cntSm.append(StyleManager.render());
            }
            // Create panel if not exists
            var pnCnt = 'views-container';
            var pnl = Panels.getPanel(pnCnt) || Panels.addPanel({ id: pnCnt });
            // Add all containers to the panel
            pnl.set('appendContent', $cnt).trigger(trgEvCnt);
            // Toggle Style Manager on target selection
            var em = editor.getModel();
            this.listenTo(em, StyleManager.events.target, this.toggleSm);
        }
        this.toggleSm();
    },
    /**
     * Toggle Style Manager visibility
     * @private
     */
    toggleSm: function () {
        var _a = this, sender = _a.sender, sm = _a.sm, $cntInner = _a.$cntInner, $header = _a.$header;
        if ((sender && sender.get && !sender.get('active')) || !sm)
            return;
        if (sm.getSelected()) {
            $cntInner === null || $cntInner === void 0 ? void 0 : $cntInner.show();
            $header === null || $header === void 0 ? void 0 : $header.hide();
        }
        else {
            $cntInner === null || $cntInner === void 0 ? void 0 : $cntInner.hide();
            $header === null || $header === void 0 ? void 0 : $header.show();
        }
    },
    stop: function () {
        var _a, _b;
        (_a = this.$cntInner) === null || _a === void 0 ? void 0 : _a.hide();
        (_b = this.$header) === null || _b === void 0 ? void 0 : _b.hide();
    },
});


/***/ }),

/***/ 521:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(815);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor, sender) {
        this.sender = sender;
        var em = editor.getModel();
        var config = editor.Config;
        var pfx = config.stylePrefix;
        var tm = editor.TraitManager;
        var confTm = tm.getConfig();
        var panelC;
        if (confTm.appendTo)
            return;
        if (!this.$cn) {
            this.$cn = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            this.$cn2 = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div></div>');
            this.$cn.append(this.$cn2);
            this.$header = (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])('<div>').append("<div class=\"".concat(confTm.stylePrefix, "header\">").concat(em.t('traitManager.empty'), "</div>"));
            this.$cn.append(this.$header);
            if (confTm.custom) {
                tm.__trgCustom({ container: this.$cn2.get(0) });
            }
            else {
                this.$cn2.append("<div class=\"".concat(pfx, "traits-label\">").concat(em.t('traitManager.label'), "</div>"));
                this.$cn2.append(tm.render());
            }
            var panels = editor.Panels;
            if (!panels.getPanel('views-container')) {
                // @ts-ignore
                panelC = panels.addPanel({ id: 'views-container' });
            }
            else {
                panelC = panels.getPanel('views-container');
            }
            panelC === null || panelC === void 0 ? void 0 : panelC.set('appendContent', this.$cn.get(0)).trigger('change:appendContent');
            this.target = editor.getModel();
            this.listenTo(this.target, 'component:toggled', this.toggleTm);
        }
        this.toggleTm();
    },
    /**
     * Toggle Trait Manager visibility
     * @private
     */
    toggleTm: function () {
        var sender = this.sender;
        if (sender && sender.get && !sender.get('active'))
            return;
        if (this.target.getSelectedAll().length === 1) {
            this.$cn2.show();
            this.$header.hide();
        }
        else {
            this.$cn2.hide();
            this.$header.show();
        }
    },
    stop: function () {
        this.$cn2 && this.$cn2.hide();
        this.$header && this.$header.hide();
    },
});


/***/ }),

/***/ 133:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (ed, s, opts) {
        if (opts === void 0) { opts = {}; }
        var em = ed.getModel();
        var clp = em.get('clipboard');
        var lastSelected = ed.getSelected();
        if ((clp === null || clp === void 0 ? void 0 : clp.length) && lastSelected) {
            ed.getSelectedAll().forEach(function (sel) {
                var _a, _b, _c;
                var selected = ((_b = (_a = sel.delegate) === null || _a === void 0 ? void 0 : _a.copy) === null || _b === void 0 ? void 0 : _b.call(_a, sel)) || sel;
                var collection = selected.collection;
                var added;
                if (collection) {
                    var at = selected.index() + 1;
                    var addOpts = { at: at, action: opts.action || 'paste-component' };
                    if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.contains)(clp, selected) && selected.get('copyable')) {
                        added = collection.add(selected.clone(), addOpts);
                    }
                    else {
                        added = doAdd(ed, clp, selected.parent(), addOpts);
                    }
                }
                else {
                    // Page body is selected
                    // Paste at the end of the body
                    var pageBody = (_c = em.Pages.getSelected()) === null || _c === void 0 ? void 0 : _c.getMainComponent();
                    var addOpts = { at: (pageBody === null || pageBody === void 0 ? void 0 : pageBody.components().length) || 0, action: opts.action || 'paste-component' };
                    added = doAdd(ed, clp, pageBody, addOpts);
                }
                added = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isArray)(added) ? added : [added];
                added.forEach(function (add) { return ed.trigger('component:paste', add); });
            });
            lastSelected.emitUpdate();
        }
    },
});
function doAdd(ed, clp, parent, addOpts) {
    var copyable = clp.filter(function (cop) { return cop.get('copyable'); });
    var pasteable = copyable.filter(function (cop) { return ed.Components.canMove(parent, cop).result; });
    return parent.components().add(pasteable.map(function (cop) { return cop.clone(); }), addOpts);
}


/***/ }),

/***/ 931:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

var cmdOutline = 'core:component-outline';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    getPanels: function (editor) {
        if (!this.panels) {
            this.panels = editor.Panels.getPanels();
        }
        return this.panels;
    },
    preventDrag: function (opts) {
        opts.abort = 1;
    },
    tglEffects: function (on) {
        var em = this.em;
        var mthEv = on ? 'on' : 'off';
        if (em) {
            var canvas = em.Canvas;
            var body = canvas.getBody();
            var tlb = canvas.getToolbarEl();
            tlb && (tlb.style.display = on ? 'none' : '');
            var elP = body.querySelectorAll(".".concat(this.ppfx, "no-pointer"));
            (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(elP, function (item) { return (item.style.pointerEvents = on ? 'all' : ''); });
            em[mthEv]('run:tlb-move:before', this.preventDrag);
        }
    },
    run: function (editor, sender) {
        var _this = this;
        this.sender = sender;
        this.selected = __spreadArray([], editor.getSelectedAll(), true);
        editor.select();
        if (!this.shouldRunSwVisibility) {
            this.shouldRunSwVisibility = editor.Commands.isActive(cmdOutline);
        }
        this.shouldRunSwVisibility && editor.stopCommand(cmdOutline);
        editor.getModel().stopDefault();
        var panels = this.getPanels(editor);
        var canvas = editor.Canvas.getElement();
        var editorEl = editor.getEl();
        var pfx = editor.Config.stylePrefix;
        if (!this.helper) {
            var helper = document.createElement('span');
            helper.className = "".concat(pfx, "off-prv fa fa-eye-slash");
            editorEl.appendChild(helper);
            helper.onclick = function () { return _this.stopCommand(); };
            this.helper = helper;
        }
        this.helper.style.display = 'inline-block';
        panels.forEach(function (panel) { return panel.set('visible', false); });
        var canvasS = canvas.style;
        canvasS.width = '100%';
        canvasS.height = '100%';
        canvasS.top = '0';
        canvasS.left = '0';
        canvasS.padding = '0';
        canvasS.margin = '0';
        editor.refresh();
        this.tglEffects(1);
    },
    stop: function (editor) {
        var _a = this, _b = _a.sender, sender = _b === void 0 ? {} : _b, selected = _a.selected;
        sender.set && sender.set('active', 0);
        var panels = this.getPanels(editor);
        if (this.shouldRunSwVisibility) {
            editor.runCommand(cmdOutline);
            this.shouldRunSwVisibility = false;
        }
        editor.getModel().runDefault();
        panels.forEach(function (panel) { return panel.set('visible', true); });
        var canvas = editor.Canvas.getElement();
        canvas.setAttribute('style', '');
        selected && editor.select(selected);
        delete this.selected;
        if (this.helper) {
            this.helper.style.display = 'none';
        }
        editor.refresh();
        this.tglEffects();
    },
});


/***/ }),

/***/ 676:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    run: function (editor, sender, opts) {
        var opt = opts || {};
        var canvas = editor.Canvas;
        var canvasView = canvas.getCanvasView();
        var options = __assign({ appendTo: canvas.getResizerEl(), prefix: editor.getConfig().stylePrefix, posFetcher: canvasView.getElementPos.bind(canvasView), mousePosFetcher: canvas.getMouseRelativePos.bind(canvas) }, (opt.options || {}));
        var canvasResizer = this.canvasResizer;
        // Create the resizer for the canvas if not yet created
        if (!canvasResizer || opt.forceNew) {
            this.canvasResizer = new editor.Utils.Resizer(options);
            canvasResizer = this.canvasResizer;
        }
        canvasResizer.setOptions(options, true);
        canvasResizer.blur();
        canvasResizer.focus(opt.el);
        return canvasResizer;
    },
    stop: function () {
        var _a;
        (_a = this.canvasResizer) === null || _a === void 0 ? void 0 : _a.blur();
    },
});


/***/ }),

/***/ 938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ SelectComponent)
});

// EXTERNAL MODULE: ./node_modules/underscore/modules/index-all.js + 160 modules
var index_all = __webpack_require__(50);
// EXTERNAL MODULE: ./src/common/index.ts
var common = __webpack_require__(847);
;// CONCATENATED MODULE: ./src/dom_components/model/ToolbarButton.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ToolbarButton = /** @class */ (function (_super) {
    __extends(ToolbarButton, _super);
    function ToolbarButton() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolbarButton.prototype.defaults = function () {
        return {
            command: '',
            attributes: {},
        };
    };
    return ToolbarButton;
}(common/* Model */.Hn));
/* harmony default export */ const model_ToolbarButton = (ToolbarButton);

;// CONCATENATED MODULE: ./src/dom_components/model/Toolbar.ts
var Toolbar_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Toolbar = /** @class */ (function (_super) {
    Toolbar_extends(Toolbar, _super);
    function Toolbar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Toolbar;
}(common/* Collection */.FE));
/* harmony default export */ const model_Toolbar = (Toolbar);
Toolbar.prototype.model = model_ToolbarButton;

;// CONCATENATED MODULE: ./src/domain_abstract/view/DomainViews.ts
var DomainViews_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var DomainViews = /** @class */ (function (_super) {
    DomainViews_extends(DomainViews, _super);
    function DomainViews(opts, config, autoAdd) {
        if (opts === void 0) { opts = {}; }
        if (autoAdd === void 0) { autoAdd = false; }
        var _this = _super.call(this, opts) || this;
        // Defines the View per type
        _this.itemsView = '';
        _this.itemType = 'type';
        _this.reuseView = false;
        _this.config = config || opts.config || {};
        autoAdd && _this.listenTo(_this.collection, 'add', _this.addTo);
        _this.items = [];
        return _this;
    }
    /**
     * Add new model to the collection
     * @param {Model} model
     * @private
     * */
    DomainViews.prototype.addTo = function (model) {
        this.add(model);
    };
    DomainViews.prototype.itemViewNotFound = function (type) {
        var _a = this, config = _a.config, ns = _a.ns;
        var em = config.em;
        var warn = "".concat(ns ? "[".concat(ns, "]: ") : '', "'").concat(type, "' type not found");
        em && em.logWarning(warn);
    };
    /**
     * Render new model inside the view
     * @param {Model} model
     * @param {Object} fragment Fragment collection
     * @private
     * */
    DomainViews.prototype.add = function (model, fragment) {
        var _a = this, config = _a.config, reuseView = _a.reuseView, items = _a.items;
        var itemsView = (this.itemsView || {});
        var inputTypes = [
            'button',
            'checkbox',
            'color',
            'date',
            'datetime-local',
            'email',
            'file',
            'hidden',
            'image',
            'month',
            'number',
            'password',
            'radio',
            'range',
            'reset',
            'search',
            'submit',
            'tel',
            'text',
            'time',
            'url',
            'week',
        ];
        var frag = fragment || null;
        var itemView = this.itemView;
        var typeField = model.get(this.itemType);
        var view;
        if (itemsView[typeField]) {
            itemView = itemsView[typeField];
        }
        else if (typeField && !itemsView[typeField] && !(0,index_all.includes)(inputTypes, typeField)) {
            this.itemViewNotFound(typeField);
        }
        if (model.view && reuseView) {
            view = model.view;
        }
        else {
            view = new itemView({ model: model, config: config }, config);
        }
        items && items.push(view);
        var rendered = view.render().el;
        if (frag)
            frag.appendChild(rendered);
        else
            this.$el.append(rendered);
    };
    DomainViews.prototype.render = function () {
        var frag = document.createDocumentFragment();
        this.clearItems();
        this.$el.empty();
        if (this.collection.length)
            this.collection.each(function (model) {
                // @ts-ignore
                this.add(model, frag);
            }, this);
        this.$el.append(frag);
        this.onRender();
        return this;
    };
    DomainViews.prototype.onRender = function () { };
    DomainViews.prototype.onRemoveBefore = function (items, opts) { };
    DomainViews.prototype.onRemove = function (items, opts) { };
    DomainViews.prototype.remove = function (opts) {
        if (opts === void 0) { opts = {}; }
        var items = this.items;
        this.onRemoveBefore(items, opts);
        this.clearItems();
        _super.prototype.remove.call(this);
        this.onRemove(items, opts);
        return this;
    };
    DomainViews.prototype.clearItems = function () {
        var items = this.items || [];
        // TODO Traits do not update the target anymore
        // items.forEach(item => item.remove());
        // this.items = [];
    };
    return DomainViews;
}(common/* View */.G7));
/* harmony default export */ const view_DomainViews = (DomainViews);
// Default view
DomainViews.prototype.itemView = '';

;// CONCATENATED MODULE: ./src/dom_components/view/ToolbarButtonView.ts
var ToolbarButtonView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var ToolbarButtonView = /** @class */ (function (_super) {
    ToolbarButtonView_extends(ToolbarButtonView, _super);
    function ToolbarButtonView(props) {
        var _this = _super.call(this, props) || this;
        _this.em = props.config.em;
        return _this;
    }
    ToolbarButtonView.prototype.events = function () {
        return (this.model.get('events') || {
            mousedown: 'handleClick',
        });
    };
    // @ts-ignore
    ToolbarButtonView.prototype.attributes = function () {
        return this.model.get('attributes');
    };
    ToolbarButtonView.prototype.handleClick = function (event) {
        event.preventDefault();
        event.stopPropagation();
        /*
         * Since the toolbar lives outside the canvas frame, the event's
         * generated on it have clientX and clientY relative to the page.
         *
         * This causes issues during events like dragging, where they depend
         * on the clientX and clientY.
         *
         * This makes sure the offsets are calculated.
         *
         * More information on
         * https://github.com/GrapesJS/grapesjs/issues/2372
         * https://github.com/GrapesJS/grapesjs/issues/2207
         */
        var em = this.em;
        var _a = em.Canvas.getFrameEl().getBoundingClientRect(), left = _a.left, top = _a.top;
        var ev = __assign(__assign({}, event), { clientX: event.clientX - left, clientY: event.clientY - top });
        em.trigger('toolbar:run:before', { event: ev });
        this.execCommand(ev);
    };
    ToolbarButtonView.prototype.execCommand = function (event) {
        var _a = this, em = _a.em, model = _a.model;
        var opts = { event: event };
        var command = model.get('command');
        var editor = em.Editor;
        if ((0,index_all.isFunction)(command)) {
            command(editor, null, opts);
        }
        if ((0,index_all.isString)(command)) {
            editor.runCommand(command, opts);
        }
    };
    ToolbarButtonView.prototype.render = function () {
        var _a = this, em = _a.em, $el = _a.$el, model = _a.model;
        var id = model.get('id');
        var label = model.get('label');
        var pfx = em.getConfig().stylePrefix;
        $el.addClass("".concat(pfx, "toolbar-item"));
        id && $el.addClass("".concat(pfx, "toolbar-item__").concat(id));
        label && $el.append(label);
        return this;
    };
    return ToolbarButtonView;
}(common/* View */.G7));
/* harmony default export */ const view_ToolbarButtonView = (ToolbarButtonView);

;// CONCATENATED MODULE: ./src/dom_components/view/ToolbarView.ts
var ToolbarView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ToolbarView = /** @class */ (function (_super) {
    ToolbarView_extends(ToolbarView, _super);
    function ToolbarView(opts) {
        var _this = _super.call(this, opts) || this;
        var em = opts.em;
        _this.em = em;
        _this.config = { em: em };
        _this.listenTo(_this.collection, 'reset', _this.render);
        return _this;
    }
    ToolbarView.prototype.onRender = function () {
        var pfx = this.em.config.stylePrefix;
        this.el.className = "".concat(pfx, "toolbar-items");
    };
    return ToolbarView;
}(view_DomainViews));
/* harmony default export */ const view_ToolbarView = (ToolbarView);
// @ts-ignore
ToolbarView.prototype.itemView = view_ToolbarButtonView;

// EXTERNAL MODULE: ./src/utils/dom.ts
var dom = __webpack_require__(968);
// EXTERNAL MODULE: ./src/utils/mixins.ts
var mixins = __webpack_require__(283);
// EXTERNAL MODULE: ./src/canvas/model/CanvasSpot.ts
var CanvasSpot = __webpack_require__(201);
;// CONCATENATED MODULE: ./src/commands/view/SelectComponent.ts
var SelectComponent_assign = (undefined && undefined.__assign) || function () {
    SelectComponent_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return SelectComponent_assign.apply(this, arguments);
};






var showOffsets;
/**
 * This command is responsible for show selecting components and displaying
 * all the necessary tools around (component toolbar, badge, highlight box, etc.)
 *
 * The command manages different boxes to display tools and when something in
 * the canvas is updated, the command triggers the appropriate method to update
 * their position (across multiple frames/components):
 * - Global Tools (updateToolsGlobal/updateGlobalPos)
 * This box contains tools intended to be displayed only on ONE component per time,
 * like Component Toolbar (updated by updateToolbar/updateToolbarPos), this means
 * you won't be able to see more than one Component Toolbar (even with multiple
 * frames or multiple selected components)
 * - Local Tools (updateToolsLocal/updateLocalPos)
 * Each frame in the canvas has its own local box, so we're able to see more than
 * one active container at the same time. When you put a mouse over an element
 * you can see stuff like the highlight box, badge, margins/paddings offsets, etc.
 * so those elements are inside the Local Tools box
 *
 *
 */
/* harmony default export */ const SelectComponent = ({
    init: function () {
        this.onSelect = (0,index_all.debounce)(this.onSelect, 0);
        (0,index_all.bindAll)(this, 'onHover', 'onOut', 'onClick', 'onFrameScroll', 'onFrameResize', 'onFrameUpdated', 'onContainerChange');
    },
    enable: function () {
        this.frameOff = this.canvasOff = this.adjScroll = null;
        this.startSelectComponent();
        showOffsets = true;
    },
    /**
     * Start select component event
     * @private
     * */
    startSelectComponent: function () {
        this.toggleSelectComponent(1);
        this.em.getSelected() && this.onSelect();
    },
    /**
     * Stop select component event
     * @private
     * */
    stopSelectComponent: function () {
        this.toggleSelectComponent();
    },
    /**
     * Toggle select component event
     * @private
     * */
    toggleSelectComponent: function (enable) {
        var _this = this;
        var em = this.em;
        var listenToEl = em.getConfig().listenToEl;
        var parentNode = em.getContainer().parentNode;
        var method = enable ? 'on' : 'off';
        var methods = { on: dom.on, off: dom/* off */.S1 };
        !listenToEl.length && parentNode && listenToEl.push(parentNode);
        var trigger = function (win, body) {
            methods[method](body, 'mouseover', _this.onHover);
            methods[method](body, 'mouseleave', _this.onOut);
            methods[method](body, 'click', _this.onClick);
            methods[method](win, 'scroll', _this.onFrameScroll, true);
            methods[method](win, 'resize', _this.onFrameResize);
        };
        methods[method](window, 'resize', this.onFrameUpdated);
        methods[method](listenToEl, 'scroll', this.onContainerChange);
        em[method]('component:toggled component:update undo redo', this.onSelect, this);
        em[method]('change:componentHovered', this.onHovered, this);
        em[method]('component:resize styleable:change component:input', this.updateGlobalPos, this);
        em[method]('component:update:toolbar', this._upToolbar, this);
        em[method]('change:canvasOffset', this.updateAttached, this);
        em[method]('frame:updated', this.onFrameUpdated, this);
        em[method]('canvas:updateTools', this.onFrameUpdated, this);
        em.Canvas.getFrames().forEach(function (frame) {
            var view = frame.view;
            var win = view === null || view === void 0 ? void 0 : view.getWindow();
            win && trigger(win, view === null || view === void 0 ? void 0 : view.getBody());
        });
    },
    /**
     * Hover command
     * @param {Object}  e
     * @private
     */
    onHover: function (ev) {
        ev.stopPropagation();
        var em = this.em;
        var el = ev.target;
        var view = (0,mixins.getComponentView)(el);
        var frameView = view === null || view === void 0 ? void 0 : view.frameView;
        var model = view === null || view === void 0 ? void 0 : view.model;
        // Get first valid model
        if (!model) {
            var parentEl = el.parentNode;
            while (!model && parentEl && !(0,dom/* isDoc */.Mx)(parentEl)) {
                model = (0,mixins.getComponentModel)(parentEl);
                parentEl = parentEl.parentNode;
            }
        }
        this.currentDoc = el.ownerDocument;
        em.setHovered(model, { useValid: true });
        frameView && em.setCurrentFrame(frameView);
    },
    onFrameUpdated: function () {
        this.updateLocalPos();
        this.updateGlobalPos();
    },
    onHovered: function (em, component) {
        var _this = this;
        var _a;
        var result = {};
        if (component) {
            (_a = component.views) === null || _a === void 0 ? void 0 : _a.forEach(function (view) {
                var el = view.el;
                var pos = _this.getElementPos(el);
                result = { el: el, pos: pos, component: component, view: (0,mixins.getViewEl)(el) };
                if (el.ownerDocument === _this.currentDoc) {
                    _this.elHovered = result;
                }
                _this.updateToolsLocal(result);
            });
        }
        else {
            this.currentDoc = null;
            this.elHovered = 0;
            this.updateToolsLocal();
            this.canvas.getFrames().forEach(function (frame) {
                var view = frame.view;
                var el = view && view.getToolsEl();
                el && _this.toggleToolsEl(0, 0, { el: el });
            });
        }
    },
    /**
     * Say what to do after the component was selected
     * @param {Object}  e
     * @param {Object}  el
     * @private
     * */
    onSelect: function () {
        var em = this.em;
        var component = em.getSelected();
        var currentFrame = em.getCurrentFrame();
        var view = component && component.getView(currentFrame === null || currentFrame === void 0 ? void 0 : currentFrame.model);
        var el = view && view.el;
        var result = {};
        if (el && (0,dom/* isVisible */.pn)(el)) {
            var pos = this.getElementPos(el);
            result = { el: el, pos: pos, component: component, view: (0,mixins.getViewEl)(el) };
        }
        this.elSelected = result;
        this.updateToolsGlobal();
        // This will hide some elements from the select component
        this.updateLocalPos(result);
        this.initResize(component);
    },
    updateGlobalPos: function () {
        var sel = this.getElSelected();
        if (!sel.el)
            return;
        sel.pos = this.getElementPos(sel.el);
        this.updateToolsGlobal();
    },
    updateLocalPos: function (data) {
        var sel = this.getElHovered();
        if (!sel.el)
            return;
        sel.pos = this.getElementPos(sel.el);
        this.updateToolsLocal(data);
    },
    getElHovered: function () {
        return this.elHovered || {};
    },
    getElSelected: function () {
        return this.elSelected || {};
    },
    onOut: function () {
        this.em.setHovered();
    },
    toggleToolsEl: function (on, view, opts) {
        if (opts === void 0) { opts = {}; }
        var el = opts.el || this.canvas.getToolsEl(view);
        el && (el.style.display = on ? '' : 'none');
        return el || {};
    },
    /**
     * Show element offset viewer
     * @param {HTMLElement}  el
     * @param {Object} pos
     */
    showElementOffset: function (el, pos, opts) {
        if (opts === void 0) { opts = {}; }
        if (!showOffsets)
            return;
        this.editor.runCommand('show-offset', {
            el: el,
            elPos: pos,
            view: opts.view,
            force: 1,
            top: 0,
            left: 0,
        });
    },
    /**
     * Hide element offset viewer
     * @param {HTMLElement}  el
     * @param {Object} pos
     */
    hideElementOffset: function (view) {
        this.editor.stopCommand('show-offset', {
            view: view,
        });
    },
    /**
     * Show fixed element offset viewer
     * @param {HTMLElement}  el
     * @param {Object} pos
     */
    showFixedElementOffset: function (el, pos) {
        this.editor.runCommand('show-offset', {
            el: el,
            elPos: pos,
            state: 'Fixed',
        });
    },
    /**
     * Hide fixed element offset viewer
     * @param {HTMLElement}  el
     * @param {Object} pos
     */
    hideFixedElementOffset: function () {
        if (this.editor)
            this.editor.stopCommand('show-offset', { state: 'Fixed' });
    },
    /**
     * Hide Highlighter element
     */
    hideHighlighter: function (view) {
        this.canvas.getHighlighter(view).style.opacity = 0;
    },
    /**
     * On element click
     * @param {Event}  e
     * @private
     */
    onClick: function (ev) {
        ev.stopPropagation();
        ev.preventDefault();
        var em = this.em;
        if (em.get('_cmpDrag'))
            return em.set('_cmpDrag');
        var el = ev.target;
        var model = (0,mixins.getComponentModel)(el);
        if (!model) {
            var parentEl = el.parentNode;
            while (!model && parentEl && !(0,dom/* isDoc */.Mx)(parentEl)) {
                model = (0,mixins.getComponentModel)(parentEl);
                parentEl = parentEl.parentNode;
            }
        }
        if (model) {
            // Avoid selection of inner text components during editing
            if (em.isEditing() && !model.get('textable') && model.isChildOf('text')) {
                return;
            }
            this.select(model, ev);
        }
    },
    /**
     * Select component
     * @param  {Component} model
     * @param  {Event} event
     */
    select: function (model, event) {
        if (event === void 0) { event = {}; }
        if (!model)
            return;
        this.editor.select(model, { event: event, useValid: true });
        this.initResize(model);
    },
    /**
     * Update badge for the component
     * @param {Object} Component
     * @param {Object} pos Position object
     * @private
     * */
    updateBadge: function (el, pos, opts) {
        if (opts === void 0) { opts = {}; }
        var canvas = this.canvas;
        var model = (0,mixins.getComponentModel)(el);
        var badge = this.getBadge(opts);
        var bStyle = badge.style;
        if (!model || !model.get('badgable')) {
            bStyle.display = 'none';
            return;
        }
        if (!opts.posOnly) {
            var config = this.canvas.getConfig();
            var icon = model.getIcon();
            var ppfx = config.pStylePrefix || '';
            var clsBadge = "".concat(ppfx, "badge");
            var customeLabel = config.customBadgeLabel;
            var badgeLabel = "".concat(icon ? "<div class=\"".concat(clsBadge, "__icon\">").concat(icon, "</div>") : '', "\n        <div class=\"").concat(clsBadge, "__name\">").concat(model.getName(), "</div>");
            badge.innerHTML = customeLabel ? customeLabel(model) : badgeLabel;
        }
        var un = 'px';
        bStyle.display = 'block';
        var targetToElem = canvas.getTargetToElementFixed(el, badge, {
            pos: pos,
        });
        var top = targetToElem.top; //opts.topOff - badgeH < 0 ? -opts.topOff : posTop;
        var left = opts.leftOff < 0 ? -opts.leftOff : 0;
        bStyle.top = top + un;
        bStyle.left = left + un;
    },
    /**
     * Update highlighter element
     * @param {HTMLElement} el
     * @param {Object} pos Position object
     * @private
     */
    showHighlighter: function (view) {
        this.canvas.getHighlighter(view).style.opacity = '';
    },
    /**
     * Init resizer on the element if possible
     * @param  {HTMLElement|Component} elem
     * @private
     */
    initResize: function (elem) {
        var _a = this, em = _a.em, canvas = _a.canvas;
        var editor = em.Editor;
        var model = !(0,index_all.isElement)(elem) && (0,dom/* isTaggableNode */.o5)(elem) ? elem : em.getSelected();
        var resizable = model === null || model === void 0 ? void 0 : model.get('resizable');
        var spotTypeResize = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Resize;
        var hasCustomResize = canvas.hasCustomSpot(spotTypeResize);
        canvas.removeSpots({ type: spotTypeResize });
        if (model && resizable) {
            canvas.addSpot({ type: spotTypeResize, component: model });
            var el = (0,index_all.isElement)(elem) ? elem : model.getEl();
            if (hasCustomResize || !el)
                return;
            var modelToStyle_1;
            var config = em.config;
            var pfx = config.stylePrefix || '';
            var resizeClass_1 = "".concat(pfx, "resizing");
            var toggleBodyClass_1 = function (method, e, opts) {
                var docs = opts.docs;
                docs &&
                    docs.forEach(function (doc) {
                        var body = doc.body;
                        var cls = body.className || '';
                        body.className = (method == 'add' ? "".concat(cls, " ").concat(resizeClass_1) : cls.replace(resizeClass_1, '')).trim();
                    });
            };
            var options = SelectComponent_assign({ 
                // Here the resizer is updated with the current element height and width
                onStart: function (e, opts) {
                    if (opts === void 0) { opts = {}; }
                    var el = opts.el, config = opts.config, resizer = opts.resizer;
                    var keyHeight = config.keyHeight, keyWidth = config.keyWidth, currentUnit = config.currentUnit, keepAutoHeight = config.keepAutoHeight, keepAutoWidth = config.keepAutoWidth;
                    toggleBodyClass_1('add', e, opts);
                    modelToStyle_1 = em.Styles.getModelToStyle(model);
                    canvas.toggleFramesEvents(false);
                    var computedStyle = getComputedStyle(el);
                    var modelStyle = modelToStyle_1.getStyle();
                    var currentWidth = modelStyle[keyWidth];
                    config.autoWidth = keepAutoWidth && currentWidth === 'auto';
                    if (isNaN(parseFloat(currentWidth))) {
                        currentWidth = computedStyle[keyWidth];
                    }
                    var currentHeight = modelStyle[keyHeight];
                    config.autoHeight = keepAutoHeight && currentHeight === 'auto';
                    if (isNaN(parseFloat(currentHeight))) {
                        currentHeight = computedStyle[keyHeight];
                    }
                    resizer.startDim.w = parseFloat(currentWidth);
                    resizer.startDim.h = parseFloat(currentHeight);
                    showOffsets = false;
                    if (currentUnit) {
                        config.unitHeight = (0,mixins.getUnitFromValue)(currentHeight);
                        config.unitWidth = (0,mixins.getUnitFromValue)(currentWidth);
                    }
                }, 
                // Update all positioned elements (eg. component toolbar)
                onMove: function () {
                    editor.trigger('component:resize');
                }, onEnd: function (e, opts) {
                    toggleBodyClass_1('remove', e, opts);
                    editor.trigger('component:resize');
                    canvas.toggleFramesEvents(true);
                    showOffsets = true;
                }, updateTarget: function (el, rect, options) {
                    if (options === void 0) { options = {}; }
                    if (!modelToStyle_1) {
                        return;
                    }
                    var store = options.store, selectedHandler = options.selectedHandler, config = options.config;
                    var keyHeight = config.keyHeight, keyWidth = config.keyWidth, autoHeight = config.autoHeight, autoWidth = config.autoWidth, unitWidth = config.unitWidth, unitHeight = config.unitHeight;
                    var onlyHeight = ['tc', 'bc'].indexOf(selectedHandler) >= 0;
                    var onlyWidth = ['cl', 'cr'].indexOf(selectedHandler) >= 0;
                    var style = {};
                    if (!onlyHeight) {
                        var bodyw = canvas.getBody().offsetWidth;
                        var width = rect.w < bodyw ? rect.w : bodyw;
                        style[keyWidth] = autoWidth ? 'auto' : "".concat(width).concat(unitWidth);
                    }
                    if (!onlyWidth) {
                        style[keyHeight] = autoHeight ? 'auto' : "".concat(rect.h).concat(unitHeight);
                    }
                    if (em.getDragMode(model)) {
                        style.top = "".concat(rect.t).concat(unitHeight);
                        style.left = "".concat(rect.l).concat(unitWidth);
                    }
                    var finalStyle = SelectComponent_assign(SelectComponent_assign({}, style), { 
                        // value for the partial update
                        __p: !store });
                    modelToStyle_1.addStyle(finalStyle, { avoidStore: !store });
                    em.Styles.__emitCmpStyleUpdate(finalStyle, { components: em.getSelected() });
                } }, ((0,mixins.isObject)(resizable) ? resizable : {}));
            this.resizer = editor.runCommand('resize', { el: el, options: options, force: 1 });
        }
        else {
            if (hasCustomResize)
                return;
            editor.stopCommand('resize');
            this.resizer = null;
        }
    },
    /**
     * Update toolbar if the component has one
     * @param {Object} mod
     */
    updateToolbar: function (mod) {
        var canvas = this.canvas;
        var em = this.config.em;
        var model = mod === em ? em.getSelected() : mod;
        var toolbarEl = canvas.getToolbarEl();
        var toolbarStyle = toolbarEl.style;
        var toolbar = model.get('toolbar');
        var showToolbar = em.config.showToolbar;
        var noCustomSpotSelect = !canvas.hasCustomSpot(CanvasSpot/* CanvasSpotBuiltInTypes */.q.Select);
        if (model && showToolbar && toolbar && toolbar.length && noCustomSpotSelect) {
            toolbarStyle.display = '';
            if (!this.toolbar) {
                toolbarEl.innerHTML = '';
                this.toolbar = new model_Toolbar(toolbar);
                // @ts-ignore
                var toolbarView = new view_ToolbarView({ collection: this.toolbar, em: em });
                toolbarEl.appendChild(toolbarView.render().el);
            }
            this.toolbar.reset(toolbar);
            toolbarStyle.top = '-100px';
            toolbarStyle.left = '0';
        }
        else {
            toolbarStyle.display = 'none';
        }
    },
    /**
     * Update toolbar positions
     * @param {HTMLElement} el
     * @param {Object} pos
     */
    updateToolbarPos: function (pos) {
        var unit = 'px';
        var style = this.canvas.getToolbarEl().style;
        style.top = "".concat(pos.top).concat(unit);
        style.left = "".concat(pos.left).concat(unit);
        style.opacity = '';
    },
    /**
     * Return canvas dimensions and positions
     * @return {Object}
     */
    getCanvasPosition: function () {
        return this.canvas.getCanvasView().getPosition();
    },
    /**
     * Returns badge element
     * @return {HTMLElement}
     * @private
     */
    getBadge: function (opts) {
        if (opts === void 0) { opts = {}; }
        return this.canvas.getBadgeEl(opts.view);
    },
    /**
     * On frame scroll callback
     * @private
     */
    onFrameScroll: function () {
        this.updateTools();
        this.canvas.refreshSpots();
    },
    onFrameResize: function () {
        this.canvas.refreshSpots();
    },
    updateTools: function () {
        this.updateLocalPos();
        this.updateGlobalPos();
    },
    isCompSelected: function (comp) {
        return comp && comp.get('status') === 'selected';
    },
    /**
     * Update tools visible on hover
     * @param {HTMLElement} el
     * @param {Object} pos
     */
    updateToolsLocal: function (data) {
        var config = this.em.getConfig();
        var _a = data || this.getElHovered(), el = _a.el, pos = _a.pos, view = _a.view, component = _a.component;
        if (!el) {
            this.lastHovered = 0;
            return;
        }
        var isHoverEn = component.get('hoverable');
        var isNewEl = this.lastHovered !== el;
        var badgeOpts = isNewEl ? {} : { posOnly: 1 };
        var customHoverSpot = this.canvas.hasCustomSpot(CanvasSpot/* CanvasSpotBuiltInTypes */.q.Hover);
        if (isNewEl && isHoverEn) {
            this.lastHovered = el;
            customHoverSpot ? this.hideHighlighter(view) : this.showHighlighter(view);
            this.showElementOffset(el, pos, { view: view });
        }
        if (this.isCompSelected(component)) {
            this.hideHighlighter(view);
            !config.showOffsetsSelected && this.hideElementOffset(view);
        }
        var unit = 'px';
        var toolsEl = this.toggleToolsEl(1, view);
        var style = toolsEl.style;
        var frameOff = this.canvas.canvasRectOffset(el, pos);
        var topOff = frameOff.top;
        var leftOff = frameOff.left;
        !customHoverSpot &&
            this.updateBadge(el, pos, SelectComponent_assign(SelectComponent_assign({}, badgeOpts), { view: view, topOff: topOff, leftOff: leftOff }));
        style.top = topOff + unit;
        style.left = leftOff + unit;
        style.width = pos.width + unit;
        style.height = pos.height + unit;
        this._trgToolUp('local', {
            component: component,
            el: toolsEl,
            top: topOff,
            left: leftOff,
            width: pos.width,
            height: pos.height,
        });
    },
    _upToolbar: (0,index_all.debounce)(function () {
        // @ts-ignore
        this.updateToolsGlobal({ force: 1 });
    }, 0),
    _trgToolUp: function (type, opts) {
        if (opts === void 0) { opts = {}; }
        this.em.trigger('canvas:tools:update', SelectComponent_assign({ type: type }, opts));
    },
    updateToolsGlobal: function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this.getElSelected(), el = _a.el, pos = _a.pos, component = _a.component;
        if (!el) {
            this.toggleToolsEl(); // Hides toolbar
            this.lastSelected = 0;
            return;
        }
        var canvas = this.canvas;
        var isNewEl = this.lastSelected !== el;
        if (isNewEl || opts.force) {
            this.lastSelected = el;
            this.updateToolbar(component);
        }
        var unit = 'px';
        var toolsEl = this.toggleToolsEl(1);
        var style = toolsEl.style;
        var targetToElem = canvas.getTargetToElementFixed(el, canvas.getToolbarEl(), { pos: pos });
        var topOff = targetToElem.canvasOffsetTop;
        var leftOff = targetToElem.canvasOffsetLeft;
        style.top = topOff + unit;
        style.left = leftOff + unit;
        style.width = pos.width + unit;
        style.height = pos.height + unit;
        this.updateToolbarPos({ top: targetToElem.top, left: targetToElem.left });
        this._trgToolUp('global', {
            component: component,
            el: toolsEl,
            top: topOff,
            left: leftOff,
            width: pos.width,
            height: pos.height,
        });
    },
    /**
     * Update attached elements, eg. component toolbar
     */
    updateAttached: (0,index_all.debounce)(function () {
        // @ts-ignore
        this.updateGlobalPos();
    }, 0),
    onContainerChange: (0,index_all.debounce)(function () {
        // @ts-ignore
        this.em.refreshCanvas();
    }, 150),
    /**
     * Returns element's data info
     * @param {HTMLElement} el
     * @return {Object}
     * @private
     */
    getElementPos: function (el) {
        return this.canvas.getCanvasView().getElementPos(el, { noScroll: true });
    },
    /**
     * Hide badge
     * @private
     * */
    hideBadge: function () {
        this.getBadge().style.display = 'none';
    },
    /**
     * Clean previous model from different states
     * @param {Component} model
     * @private
     */
    cleanPrevious: function (model) {
        model &&
            model.set({
                status: '',
                state: '',
            });
    },
    /**
     * Returns content window
     * @private
     */
    getContentWindow: function () {
        return this.canvas.getWindow();
    },
    run: function (editor) {
        if (!(0,mixins.hasWin)())
            return;
        // @ts-ignore
        this.editor = editor && editor.get('Editor');
        this.enable();
    },
    stop: function (ed, sender, opts) {
        if (opts === void 0) { opts = {}; }
        if (!(0,mixins.hasWin)())
            return;
        var _a = this, em = _a.em, editor = _a.editor;
        this.onHovered(); // force to hide toolbar
        this.stopSelectComponent();
        !opts.preserveSelected && em.setSelected();
        this.toggleToolsEl();
        editor && editor.stopCommand('resize');
    },
});


/***/ }),

/***/ 477:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(815);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    /**
     * Start select position event
     * @param {HTMLElement} trg
     * @private
     * */
    startSelectPosition: function (trg, doc, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        this.isPointed = false;
        var utils = this.em.Utils;
        var container = trg.ownerDocument.body;
        if (utils && !this.sorter)
            this.sorter = new utils.Sorter({
                // @ts-ignore
                container: container,
                placer: this.canvas.getPlacerEl(),
                containerSel: '*',
                itemSel: '*',
                pfx: this.ppfx,
                direction: 'a',
                document: doc,
                wmargin: 1,
                nested: 1,
                em: this.em,
                canvasRelative: 1,
                scale: function () { return _this.em.getZoomDecimal(); },
            });
        if (opts.onStart)
            this.sorter.onStart = opts.onStart;
        trg && this.sorter.startSort(trg, { container: container });
    },
    /**
     * Get frame position
     * @return {Object}
     * @private
     */
    getOffsetDim: function () {
        var frameOff = this.offset(this.canvas.getFrameEl());
        var canvasOff = this.offset(this.canvas.getElement());
        var top = frameOff.top - canvasOff.top;
        var left = frameOff.left - canvasOff.left;
        return { top: top, left: left };
    },
    /**
     * Stop select position event
     * @private
     * */
    stopSelectPosition: function () {
        this.posTargetCollection = null;
        this.posIndex = this.posMethod == 'after' && this.cDim.length !== 0 ? this.posIndex + 1 : this.posIndex; //Normalize
        if (this.sorter) {
            this.sorter.moved = 0;
            this.sorter.endMove();
        }
        if (this.cDim) {
            this.posIsLastEl = this.cDim.length !== 0 && this.posMethod == 'after' && this.posIndex == this.cDim.length;
            this.posTargetEl =
                this.cDim.length === 0
                    ? (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])(this.outsideElem)
                    : !this.posIsLastEl && this.cDim[this.posIndex]
                        ? (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])(this.cDim[this.posIndex][5]).parent()
                        : (0,_common__WEBPACK_IMPORTED_MODULE_0__["default"])(this.outsideElem);
            this.posTargetModel = this.posTargetEl.data('model');
            this.posTargetCollection = this.posTargetEl.data('model-comp');
        }
    },
    /**
     * Enabel select position
     * @private
     */
    enable: function () {
        this.startSelectPosition();
    },
    /**
     * Check if the pointer is near to the float component
     * @param {number} index
     * @param {string} method
     * @param {Array<Array>} dims
     * @return {Boolean}
     * @private
     * */
    nearFloat: function (index, method, dims) {
        var i = index || 0;
        var m = method || 'before';
        var len = dims.length;
        var isLast = len !== 0 && m == 'after' && i == len;
        if (len !== 0 && ((!isLast && !dims[i][4]) || (dims[i - 1] && !dims[i - 1][4]) || (isLast && !dims[i - 1][4])))
            return 1;
        return 0;
    },
    run: function () {
        this.enable();
    },
    stop: function () {
        this.stopSelectPosition();
        this.$wrapper.css('cursor', '');
        this.$wrapper.unbind();
    },
});


/***/ }),

/***/ 886:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _canvas_model_CanvasSpot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(201);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(815);
/* harmony import */ var _utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    getOffsetMethod: function (state) {
        var method = state || '';
        return 'get' + method + 'OffsetViewerEl';
    },
    run: function (editor, sender, opts) {
        var canvas = this.canvas;
        var opt = opts || {};
        var state = opt.state || '';
        var config = editor.getConfig();
        var zoom = this.em.getZoomDecimal();
        var el = opt.el;
        if (!config.showOffsets || !el || (0,_utils_dom__WEBPACK_IMPORTED_MODULE_1__/* .isTextNode */ .BM)(el) || (!config.showOffsetsSelected && state == 'Fixed')) {
            editor.stopCommand("".concat(this.id), opts);
            return;
        }
        if (canvas.hasCustomSpot(_canvas_model_CanvasSpot__WEBPACK_IMPORTED_MODULE_2__/* .CanvasSpotBuiltInTypes */ .q.Spacing)) {
            return;
        }
        var pos = __assign({}, (opt.elPos || canvas.getElementPos(el)));
        if (!(0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(opt.top)) {
            pos.top = opt.top;
        }
        if (!(0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(opt.left)) {
            pos.left = opt.left;
        }
        var style = window.getComputedStyle(el);
        var ppfx = this.ppfx;
        var stateVar = state + 'State';
        var method = this.getOffsetMethod(state);
        // @ts-ignore
        var offsetViewer = canvas[method](opts.view);
        offsetViewer.style.opacity = '';
        var marginT = this['marginT' + state];
        var marginB = this['marginB' + state];
        var marginL = this['marginL' + state];
        var marginR = this['marginR' + state];
        var padT = this['padT' + state];
        var padB = this['padB' + state];
        var padL = this['padL' + state];
        var padR = this['padR' + state];
        if (offsetViewer.childNodes.length) {
            this[stateVar] = '1';
            marginT = offsetViewer.querySelector('[data-offset-m-t]');
            marginB = offsetViewer.querySelector('[data-offset-m-b]');
            marginL = offsetViewer.querySelector('[data-offset-m-l]');
            marginR = offsetViewer.querySelector('[data-offset-m-r]');
            padT = offsetViewer.querySelector('[data-offset-p-t]');
            padB = offsetViewer.querySelector('[data-offset-p-b]');
            padL = offsetViewer.querySelector('[data-offset-p-l]');
            padR = offsetViewer.querySelector('[data-offset-p-r]');
        }
        if (!this[stateVar]) {
            var stateLow = state.toLowerCase();
            var marginName = stateLow + 'margin-v';
            var paddingName = stateLow + 'padding-v';
            var marginV = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(ppfx, "marginName\">")).get(0);
            var paddingV = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(ppfx, "paddingName\">")).get(0);
            var marginEls = ppfx + marginName + '-el';
            var paddingEls = ppfx + paddingName + '-el';
            var fullMargName = "".concat(marginEls, " ").concat(ppfx + marginName);
            var fullPadName = "".concat(paddingEls, " ").concat(ppfx + paddingName);
            marginT = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullMargName, "-top\"></div>")).get(0);
            marginB = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullMargName, "-bottom\"></div>")).get(0);
            marginL = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullMargName, "-left\"></div>")).get(0);
            marginR = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullMargName, "-right\"></div>")).get(0);
            padT = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullPadName, "-top\"></div>")).get(0);
            padB = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullPadName, "-bottom\"></div>")).get(0);
            padL = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullPadName, "-left\"></div>")).get(0);
            padR = (0,_common__WEBPACK_IMPORTED_MODULE_3__["default"])("<div class=\"".concat(fullPadName, "-right\"></div>")).get(0);
            this['marginT' + state] = marginT;
            this['marginB' + state] = marginB;
            this['marginL' + state] = marginL;
            this['marginR' + state] = marginR;
            this['padT' + state] = padT;
            this['padB' + state] = padB;
            this['padL' + state] = padL;
            this['padR' + state] = padR;
            marginV.appendChild(marginT);
            marginV.appendChild(marginB);
            marginV.appendChild(marginL);
            marginV.appendChild(marginR);
            paddingV.appendChild(padT);
            paddingV.appendChild(padB);
            paddingV.appendChild(padL);
            paddingV.appendChild(padR);
            offsetViewer.appendChild(marginV);
            offsetViewer.appendChild(paddingV);
            this[stateVar] = '1';
        }
        var unit = 'px';
        var marginLeftSt = parseFloat(style.marginLeft.replace(unit, '')) * zoom;
        var marginRightSt = parseFloat(style.marginRight.replace(unit, '')) * zoom;
        var marginTopSt = parseFloat(style.marginTop.replace(unit, '')) * zoom;
        var marginBottomSt = parseFloat(style.marginBottom.replace(unit, '')) * zoom;
        var mtStyle = marginT.style;
        var mbStyle = marginB.style;
        var mlStyle = marginL.style;
        var mrStyle = marginR.style;
        var ptStyle = padT.style;
        var pbStyle = padB.style;
        var plStyle = padL.style;
        var prStyle = padR.style;
        var posLeft = parseFloat(pos.left);
        var widthEl = parseFloat(style.width) * zoom + unit;
        // Margin style
        mtStyle.height = marginTopSt + unit;
        mtStyle.width = widthEl;
        mtStyle.top = pos.top - marginTopSt + unit;
        mtStyle.left = posLeft + unit;
        mbStyle.height = marginBottomSt + unit;
        mbStyle.width = widthEl;
        mbStyle.top = pos.top + pos.height + unit;
        mbStyle.left = posLeft + unit;
        var marginSideH = pos.height + marginTopSt + marginBottomSt + unit;
        var marginSideT = pos.top - marginTopSt + unit;
        mlStyle.height = marginSideH;
        mlStyle.width = marginLeftSt + unit;
        mlStyle.top = marginSideT;
        mlStyle.left = posLeft - marginLeftSt + unit;
        mrStyle.height = marginSideH;
        mrStyle.width = marginRightSt + unit;
        mrStyle.top = marginSideT;
        mrStyle.left = posLeft + pos.width + unit;
        // Padding style
        var padTop = parseFloat(style.paddingTop) * zoom;
        ptStyle.height = padTop + unit;
        // ptStyle.width = widthEl;
        // ptStyle.top = pos.top + unit;
        // ptStyle.left = posLeft + unit;
        var padBot = parseFloat(style.paddingBottom) * zoom;
        pbStyle.height = padBot + unit;
        // pbStyle.width = widthEl;
        // pbStyle.top = pos.top + pos.height - padBot + unit;
        // pbStyle.left = posLeft + unit;
        var padSideH = pos.height - padBot - padTop + unit;
        var padSideT = pos.top + padTop + unit;
        plStyle.height = padSideH;
        plStyle.width = parseFloat(style.paddingLeft) * zoom + unit;
        plStyle.top = padSideT;
        // plStyle.left = pos.left + unit;
        //  plStyle.right = 0;
        var padRight = parseFloat(style.paddingRight) * zoom;
        prStyle.height = padSideH;
        prStyle.width = padRight + unit;
        prStyle.top = padSideT;
        // prStyle.left = pos.left + pos.width - padRight + unit;
        //  prStyle.left = 0;
    },
    stop: function (editor, sender, opts) {
        if (opts === void 0) { opts = {}; }
        var opt = opts || {};
        var state = opt.state || '';
        var method = this.getOffsetMethod(state);
        var view = opts.view;
        var canvas = this.canvas;
        // @ts-ignore
        var offsetViewer = canvas[method](view);
        offsetViewer.style.opacity = 0;
    },
});


/***/ }),

/***/ 817:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _utils_mixins__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(283);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    init: function () {
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.bindAll)(this, '_onFramesChange');
    },
    run: function (ed) {
        this.toggleVis(ed, true);
    },
    stop: function (ed) {
        this.toggleVis(ed, false);
    },
    toggleVis: function (ed, active) {
        if (active === void 0) { active = true; }
        if (!ed.Commands.isActive('preview')) {
            var cv = ed.Canvas;
            var mth = active ? 'on' : 'off';
            var canvasModel = cv.getModel();
            canvasModel[mth]('change:frames', this._onFramesChange);
            this.handleFrames(cv.getFrames(), active);
        }
    },
    handleFrames: function (frames, active) {
        var _this = this;
        frames.forEach(function (frame) {
            var _a;
            ((_a = frame.view) === null || _a === void 0 ? void 0 : _a.loaded) && _this._upFrame(frame, active);
            if (!frame.__ol) {
                frame.on('loaded', function () { return _this._upFrame(frame); });
                frame.__ol = true;
            }
        });
    },
    _onFramesChange: function (_, frames) {
        this.handleFrames(frames);
    },
    _upFrame: function (frame, active) {
        var _a;
        var _b = this, ppfx = _b.ppfx, em = _b.em, id = _b.id;
        var isActive = (0,_utils_mixins__WEBPACK_IMPORTED_MODULE_1__.isDef)(active) ? active : em.Commands.isActive(id);
        var method = isActive ? 'add' : 'remove';
        var cls = "".concat(ppfx, "dashed");
        (_a = frame.view) === null || _a === void 0 ? void 0 : _a.getBody().classList[method](cls);
    },
});


/***/ }),

/***/ 847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FE: () => (/* binding */ Collection),
/* harmony export */   G7: () => (/* binding */ View),
/* harmony export */   Hn: () => (/* binding */ Model),
/* harmony export */   pH: () => (/* binding */ DEFAULT_COORDS),
/* harmony export */   vA: () => (/* binding */ CoordinatesTypes)
/* harmony export */ });
/* unused harmony exports CollectionView, DEFAULT_BOXRECT */
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(316);
/* harmony import */ var backbone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(backbone__WEBPACK_IMPORTED_MODULE_0__);
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var Model = /** @class */ (function (_super) {
    __extends(Model, _super);
    function Model() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Model;
}((backbone__WEBPACK_IMPORTED_MODULE_0___default().Model)));

var Collection = /** @class */ (function (_super) {
    __extends(Collection, _super);
    function Collection() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Collection;
}((backbone__WEBPACK_IMPORTED_MODULE_0___default().Collection)));

var View = /** @class */ (function (_super) {
    __extends(View, _super);
    function View() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return View;
}((backbone__WEBPACK_IMPORTED_MODULE_0___default().View)));

var CollectionView = /** @class */ (function (_super) {
    __extends(CollectionView, _super);
    function CollectionView(opts) {
        var _this = _super.call(this, opts) || this;
        _this.collection = opts.collection;
        return _this;
    }
    return CollectionView;
}((backbone__WEBPACK_IMPORTED_MODULE_0___default().View)));

var CoordinatesTypes;
(function (CoordinatesTypes) {
    CoordinatesTypes["Screen"] = "screen";
    CoordinatesTypes["World"] = "world";
})(CoordinatesTypes || (CoordinatesTypes = {}));
var DEFAULT_COORDS = {
    x: 0,
    y: 0,
};
var DEFAULT_BOXRECT = __assign(__assign({}, DEFAULT_COORDS), { width: 0, height: 0 });


/***/ }),

/***/ 250:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Z: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};


var resetPos = function () { return ({ x: 0, y: 0 }); };
var xyArr = ['x', 'y'];
var Dragger = /** @class */ (function () {
    /**
     * Init the dragger
     * @param  {Object} opts
     */
    function Dragger(opts) {
        if (opts === void 0) { opts = {}; }
        this.opts = {
            snapOffset: 5,
            scale: 1,
        };
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.bindAll)(this, 'drag', 'stop', 'keyHandle', 'handleScroll');
        this.setOptions(opts);
        this.delta = resetPos();
        this.lastScroll = resetPos();
        this.lastScrollDiff = resetPos();
        this.startPointer = resetPos();
        this.startPosition = resetPos();
        this.globScrollDiff = resetPos();
        this.currentPointer = resetPos();
        this.position = resetPos();
        this.guidesStatic = [];
        this.guidesTarget = [];
        this.docs = [];
        return this;
    }
    /**
     * Update options
     * @param {Object} options
     */
    Dragger.prototype.setOptions = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.opts = __assign(__assign({}, this.opts), opts);
    };
    Dragger.prototype.toggleDrag = function (enable) {
        var docs = this.getDocumentEl();
        var container = this.getContainerEl();
        var win = this.getWindowEl();
        var method = enable ? 'on' : 'off';
        var methods = { on: _dom__WEBPACK_IMPORTED_MODULE_1__.on, off: _dom__WEBPACK_IMPORTED_MODULE_1__/* .off */ .S1 };
        methods[method](container, 'mousemove dragover', this.drag);
        methods[method](docs, 'mouseup dragend touchend', this.stop);
        methods[method](docs, 'keydown', this.keyHandle);
        methods[method](win, 'scroll', this.handleScroll);
    };
    Dragger.prototype.handleScroll = function () {
        var _a = this, lastScroll = _a.lastScroll, delta = _a.delta;
        var actualScroll = this.getScrollInfo();
        var scrollDiff = {
            x: actualScroll.x - lastScroll.x,
            y: actualScroll.y - lastScroll.y,
        };
        this.move(delta.x + scrollDiff.x, delta.y + scrollDiff.y);
        this.lastScrollDiff = scrollDiff;
    };
    /**
     * Start dragging
     * @param  {Event} e
     */
    Dragger.prototype.start = function (ev) {
        var opts = this.opts;
        var onStart = opts.onStart;
        this.toggleDrag(true);
        this.startPointer = this.getPointerPos(ev);
        this.guidesStatic = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.result)(opts, 'guidesStatic') || [];
        this.guidesTarget = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.result)(opts, 'guidesTarget') || [];
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onStart) && onStart(ev, this);
        this.startPosition = this.getStartPosition();
        this.lastScrollDiff = resetPos();
        this.globScrollDiff = resetPos();
        this.drag(ev);
    };
    /**
     * Drag event
     * @param  {Event} event
     */
    Dragger.prototype.drag = function (ev) {
        var _this = this;
        var _a = this, opts = _a.opts, lastScrollDiff = _a.lastScrollDiff, globScrollDiff = _a.globScrollDiff;
        var onDrag = opts.onDrag;
        var startPointer = this.startPointer;
        var currentPos = this.getPointerPos(ev);
        var glDiff = {
            x: globScrollDiff.x + lastScrollDiff.x,
            y: globScrollDiff.y + lastScrollDiff.y,
        };
        this.globScrollDiff = glDiff;
        var delta = {
            x: currentPos.x - startPointer.x + glDiff.x,
            y: currentPos.y - startPointer.y + glDiff.y,
        };
        this.lastScrollDiff = resetPos();
        var lockedAxis = this.lockedAxis;
        // @ts-ignore Lock one axis
        if (ev.shiftKey) {
            lockedAxis = !lockedAxis && this.detectAxisLock(delta.x, delta.y);
        }
        else {
            lockedAxis = null;
        }
        if (lockedAxis === 'x') {
            delta.x = startPointer.x;
        }
        else if (lockedAxis === 'y') {
            delta.y = startPointer.y;
        }
        var moveDelta = function (delta) {
            xyArr.forEach(function (co) { return (delta[co] = delta[co] * (0,underscore__WEBPACK_IMPORTED_MODULE_0__.result)(opts, 'scale')); });
            _this.delta = delta;
            _this.move(delta.x, delta.y);
            (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onDrag) && onDrag(ev, _this);
        };
        var deltaPre = __assign({}, delta);
        this.currentPointer = currentPos;
        this.lockedAxis = lockedAxis;
        this.lastScroll = this.getScrollInfo();
        moveDelta(delta);
        if (this.guidesTarget.length) {
            var _b = this.snapGuides(deltaPre), newDelta = _b.newDelta, trgX = _b.trgX, trgY = _b.trgY;
            (trgX || trgY) && moveDelta(newDelta);
        }
        // @ts-ignore In case the mouse button was released outside of the window
        ev.which === 0 && this.stop(ev);
    };
    /**
     * Check if the delta hits some guide
     */
    Dragger.prototype.snapGuides = function (delta) {
        var _this = this;
        var newDelta = delta;
        var _a = this, trgX = _a.trgX, trgY = _a.trgY;
        this.guidesTarget.forEach(function (trg) {
            // Skip the guide if its locked axis already exists
            if ((trg.x && _this.trgX) || (trg.y && _this.trgY))
                return;
            trg.active = false;
            _this.guidesStatic.forEach(function (stat) {
                if ((trg.y && stat.x) || (trg.x && stat.y))
                    return;
                var isY = trg.y && stat.y;
                var axs = isY ? 'y' : 'x';
                var trgPoint = trg[axs];
                var statPoint = stat[axs];
                var deltaPoint = delta[axs];
                var trgGuide = isY ? trgY : trgX;
                if (_this.isPointIn(trgPoint, statPoint)) {
                    if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(trgGuide)) {
                        var trgValue = deltaPoint - (trgPoint - statPoint);
                        _this.setGuideLock(trg, trgValue);
                    }
                }
            });
        });
        trgX = this.trgX;
        trgY = this.trgY;
        xyArr.forEach(function (co) {
            var axis = co.toUpperCase();
            // @ts-ignore
            var trg = _this["trg".concat(axis)];
            if (trg && !_this.isPointIn(delta[co], trg.lock)) {
                _this.setGuideLock(trg, null);
                trg = null;
            }
            if (trg && !(0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(trg.lock)) {
                newDelta[co] = trg.lock;
            }
        });
        return {
            newDelta: newDelta,
            trgX: this.trgX,
            trgY: this.trgY,
        };
    };
    Dragger.prototype.isPointIn = function (src, trg, _a) {
        var _b = _a === void 0 ? {} : _a, offset = _b.offset;
        var ofst = offset || this.opts.snapOffset || 0;
        return (src >= trg && src <= trg + ofst) || (src <= trg && src >= trg - ofst);
    };
    Dragger.prototype.setGuideLock = function (guide, value) {
        var axis = !(0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(guide.x) ? 'X' : 'Y';
        var trgName = "trg".concat(axis);
        if (value !== null) {
            guide.active = true;
            guide.lock = value;
            // @ts-ignore
            this[trgName] = guide;
        }
        else {
            delete guide.active;
            delete guide.lock;
            // @ts-ignore
            delete this[trgName];
        }
        return guide;
    };
    /**
     * Stop dragging
     */
    Dragger.prototype.stop = function (ev, opts) {
        if (opts === void 0) { opts = {}; }
        var delta = this.delta;
        var cancelled = !!opts.cancel;
        var x = cancelled ? 0 : delta.x;
        var y = cancelled ? 0 : delta.y;
        this.toggleDrag();
        this.lockedAxis = null;
        this.move(x, y, true);
        var onEnd = this.opts.onEnd;
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(onEnd) && onEnd(ev, this, { cancelled: cancelled });
    };
    Dragger.prototype.keyHandle = function (ev) {
        if ((0,_dom__WEBPACK_IMPORTED_MODULE_1__/* .isEscKey */ .kl)(ev)) {
            this.stop(ev, { cancel: true });
        }
    };
    /**
     * Move the element
     * @param  {integer} x
     * @param  {integer} y
     */
    Dragger.prototype.move = function (x, y, end) {
        var _a = this, el = _a.el, opts = _a.opts;
        var pos = this.startPosition;
        if (!pos)
            return;
        var setPosition = opts.setPosition;
        var xPos = pos.x + x;
        var yPos = pos.y + y;
        this.position = {
            x: xPos,
            y: yPos,
            end: end,
        };
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(setPosition) && setPosition(this.position);
        if (el) {
            el.style.left = "".concat(xPos, "px");
            el.style.top = "".concat(yPos, "px");
        }
    };
    Dragger.prototype.getContainerEl = function () {
        var container = this.opts.container;
        return container ? [container] : this.getDocumentEl();
    };
    Dragger.prototype.getWindowEl = function () {
        var cont = this.getContainerEl();
        return cont.map(function (item) {
            var doc = item.ownerDocument || item;
            // @ts-ignore
            return doc.defaultView || doc.parentWindow;
        });
    };
    /**
     * Returns documents
     */
    Dragger.prototype.getDocumentEl = function (el) {
        var doc = this.opts.doc;
        el = el || this.el;
        if (!this.docs.length) {
            var docs = [document];
            el && docs.push(el.ownerDocument);
            doc && docs.push(doc);
            this.docs = docs;
        }
        return this.docs;
    };
    /**
     * Get mouse coordinates
     * @param  {Event} event
     * @return {Object}
     */
    Dragger.prototype.getPointerPos = function (ev) {
        var getPos = this.opts.getPointerPosition;
        var pEv = (0,_dom__WEBPACK_IMPORTED_MODULE_1__/* .getPointerEvent */ .VB)(ev);
        return getPos
            ? getPos(ev)
            : {
                x: pEv.clientX,
                y: pEv.clientY,
            };
    };
    Dragger.prototype.getStartPosition = function () {
        var _a = this, el = _a.el, opts = _a.opts;
        var getPos = opts.getPosition;
        var result = resetPos();
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(getPos)) {
            result = getPos();
        }
        else if (el) {
            result = {
                x: parseFloat(el.style.left),
                y: parseFloat(el.style.top),
            };
        }
        return result;
    };
    Dragger.prototype.getScrollInfo = function () {
        var doc = this.opts.doc;
        var body = doc && doc.body;
        return {
            y: body ? body.scrollTop : 0,
            x: body ? body.scrollLeft : 0,
        };
    };
    Dragger.prototype.detectAxisLock = function (x, y) {
        var relX = x;
        var relY = y;
        var absX = Math.abs(relX);
        var absY = Math.abs(relY);
        // Vertical or Horizontal lock
        if (relY >= absX || relY <= -absX) {
            return 'x';
        }
        else if (relX > absY || relX < -absY) {
            return 'y';
        }
    };
    return Dragger;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Dragger);


/***/ }),

/***/ 815:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// @ts-nocheck
/* Adapted for headless */
/* MIT https://github.com/kenwheeler/cash */

var doc = typeof document !== 'undefined' ? document : null, win = typeof window !== 'undefined' ? window : null, _Array$prototype = Array.prototype, filter = _Array$prototype.filter, indexOf = _Array$prototype.indexOf, map = _Array$prototype.map, push = _Array$prototype.push, reverse = _Array$prototype.reverse, slice = _Array$prototype.slice, splice = _Array$prototype.splice;
var idRe = /^#[\w-]*$/, classRe = /^\.[\w-]*$/, htmlRe = /<.+>/, tagRe = /^\w+$/; // @require ./variables.js
function find(selector, context) {
    if (context === void 0) {
        context = doc;
    }
    return classRe.test(selector)
        ? context.getElementsByClassName(selector.slice(1))
        : tagRe.test(selector)
            ? context.getElementsByTagName(selector)
            : context.querySelectorAll(selector);
} // @require ./find.js
// @require ./variables.js
function Cash(selector, context) {
    if (context === void 0) {
        context = doc;
    }
    if (!selector)
        return;
    if (selector.__cash)
        return selector;
    var eles = selector;
    if (isString(selector)) {
        if (context.__cash)
            context = context[0];
        eles = idRe.test(selector)
            ? context.getElementById(selector.slice(1))
            : htmlRe.test(selector)
                ? parseHTML(selector)
                : find(selector, context);
        if (!eles)
            return;
    }
    else if (isFunction(selector)) {
        return this.ready(selector); //FIXME: `fn.ready` is not included in `core`, but it's actually a core functionality
    }
    if (eles.nodeType || eles === win)
        eles = [eles];
    this.length = eles.length;
    for (var i = 0, l = this.length; i < l; i++) {
        this[i] = eles[i];
    }
}
function cash(selector, context) {
    return new Cash(selector, context);
}
/* PROTOTYPE */
var fn = (cash.fn =
    cash.prototype =
        Cash.prototype =
            {
                constructor: cash,
                __cash: true,
                length: 0,
                splice: splice, // Ensures a cash collection gets printed as array-like in Chrome
            }); // @require core/cash.js
// @require core/variables.js
fn.get = function (index) {
    if (index === undefined)
        return slice.call(this);
    return this[index < 0 ? index + this.length : index];
}; // @require core/cash.js
// @require ./get.js
fn.eq = function (index) {
    return cash(this.get(index));
}; // @require core/cash.js
// @require ./eq.js
fn.first = function () {
    return this.eq(0);
}; // @require core/cash.js
// @require ./eq.js
fn.last = function () {
    return this.eq(-1);
}; // @require core/cash.js
// @require core/variables.js
fn.map = function (callback) {
    return cash(map.call(this, function (ele, i) {
        return callback.call(ele, i, ele);
    }));
}; // @require core/cash.js
// @require core/variables.js
fn.slice = function () {
    return cash(slice.apply(this, arguments));
}; // @require ./cash.js
var camelCaseRe = /(?:^\w|[A-Z]|\b\w)/g, camelCaseWhitespaceRe = /[\s-_]+/g;
function camelCase(str) {
    return str
        .replace(camelCaseRe, function (letter, index) {
        return letter[!index ? 'toLowerCase' : 'toUpperCase']();
    })
        .replace(camelCaseWhitespaceRe, '');
}
cash.camelCase = camelCase; // @require ./cash.js
function each(arr, callback) {
    for (var i = 0, l = arr.length; i < l; i++) {
        if (callback.call(arr[i], arr[i], i, arr) === false)
            break;
    }
}
cash.each = each; // @require core/cash.js
// @require core/each.js
fn.each = function (callback) {
    each(this, function (ele, i) {
        return callback.call(ele, i, ele);
    });
    return this;
}; // @require core/cash.js
// @require collection/each.js
fn.removeProp = function (prop) {
    return this.each(function (i, ele) {
        delete ele[prop];
    });
}; // @require ./cash.js
function extend(target) {
    if (target === void 0) {
        target = this;
    }
    var args = arguments, length = args.length;
    for (var i = length < 2 ? 0 : 1; i < length; i++) {
        for (var key in args[i]) {
            target[key] = args[i][key];
        }
    }
    return target;
}
cash.extend = fn.extend = extend; // @require ./cash.js
var guid = 1;
cash.guid = guid; // @require ./cash.js
function matches(ele, selector) {
    var matches = ele &&
        (ele.matches ||
            ele.webkitMatchesSelector ||
            ele.mozMatchesSelector ||
            ele.msMatchesSelector ||
            ele.oMatchesSelector);
    return !!matches && matches.call(ele, selector);
}
cash.matches = matches; // @require ./cash.js
function isFunction(x) {
    return typeof x === 'function';
}
cash.isFunction = isFunction;
function isString(x) {
    return typeof x === 'string';
}
cash.isString = isString;
function isNumeric(x) {
    return !isNaN(parseFloat(x)) && isFinite(x);
}
cash.isNumeric = isNumeric;
var isArray = Array.isArray;
cash.isArray = isArray; // @require core/cash.js
// @require core/type_checking.js
// @require collection/each.js
fn.prop = function (prop, value) {
    if (!prop)
        return;
    if (isString(prop)) {
        if (arguments.length < 2)
            return this[0] && this[0][prop];
        return this.each(function (i, ele) {
            ele[prop] = value;
        });
    }
    for (var key in prop) {
        this.prop(key, prop[key]);
    }
    return this;
}; // @require ./matches.js
// @require ./type_checking.js
function getCompareFunction(selector) {
    return isString(selector)
        ? function (i, ele) {
            return matches(ele, selector);
        }
        : selector.__cash
            ? function (i, ele) {
                return selector.is(ele);
            }
            : function (i, ele, selector) {
                return ele === selector;
            };
} // @require core/cash.js
// @require core/get_compare_function.js
// @require core/type_checking.js
// @require core/variables.js
// @require collection/get.js
fn.filter = function (selector) {
    if (!selector)
        return cash();
    var comparator = isFunction(selector) ? selector : getCompareFunction(selector);
    return cash(filter.call(this, function (ele, i) {
        return comparator.call(ele, i, ele, selector);
    }));
}; // @require ./type_checking.js
var splitValuesRe = /\S+/g;
function getSplitValues(str) {
    return isString(str) ? str.match(splitValuesRe) || [] : [];
} // @require core/cash.js
// @require core/get_split_values.js
// @require collection/each.js
fn.hasClass = function (cls) {
    var classes = getSplitValues(cls);
    var check = false;
    if (classes.length) {
        this.each(function (i, ele) {
            check = ele.classList.contains(classes[0]);
            return !check;
        });
    }
    return check;
}; // @require core/cash.js
// @require core/get_split_values.js
// @require collection/each.js
fn.removeAttr = function (attr) {
    var attrs = getSplitValues(attr);
    if (!attrs.length)
        return this;
    return this.each(function (i, ele) {
        each(attrs, function (a) {
            ele.removeAttribute(a);
        });
    });
}; // @require core/cash.js
// @require core/type_checking.js
// @require collection/each.js
// @require ./remove_attr.js
fn.attr = function (attr, value) {
    if (!attr)
        return;
    if (isString(attr)) {
        if (arguments.length < 2) {
            if (!this[0])
                return;
            var _value = this[0].getAttribute(attr);
            return _value === null ? undefined : _value;
        }
        if (value === null)
            return this.removeAttr(attr);
        return this.each(function (i, ele) {
            ele.setAttribute(attr, value);
        });
    }
    for (var key in attr) {
        this.attr(key, attr[key]);
    }
    return this;
}; // @require core/cash.js
// @require core/each.js
// @require core/get_split_values.js
// @require collection/each.js
fn.toggleClass = function (cls, force) {
    var classes = getSplitValues(cls), isForce = force !== undefined;
    if (!classes.length)
        return this;
    return this.each(function (i, ele) {
        each(classes, function (c) {
            if (isForce) {
                force ? ele.classList.add(c) : ele.classList.remove(c);
            }
            else {
                ele.classList.toggle(c);
            }
        });
    });
}; // @require core/cash.js
// @require ./toggle_class.js
fn.addClass = function (cls) {
    return this.toggleClass(cls, true);
}; // @require core/cash.js
// @require ./attr.js
// @require ./toggle_class.js
fn.removeClass = function (cls) {
    return !arguments.length ? this.attr('class', '') : this.toggleClass(cls, false);
}; // @optional ./add_class.js
// @optional ./attr.js
// @optional ./has_class.js
// @optional ./prop.js
// @optional ./remove_attr.js
// @optional ./remove_class.js
// @optional ./remove_prop.js
// @optional ./toggle_class.js
// @require ./cash.js
function unique(arr) {
    return arr.filter(function (item, index, self) {
        return self.indexOf(item) === index;
    });
}
cash.unique = unique; // @require core/cash.js
// @require core/unique.js
// @require ./get.js
fn.add = function (selector, context) {
    return cash(unique(this.get().concat(cash(selector, context).get())));
}; // @require core/variables.js
function computeStyle(ele, prop, isVariable) {
    if (ele.nodeType !== 1)
        return;
    var style = win.getComputedStyle(ele, null);
    return prop ? (isVariable ? style.getPropertyValue(prop) : style[prop]) : style;
} // @require ./compute_style.js
function computeStyleInt(ele, prop) {
    return parseInt(computeStyle(ele, prop), 10) || 0;
}
var cssVariableRe = /^--/; // @require ./variables.js
function isCSSVariable(prop) {
    return cssVariableRe.test(prop);
} // @require core/camel_case.js
// @require core/cash.js
// @require core/each.js
// @require core/variables.js
// @require ./is_css_variable.js
var prefixedProps = {}, docEl = doc && doc.createElement('div'), style = docEl ? docEl.style : {}, vendorsPrefixes = ['webkit', 'moz', 'ms', 'o'];
function getPrefixedProp(prop, isVariable) {
    if (isVariable === void 0) {
        isVariable = isCSSVariable(prop);
    }
    if (isVariable)
        return prop;
    if (!prefixedProps[prop]) {
        var propCC = camelCase(prop), propUC = '' + propCC.charAt(0).toUpperCase() + propCC.slice(1), props = (propCC + ' ' + vendorsPrefixes.join(propUC + ' ') + propUC).split(' ');
        each(props, function (p) {
            if (p in style) {
                prefixedProps[prop] = p;
                return false;
            }
        });
    }
    return prefixedProps[prop];
}
cash.prefixedProp = getPrefixedProp; // @require core/type_checking.js
// @require ./is_css_variable.js
var numericProps = {
    animationIterationCount: true,
    columnCount: true,
    flexGrow: true,
    flexShrink: true,
    fontWeight: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    widows: true,
    zIndex: true,
};
function getSuffixedValue(prop, value, isVariable) {
    if (isVariable === void 0) {
        isVariable = isCSSVariable(prop);
    }
    return !isVariable && !numericProps[prop] && isNumeric(value) ? value + 'px' : value;
} // @require core/cash.js
// @require core/type_checking.js
// @require collection/each.js
// @require ./helpers/compute_style.js
// @require ./helpers/get_prefixed_prop.js
// @require ./helpers/get_suffixed_value.js
// @require ./helpers/is_css_variable.js
fn.css = function (prop, value) {
    if (isString(prop)) {
        var isVariable = isCSSVariable(prop);
        prop = getPrefixedProp(prop, isVariable);
        if (arguments.length < 2)
            return this[0] && computeStyle(this[0], prop, isVariable);
        if (!prop)
            return this;
        value = getSuffixedValue(prop, value, isVariable);
        return this.each(function (i, ele) {
            if (ele.nodeType !== 1)
                return;
            if (isVariable) {
                ele.style.setProperty(prop, value);
            }
            else {
                ele.style[prop] = value;
            }
        });
    }
    for (var key in prop) {
        this.css(key, prop[key]);
    }
    return this;
}; // @optional ./css.js
var dataNamespace = '__cashData', dataAttributeRe = /^data-(.*)/; // @require core/cash.js
// @require ./helpers/variables.js
cash.hasData = function (ele) {
    return dataNamespace in ele;
}; // @require ./variables.js
function getDataCache(ele) {
    return (ele[dataNamespace] = ele[dataNamespace] || {});
} // @require attributes/attr.js
// @require ./get_data_cache.js
function getData(ele, key) {
    var cache = getDataCache(ele);
    if (key) {
        if (!(key in cache)) {
            var value = ele.dataset ? ele.dataset[key] || ele.dataset[camelCase(key)] : cash(ele).attr('data-' + key);
            if (value !== undefined) {
                try {
                    value = JSON.parse(value);
                }
                catch (e) { }
                cache[key] = value;
            }
        }
        return cache[key];
    }
    return cache;
} // @require ./variables.js
// @require ./get_data_cache.js
function removeData(ele, key) {
    if (key === undefined) {
        delete ele[dataNamespace];
    }
    else {
        delete getDataCache(ele)[key];
    }
} // @require ./get_data_cache.js
function setData(ele, key, value) {
    getDataCache(ele)[key] = value;
} // @require core/cash.js
// @require core/type_checking.js
// @require collection/each.js
// @require ./helpers/get_data.js
// @require ./helpers/set_data.js
// @require ./helpers/variables.js
fn.data = function (name, value) {
    var _this = this;
    if (!name) {
        if (!this[0])
            return;
        each(this[0].attributes, function (attr) {
            var match = attr.name.match(dataAttributeRe);
            if (!match)
                return;
            _this.data(match[1]);
        });
        return getData(this[0]);
    }
    if (isString(name)) {
        if (value === undefined)
            return this[0] && getData(this[0], name);
        return this.each(function (i, ele) {
            return setData(ele, name, value);
        });
    }
    for (var key in name) {
        this.data(key, name[key]);
    }
    return this;
}; // @require core/cash.js
// @require collection/each.js
// @require ./helpers/remove_data.js
fn.removeData = function (key) {
    return this.each(function (i, ele) {
        return removeData(ele, key);
    });
}; // @optional ./data.js
// @optional ./remove_data.js
// @require css/helpers/compute_style_int.js
function getExtraSpace(ele, xAxis) {
    return (computeStyleInt(ele, 'border' + (xAxis ? 'Left' : 'Top') + 'Width') +
        computeStyleInt(ele, 'padding' + (xAxis ? 'Left' : 'Top')) +
        computeStyleInt(ele, 'padding' + (xAxis ? 'Right' : 'Bottom')) +
        computeStyleInt(ele, 'border' + (xAxis ? 'Right' : 'Bottom') + 'Width'));
} // @require core/cash.js
// @require core/each.js
// @require core/variables.js
each(['Width', 'Height'], function (prop) {
    fn['inner' + prop] = function () {
        if (!this[0])
            return;
        if (this[0] === win)
            return win['inner' + prop];
        return this[0]['client' + prop];
    };
}); // @require core/camel_case.js
// @require core/cash.js
// @require core/each.js
// @require core/variables.js
// @require css/helpers/compute_style.js
// @require css/helpers/get_suffixed_value.js
// @require ./helpers/get_extra_space.js
each(['width', 'height'], function (prop, index) {
    fn[prop] = function (value) {
        if (!this[0])
            return value === undefined ? undefined : this;
        if (!arguments.length) {
            if (this[0] === win)
                return this[0][camelCase('outer-' + prop)];
            return this[0].getBoundingClientRect()[prop] - getExtraSpace(this[0], !index);
        }
        value = parseInt(value, 10);
        return this.each(function (i, ele) {
            if (ele.nodeType !== 1)
                return;
            var boxSizing = computeStyle(ele, 'boxSizing');
            ele.style[prop] = getSuffixedValue(prop, value + (boxSizing === 'border-box' ? getExtraSpace(ele, !index) : 0));
        });
    };
}); // @require core/cash.js
// @require core/each.js
// @require core/variables.js
// @require css/helpers/compute_style_int.js
each(['Width', 'Height'], function (prop, index) {
    fn['outer' + prop] = function (includeMargins) {
        if (!this[0])
            return;
        if (this[0] === win)
            return win['outer' + prop];
        return (this[0]['offset' + prop] +
            (includeMargins
                ? computeStyleInt(this[0], 'margin' + (!index ? 'Left' : 'Top')) +
                    computeStyleInt(this[0], 'margin' + (!index ? 'Right' : 'Bottom'))
                : 0));
    };
}); // @optional ./inner.js
// @optional ./normal.js
// @optional ./outer.js
function hasNamespaces(ns1, ns2) {
    for (var i = 0, l = ns2.length; i < l; i++) {
        if (ns1.indexOf(ns2[i]) < 0)
            return false;
    }
    return true;
} // @require core/each.js
function removeEventListeners(cache, ele, name) {
    each(cache[name], function (_ref) {
        var namespaces = _ref[0], callback = _ref[1];
        ele.removeEventListener(name, callback);
    });
    delete cache[name];
}
var eventsNamespace = '__cashEvents', eventsNamespacesSeparator = '.'; // @require ./variables.js
function getEventsCache(ele) {
    return (ele[eventsNamespace] = ele[eventsNamespace] || {});
} // @require core/guid.js
// @require events/helpers/get_events_cache.js
function addEvent(ele, name, namespaces, callback) {
    callback.guid = callback.guid || guid++;
    var eventCache = getEventsCache(ele);
    eventCache[name] = eventCache[name] || [];
    eventCache[name].push([namespaces, callback]);
    ele.addEventListener(name, callback);
} // @require ./variables.js
function parseEventName(eventName) {
    var parts = eventName.split(eventsNamespacesSeparator);
    return [parts[0], parts.slice(1).sort()]; // [name, namespaces]
} // @require core/guid.js
// @require ./get_events_cache.js
// @require ./has_namespaces.js
// @require ./parse_event_name.js
// @require ./remove_event_listeners.js
function removeEvent(ele, name, namespaces, callback) {
    var cache = getEventsCache(ele);
    if (!name) {
        if (!namespaces || !namespaces.length) {
            for (name in cache) {
                removeEventListeners(cache, ele, name);
            }
        }
        else {
            for (name in cache) {
                removeEvent(ele, name, namespaces, callback);
            }
        }
    }
    else {
        var eventCache = cache[name];
        if (!eventCache)
            return;
        if (callback)
            callback.guid = callback.guid || guid++;
        cache[name] = eventCache.filter(function (_ref2) {
            var ns = _ref2[0], cb = _ref2[1];
            if ((callback && cb.guid !== callback.guid) || !hasNamespaces(ns, namespaces))
                return true;
            ele.removeEventListener(name, cb);
        });
    }
} // @require core/cash.js
// @require core/each.js
// @require collection/each.js
// @require ./helpers/parse_event_name.js
// @require ./helpers/remove_event.js
fn.off = function (eventFullName, callback) {
    var _this2 = this;
    if (eventFullName === undefined) {
        this.each(function (i, ele) {
            return removeEvent(ele);
        });
    }
    else {
        each(getSplitValues(eventFullName), function (eventFullName) {
            var _parseEventName = parseEventName(eventFullName), name = _parseEventName[0], namespaces = _parseEventName[1];
            _this2.each(function (i, ele) {
                return removeEvent(ele, name, namespaces, callback);
            });
        });
    }
    return this;
}; // @require core/cash.js
// @require core/get_split_values.js
// @require core/guid.js
// @require core/matches.js
// @require core/type_checking.js
// @require collection/each.js
// @require ./helpers/variables.js
// @require ./helpers/add_event.js
// @require ./helpers/has_namespaces.js
// @require ./helpers/parse_event_name.js
// @require ./helpers/remove_event.js
fn.on = function (eventFullName, selector, callback, _one) {
    var _this3 = this;
    if (!isString(eventFullName)) {
        for (var key in eventFullName) {
            this.on(key, selector, eventFullName[key]);
        }
        return this;
    }
    if (isFunction(selector)) {
        callback = selector;
        selector = false;
    }
    each(getSplitValues(eventFullName), function (eventFullName) {
        var _parseEventName2 = parseEventName(eventFullName), name = _parseEventName2[0], namespaces = _parseEventName2[1];
        _this3.each(function (i, ele) {
            var finalCallback = function finalCallback(event) {
                if (event.namespace && !hasNamespaces(namespaces, event.namespace.split(eventsNamespacesSeparator)))
                    return;
                var thisArg = ele;
                if (selector) {
                    var target = event.target;
                    while (!matches(target, selector)) {
                        if (target === ele)
                            return;
                        target = target.parentNode;
                        if (!target)
                            return;
                    }
                    thisArg = target;
                }
                event.namespace = event.namespace || '';
                var returnValue = callback.call(thisArg, event, event.data);
                if (_one) {
                    removeEvent(ele, name, namespaces, finalCallback);
                }
                if (returnValue === false) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
            finalCallback.guid = callback.guid = callback.guid || guid++;
            addEvent(ele, name, namespaces, finalCallback);
        });
    });
    return this;
}; // @require core/cash.js
// @require ./on.js
fn.one = function (eventFullName, delegate, callback) {
    return this.on(eventFullName, delegate, callback, true);
}; // @require core/cash.js
// @require core/variables.js
fn.ready = function (callback) {
    var finalCallback = function finalCallback() {
        return callback(cash);
    };
    if (doc.readyState !== 'loading') {
        setTimeout(finalCallback);
    }
    else {
        doc.addEventListener('DOMContentLoaded', finalCallback);
    }
    return this;
}; // @require core/cash.js
// @require core/type_checking.js
// @require core/variables.js
// @require collection/each.js
// @require ./helpers/parse_event_name.js
// @require ./helpers/variables.js
fn.trigger = function (eventFullName, data) {
    var evt = eventFullName;
    if (isString(eventFullName)) {
        var _parseEventName3 = parseEventName(eventFullName), name = _parseEventName3[0], namespaces = _parseEventName3[1];
        evt = doc.createEvent('HTMLEvents');
        evt.initEvent(name, true, true);
        evt.namespace = namespaces.join(eventsNamespacesSeparator);
    }
    evt.data = data;
    return this.each(function (i, ele) {
        ele.dispatchEvent(evt);
    });
}; // @optional ./off.js
// @optional ./on.js
// @optional ./one.js
// @optional ./ready.js
// @optional ./trigger.js
// @require core/each.js
function getValueSelectMultiple(ele) {
    var values = [];
    each(ele.options, function (option) {
        if (option.selected && !option.disabled && !option.parentNode.disabled) {
            values.push(option.value);
        }
    });
    return values;
}
function getValueSelectSingle(ele) {
    return ele.selectedIndex < 0 ? null : ele.options[ele.selectedIndex].value;
} // @require ./get_value_select_single.js
// @require ./get_value_select_multiple.js
var selectOneRe = /select-one/i, selectMultipleRe = /select-multiple/i;
function getValue(ele) {
    var type = ele.type;
    if (selectOneRe.test(type))
        return getValueSelectSingle(ele);
    if (selectMultipleRe.test(type))
        return getValueSelectMultiple(ele);
    return ele.value;
}
var queryEncodeSpaceRe = /%20/g;
function queryEncode(prop, value) {
    return '&' + encodeURIComponent(prop) + '=' + encodeURIComponent(value).replace(queryEncodeSpaceRe, '+');
} // @require core/cash.js
// @require core/each.js
// @require core/type_checking.js
// @require ./helpers/get_value.js
// @require ./helpers/query_encode.js
var skippableRe = /file|reset|submit|button|image/i, checkableRe = /radio|checkbox/i;
fn.serialize = function () {
    var query = '';
    this.each(function (i, ele) {
        each(ele.elements || [ele], function (ele) {
            if (ele.disabled || !ele.name || ele.tagName === 'FIELDSET')
                return;
            if (skippableRe.test(ele.type))
                return;
            if (checkableRe.test(ele.type) && !ele.checked)
                return;
            var value = getValue(ele);
            if (value === undefined)
                return;
            var values = isArray(value) ? value : [value];
            each(values, function (value) {
                query += queryEncode(ele.name, value);
            });
        });
    });
    return query.substr(1);
}; // @require core/cash.js
// @require core/each.js
// @require core/type_checking.js
// @require collection/each.js
// @require ./helpers/get_value.js
fn.val = function (value) {
    if (value === undefined)
        return this[0] && getValue(this[0]);
    return this.each(function (i, ele) {
        var isMultiple = selectMultipleRe.test(ele.type), eleValue = value === null ? (isMultiple ? [] : '') : value;
        if (isMultiple && isArray(eleValue)) {
            each(ele.options, function (option) {
                option.selected = eleValue.indexOf(option.value) >= 0;
            });
        }
        else {
            ele.value = eleValue;
        }
    });
}; // @optional ./serialize.js
// @optional ./val.js
// @require core/cash.js
// @require collection/map.js
fn.clone = function () {
    return this.map(function (i, ele) {
        return ele.cloneNode(true);
    });
}; // @require core/cash.js
// @require collection/each.js
fn.detach = function () {
    return this.each(function (i, ele) {
        if (ele.parentNode) {
            ele.parentNode.removeChild(ele);
        }
    });
}; // @require ./cash.js
// @require ./variables.js
// @require ./type_checking.js
// @require collection/get.js
// @require manipulation/detach.js
var fragmentRe = /^\s*<(\w+)[^>]*>/, singleTagRe = /^\s*<(\w+)\s*\/?>(?:<\/\1>)?\s*$/;
var containers;
function initContainers() {
    if (containers)
        return;
    var table = doc.createElement('table'), tr = doc.createElement('tr');
    containers = {
        '*': doc.createElement('div'),
        tr: doc.createElement('tbody'),
        td: tr,
        th: tr,
        thead: table,
        tbody: table,
        tfoot: table,
    };
}
function parseHTML(html) {
    initContainers();
    if (!isString(html))
        return [];
    if (singleTagRe.test(html))
        return [doc.createElement(RegExp.$1)];
    var fragment = fragmentRe.test(html) && RegExp.$1, container = containers[fragment] || containers['*'];
    container.innerHTML = html;
    return cash(container.childNodes).detach().get();
}
cash.parseHTML = parseHTML; // @optional ./camel_case.js
// @optional ./each.js
// @optional ./export.js
// @optional ./extend.js
// @optional ./find.js
// @optional ./get_compare_function.js
// @optional ./get_split_values.js
// @optional ./guid.js
// @optional ./matches.js
// @optional ./parse_html.js
// @optional ./unique.js
// @optional ./variables.js
// @require ./cash.js
// @require ./type_checking.js
// @require core/cash.js
fn.empty = function () {
    var ele = this[0];
    if (ele) {
        while (ele.firstChild) {
            ele.removeChild(ele.firstChild);
        }
    }
    return this;
};
function insertElement(ele, child, prepend) {
    if (prepend) {
        ele.insertBefore(child, ele.childNodes[0]);
    }
    else {
        ele.appendChild(child);
    }
} // @require core/each.js
// @require core/type_checking.js
// @require ./insert_element.js
function insertContent(parent, child, prepend) {
    if (child === undefined)
        return;
    var isStr = isString(child);
    if (!isStr && child.length) {
        each(child, function (ele) {
            return insertContent(parent, ele, prepend);
        });
    }
    else {
        each(parent, isStr
            ? function (ele) {
                ele.insertAdjacentHTML(prepend ? 'afterbegin' : 'beforeend', child);
            }
            : function (ele, index) {
                return insertElement(ele, !index ? child : child.cloneNode(true), prepend);
            });
    }
} // @require core/cash.js
// @require core/each.js
// @require ./helpers/insert_content.js
fn.append = function () {
    var _this4 = this;
    each(arguments, function (content) {
        insertContent(_this4, content);
    });
    return this;
}; // @require core/cash.js
// @require ./helpers/insert_content.js
fn.appendTo = function (parent) {
    insertContent(cash(parent), this);
    return this;
}; // @require core/cash.js
// @require collection/each.js
fn.html = function (content) {
    if (content === undefined)
        return this[0] && this[0].innerHTML;
    var source = content.nodeType ? content[0].outerHTML : content;
    return this.each(function (i, ele) {
        ele.innerHTML = source;
    });
}; // @require core/cash.js
// @require collection/each.js
fn.insertAfter = function (content) {
    var _this5 = this;
    cash(content).each(function (index, ele) {
        var parent = ele.parentNode;
        _this5.each(function (i, e) {
            parent.insertBefore(!index ? e : e.cloneNode(true), ele.nextSibling);
        });
    });
    return this;
}; // @require core/cash.js
// @require core/each.js
// @require core/variables.js
// @require collection/slice.js
// @require ./insert_after.js
fn.after = function () {
    var _this6 = this;
    each(reverse.apply(arguments), function (content) {
        reverse.apply(cash(content).slice()).insertAfter(_this6);
    });
    return this;
}; // @require core/cash.js
// @require collection/each.js
fn.insertBefore = function (selector) {
    var _this7 = this;
    cash(selector).each(function (index, ele) {
        var parent = ele.parentNode;
        _this7.each(function (i, e) {
            parent.insertBefore(!index ? e : e.cloneNode(true), ele);
        });
    });
    return this;
}; // @require core/cash.js
// @require core/each.js
// @require ./insert_before.js
fn.before = function () {
    var _this8 = this;
    each(arguments, function (content) {
        cash(content).insertBefore(_this8);
    });
    return this;
}; // @require core/cash.js
// @require core/each.js
// @require ./helpers/insert_content.js
fn.prepend = function () {
    var _this9 = this;
    each(arguments, function (content) {
        insertContent(_this9, content, true);
    });
    return this;
}; // @require core/cash.js
// @require core/variables.js
// @require collection/slice.js
// @require ./helpers/insert_content.js
fn.prependTo = function (parent) {
    insertContent(cash(parent), reverse.apply(this.slice()), true);
    return this;
}; // @require core/cash.js
// @require events/off.js
// @require ./detach.js
fn.remove = function () {
    return this.detach().off();
}; // @require core/cash.js
// @require collection/each.js
// @require collection/slice.js
// @require ./after.js
// @require ./remove.js
fn.replaceWith = function (content) {
    var _this10 = this;
    return this.each(function (i, ele) {
        var parent = ele.parentNode;
        if (!parent)
            return;
        var $eles = i ? cash(content).clone() : cash(content);
        if (!$eles[0]) {
            _this10.remove();
            return false;
        }
        parent.replaceChild($eles[0], ele);
        cash($eles[0]).after($eles.slice(1));
    });
}; // @require core/cash.js
// @require ./replace_with.js
fn.replaceAll = function (content) {
    cash(content).replaceWith(this);
    return this;
}; // @require core/cash.js
// @require collection/each.js
fn.text = function (content) {
    if (content === undefined)
        return this[0] ? this[0].textContent : '';
    return this.each(function (i, ele) {
        ele.textContent = content;
    });
}; // @optional ./after.js
// @optional ./append.js
// @optional ./append_to.js
// @optional ./before.js
// @optional ./clone.js
// @optional ./detach.js
// @optional ./empty.js
// @optional ./html.js
// @optional ./insert_after.js
// @optional ./insert_before.js
// @optional ./prepend.js
// @optional ./prepend_to.js
// @optional ./remove.js
// @optional ./replace_all.js
// @optional ./replace_with.js
// @optional ./text.js
// @require core/cash.js
// @require core/variables.js
var docEle = doc && doc.documentElement;
fn.offset = function () {
    var ele = this[0];
    if (!ele)
        return;
    var rect = ele.getBoundingClientRect();
    return {
        top: rect.top + win.pageYOffset - docEle.clientTop,
        left: rect.left + win.pageXOffset - docEle.clientLeft,
    };
}; // @require core/cash.js
fn.offsetParent = function () {
    return cash(this[0] && this[0].offsetParent);
}; // @require core/cash.js
fn.position = function () {
    var ele = this[0];
    if (!ele)
        return;
    return {
        left: ele.offsetLeft,
        top: ele.offsetTop,
    };
}; // @optional ./offset.js
// @optional ./offset_parent.js
// @optional ./position.js
// @require core/cash.js
// @require core/matches.js
// @require core/unique.js
// @require collection/each.js
// @require collection/filter.js
fn.children = function (selector) {
    var result = [];
    this.each(function (i, ele) {
        push.apply(result, ele.children);
    });
    result = cash(unique(result));
    if (!selector)
        return result;
    return result.filter(function (i, ele) {
        return matches(ele, selector);
    });
}; // @require core/cash.js
// @require core/unique.js
// @require collection/each.js
fn.contents = function () {
    var result = [];
    this.each(function (i, ele) {
        push.apply(result, ele.tagName === 'IFRAME' ? [ele.contentDocument] : ele.childNodes);
    });
    return cash(result.length && unique(result));
}; // @require core/cash.js
// @require core/unique.js
// @require core/find.js
// @require core/variables.js
fn.find = function (selector) {
    var result = [];
    for (var i = 0, l = this.length; i < l; i++) {
        var found = find(selector, this[i]);
        if (found.length) {
            push.apply(result, found);
        }
    }
    return cash(result.length && unique(result));
}; // @require core/cash.js
// @require core/find.js
// @require core/type_checking.js
// @require collection/filter.js
fn.has = function (selector) {
    var comparator = isString(selector)
        ? function (i, ele) {
            return !!find(selector, ele).length;
        }
        : function (i, ele) {
            return ele.contains(selector);
        };
    return this.filter(comparator);
}; // @require core/cash.js
// @require core/get_compare_function.js
// @require collection/each.js
fn.is = function (selector) {
    if (!selector || !this[0])
        return false;
    var comparator = getCompareFunction(selector);
    var check = false;
    this.each(function (i, ele) {
        check = comparator(i, ele, selector);
        return !check;
    });
    return check;
}; // @require core/cash.js
fn.next = function () {
    return cash(this[0] && this[0].nextElementSibling);
}; // @require core/cash.js
// @require core/get_compare_function.js
// @require collection/filter.js
fn.not = function (selector) {
    if (!selector || !this[0])
        return this;
    var comparator = getCompareFunction(selector);
    return this.filter(function (i, ele) {
        return !comparator(i, ele, selector);
    });
}; // @require core/cash.js
// @require core/unique.js
// @require collection/each.js
fn.parent = function () {
    var result = [];
    this.each(function (i, ele) {
        if (ele && ele.parentNode) {
            result.push(ele.parentNode);
        }
    });
    return cash(unique(result));
}; // @require core/cash.js
// @require core/variables.js
// @require traversal/children.js
// @require traversal/parent.js
// @require ./get.js
//FIXME Ugly file name, is there a better option?
fn.index = function (ele) {
    var child = ele ? cash(ele)[0] : this[0], collection = ele ? this : cash(child).parent().children();
    return indexOf.call(collection, child);
}; // @optional ./add.js
// @optional ./each.js
// @optional ./eq.js
// @optional ./filter.js
// @optional ./first.js
// @optional ./get.js
// @optional ./indexFn.js
// @optional ./last.js
// @optional ./map.js
// @optional ./slice.js
// @require core/cash.js
// @require collection/filter.js
// @require ./is.js
// @require ./parent.js
fn.closest = function (selector) {
    if (!selector || !this[0])
        return cash();
    if (this.is(selector))
        return this.filter(selector);
    return this.parent().closest(selector);
}; // @require core/cash.js
// @require core/matches.js
// @require core/unique.js
// @require core/variables.js
// @require collection/each.js
fn.parents = function (selector) {
    var result = [];
    var last;
    this.each(function (i, ele) {
        last = ele;
        while (last && last.parentNode && last !== doc.body.parentNode) {
            last = last.parentNode;
            if (!selector || (selector && matches(last, selector))) {
                result.push(last);
            }
        }
    });
    return cash(unique(result));
}; // @require core/cash.js
fn.prev = function () {
    return cash(this[0] && this[0].previousElementSibling);
}; // @require core/cash.js
// @require collection/filter.js
// @require ./children.js
// @require ./parent.js
fn.siblings = function () {
    var ele = this[0];
    return this.parent()
        .children()
        .filter(function (i, child) {
        return child !== ele;
    });
}; // @optional ./children.js
// @optional ./closest.js
// @optional ./contents.js
// @optional ./find.js
// @optional ./has.js
// @optional ./is.js
// @optional ./next.js
// @optional ./not.js
// @optional ./parent.js
// @optional ./parents.js
// @optional ./prev.js
// @optional ./siblings.js
// @optional attributes/index.js
// @optional collection/index.js
// @optional css/index.js
// @optional data/index.js
// @optional dimensions/index.js
// @optional events/index.js
// @optional forms/index.js
// @optional manipulation/index.js
// @optional offset/index.js
// @optional traversal/index.js
// @require core/index.js
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cash);


/***/ }),

/***/ 968:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $Q: () => (/* binding */ appendAtIndex),
/* harmony export */   BM: () => (/* binding */ isTextNode),
/* harmony export */   FW: () => (/* binding */ attrUp),
/* harmony export */   G1: () => (/* binding */ motionsEv),
/* harmony export */   GX: () => (/* binding */ getDocumentScroll),
/* harmony export */   L_: () => (/* binding */ removeEl),
/* harmony export */   Mx: () => (/* binding */ isDoc),
/* harmony export */   R3: () => (/* binding */ append),
/* harmony export */   S1: () => (/* binding */ off),
/* harmony export */   SJ: () => (/* binding */ appendVNodes),
/* harmony export */   Ut: () => (/* binding */ getElRect),
/* harmony export */   VB: () => (/* binding */ getPointerEvent),
/* harmony export */   Vb: () => (/* binding */ hasModifierKey),
/* harmony export */   cx: () => (/* binding */ cx),
/* harmony export */   dL: () => (/* binding */ replaceWith),
/* harmony export */   kl: () => (/* binding */ isEscKey),
/* harmony export */   o5: () => (/* binding */ isTaggableNode),
/* harmony export */   on: () => (/* binding */ on),
/* harmony export */   pn: () => (/* binding */ isVisible),
/* harmony export */   r$: () => (/* binding */ isEnterKey),
/* harmony export */   rw: () => (/* binding */ createText),
/* harmony export */   sE: () => (/* binding */ find),
/* harmony export */   sN: () => (/* binding */ getKeyChar),
/* harmony export */   t3: () => (/* binding */ createCustomEvent),
/* harmony export */   ut: () => (/* binding */ createEl)
/* harmony export */ });
/* unused harmony exports empty, isCommentNode, getKeyCode, hasCtrlKey */
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

var KEY_TAG = 'tag';
var KEY_ATTR = 'attributes';
var KEY_CHILD = 'children';
var motionsEv = 'transitionend oTransitionEnd transitionend webkitTransitionEnd';
var isDoc = function (el) { return (el === null || el === void 0 ? void 0 : el.nodeType) === Node.DOCUMENT_NODE; };
var removeEl = function (el) {
    var parent = el && el.parentNode;
    parent && parent.removeChild(el);
};
function cx() {
    var inputs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        inputs[_i] = arguments[_i];
    }
    var inp = Array.isArray(inputs[0]) ? inputs[0] : __spreadArray([], inputs, true);
    return inp.filter(Boolean).join(' ');
}
var find = function (el, query) { return el.querySelectorAll(query); };
var attrUp = function (el, attrs) {
    if (attrs === void 0) { attrs = {}; }
    return el && el.setAttribute && (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(attrs, function (value, key) { return el.setAttribute(key, value); });
};
var isVisible = function (el) {
    return el && !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
};
var empty = function (node) {
    while (node.firstChild)
        node.removeChild(node.firstChild);
};
var replaceWith = function (oldEl, newEl) {
    var _a;
    (_a = oldEl.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(newEl, oldEl);
};
var appendAtIndex = function (parent, child, index) {
    var childNodes = parent.childNodes;
    var total = childNodes.length;
    var at = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(index) ? total : index;
    if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isString)(child)) {
        // @ts-ignore
        parent.insertAdjacentHTML('beforeEnd', child);
        child = parent.lastChild;
        parent.removeChild(child);
    }
    if (at >= total) {
        parent.appendChild(child);
    }
    else {
        parent.insertBefore(child, childNodes[at]);
    }
};
var append = function (parent, child) { return appendAtIndex(parent, child); };
var createEl = function (tag, attrs, child) {
    if (attrs === void 0) { attrs = {}; }
    var el = document.createElement(tag);
    attrs && (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(attrs, function (value, key) { return el.setAttribute(key, value); });
    if (child) {
        if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isString)(child))
            el.innerHTML = child;
        else
            el.appendChild(child);
    }
    return el;
};
var createText = function (str) { return document.createTextNode(str); };
// Unfortunately just creating `KeyboardEvent(e.type, e)` is not enough,
// the keyCode/which will be always `0`. Even if it's an old/deprecated
// property keymaster (and many others) still use it... using `defineProperty`
// hack seems the only way
var createCustomEvent = function (e, cls) {
    var oEvent;
    var type = e.type;
    try {
        // @ts-ignore
        oEvent = new window[cls](type, e);
    }
    catch (err) {
        oEvent = document.createEvent(cls);
        oEvent.initEvent(type, true, true);
    }
    oEvent._parentEvent = e;
    if (type.indexOf('key') === 0) {
        oEvent.keyCodeVal = e.keyCode;
        ['keyCode', 'which'].forEach(function (prop) {
            Object.defineProperty(oEvent, prop, {
                get: function () {
                    return this.keyCodeVal;
                },
            });
        });
    }
    return oEvent;
};
/**
 * Append an array of vNodes to an element
 * @param {HTMLElement} node HTML element
 * @param {Array} vNodes Array of node objects
 */
var appendVNodes = function (node, vNodes) {
    if (vNodes === void 0) { vNodes = []; }
    var vNodesArr = Array.isArray(vNodes) ? vNodes : [vNodes];
    vNodesArr.forEach(function (vnode) {
        var tag = vnode[KEY_TAG] || 'div';
        var attr = vnode[KEY_ATTR] || {};
        var el = document.createElement(tag);
        (0,underscore__WEBPACK_IMPORTED_MODULE_0__.each)(attr, function (value, key) {
            el.setAttribute(key, value);
        });
        node.appendChild(el);
    });
};
/**
 * Check if element is a text node
 * @param  {Node} el
 * @return {Boolean}
 */
var isTextNode = function (el) { return (el === null || el === void 0 ? void 0 : el.nodeType) === Node.TEXT_NODE; };
/**
 * Check if element is a comment node
 * @param  {Node} el
 * @return {Boolean}
 */
var isCommentNode = function (el) { return (el === null || el === void 0 ? void 0 : el.nodeType) === Node.COMMENT_NODE; };
/**
 * Check if taggable node
 * @param  {Node} el
 * @return {Boolean}
 */
var isTaggableNode = function (el) { return el && !isTextNode(el) && !isCommentNode(el); };
/**
 * Get DOMRect of the element.
 * @param el
 * @returns {DOMRect}
 */
var getElRect = function (el) {
    var def = {
        top: 0,
        left: 0,
        width: 0,
        height: 0,
    };
    if (!el)
        return def;
    var rectText;
    if (isTextNode(el)) {
        var range = document.createRange();
        range.selectNode(el);
        rectText = range.getBoundingClientRect();
        range.detach();
    }
    return rectText || (el.getBoundingClientRect ? el.getBoundingClientRect() : def);
};
/**
 * Get document scroll coordinates
 */
var getDocumentScroll = function (el) {
    var doc = (el === null || el === void 0 ? void 0 : el.ownerDocument) || document;
    var docEl = doc.documentElement;
    var win = doc.defaultView || window;
    return {
        x: (win.pageXOffset || docEl.scrollLeft || 0) - (docEl.clientLeft || 0),
        y: (win.pageYOffset || docEl.scrollTop || 0) - (docEl.clientTop || 0),
    };
};
var getKeyCode = function (ev) { return ev.which || ev.keyCode; };
var getKeyChar = function (ev) { return String.fromCharCode(getKeyCode(ev)); };
var getPointerEvent = function (ev) { return (ev.touches && ev.touches[0] ? ev.touches[0] : ev); };
var isEscKey = function (ev) { return getKeyCode(ev) === 27; };
var isEnterKey = function (ev) { return getKeyCode(ev) === 13; };
var hasCtrlKey = function (ev) { return ev.ctrlKey; };
var hasModifierKey = function (ev) { return hasCtrlKey(ev) || ev.metaKey; };
var on = function (el, ev, fn, opts) {
    var evs = ev.split(/\s+/);
    var els = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isArray)(el) ? el : [el];
    evs.forEach(function (ev) {
        els.forEach(function (el) { return el === null || el === void 0 ? void 0 : el.addEventListener(ev, fn, opts); });
    });
};
var off = function (el, ev, fn, opts) {
    var evs = ev.split(/\s+/);
    var els = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isArray)(el) ? el : [el];
    evs.forEach(function (ev) {
        els.forEach(function (el) { return el === null || el === void 0 ? void 0 : el.removeEventListener(ev, fn, opts); });
    });
};


/***/ }),

/***/ 283:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   appendStyles: () => (/* binding */ appendStyles),
/* harmony export */   buildBase64UrlFromSvg: () => (/* binding */ buildBase64UrlFromSvg),
/* harmony export */   camelCase: () => (/* binding */ camelCase),
/* harmony export */   capitalize: () => (/* binding */ capitalize),
/* harmony export */   createId: () => (/* binding */ createId),
/* harmony export */   deepMerge: () => (/* binding */ deepMerge),
/* harmony export */   escape: () => (/* binding */ escape),
/* harmony export */   escapeNodeContent: () => (/* binding */ escapeNodeContent),
/* harmony export */   find: () => (/* binding */ find),
/* harmony export */   getComponentModel: () => (/* binding */ getComponentModel),
/* harmony export */   getComponentView: () => (/* binding */ getComponentView),
/* harmony export */   getElement: () => (/* binding */ getElement),
/* harmony export */   getGlobal: () => (/* binding */ getGlobal),
/* harmony export */   getModel: () => (/* binding */ getModel),
/* harmony export */   getUiClass: () => (/* binding */ getUiClass),
/* harmony export */   getUnitFromValue: () => (/* binding */ getUnitFromValue),
/* harmony export */   getViewEl: () => (/* binding */ getViewEl),
/* harmony export */   hasDnd: () => (/* binding */ hasDnd),
/* harmony export */   hasWin: () => (/* binding */ hasWin),
/* harmony export */   isBultInMethod: () => (/* binding */ isBultInMethod),
/* harmony export */   isComponent: () => (/* binding */ isComponent),
/* harmony export */   isDef: () => (/* binding */ isDef),
/* harmony export */   isEmptyObj: () => (/* binding */ isEmptyObj),
/* harmony export */   isObject: () => (/* binding */ isObject),
/* harmony export */   isRule: () => (/* binding */ isRule),
/* harmony export */   matches: () => (/* binding */ matches),
/* harmony export */   normalizeFloat: () => (/* binding */ normalizeFloat),
/* harmony export */   normalizeKey: () => (/* binding */ normalizeKey),
/* harmony export */   setViewEl: () => (/* binding */ setViewEl),
/* harmony export */   shallowDiff: () => (/* binding */ shallowDiff),
/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),
/* harmony export */   upFirst: () => (/* binding */ upFirst),
/* harmony export */   wait: () => (/* binding */ wait)
/* harmony export */ });
/* harmony import */ var underscore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(968);
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


var obj = {};
var isBultInMethod = function (key) { return (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isFunction)(obj[key]); };
var normalizeKey = function (key) { return (isBultInMethod(key) ? "_".concat(key) : key); };
var wait = function (mls) {
    if (mls === void 0) { mls = 0; }
    return new Promise(function (res) { return setTimeout(res, mls); });
};
var isDef = function (value) { return typeof value !== 'undefined'; };
var hasWin = function () { return typeof window !== 'undefined'; };
var getGlobal = function () {
    return typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : __webpack_require__.g;
};
var toLowerCase = function (str) { return (str || '').toLowerCase(); };
var elProt = hasWin() ? window.Element.prototype : {};
// @ts-ignore
var matches = elProt.matches || elProt.webkitMatchesSelector || elProt.mozMatchesSelector || elProt.msMatchesSelector;
var getUiClass = function (em, defCls) {
    var _a = em.getConfig(), stylePrefix = _a.stylePrefix, customUI = _a.customUI;
    return [customUI && "".concat(stylePrefix, "cui"), defCls].filter(function (i) { return i; }).join(' ');
};
/**
 * Import styles asynchronously
 * @param {String|Array<String>} styles
 */
var appendStyles = function (styles, opts) {
    if (opts === void 0) { opts = {}; }
    var stls = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isArray)(styles) ? __spreadArray([], styles, true) : [styles];
    if (stls.length) {
        var href = stls.shift();
        if (href && (!opts.unique || !document.querySelector("link[href=\"".concat(href, "\"]")))) {
            var head = document.head;
            var link = document.createElement('link');
            link.href = href;
            link.rel = 'stylesheet';
            if (opts.prepand) {
                head.insertBefore(link, head.firstChild);
            }
            else {
                head.appendChild(link);
            }
        }
        appendStyles(stls);
    }
};
/**
 * Returns shallow diff between 2 objects
 * @param  {Object} objOrig
 * @param  {Objec} objNew
 * @return {Object}
 * @example
 * var a = {foo: 'bar', baz: 1, faz: 'sop'};
 * var b = {foo: 'bar', baz: 2, bar: ''};
 * shallowDiff(a, b);
 * // -> {baz: 2, faz: null, bar: ''};
 */
var shallowDiff = function (objOrig, objNew) {
    var result = {};
    var keysNew = (0,underscore__WEBPACK_IMPORTED_MODULE_0__.keys)(objNew);
    for (var prop in objOrig) {
        if (objOrig.hasOwnProperty(prop)) {
            var origValue = objOrig[prop];
            var newValue = objNew[prop];
            if (keysNew.indexOf(prop) >= 0) {
                if (origValue !== newValue) {
                    result[prop] = newValue;
                }
            }
            else {
                result[prop] = null;
            }
        }
    }
    for (var prop in objNew) {
        if (objNew.hasOwnProperty(prop)) {
            if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isUndefined)(objOrig[prop])) {
                result[prop] = objNew[prop];
            }
        }
    }
    return result;
};
var getUnitFromValue = function (value) {
    return value.replace(parseFloat(value), '');
};
var upFirst = function (value) { return value[0].toUpperCase() + value.toLowerCase().slice(1); };
var camelCase = function (value) {
    return value.replace(/-./g, function (x) { return x[1].toUpperCase(); });
};
var normalizeFloat = function (value, step, valueDef) {
    if (step === void 0) { step = 1; }
    if (valueDef === void 0) { valueDef = 0; }
    var stepDecimals = 0;
    if (isNaN(value))
        return valueDef;
    value = parseFloat(value);
    if (Math.floor(value) !== value) {
        var side = step.toString().split('.')[1];
        stepDecimals = side ? side.length : 0;
    }
    return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
};
var hasDnd = function (em) {
    return 'draggable' in document.createElement('i') && (em ? em.config.nativeDnD : true);
};
/**
 * Ensure to fetch the element from the input argument
 * @param  {HTMLElement|Component} el Component or HTML element
 * @return {HTMLElement}
 */
var getElement = function (el) {
    if ((0,underscore__WEBPACK_IMPORTED_MODULE_0__.isElement)(el) || (0,_dom__WEBPACK_IMPORTED_MODULE_1__/* .isTextNode */ .BM)(el)) {
        return el;
        // @ts-ignore
    }
    else if (el && el.getEl) {
        // @ts-ignore
        return el.getEl();
    }
};
var find = function (arr, test) {
    var result = null;
    arr.some(function (el, i) { return (test(el, i, arr) ? ((result = el), 1) : 0); });
    return result;
};
var escape = function (str) {
    if (str === void 0) { str = ''; }
    return "".concat(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;')
        .replace(/`/g, '&#96;');
};
var escapeNodeContent = function (str) {
    if (str === void 0) { str = ''; }
    return "".concat(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
};
var deepMerge = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var target = __assign({}, args[0]);
    for (var i = 1; i < args.length; i++) {
        var source = __assign({}, args[i]);
        for (var key in source) {
            var targValue = target[key];
            var srcValue = source[key];
            if (isObject(targValue) && isObject(srcValue)) {
                target[key] = deepMerge(targValue, srcValue);
            }
            else {
                target[key] = srcValue;
            }
        }
    }
    return target;
};
/**
 * Ensure to fetch the model from the input argument
 * @param  {HTMLElement|Component} el Component or HTML element
 * @return {Component}
 */
var getModel = function (el, $) {
    var model;
    if (!$ && el && el.__cashData) {
        model = el.__cashData.model;
    }
    else if ($ && (0,underscore__WEBPACK_IMPORTED_MODULE_0__.isElement)(el)) {
        model = $(el).data('model');
    }
    return model;
};
var isObject = function (val) { return val && !Array.isArray(val) && typeof val === 'object'; };
var isEmptyObj = function (val) { return Object.keys(val).length <= 0; };
var capitalize = function (str) {
    if (str === void 0) { str = ''; }
    return str && str.charAt(0).toUpperCase() + str.substring(1);
};
var isRule = function (obj) { return obj && obj.toCSS; };
var getViewEl = function (el) { return el === null || el === void 0 ? void 0 : el.__gjsv; };
var isComponent = function (obj) { return !!(obj === null || obj === void 0 ? void 0 : obj.toHTML); };
var getComponentView = function (el) { return getViewEl(el); };
var getComponentModel = function (el) { var _a; return (_a = getComponentView(el)) === null || _a === void 0 ? void 0 : _a.model; };
var setViewEl = function (el, view) {
    el.__gjsv = view;
};
var createId = function (length) {
    if (length === void 0) { length = 16; }
    var result = '';
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var len = chars.length;
    for (var i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * len));
    }
    return result;
};
var buildBase64UrlFromSvg = function (svg) {
    if (svg && svg.substr(0, 4) === '<svg') {
        var base64Str = '';
        if (hasWin()) {
            base64Str = window.btoa(svg);
        }
        else if (typeof Buffer !== 'undefined') {
            base64Str = Buffer.from(svg, 'utf8').toString('base64');
        }
        return base64Str ? "data:image/svg+xml;base64,".concat(base64Str) : svg;
    }
    return svg;
};



/***/ }),

/***/ 828:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
<<<<<<< HEAD
	"./CanvasClear": 266,
	"./CanvasClear.ts": 266,
	"./CanvasMove": 142,
	"./CanvasMove.ts": 142,
	"./CommandAbstract": 458,
	"./CommandAbstract.ts": 458,
	"./ComponentDelete": 463,
	"./ComponentDelete.ts": 463,
	"./ComponentDrag": 474,
	"./ComponentDrag.ts": 474,
	"./ComponentEnter": 866,
	"./ComponentEnter.ts": 866,
	"./ComponentExit": 594,
	"./ComponentExit.ts": 594,
	"./ComponentNext": 656,
	"./ComponentNext.ts": 656,
	"./ComponentPrev": 768,
	"./ComponentPrev.ts": 768,
	"./ComponentStyleClear": 570,
	"./ComponentStyleClear.ts": 570,
	"./CopyComponent": 282,
	"./CopyComponent.ts": 282,
	"./ExportTemplate": 905,
	"./ExportTemplate.ts": 905,
	"./Fullscreen": 212,
	"./Fullscreen.ts": 212,
	"./MoveComponent": 907,
	"./MoveComponent.ts": 907,
	"./OpenAssets": 963,
	"./OpenAssets.ts": 963,
	"./OpenBlocks": 268,
	"./OpenBlocks.ts": 268,
	"./OpenLayers": 556,
	"./OpenLayers.ts": 556,
	"./OpenPages": 120,
	"./OpenPages.ts": 120,
	"./OpenStyleManager": 462,
	"./OpenStyleManager.ts": 462,
	"./OpenTraitManager": 521,
	"./OpenTraitManager.ts": 521,
	"./PasteComponent": 133,
	"./PasteComponent.ts": 133,
	"./Preview": 931,
	"./Preview.ts": 931,
	"./Resize": 676,
	"./Resize.ts": 676,
	"./SelectComponent": 938,
	"./SelectComponent.ts": 938,
	"./SelectPosition": 477,
	"./SelectPosition.ts": 477,
	"./ShowOffset": 886,
	"./ShowOffset.ts": 886,
	"./SwitchVisibility": 817,
	"./SwitchVisibility.ts": 817
=======
	"./CanvasClear": 858,
	"./CanvasClear.ts": 858,
	"./CanvasMove": 884,
	"./CanvasMove.ts": 884,
	"./CommandAbstract": 790,
	"./CommandAbstract.ts": 790,
	"./ComponentDelete": 180,
	"./ComponentDelete.ts": 180,
	"./ComponentDrag": 544,
	"./ComponentDrag.ts": 544,
	"./ComponentEnter": 236,
	"./ComponentEnter.ts": 236,
	"./ComponentExit": 368,
	"./ComponentExit.ts": 368,
	"./ComponentNext": 243,
	"./ComponentNext.ts": 243,
	"./ComponentPrev": 400,
	"./ComponentPrev.ts": 400,
	"./ComponentStyleClear": 910,
	"./ComponentStyleClear.ts": 910,
	"./CopyComponent": 744,
	"./CopyComponent.ts": 744,
	"./ExportTemplate": 457,
	"./ExportTemplate.ts": 457,
	"./Fullscreen": 975,
	"./Fullscreen.ts": 975,
	"./MoveComponent": 191,
	"./MoveComponent.ts": 191,
	"./OpenAssets": 912,
	"./OpenAssets.ts": 912,
	"./OpenBlocks": 117,
	"./OpenBlocks.ts": 117,
	"./OpenLayers": 614,
	"./OpenLayers.ts": 614,
	"./OpenStyleManager": 801,
	"./OpenStyleManager.ts": 801,
	"./OpenTraitManager": 395,
	"./OpenTraitManager.ts": 395,
	"./PasteComponent": 98,
	"./PasteComponent.ts": 98,
	"./Preview": 129,
	"./Preview.ts": 129,
	"./Resize": 116,
	"./Resize.ts": 116,
	"./SelectComponent": 407,
	"./SelectComponent.ts": 407,
	"./SelectPosition": 189,
	"./SelectPosition.ts": 189,
	"./ShowOffset": 804,
	"./ShowOffset.ts": 804,
	"./SwitchVisibility": 434,
	"./SwitchVisibility.ts": 434
>>>>>>> script-module
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 828;

/***/ }),

/***/ 50:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  VERSION: () => (/* reexport */ VERSION),
  after: () => (/* reexport */ after),
  all: () => (/* reexport */ every),
  allKeys: () => (/* reexport */ allKeys),
  any: () => (/* reexport */ some),
  assign: () => (/* reexport */ extendOwn),
  before: () => (/* reexport */ before),
  bind: () => (/* reexport */ bind),
  bindAll: () => (/* reexport */ bindAll),
  chain: () => (/* reexport */ chain),
  chunk: () => (/* reexport */ chunk),
  clone: () => (/* reexport */ clone),
  collect: () => (/* reexport */ map),
  compact: () => (/* reexport */ compact),
  compose: () => (/* reexport */ compose),
  constant: () => (/* reexport */ constant),
  contains: () => (/* reexport */ contains),
  countBy: () => (/* reexport */ countBy),
  create: () => (/* reexport */ create),
  debounce: () => (/* reexport */ debounce),
  "default": () => (/* reexport */ index_default),
  defaults: () => (/* reexport */ defaults),
  defer: () => (/* reexport */ defer),
  delay: () => (/* reexport */ delay),
  detect: () => (/* reexport */ find),
  difference: () => (/* reexport */ difference),
  drop: () => (/* reexport */ rest),
  each: () => (/* reexport */ each),
  escape: () => (/* reexport */ modules_escape),
  every: () => (/* reexport */ every),
  extend: () => (/* reexport */ extend),
  extendOwn: () => (/* reexport */ extendOwn),
  filter: () => (/* reexport */ filter),
  find: () => (/* reexport */ find),
  findIndex: () => (/* reexport */ findIndex),
  findKey: () => (/* reexport */ findKey),
  findLastIndex: () => (/* reexport */ findLastIndex),
  findWhere: () => (/* reexport */ findWhere),
  first: () => (/* reexport */ first),
  flatten: () => (/* reexport */ flatten_flatten),
  foldl: () => (/* reexport */ reduce),
  foldr: () => (/* reexport */ reduceRight),
  forEach: () => (/* reexport */ each),
  functions: () => (/* reexport */ functions),
  get: () => (/* reexport */ get),
  groupBy: () => (/* reexport */ groupBy),
  has: () => (/* reexport */ has_has),
  head: () => (/* reexport */ first),
  identity: () => (/* reexport */ identity),
  include: () => (/* reexport */ contains),
  includes: () => (/* reexport */ contains),
  indexBy: () => (/* reexport */ indexBy),
  indexOf: () => (/* reexport */ indexOf),
  initial: () => (/* reexport */ initial),
  inject: () => (/* reexport */ reduce),
  intersection: () => (/* reexport */ intersection),
  invert: () => (/* reexport */ invert),
  invoke: () => (/* reexport */ invoke),
  isArguments: () => (/* reexport */ modules_isArguments),
  isArray: () => (/* reexport */ isArray),
  isArrayBuffer: () => (/* reexport */ isArrayBuffer),
  isBoolean: () => (/* reexport */ isBoolean),
  isDataView: () => (/* reexport */ modules_isDataView),
  isDate: () => (/* reexport */ isDate),
  isElement: () => (/* reexport */ isElement),
  isEmpty: () => (/* reexport */ isEmpty),
  isEqual: () => (/* reexport */ isEqual),
  isError: () => (/* reexport */ isError),
  isFinite: () => (/* reexport */ isFinite_isFinite),
  isFunction: () => (/* reexport */ modules_isFunction),
  isMap: () => (/* reexport */ isMap),
  isMatch: () => (/* reexport */ isMatch),
  isNaN: () => (/* reexport */ isNaN_isNaN),
  isNull: () => (/* reexport */ isNull),
  isNumber: () => (/* reexport */ isNumber),
  isObject: () => (/* reexport */ isObject),
  isRegExp: () => (/* reexport */ isRegExp),
  isSet: () => (/* reexport */ isSet),
  isString: () => (/* reexport */ isString),
  isSymbol: () => (/* reexport */ isSymbol),
  isTypedArray: () => (/* reexport */ modules_isTypedArray),
  isUndefined: () => (/* reexport */ isUndefined),
  isWeakMap: () => (/* reexport */ isWeakMap),
  isWeakSet: () => (/* reexport */ isWeakSet),
  iteratee: () => (/* reexport */ iteratee),
  keys: () => (/* reexport */ keys),
  last: () => (/* reexport */ last),
  lastIndexOf: () => (/* reexport */ lastIndexOf),
  map: () => (/* reexport */ map),
  mapObject: () => (/* reexport */ mapObject),
  matcher: () => (/* reexport */ matcher),
  matches: () => (/* reexport */ matcher),
  max: () => (/* reexport */ max),
  memoize: () => (/* reexport */ memoize),
  methods: () => (/* reexport */ functions),
  min: () => (/* reexport */ min),
  mixin: () => (/* reexport */ mixin),
  negate: () => (/* reexport */ negate),
  noop: () => (/* reexport */ noop),
  now: () => (/* reexport */ now),
  object: () => (/* reexport */ object),
  omit: () => (/* reexport */ omit),
  once: () => (/* reexport */ once),
  pairs: () => (/* reexport */ pairs),
  partial: () => (/* reexport */ modules_partial),
  partition: () => (/* reexport */ partition),
  pick: () => (/* reexport */ pick),
  pluck: () => (/* reexport */ pluck),
  property: () => (/* reexport */ property),
  propertyOf: () => (/* reexport */ propertyOf),
  random: () => (/* reexport */ random),
  range: () => (/* reexport */ range),
  reduce: () => (/* reexport */ reduce),
  reduceRight: () => (/* reexport */ reduceRight),
  reject: () => (/* reexport */ reject),
  rest: () => (/* reexport */ rest),
  restArguments: () => (/* reexport */ restArguments),
  result: () => (/* reexport */ result),
  sample: () => (/* reexport */ sample),
  select: () => (/* reexport */ filter),
  shuffle: () => (/* reexport */ shuffle),
  size: () => (/* reexport */ size),
  some: () => (/* reexport */ some),
  sortBy: () => (/* reexport */ sortBy),
  sortedIndex: () => (/* reexport */ sortedIndex),
  tail: () => (/* reexport */ rest),
  take: () => (/* reexport */ first),
  tap: () => (/* reexport */ tap),
  template: () => (/* reexport */ template),
  templateSettings: () => (/* reexport */ templateSettings),
  throttle: () => (/* reexport */ throttle),
  times: () => (/* reexport */ times),
  toArray: () => (/* reexport */ toArray),
  toPath: () => (/* reexport */ toPath),
  transpose: () => (/* reexport */ unzip),
  unescape: () => (/* reexport */ modules_unescape),
  union: () => (/* reexport */ union),
  uniq: () => (/* reexport */ uniq),
  unique: () => (/* reexport */ uniq),
  uniqueId: () => (/* reexport */ uniqueId),
  unzip: () => (/* reexport */ unzip),
  values: () => (/* reexport */ values),
  where: () => (/* reexport */ where),
  without: () => (/* reexport */ without),
  wrap: () => (/* reexport */ wrap),
  zip: () => (/* reexport */ zip)
});

// NAMESPACE OBJECT: ./node_modules/underscore/modules/index.js
var modules_namespaceObject = {};
__webpack_require__.r(modules_namespaceObject);
__webpack_require__.d(modules_namespaceObject, {
  VERSION: () => (VERSION),
  after: () => (after),
  all: () => (every),
  allKeys: () => (allKeys),
  any: () => (some),
  assign: () => (extendOwn),
  before: () => (before),
  bind: () => (bind),
  bindAll: () => (bindAll),
  chain: () => (chain),
  chunk: () => (chunk),
  clone: () => (clone),
  collect: () => (map),
  compact: () => (compact),
  compose: () => (compose),
  constant: () => (constant),
  contains: () => (contains),
  countBy: () => (countBy),
  create: () => (create),
  debounce: () => (debounce),
  "default": () => (underscore_array_methods),
  defaults: () => (defaults),
  defer: () => (defer),
  delay: () => (delay),
  detect: () => (find),
  difference: () => (difference),
  drop: () => (rest),
  each: () => (each),
  escape: () => (modules_escape),
  every: () => (every),
  extend: () => (extend),
  extendOwn: () => (extendOwn),
  filter: () => (filter),
  find: () => (find),
  findIndex: () => (findIndex),
  findKey: () => (findKey),
  findLastIndex: () => (findLastIndex),
  findWhere: () => (findWhere),
  first: () => (first),
  flatten: () => (flatten_flatten),
  foldl: () => (reduce),
  foldr: () => (reduceRight),
  forEach: () => (each),
  functions: () => (functions),
  get: () => (get),
  groupBy: () => (groupBy),
  has: () => (has_has),
  head: () => (first),
  identity: () => (identity),
  include: () => (contains),
  includes: () => (contains),
  indexBy: () => (indexBy),
  indexOf: () => (indexOf),
  initial: () => (initial),
  inject: () => (reduce),
  intersection: () => (intersection),
  invert: () => (invert),
  invoke: () => (invoke),
  isArguments: () => (modules_isArguments),
  isArray: () => (isArray),
  isArrayBuffer: () => (isArrayBuffer),
  isBoolean: () => (isBoolean),
  isDataView: () => (modules_isDataView),
  isDate: () => (isDate),
  isElement: () => (isElement),
  isEmpty: () => (isEmpty),
  isEqual: () => (isEqual),
  isError: () => (isError),
  isFinite: () => (isFinite_isFinite),
  isFunction: () => (modules_isFunction),
  isMap: () => (isMap),
  isMatch: () => (isMatch),
  isNaN: () => (isNaN_isNaN),
  isNull: () => (isNull),
  isNumber: () => (isNumber),
  isObject: () => (isObject),
  isRegExp: () => (isRegExp),
  isSet: () => (isSet),
  isString: () => (isString),
  isSymbol: () => (isSymbol),
  isTypedArray: () => (modules_isTypedArray),
  isUndefined: () => (isUndefined),
  isWeakMap: () => (isWeakMap),
  isWeakSet: () => (isWeakSet),
  iteratee: () => (iteratee),
  keys: () => (keys),
  last: () => (last),
  lastIndexOf: () => (lastIndexOf),
  map: () => (map),
  mapObject: () => (mapObject),
  matcher: () => (matcher),
  matches: () => (matcher),
  max: () => (max),
  memoize: () => (memoize),
  methods: () => (functions),
  min: () => (min),
  mixin: () => (mixin),
  negate: () => (negate),
  noop: () => (noop),
  now: () => (now),
  object: () => (object),
  omit: () => (omit),
  once: () => (once),
  pairs: () => (pairs),
  partial: () => (modules_partial),
  partition: () => (partition),
  pick: () => (pick),
  pluck: () => (pluck),
  property: () => (property),
  propertyOf: () => (propertyOf),
  random: () => (random),
  range: () => (range),
  reduce: () => (reduce),
  reduceRight: () => (reduceRight),
  reject: () => (reject),
  rest: () => (rest),
  restArguments: () => (restArguments),
  result: () => (result),
  sample: () => (sample),
  select: () => (filter),
  shuffle: () => (shuffle),
  size: () => (size),
  some: () => (some),
  sortBy: () => (sortBy),
  sortedIndex: () => (sortedIndex),
  tail: () => (rest),
  take: () => (first),
  tap: () => (tap),
  template: () => (template),
  templateSettings: () => (templateSettings),
  throttle: () => (throttle),
  times: () => (times),
  toArray: () => (toArray),
  toPath: () => (toPath),
  transpose: () => (unzip),
  unescape: () => (modules_unescape),
  union: () => (union),
  uniq: () => (uniq),
  unique: () => (uniq),
  uniqueId: () => (uniqueId),
  unzip: () => (unzip),
  values: () => (values),
  where: () => (where),
  without: () => (without),
  wrap: () => (wrap),
  zip: () => (zip)
});

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_setup.js
// Current version.
var VERSION = '1.13.6';

// Establish the root object, `window` (`self`) in the browser, `global`
// on the server, or `this` in some virtual machines. We use `self`
// instead of `window` for `WebWorker` support.
var root = (typeof self == 'object' && self.self === self && self) ||
          (typeof global == 'object' && global.global === global && global) ||
          Function('return this')() ||
          {};

// Save bytes in the minified (but not gzipped) version:
var ArrayProto = Array.prototype, ObjProto = Object.prototype;
var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

// Create quick reference variables for speed access to core prototypes.
var push = ArrayProto.push,
    slice = ArrayProto.slice,
    _setup_toString = ObjProto.toString,
    _setup_hasOwnProperty = ObjProto.hasOwnProperty;

// Modern feature detection.
var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
    supportsDataView = typeof DataView !== 'undefined';

// All **ECMAScript 5+** native function implementations that we hope to use
// are declared here.
var nativeIsArray = Array.isArray,
    nativeKeys = Object.keys,
    nativeCreate = Object.create,
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

// Create references to these builtin functions because we override them.
var _isNaN = isNaN,
    _isFinite = isFinite;

// Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
  'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

// The largest integer that can be represented exactly.
var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

;// CONCATENATED MODULE: ./node_modules/underscore/modules/restArguments.js
// Some functions take a variable number of arguments, or a few expected
// arguments at the beginning and then a variable number of values to operate
// on. This helper accumulates all remaining arguments past the function’s
// argument length (or an explicit `startIndex`), into an array that becomes
// the last argument. Similar to ES6’s "rest parameter".
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0),
        rest = Array(length),
        index = 0;
    for (; index < length; index++) {
      rest[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, arguments[0], rest);
      case 2: return func.call(this, arguments[0], arguments[1], rest);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest;
    return func.apply(this, args);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isObject.js
// Is a given variable an object?
function isObject(obj) {
  var type = typeof obj;
  return type === 'function' || (type === 'object' && !!obj);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isNull.js
// Is a given value equal to null?
function isNull(obj) {
  return obj === null;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isUndefined.js
// Is a given variable undefined?
function isUndefined(obj) {
  return obj === void 0;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isBoolean.js


// Is a given value a boolean?
function isBoolean(obj) {
  return obj === true || obj === false || _setup_toString.call(obj) === '[object Boolean]';
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isElement.js
// Is a given value a DOM element?
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_tagTester.js


// Internal function for creating a `toString`-based type tester.
function tagTester(name) {
  var tag = '[object ' + name + ']';
  return function(obj) {
    return _setup_toString.call(obj) === tag;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isString.js


/* harmony default export */ const isString = (tagTester('String'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isNumber.js


/* harmony default export */ const isNumber = (tagTester('Number'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isDate.js


/* harmony default export */ const isDate = (tagTester('Date'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isRegExp.js


/* harmony default export */ const isRegExp = (tagTester('RegExp'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isError.js


/* harmony default export */ const isError = (tagTester('Error'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isSymbol.js


/* harmony default export */ const isSymbol = (tagTester('Symbol'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isArrayBuffer.js


/* harmony default export */ const isArrayBuffer = (tagTester('ArrayBuffer'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isFunction.js



var isFunction = tagTester('Function');

// Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
// v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
var nodelist = root.document && root.document.childNodes;
if ( true && typeof Int8Array != 'object' && typeof nodelist != 'function') {
  isFunction = function(obj) {
    return typeof obj == 'function' || false;
  };
}

/* harmony default export */ const modules_isFunction = (isFunction);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_hasObjectTag.js


/* harmony default export */ const _hasObjectTag = (tagTester('Object'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_stringTagBug.js



// In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
// In IE 11, the most common among them, this problem also applies to
// `Map`, `WeakMap` and `Set`.
var hasStringTagBug = (
      supportsDataView && _hasObjectTag(new DataView(new ArrayBuffer(8)))
    ),
    isIE11 = (typeof Map !== 'undefined' && _hasObjectTag(new Map));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isDataView.js





var isDataView = tagTester('DataView');

// In IE 10 - Edge 13, we need a different heuristic
// to determine whether an object is a `DataView`.
function ie10IsDataView(obj) {
  return obj != null && modules_isFunction(obj.getInt8) && isArrayBuffer(obj.buffer);
}

/* harmony default export */ const modules_isDataView = (hasStringTagBug ? ie10IsDataView : isDataView);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isArray.js



// Is a given value an array?
// Delegates to ECMA5's native `Array.isArray`.
/* harmony default export */ const isArray = (nativeIsArray || tagTester('Array'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_has.js


// Internal function to check whether `key` is an own property name of `obj`.
function has(obj, key) {
  return obj != null && _setup_hasOwnProperty.call(obj, key);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isArguments.js



var isArguments = tagTester('Arguments');

// Define a fallback version of the method in browsers (ahem, IE < 9), where
// there isn't any inspectable "Arguments" type.
(function() {
  if (!isArguments(arguments)) {
    isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }
}());

/* harmony default export */ const modules_isArguments = (isArguments);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isFinite.js



// Is a given object a finite number?
function isFinite_isFinite(obj) {
  return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isNaN.js



// Is the given value `NaN`?
function isNaN_isNaN(obj) {
  return isNumber(obj) && _isNaN(obj);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/constant.js
// Predicate-generating function. Often useful outside of Underscore.
function constant(value) {
  return function() {
    return value;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createSizePropertyCheck.js


// Common internal logic for `isArrayLike` and `isBufferLike`.
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  }
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_shallowProperty.js
// Internal helper to generate a function to obtain property `key` from `obj`.
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_getByteLength.js


// Internal helper to obtain the `byteLength` property of an object.
/* harmony default export */ const _getByteLength = (shallowProperty('byteLength'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_isBufferLike.js



// Internal helper to determine whether we should spend extensive checks against
// `ArrayBuffer` et al.
/* harmony default export */ const _isBufferLike = (createSizePropertyCheck(_getByteLength));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isTypedArray.js





// Is a given value a typed array?
var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
function isTypedArray(obj) {
  // `ArrayBuffer.isView` is the most future-proof, so use it when available.
  // Otherwise, fall back on the above regular expression.
  return nativeIsView ? (nativeIsView(obj) && !modules_isDataView(obj)) :
                _isBufferLike(obj) && typedArrayPattern.test(_setup_toString.call(obj));
}

/* harmony default export */ const modules_isTypedArray = (supportsArrayBuffer ? isTypedArray : constant(false));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_getLength.js


// Internal helper to obtain the `length` property of an object.
/* harmony default export */ const _getLength = (shallowProperty('length'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_collectNonEnumProps.js




// Internal helper to create a simple lookup structure.
// `collectNonEnumProps` used to depend on `_.contains`, but this led to
// circular imports. `emulatedSet` is a one-off solution that only works for
// arrays of strings.
function emulatedSet(keys) {
  var hash = {};
  for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
  return {
    contains: function(key) { return hash[key] === true; },
    push: function(key) {
      hash[key] = true;
      return keys.push(key);
    }
  };
}

// Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
// be iterated by `for key in ...` and thus missed. Extends `keys` in place if
// needed.
function collectNonEnumProps(obj, keys) {
  keys = emulatedSet(keys);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = (modules_isFunction(constructor) && constructor.prototype) || ObjProto;

  // Constructor is a special case.
  var prop = 'constructor';
  if (has(obj, prop) && !keys.contains(prop)) keys.push(prop);

  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
      keys.push(prop);
    }
  }
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/keys.js





// Retrieve the names of an object's own properties.
// Delegates to **ECMAScript 5**'s native `Object.keys`.
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys = [];
  for (var key in obj) if (has(obj, key)) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isEmpty.js






// Is a given array, string, or object empty?
// An "empty" object has no enumerable own-properties.
function isEmpty(obj) {
  if (obj == null) return true;
  // Skip the more expensive `toString`-based type checks if `obj` has no
  // `.length`.
  var length = _getLength(obj);
  if (typeof length == 'number' && (
    isArray(obj) || isString(obj) || modules_isArguments(obj)
  )) return length === 0;
  return _getLength(keys(obj)) === 0;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isMatch.js


// Returns whether an object has a given set of `key:value` pairs.
function isMatch(object, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object == null) return !length;
  var obj = Object(object);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/underscore.js


// If Underscore is called as a function, it returns a wrapped object that can
// be used OO-style. This wrapper holds altered versions of all functions added
// through `_.mixin`. Wrapped objects may be chained.
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}

_.VERSION = VERSION;

// Extracts the result from a wrapped and chained object.
_.prototype.value = function() {
  return this._wrapped;
};

// Provide unwrapping proxies for some methods used in engine operations
// such as arithmetic and JSON stringification.
_.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

_.prototype.toString = function() {
  return String(this._wrapped);
};

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_toBufferView.js


// Internal function to wrap or shallow-copy an ArrayBuffer,
// typed array or DataView to a new view, reusing the buffer.
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    _getByteLength(bufferSource)
  );
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isEqual.js











// We use this string twice, so give it a name for minification.
var tagDataView = '[object DataView]';

// Internal recursive comparison function for `_.isEqual`.
function eq(a, b, aStack, bStack) {
  // Identical objects are equal. `0 === -0`, but they aren't identical.
  // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  // `null` or `undefined` only equal to itself (strict comparison).
  if (a == null || b == null) return false;
  // `NaN`s are equivalent, but non-reflexive.
  if (a !== a) return b !== b;
  // Exhaust primitive checks
  var type = typeof a;
  if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
  return deepEq(a, b, aStack, bStack);
}

// Internal recursive comparison function for `_.isEqual`.
function deepEq(a, b, aStack, bStack) {
  // Unwrap any wrapped objects.
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  // Compare `[[Class]]` names.
  var className = _setup_toString.call(a);
  if (className !== _setup_toString.call(b)) return false;
  // Work around a bug in IE 10 - Edge 13.
  if (hasStringTagBug && className == '[object Object]' && modules_isDataView(a)) {
    if (!modules_isDataView(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case '[object String]':
      // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
      // equivalent to `new String("5")`.
      return '' + a === '' + b;
    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive.
      // Object(NaN) is equivalent to NaN.
      if (+a !== +a) return +b !== +b;
      // An `egal` comparison is performed for other numeric values.
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values. Dates are compared by their
      // millisecond representations. Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a === +b;
    case '[object Symbol]':
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case '[object ArrayBuffer]':
    case tagDataView:
      // Coerce to typed array so we can fall through.
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }

  var areArrays = className === '[object Array]';
  if (!areArrays && modules_isTypedArray(a)) {
      var byteLength = _getByteLength(a);
      if (byteLength !== _getByteLength(b)) return false;
      if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
      areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != 'object' || typeof b != 'object') return false;

    // Objects with different constructors are not equivalent, but `Object`s or `Array`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(modules_isFunction(aCtor) && aCtor instanceof aCtor &&
                             modules_isFunction(bCtor) && bCtor instanceof bCtor)
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
  }
  // Assume equality for cyclic structures. The algorithm for detecting cyclic
  // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

  // Initializing stack of traversed objects.
  // It's done here since we only need them for objects and arrays comparison.
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    // Linear search. Performance is inversely proportional to the number of
    // unique nested structures.
    if (aStack[length] === a) return bStack[length] === b;
  }

  // Add the first object to the stack of traversed objects.
  aStack.push(a);
  bStack.push(b);

  // Recursively compare objects and arrays.
  if (areArrays) {
    // Compare array lengths to determine if a deep comparison is necessary.
    length = a.length;
    if (length !== b.length) return false;
    // Deep compare the contents, ignoring non-numeric properties.
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    // Deep compare objects.
    var _keys = keys(a), key;
    length = _keys.length;
    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b).length !== length) return false;
    while (length--) {
      // Deep compare each member
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  // Remove the first object from the stack of traversed objects.
  aStack.pop();
  bStack.pop();
  return true;
}

// Perform a deep comparison to check if two objects are equal.
function isEqual(a, b) {
  return eq(a, b);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/allKeys.js




// Retrieve all the enumerable property names of an object.
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys = [];
  for (var key in obj) keys.push(key);
  // Ahem, IE < 9.
  if (hasEnumBug) collectNonEnumProps(obj, keys);
  return keys;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_methodFingerprint.js




// Since the regular `Object.prototype.toString` type tests don't work for
// some types in IE 11, we use a fingerprinting heuristic instead, based
// on the methods. It's not great, but it's the best we got.
// The fingerprint method lists are defined below.
function ie11fingerprint(methods) {
  var length = _getLength(methods);
  return function(obj) {
    if (obj == null) return false;
    // `Map`, `WeakMap` and `Set` have no enumerable keys.
    var keys = allKeys(obj);
    if (_getLength(keys)) return false;
    for (var i = 0; i < length; i++) {
      if (!modules_isFunction(obj[methods[i]])) return false;
    }
    // If we are testing against `WeakMap`, we need to ensure that
    // `obj` doesn't have a `forEach` method in order to distinguish
    // it from a regular `Map`.
    return methods !== weakMapMethods || !modules_isFunction(obj[forEachName]);
  };
}

// In the interest of compact minification, we write
// each string in the fingerprints only once.
var forEachName = 'forEach',
    hasName = 'has',
    commonInit = ['clear', 'delete'],
    mapTail = ['get', hasName, 'set'];

// `Map`, `WeakMap` and `Set` each have slightly different
// combinations of the above sublists.
var mapMethods = commonInit.concat(forEachName, mapTail),
    weakMapMethods = commonInit.concat(mapTail),
    setMethods = ['add'].concat(commonInit, forEachName, hasName);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isMap.js




/* harmony default export */ const isMap = (isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isWeakMap.js




/* harmony default export */ const isWeakMap = (isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isSet.js




/* harmony default export */ const isSet = (isIE11 ? ie11fingerprint(setMethods) : tagTester('Set'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/isWeakSet.js


/* harmony default export */ const isWeakSet = (tagTester('WeakSet'));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/values.js


// Retrieve the values of an object's properties.
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values = Array(length);
  for (var i = 0; i < length; i++) {
    values[i] = obj[_keys[i]];
  }
  return values;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/pairs.js


// Convert an object into a list of `[key, value]` pairs.
// The opposite of `_.object` with one argument.
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs = Array(length);
  for (var i = 0; i < length; i++) {
    pairs[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/invert.js


// Invert the keys and values of an object. The values must be serializable.
function invert(obj) {
  var result = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result[obj[_keys[i]]] = _keys[i];
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/functions.js


// Return a sorted list of the function names available on the object.
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (modules_isFunction(obj[key])) names.push(key);
  }
  return names.sort();
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createAssigner.js
// An internal function for creating assigner functions.
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index],
          keys = keysFunc(source),
          l = keys.length;
      for (var i = 0; i < l; i++) {
        var key = keys[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/extend.js



// Extend a given object with all the properties in passed-in object(s).
/* harmony default export */ const extend = (createAssigner(allKeys));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/extendOwn.js



// Assigns a given object with all the own properties in the passed-in
// object(s).
// (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
/* harmony default export */ const extendOwn = (createAssigner(keys));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/defaults.js



// Fill in a given object with default properties.
/* harmony default export */ const defaults = (createAssigner(allKeys, true));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_baseCreate.js



// Create a naked function reference for surrogate-prototype-swapping.
function ctor() {
  return function(){};
}

// An internal function for creating a new object that inherits from another.
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result = new Ctor;
  Ctor.prototype = null;
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/create.js



// Creates an object that inherits from the given prototype object.
// If additional properties are provided then they will be added to the
// created object.
function create(prototype, props) {
  var result = baseCreate(prototype);
  if (props) extendOwn(result, props);
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/clone.js




// Create a (shallow-cloned) duplicate of an object.
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray(obj) ? obj.slice() : extend({}, obj);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/tap.js
// Invokes `interceptor` with the `obj` and then returns `obj`.
// The primary purpose of this method is to "tap into" a method chain, in
// order to perform operations on intermediate results within the chain.
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/toPath.js



// Normalize a (deep) property `path` to array.
// Like `_.iteratee`, this function can be customized.
function toPath(path) {
  return isArray(path) ? path : [path];
}
_.toPath = toPath;

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_toPath.js



// Internal wrapper for `_.toPath` to enable minification.
// Similar to `cb` for `_.iteratee`.
function _toPath_toPath(path) {
  return _.toPath(path);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_deepGet.js
// Internal function to obtain a nested property in `obj` along `path`.
function deepGet(obj, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path[i]];
  }
  return length ? obj : void 0;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/get.js




// Get the value of the (deep) property on `path` from `object`.
// If any property in `path` does not exist or if the value is
// `undefined`, return `defaultValue` instead.
// The `path` is normalized through `_.toPath`.
function get(object, path, defaultValue) {
  var value = deepGet(object, _toPath_toPath(path));
  return isUndefined(value) ? defaultValue : value;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/has.js



// Shortcut function for checking if an object has a given property directly on
// itself (in other words, not on a prototype). Unlike the internal `has`
// function, this public version can also traverse nested properties.
function has_has(obj, path) {
  path = _toPath_toPath(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/identity.js
// Keep the identity function around for default iteratees.
function identity(value) {
  return value;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/matcher.js



// Returns a predicate for checking whether an object has a given set of
// `key:value` pairs.
function matcher(attrs) {
  attrs = extendOwn({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/property.js



// Creates a function that, when passed an object, will traverse that object’s
// properties down the given `path`, specified as an array of keys or indices.
function property(path) {
  path = _toPath_toPath(path);
  return function(obj) {
    return deepGet(obj, path);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_optimizeCb.js
// Internal function that returns an efficient (for current engines) version
// of the passed-in callback, to be repeatedly applied in other Underscore
// functions.
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1: return function(value) {
      return func.call(context, value);
    };
    // The 2-argument case is omitted because we’re not using it.
    case 3: return function(value, index, collection) {
      return func.call(context, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(context, accumulator, value, index, collection);
    };
  }
  return function() {
    return func.apply(context, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_baseIteratee.js








// An internal function to generate callbacks that can be applied to each
// element in a collection, returning the desired result — either `_.identity`,
// an arbitrary callback, a property matcher, or a property accessor.
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (modules_isFunction(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray(value)) return matcher(value);
  return property(value);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/iteratee.js



// External wrapper for our callback generator. Users may customize
// `_.iteratee` if they want additional predicate/iteratee shorthand styles.
// This abstraction hides the internal-only `argCount` argument.
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
_.iteratee = iteratee;

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_cb.js




// The function we call internally to generate a callback. It invokes
// `_.iteratee` if overridden, otherwise `baseIteratee`.
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/mapObject.js



// Returns the results of applying the `iteratee` to each element of `obj`.
// In contrast to `_.map` it returns an object.
function mapObject(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = keys(obj),
      length = _keys.length,
      results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/noop.js
// Predicate-generating function. Often useful outside of Underscore.
function noop(){}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/propertyOf.js



// Generates a function for a given object that returns a given property.
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path) {
    return get(obj, path);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/times.js


// Run a function **n** times.
function times(n, iteratee, context) {
  var accum = Array(Math.max(0, n));
  iteratee = optimizeCb(iteratee, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee(i);
  return accum;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/random.js
// Return a random integer between `min` and `max` (inclusive).
function random(min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  return min + Math.floor(Math.random() * (max - min + 1));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/now.js
// A (possibly faster) way to get the current timestamp as an integer.
/* harmony default export */ const now = (Date.now || function() {
  return new Date().getTime();
});

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createEscaper.js


// Internal helper to generate functions for escaping and unescaping strings
// to/from HTML interpolation.
function createEscaper(map) {
  var escaper = function(match) {
    return map[match];
  };
  // Regexes for identifying a key that needs to be escaped.
  var source = '(?:' + keys(map).join('|') + ')';
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, 'g');
  return function(string) {
    string = string == null ? '' : '' + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_escapeMap.js
// Internal list of HTML entities for escaping.
/* harmony default export */ const _escapeMap = ({
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#x27;',
  '`': '&#x60;'
});

;// CONCATENATED MODULE: ./node_modules/underscore/modules/escape.js



// Function for escaping strings to HTML interpolation.
/* harmony default export */ const modules_escape = (createEscaper(_escapeMap));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_unescapeMap.js



// Internal list of HTML entities for unescaping.
/* harmony default export */ const _unescapeMap = (invert(_escapeMap));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/unescape.js



// Function for unescaping strings from HTML interpolation.
/* harmony default export */ const modules_unescape = (createEscaper(_unescapeMap));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/templateSettings.js


// By default, Underscore uses ERB-style template delimiters. Change the
// following template settings to use alternative delimiters.
/* harmony default export */ const templateSettings = (_.templateSettings = {
  evaluate: /<%([\s\S]+?)%>/g,
  interpolate: /<%=([\s\S]+?)%>/g,
  escape: /<%-([\s\S]+?)%>/g
});

;// CONCATENATED MODULE: ./node_modules/underscore/modules/template.js




// When customizing `_.templateSettings`, if you don't want to define an
// interpolation, evaluation or escaping regex, we need one that is
// guaranteed not to match.
var noMatch = /(.)^/;

// Certain characters need to be escaped so that they can be put into a
// string literal.
var escapes = {
  "'": "'",
  '\\': '\\',
  '\r': 'r',
  '\n': 'n',
  '\u2028': 'u2028',
  '\u2029': 'u2029'
};

var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

function escapeChar(match) {
  return '\\' + escapes[match];
}

// In order to prevent third-party code injection through
// `_.templateSettings.variable`, we test it against the following regular
// expression. It is intentionally a bit more liberal than just matching valid
// identifiers, but still prevents possible loopholes through defaults or
// destructuring assignment.
var bareIdentifier = /^\s*(\w|\$)+\s*$/;

// JavaScript micro-templating, similar to John Resig's implementation.
// Underscore templating handles arbitrary delimiters, preserves whitespace,
// and correctly escapes quotes within interpolated code.
// NB: `oldSettings` only exists for backwards compatibility.
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults({}, settings, _.templateSettings);

  // Combine delimiters into one regular expression via alternation.
  var matcher = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join('|') + '|$', 'g');

  // Compile the template source, escaping string literals appropriately.
  var index = 0;
  var source = "__p+='";
  text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;

    if (escape) {
      source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }

    // Adobe VMs need the match returned to produce the correct offset.
    return match;
  });
  source += "';\n";

  var argument = settings.variable;
  if (argument) {
    // Insure against third-party code injection. (CVE-2021-23358)
    if (!bareIdentifier.test(argument)) throw new Error(
      'variable is not a bare identifier: ' + argument
    );
  } else {
    // If a variable is not specified, place data values in local scope.
    source = 'with(obj||{}){\n' + source + '}\n';
    argument = 'obj';
  }

  source = "var __t,__p='',__j=Array.prototype.join," +
    "print=function(){__p+=__j.call(arguments,'');};\n" +
    source + 'return __p;\n';

  var render;
  try {
    render = new Function(argument, '_', source);
  } catch (e) {
    e.source = source;
    throw e;
  }

  var template = function(data) {
    return render.call(this, data, _);
  };

  // Provide the compiled source as a convenience for precompilation.
  template.source = 'function(' + argument + '){\n' + source + '}';

  return template;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/result.js



// Traverses the children of `obj` along `path`. If a child is a function, it
// is invoked with its parent as context. Returns the value of the final
// child, or `fallback` if any child is undefined.
function result(obj, path, fallback) {
  path = _toPath_toPath(path);
  var length = path.length;
  if (!length) {
    return modules_isFunction(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length; // Ensure we don't continue iterating.
    }
    obj = modules_isFunction(prop) ? prop.call(obj) : prop;
  }
  return obj;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/uniqueId.js
// Generate a unique integer id (unique within the entire client session).
// Useful for temporary DOM ids.
var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter + '';
  return prefix ? prefix + id : id;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/chain.js


// Start chaining a wrapped Underscore object.
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_executeBound.js



// Internal function to execute `sourceFunc` bound to `context` with optional
// `args`. Determines whether to execute a function as a constructor or as a
// normal function.
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self = baseCreate(sourceFunc.prototype);
  var result = sourceFunc.apply(self, args);
  if (isObject(result)) return result;
  return self;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/partial.js




// Partially apply a function by creating a version that has had some of its
// arguments pre-filled, without changing its dynamic `this` context. `_` acts
// as a placeholder by default, allowing any combination of arguments to be
// pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
var partial = restArguments(function(func, boundArgs) {
  var placeholder = partial.placeholder;
  var bound = function() {
    var position = 0, length = boundArgs.length;
    var args = Array(length);
    for (var i = 0; i < length; i++) {
      args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
    }
    while (position < arguments.length) args.push(arguments[position++]);
    return executeBound(func, bound, this, this, args);
  };
  return bound;
});

partial.placeholder = _;
/* harmony default export */ const modules_partial = (partial);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/bind.js




// Create a function bound to a given object (assigning `this`, and arguments,
// optionally).
/* harmony default export */ const bind = (restArguments(function(func, context, args) {
  if (!modules_isFunction(func)) throw new TypeError('Bind must be called on a function');
  var bound = restArguments(function(callArgs) {
    return executeBound(func, bound, context, this, args.concat(callArgs));
  });
  return bound;
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_isArrayLike.js



// Internal helper for collection methods to determine whether a collection
// should be iterated as an array or as an object.
// Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
// Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
/* harmony default export */ const _isArrayLike = (createSizePropertyCheck(_getLength));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_flatten.js





// Internal implementation of a recursive `flatten` function.
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = _getLength(input); i < length; i++) {
    var value = input[i];
    if (_isArrayLike(value) && (isArray(value) || modules_isArguments(value))) {
      // Flatten current level of array or arguments object.
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/bindAll.js




// Bind a number of an object's methods to that object. Remaining arguments
// are the method names to be bound. Useful for ensuring that all callbacks
// defined on an object belong to it.
/* harmony default export */ const bindAll = (restArguments(function(obj, keys) {
  keys = flatten(keys, false, false);
  var index = keys.length;
  if (index < 1) throw new Error('bindAll must be passed function names');
  while (index--) {
    var key = keys[index];
    obj[key] = bind(obj[key], obj);
  }
  return obj;
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/memoize.js


// Memoize an expensive function by storing its results.
function memoize(func, hasher) {
  var memoize = function(key) {
    var cache = memoize.cache;
    var address = '' + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize.cache = {};
  return memoize;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/delay.js


// Delays a function for the given number of milliseconds, and then calls
// it with the arguments supplied.
/* harmony default export */ const delay = (restArguments(function(func, wait, args) {
  return setTimeout(function() {
    return func.apply(null, args);
  }, wait);
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/defer.js




// Defers a function, scheduling it to run after the current call stack has
// cleared.
/* harmony default export */ const defer = (modules_partial(delay, _, 1));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/throttle.js


// Returns a function, that, when invoked, will only be triggered at most once
// during a given window of time. Normally, the throttled function will run
// as much as it can, without ever going more than once per `wait` duration;
// but if you'd like to disable the execution on the leading edge, pass
// `{leading: false}`. To disable execution on the trailing edge, ditto.
function throttle(func, wait, options) {
  var timeout, context, args, result;
  var previous = 0;
  if (!options) options = {};

  var later = function() {
    previous = options.leading === false ? 0 : now();
    timeout = null;
    result = func.apply(context, args);
    if (!timeout) context = args = null;
  };

  var throttled = function() {
    var _now = now();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result;
  };

  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };

  return throttled;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/debounce.js



// When a sequence of calls of the returned function ends, the argument
// function is triggered. The end of a sequence is defined by the `wait`
// parameter. If `immediate` is passed, the argument function will be
// triggered at the beginning of the sequence instead of at the end.
function debounce(func, wait, immediate) {
  var timeout, previous, args, result, context;

  var later = function() {
    var passed = now() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result = func.apply(context, args);
      // This check is needed because `func` can recursively invoke `debounced`.
      if (!timeout) args = context = null;
    }
  };

  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result = func.apply(context, args);
    }
    return result;
  });

  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };

  return debounced;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/wrap.js


// Returns the first function passed as an argument to the second,
// allowing you to adjust arguments, run code before and after, and
// conditionally execute the original function.
function wrap(func, wrapper) {
  return modules_partial(wrapper, func);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/negate.js
// Returns a negated version of the passed-in predicate.
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/compose.js
// Returns a function that is the composition of a list of functions, each
// consuming the return value of the function that follows.
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result = args[start].apply(this, arguments);
    while (i--) result = args[i].call(this, result);
    return result;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/after.js
// Returns a function that will only be executed on and after the Nth call.
function after(times, func) {
  return function() {
    if (--times < 1) {
      return func.apply(this, arguments);
    }
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/before.js
// Returns a function that will only be executed up to (but not including) the
// Nth call.
function before(times, func) {
  var memo;
  return function() {
    if (--times > 0) {
      memo = func.apply(this, arguments);
    }
    if (times <= 1) func = null;
    return memo;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/once.js



// Returns a function that will be executed at most one time, no matter how
// often you call it. Useful for lazy initialization.
/* harmony default export */ const once = (modules_partial(before, 2));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/findKey.js



// Returns the first key on an object that passes a truth test.
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createPredicateIndexFinder.js



// Internal function to generate `_.findIndex` and `_.findLastIndex`.
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = _getLength(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/findIndex.js


// Returns the first index on an array-like that passes a truth test.
/* harmony default export */ const findIndex = (createPredicateIndexFinder(1));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/findLastIndex.js


// Returns the last index on an array-like that passes a truth test.
/* harmony default export */ const findLastIndex = (createPredicateIndexFinder(-1));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/sortedIndex.js



// Use a comparator function to figure out the smallest index at which
// an object should be inserted so as to maintain order. Uses binary search.
function sortedIndex(array, obj, iteratee, context) {
  iteratee = cb(iteratee, context, 1);
  var value = iteratee(obj);
  var low = 0, high = _getLength(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
  }
  return low;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createIndexFinder.js




// Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
function createIndexFinder(dir, predicateFind, sortedIndex) {
  return function(array, item, idx) {
    var i = 0, length = _getLength(array);
    if (typeof idx == 'number') {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex && idx && length) {
      idx = sortedIndex(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN_isNaN);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/indexOf.js




// Return the position of the first occurrence of an item in an array,
// or -1 if the item is not included in the array.
// If the array is large and already in sort order, pass `true`
// for **isSorted** to use binary search.
/* harmony default export */ const indexOf = (createIndexFinder(1, findIndex, sortedIndex));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/lastIndexOf.js



// Return the position of the last occurrence of an item in an array,
// or -1 if the item is not included in the array.
/* harmony default export */ const lastIndexOf = (createIndexFinder(-1, findLastIndex));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/find.js




// Return the first value which passes a truth test.
function find(obj, predicate, context) {
  var keyFinder = _isArrayLike(obj) ? findIndex : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/findWhere.js



// Convenience version of a common use case of `_.find`: getting the first
// object containing specific `key:value` pairs.
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/each.js




// The cornerstone for collection functions, an `each`
// implementation, aka `forEach`.
// Handles raw objects in addition to array-likes. Treats all
// sparse array-likes as if they were dense.
function each(obj, iteratee, context) {
  iteratee = optimizeCb(iteratee, context);
  var i, length;
  if (_isArrayLike(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/map.js




// Return the results of applying the iteratee to each element.
function map(obj, iteratee, context) {
  iteratee = cb(iteratee, context);
  var _keys = !_isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length,
      results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee(obj[currentKey], currentKey, obj);
  }
  return results;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_createReduce.js




// Internal helper to create a reducing function, iterating left or right.
function createReduce(dir) {
  // Wrap code that reassigns argument variables in a separate function than
  // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
  var reducer = function(obj, iteratee, memo, initial) {
    var _keys = !_isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length,
        index = dir > 0 ? 0 : length - 1;
    if (!initial) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  return function(obj, iteratee, memo, context) {
    var initial = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/reduce.js


// **Reduce** builds up a single result from a list of values, aka `inject`,
// or `foldl`.
/* harmony default export */ const reduce = (createReduce(1));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/reduceRight.js


// The right-associative version of reduce, also known as `foldr`.
/* harmony default export */ const reduceRight = (createReduce(-1));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/filter.js



// Return all the elements that pass a truth test.
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/reject.js




// Return all the elements for which a truth test fails.
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/every.js




// Determine whether all of the elements pass a truth test.
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !_isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/some.js




// Determine if at least one element in the object passes a truth test.
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !_isArrayLike(obj) && keys(obj),
      length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/contains.js




// Determine if the array or object contains a given item (using `===`).
function contains(obj, item, fromIndex, guard) {
  if (!_isArrayLike(obj)) obj = values(obj);
  if (typeof fromIndex != 'number' || guard) fromIndex = 0;
  return indexOf(obj, item, fromIndex) >= 0;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/invoke.js






// Invoke a method (with arguments) on every item in a collection.
/* harmony default export */ const invoke = (restArguments(function(obj, path, args) {
  var contextPath, func;
  if (modules_isFunction(path)) {
    func = path;
  } else {
    path = _toPath_toPath(path);
    contextPath = path.slice(0, -1);
    path = path[path.length - 1];
  }
  return map(obj, function(context) {
    var method = func;
    if (!method) {
      if (contextPath && contextPath.length) {
        context = deepGet(context, contextPath);
      }
      if (context == null) return void 0;
      method = context[path];
    }
    return method == null ? method : method.apply(context, args);
  });
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/pluck.js



// Convenience version of a common use case of `_.map`: fetching a property.
function pluck(obj, key) {
  return map(obj, property(key));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/where.js



// Convenience version of a common use case of `_.filter`: selecting only
// objects containing specific `key:value` pairs.
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/max.js





// Return the maximum element (or element-based computation).
function max(obj, iteratee, context) {
  var result = -Infinity, lastComputed = -Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = _isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/min.js





// Return the minimum element (or element-based computation).
function min(obj, iteratee, context) {
  var result = Infinity, lastComputed = Infinity,
      value, computed;
  if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
    obj = _isArrayLike(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result) {
        result = value;
      }
    }
  } else {
    iteratee = cb(iteratee, context);
    each(obj, function(v, index, list) {
      computed = iteratee(v, index, list);
      if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
        result = v;
        lastComputed = computed;
      }
    });
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/toArray.js








// Safely create a real, live array from anything iterable.
var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
function toArray(obj) {
  if (!obj) return [];
  if (isArray(obj)) return slice.call(obj);
  if (isString(obj)) {
    // Keep surrogate pair characters together.
    return obj.match(reStrSymbol);
  }
  if (_isArrayLike(obj)) return map(obj, identity);
  return values(obj);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/sample.js






// Sample **n** random values from a collection using the modern version of the
// [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
// If **n** is not specified, returns a single random element.
// The internal `guard` argument allows it to work with `_.map`.
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!_isArrayLike(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample = toArray(obj);
  var length = _getLength(sample);
  n = Math.max(Math.min(n, length), 0);
  var last = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last);
    var temp = sample[index];
    sample[index] = sample[rand];
    sample[rand] = temp;
  }
  return sample.slice(0, n);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/shuffle.js


// Shuffle a collection.
function shuffle(obj) {
  return sample(obj, Infinity);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/sortBy.js




// Sort the object's values by a criterion produced by an iteratee.
function sortBy(obj, iteratee, context) {
  var index = 0;
  iteratee = cb(iteratee, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value: value,
      index: index++,
      criteria: iteratee(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), 'value');
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_group.js



// An internal function used for aggregate "group by" operations.
function group(behavior, partition) {
  return function(obj, iteratee, context) {
    var result = partition ? [[], []] : {};
    iteratee = cb(iteratee, context);
    each(obj, function(value, index) {
      var key = iteratee(value, index, obj);
      behavior(result, value, key);
    });
    return result;
  };
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/groupBy.js



// Groups the object's values by a criterion. Pass either a string attribute
// to group by, or a function that returns the criterion.
/* harmony default export */ const groupBy = (group(function(result, value, key) {
  if (has(result, key)) result[key].push(value); else result[key] = [value];
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/indexBy.js


// Indexes the object's values by a criterion, similar to `_.groupBy`, but for
// when you know that your index values will be unique.
/* harmony default export */ const indexBy = (group(function(result, value, key) {
  result[key] = value;
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/countBy.js



// Counts instances of an object that group by a certain criterion. Pass
// either a string attribute to count by, or a function that returns the
// criterion.
/* harmony default export */ const countBy = (group(function(result, value, key) {
  if (has(result, key)) result[key]++; else result[key] = 1;
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/partition.js


// Split a collection into two arrays: one whose elements all pass the given
// truth test, and one whose elements all do not pass the truth test.
/* harmony default export */ const partition = (group(function(result, value, pass) {
  result[pass ? 0 : 1].push(value);
}, true));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/size.js



// Return the number of elements in a collection.
function size(obj) {
  if (obj == null) return 0;
  return _isArrayLike(obj) ? obj.length : keys(obj).length;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_keyInObj.js
// Internal `_.pick` helper function to determine whether `key` is an enumerable
// property name of `obj`.
function keyInObj(value, key, obj) {
  return key in obj;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/pick.js







// Return a copy of the object only containing the allowed properties.
/* harmony default export */ const pick = (restArguments(function(obj, keys) {
  var result = {}, iteratee = keys[0];
  if (obj == null) return result;
  if (modules_isFunction(iteratee)) {
    if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
    keys = allKeys(obj);
  } else {
    iteratee = keyInObj;
    keys = flatten(keys, false, false);
    obj = Object(obj);
  }
  for (var i = 0, length = keys.length; i < length; i++) {
    var key = keys[i];
    var value = obj[key];
    if (iteratee(value, key, obj)) result[key] = value;
  }
  return result;
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/omit.js








// Return a copy of the object without the disallowed properties.
/* harmony default export */ const omit = (restArguments(function(obj, keys) {
  var iteratee = keys[0], context;
  if (modules_isFunction(iteratee)) {
    iteratee = negate(iteratee);
    if (keys.length > 1) context = keys[1];
  } else {
    keys = map(flatten(keys, false, false), String);
    iteratee = function(value, key) {
      return !contains(keys, key);
    };
  }
  return pick(obj, iteratee, context);
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/initial.js


// Returns everything but the last entry of the array. Especially useful on
// the arguments object. Passing **n** will return all the values in
// the array, excluding the last N.
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/first.js


// Get the first element of an array. Passing **n** will return the first N
// values in the array. The **guard** check allows it to work with `_.map`.
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/rest.js


// Returns everything but the first entry of the `array`. Especially useful on
// the `arguments` object. Passing an **n** will return the rest N values in the
// `array`.
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/last.js


// Get the last element of an array. Passing **n** will return the last N
// values in the array.
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/compact.js


// Trim out all falsy values from an array.
function compact(array) {
  return filter(array, Boolean);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/flatten.js


// Flatten out an array, either recursively (by default), or up to `depth`.
// Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
function flatten_flatten(array, depth) {
  return flatten(array, depth, false);
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/difference.js





// Take the difference between one array and a number of other arrays.
// Only the elements present in just the first array will remain.
/* harmony default export */ const difference = (restArguments(function(array, rest) {
  rest = flatten(rest, true, true);
  return filter(array, function(value){
    return !contains(rest, value);
  });
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/without.js



// Return a version of the array that does not contain the specified value(s).
/* harmony default export */ const without = (restArguments(function(array, otherArrays) {
  return difference(array, otherArrays);
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/uniq.js





// Produce a duplicate-free version of the array. If the array has already
// been sorted, you have the option of using a faster algorithm.
// The faster algorithm will not work with an iteratee if the iteratee
// is not a one-to-one function, so providing an iteratee will disable
// the faster algorithm.
function uniq(array, isSorted, iteratee, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee;
    iteratee = isSorted;
    isSorted = false;
  }
  if (iteratee != null) iteratee = cb(iteratee, context);
  var result = [];
  var seen = [];
  for (var i = 0, length = _getLength(array); i < length; i++) {
    var value = array[i],
        computed = iteratee ? iteratee(value, i, array) : value;
    if (isSorted && !iteratee) {
      if (!i || seen !== computed) result.push(value);
      seen = computed;
    } else if (iteratee) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result.push(value);
      }
    } else if (!contains(result, value)) {
      result.push(value);
    }
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/union.js




// Produce an array that contains the union: each distinct element from all of
// the passed-in arrays.
/* harmony default export */ const union = (restArguments(function(arrays) {
  return uniq(flatten(arrays, true, true));
}));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/intersection.js



// Produce an array that contains every item shared between all the
// passed-in arrays.
function intersection(array) {
  var result = [];
  var argsLength = arguments.length;
  for (var i = 0, length = _getLength(array); i < length; i++) {
    var item = array[i];
    if (contains(result, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result.push(item);
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/unzip.js




// Complement of zip. Unzip accepts an array of arrays and groups
// each array's elements on shared indices.
function unzip(array) {
  var length = (array && max(array, _getLength).length) || 0;
  var result = Array(length);

  for (var index = 0; index < length; index++) {
    result[index] = pluck(array, index);
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/zip.js



// Zip together multiple lists into a single array -- elements that share
// an index go together.
/* harmony default export */ const zip = (restArguments(unzip));

;// CONCATENATED MODULE: ./node_modules/underscore/modules/object.js


// Converts lists into objects. Pass either a single array of `[key, value]`
// pairs, or two parallel arrays of the same length -- one of keys, and one of
// the corresponding values. Passing by pairs is the reverse of `_.pairs`.
function object(list, values) {
  var result = {};
  for (var i = 0, length = _getLength(list); i < length; i++) {
    if (values) {
      result[list[i]] = values[i];
    } else {
      result[list[i][0]] = list[i][1];
    }
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/range.js
// Generate an integer Array containing an arithmetic progression. A port of
// the native Python `range()` function. See
// [the Python documentation](https://docs.python.org/library/functions.html#range).
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }

  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range = Array(length);

  for (var idx = 0; idx < length; idx++, start += step) {
    range[idx] = start;
  }

  return range;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/chunk.js


// Chunk a single array into multiple arrays, each containing `count` or fewer
// items.
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result = [];
  var i = 0, length = array.length;
  while (i < length) {
    result.push(slice.call(array, i, i += count));
  }
  return result;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/_chainResult.js


// Helper function to continue chaining intermediate results.
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/mixin.js






// Add your own custom functions to the Underscore object.
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}

;// CONCATENATED MODULE: ./node_modules/underscore/modules/underscore-array-methods.js





// Add all mutator `Array` functions to the wrapper.
each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) {
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) {
        delete obj[0];
      }
    }
    return chainResult(this, obj);
  };
});

// Add all accessor `Array` functions to the wrapper.
each(['concat', 'join', 'slice'], function(name) {
  var method = ArrayProto[name];
  _.prototype[name] = function() {
    var obj = this._wrapped;
    if (obj != null) obj = method.apply(obj, arguments);
    return chainResult(this, obj);
  };
});

/* harmony default export */ const underscore_array_methods = (_);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/index.js
// Named Exports
// =============

//     Underscore.js 1.13.6
//     https://underscorejs.org
//     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

// Baseline setup.



// Object Functions
// ----------------
// Our most fundamental functions operate on any JavaScript object.
// Most functions in Underscore depend on at least one function in this section.

// A group of functions that check the types of core JavaScript values.
// These are often informally referred to as the "isType" functions.



























// Functions that treat an object as a dictionary of key-value pairs.
















// Utility Functions
// -----------------
// A bit of a grab bag: Predicate-generating functions for use with filters and
// loops, string escaping and templating, create random numbers and unique ids,
// and functions that facilitate Underscore's chaining and iteration conventions.



















// Function (ahem) Functions
// -------------------------
// These functions take a function as an argument and return a new function
// as the result. Also known as higher-order functions.















// Finders
// -------
// Functions that extract (the position of) a single element from an object
// or array based on some criterion.









// Collection Functions
// --------------------
// Functions that work on any collection of elements: either an array, or
// an object of key-value pairs.
























// `_.pick` and `_.omit` are actually object functions, but we put
// them here in order to create a more natural reading order in the
// monolithic build as they depend on `_.contains`.



// Array Functions
// ---------------
// Functions that operate on arrays (and array-likes) only, because they’re
// expressed in terms of operations on an ordered list of values.

















// OOP
// ---
// These modules support the "object-oriented" calling style. See also
// `underscore.js` and `index-default.js`.



;// CONCATENATED MODULE: ./node_modules/underscore/modules/index-default.js
// Default Export
// ==============
// In this module, we mix our bundled exports into the `_` object and export
// the result. This is analogous to setting `module.exports = _` in CommonJS.
// Hence, this module is also the entry point of our UMD bundle and the package
// entry point for CommonJS and AMD users. In other words, this is (the source
// of) the module you are interfacing with when you do any of the following:
//
// ```js
// // CommonJS
// var _ = require('underscore');
//
// // AMD
// define(['underscore'], function(_) {...});
//
// // UMD in the browser
// // _ is available as a global variable
// ```



// Add all of the Underscore functions to the wrapper object.
var index_default_ = mixin(modules_namespaceObject);
// Legacy Node.js API.
index_default_._ = index_default_;
// Export the Underscore API.
/* harmony default export */ const index_default = (index_default_);

;// CONCATENATED MODULE: ./node_modules/underscore/modules/index-all.js
// ESM Exports
// ===========
// This module is the package entry point for ES module users. In other words,
// it is the module they are interfacing with when they import from the whole
// package instead of from a submodule, like this:
//
// ```js
// import { map } from 'underscore';
// ```
//
// The difference with `./index-default`, which is the package entry point for
// CommonJS, AMD and UMD users, is purely technical. In ES modules, named and
// default exports are considered to be siblings, so when you have a default
// export, its properties are not automatically available as named exports. For
// this reason, we re-export the named exports in addition to providing the same
// default export as in `./index-default`.




/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__webpack_require__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  ZP: () => (/* binding */ src_0),
  kr: () => (/* binding */ grapesjs),
  j7: () => (/* binding */ usePlugin)
});

// EXTERNAL MODULE: ./node_modules/underscore/modules/index-all.js + 160 modules
var index_all = __webpack_require__(50);
// EXTERNAL MODULE: ./src/utils/mixins.ts
var mixins = __webpack_require__(283);
;// CONCATENATED MODULE: ./src/utils/html.ts

/**
 * Safe ES6 tagged template strings
 * @param {Array<String>} literals
 * @param  {Array<String>} substs
 * @returns {String}
 * @example
 * const str = '<b>Hello</b>';
 * const strHtml = html`Escaped ${str}, unescaped $${str}`;
 */
function html(literals) {
    var substs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        substs[_i - 1] = arguments[_i];
    }
    var raw = literals.raw;
    return raw.reduce(function (acc, lit, i) {
        var subst = substs[i - 1];
        var last = raw[i - 1];
        if (Array.isArray(subst)) {
            subst = subst.join('');
        }
        else if (last && last.slice(-1) === '$') {
            // If the interpolation is preceded by a dollar sign, it won't be escaped
            acc = acc.slice(0, -1);
        }
        else {
            subst = (0,mixins.escape)(subst);
        }
        return acc + subst + lit;
    });
}

;// CONCATENATED MODULE: ./src/editor/config/config.ts
var config = {
    stylePrefix: 'gjs-',
    components: '',
    style: '',
    fromElement: false,
    projectData: undefined,
    noticeOnUnload: true,
    showOffsets: false,
    showOffsetsSelected: false,
    forceClass: true,
    height: '900px',
    width: '100%',
    log: ['warning', 'error'],
    baseCss: '',
    protectedCss: '* { box-sizing: border-box; } body {margin: 0;}',
    canvasCss: '',
    defaultCommand: 'select-comp',
    showToolbar: true,
    showDevices: true,
    devicePreviewMode: false,
    mediaCondition: 'max-width',
    tagVarStart: '{[ ',
    tagVarEnd: ' ]}',
    keepEmptyTextNodes: false,
    jsInHtml: true,
    nativeDnD: true,
    multipleSelection: true,
    optsHtml: {},
    optsCss: {},
    avoidInlineStyle: true,
    avoidDefaults: true,
    clearStyles: false,
    listenToEl: [],
    cssIcons: 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css',
    icons: {
        close: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>',
        move: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M13,6V11H18V7.75L22.25,12L18,16.25V13H13V18H16.25L12,22.25L7.75,18H11V13H6V16.25L1.75,12L6,7.75V11H11V6H7.75L12,1.75L16.25,6H13Z"/></svg>',
        plus: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" /></svg>',
        caret: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M7,10L12,15L17,10H7Z" /></svg>',
        delete: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" /></svg>',
        copy: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z" /></svg>',
        arrowUp: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z" /></svg>',
        chevron: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z" /></svg>',
        eye: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M12,9A3,3 0 0,0 9,12A3,3 0 0,0 12,15A3,3 0 0,0 15,12A3,3 0 0,0 12,9M12,17A5,5 0 0,1 7,12A5,5 0 0,1 12,7A5,5 0 0,1 17,12A5,5 0 0,1 12,17M12,4.5C7,4.5 2.73,7.61 1,12C2.73,16.39 7,19.5 12,19.5C17,19.5 21.27,16.39 23,12C21.27,7.61 17,4.5 12,4.5Z" /></svg>',
        eyeOff: '<svg viewBox="0 0 24 24"><path fill="currentColor" d="M11.83,9L15,12.16C15,12.11 15,12.05 15,12A3,3 0 0,0 12,9C11.94,9 11.89,9 11.83,9M7.53,9.8L9.08,11.35C9.03,11.56 9,11.77 9,12A3,3 0 0,0 12,15C12.22,15 12.44,14.97 12.65,14.92L14.2,16.47C13.53,16.8 12.79,17 12,17A5,5 0 0,1 7,12C7,11.21 7.2,10.47 7.53,9.8M2,4.27L4.28,6.55L4.73,7C3.08,8.3 1.78,10 1,12C2.73,16.39 7,19.5 12,19.5C13.55,19.5 15.03,19.2 16.38,18.66L16.81,19.08L19.73,22L21,20.73L3.27,3M12,7A5,5 0 0,1 17,12C17,12.64 16.87,13.26 16.64,13.82L19.57,16.75C21.07,15.5 22.27,13.86 23,12C21.27,7.61 17,4.5 12,4.5C10.6,4.5 9.26,4.75 8,5.2L10.17,7.35C10.74,7.13 11.35,7 12,7Z" /></svg>',
    },
    i18n: {},
    undoManager: {},
    assetManager: {},
    canvas: {},
    layerManager: {},
    storageManager: {},
    richTextEditor: {},
    domComponents: {},
    modal: {},
    codeManager: {},
    panels: {},
    commands: {},
    cssComposer: {},
    selectorManager: {},
    deviceManager: {},
    styleManager: {},
    blockManager: {},
    traitManager: {},
    textViewCode: 'Code',
    keepUnusedStyles: false,
    customUI: false,
};
/* harmony default export */ const config_config = (config);

// EXTERNAL MODULE: ./node_modules/backbone/backbone.js
var backbone = __webpack_require__(316);
var backbone_default = /*#__PURE__*/__webpack_require__.n(backbone);
// EXTERNAL MODULE: ./src/utils/cash-dom.ts
var cash_dom = __webpack_require__(815);
;// CONCATENATED MODULE: ./src/utils/extender.ts

/* harmony default export */ const extender = (function (_a) {
    var $ = _a.$;
    if ($ && $.prototype && $.prototype.constructor.name !== 'jQuery') {
        var fn = $.fn;
        // Additional helpers
        fn.hide = function () {
            return this.css('display', 'none');
        };
        fn.show = function () {
            return this.css('display', 'block');
        };
        fn.focus = function () {
            var el = this.get(0);
            el && el.focus();
            return this;
        };
        // For spectrum compatibility
        fn.bind = function (ev, h) {
            return this.on(ev, h);
        };
        fn.unbind = function (ev, h) {
            if ((0,index_all.isObject)(ev)) {
                for (var name_1 in ev) {
                    ev.hasOwnProperty(name_1) && this.off(name_1, ev[name_1]);
                }
                return this;
            }
            else {
                return this.off(ev, h);
            }
        };
        fn.click = function (h) {
            return h ? this.on('click', h) : this.trigger('click');
        };
        fn.change = function (h) {
            return h ? this.on('change', h) : this.trigger('change');
        };
        fn.keydown = function (h) {
            return h ? this.on('keydown', h) : this.trigger('keydown');
        };
        fn.delegate = function (selector, events, data, handler) {
            if (!handler) {
                handler = data;
            }
            return this.on(events, selector, function (e) {
                e.data = data;
                handler(e);
            });
        };
        fn.scrollLeft = function () {
            var el = this.get(0);
            el = el.nodeType == 9 ? el.defaultView : el;
            var win = el instanceof Window ? el : null;
            return win ? win.pageXOffset : el.scrollLeft || 0;
        };
        fn.scrollTop = function () {
            var el = this.get(0);
            el = el.nodeType == 9 ? el.defaultView : el;
            var win = el instanceof Window ? el : null;
            return win ? win.pageYOffset : el.scrollTop || 0;
        };
        var offset_1 = $.prototype.offset;
        fn.offset = function (coords) {
            var top, left;
            if (coords) {
                top = coords.top;
                left = coords.left;
            }
            if (typeof top != 'undefined') {
                this.css('top', "".concat(top, "px"));
            }
            if (typeof left != 'undefined') {
                this.css('left', "".concat(left, "px"));
            }
            return offset_1.call(this);
        };
        $.map = function (items, clb) {
            var ar = [];
            for (var i = 0; i < items.length; i++) {
                ar.push(clb(items[i], i));
            }
            return ar;
        };
        var indexOf_1 = Array.prototype.indexOf;
        $.inArray = function (val, arr, i) {
            return arr == null ? -1 : indexOf_1.call(arr, val, i);
        };
        $.Event = function (src, props) {
            if (!(this instanceof $.Event)) {
                return new $.Event(src, props);
            }
            this.type = src;
            this.isDefaultPrevented = function () { return false; };
        };
    }
});

// EXTERNAL MODULE: ./src/common/index.ts
var common = __webpack_require__(847);
;// CONCATENATED MODULE: ./src/editor/model/Selected.ts
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Selectable = /** @class */ (function (_super) {
    __extends(Selectable, _super);
    function Selectable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Selectable;
}(common/* Model */.Hn));

var Selected = /** @class */ (function (_super) {
    __extends(Selected, _super);
    function Selected() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Selected.prototype.getByComponent = function (component) {
        var _this = this;
        return this.filter(function (s) { return _this.getComponent(s) === component; })[0];
    };
    Selected.prototype.addComponent = function (component, opts) {
        var _this = this;
        var toAdd = ((0,index_all.isArray)(component) ? component : [component])
            .filter(function (c) { return !_this.hasComponent(c); })
            .map(function (component) { return new Selectable({ component: component }); })[0];
        return this.push(toAdd, opts);
    };
    Selected.prototype.getComponent = function (model) {
        return model.get('component');
    };
    Selected.prototype.hasComponent = function (component) {
        var model = this.getByComponent(component);
        return model && this.contains(model);
    };
    Selected.prototype.lastComponent = function () {
        var last = this.last();
        return last ? this.getComponent(last) : undefined;
    };
    Selected.prototype.allComponents = function () {
        var _this = this;
        return this.map(function (s) { return _this.getComponent(s); }).filter(function (i) { return i; });
    };
    Selected.prototype.removeComponent = function (component, opts) {
        var _this = this;
        var toRemove = ((0,index_all.isArray)(component) ? component : [component]).map(function (c) { return _this.getByComponent(c); });
        return this.remove(toRemove, opts);
    };
    return Selected;
}(common/* Collection */.FE));
/* harmony default export */ const model_Selected = (Selected);

;// CONCATENATED MODULE: ./src/abstract/Module.ts
var Module_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};


var Module = /** @class */ (function () {
    function Module(em, moduleName, defaults) {
        this.cls = [];
        this._em = em;
        this._name = moduleName;
        var name = (this.name.charAt(0).toLowerCase() + this.name.slice(1));
        var cfgParent = !(0,index_all.isUndefined)(em.config[name]) ? em.config[name] : em.config[this.name];
        var cfg = (cfgParent === true ? {} : cfgParent || {});
        cfg.pStylePrefix = em.config.pStylePrefix || '';
        if (!(0,index_all.isUndefined)(cfgParent) && !cfgParent) {
            cfg._disable = 1;
        }
        cfg.em = em;
        this._config = (0,mixins.deepMerge)(defaults || {}, cfg);
    }
    Object.defineProperty(Module.prototype, "em", {
        get: function () {
            return this._em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Module.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: false,
        configurable: true
    });
    Module.prototype.render = function (opts) { };
    Module.prototype.postLoad = function (key) { };
    Object.defineProperty(Module.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    Module.prototype.getConfig = function (name) {
        // @ts-ignore
        return name ? this.config[name] : this.config;
    };
    Module.prototype.__logWarn = function (str, opts) {
        if (opts === void 0) { opts = {}; }
        this.em.logWarning("[".concat(this.name, "]: ").concat(str), opts);
    };
    /**
     * Move the main DOM element of the module.
     * To execute only post editor render (in postRender)
     */
    Module.prototype.__appendTo = function () {
        var elTo = this.getConfig().appendTo;
        if (elTo) {
            var el = (0,index_all.isElement)(elTo) ? elTo : document.querySelector(elTo);
            if (!el)
                return this.__logWarn('"appendTo" element not found');
            el.appendChild(this.render());
        }
    };
    return Module;
}());
/* harmony default export */ const abstract_Module = (Module);
var ItemManagerModule = /** @class */ (function (_super) {
    Module_extends(ItemManagerModule, _super);
    function ItemManagerModule(em, moduleName, all, events, defaults, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, em, moduleName, defaults) || this;
        _this.cls = [];
        _this.private = false;
        _this.all = all;
        _this.events = events;
        !opts.skipListen && _this.__initListen();
        return _this;
    }
    ItemManagerModule.prototype.postLoad = function (key) { };
    ItemManagerModule.prototype.render = function (opts) { };
    ItemManagerModule.prototype.getProjectData = function (data) {
        var obj = {};
        var key = this.storageKey;
        if (key) {
            obj[key] = data || this.getAll();
        }
        return obj;
    };
    ItemManagerModule.prototype.loadProjectData = function (data, param) {
        if (data === void 0) { data = {}; }
        if (param === void 0) { param = {}; }
        var all = param.all, onResult = param.onResult, reset = param.reset;
        var key = this.storageKey;
        var opts = { action: 'load' };
        var coll = all || this.all;
        var result = data[key];
        if (typeof result == 'string') {
            try {
                result = JSON.parse(result);
            }
            catch (err) {
                this.__logWarn('Data parsing failed', { input: result });
            }
        }
        reset && result && coll.reset(undefined, opts);
        if (onResult) {
            result && onResult(result, opts);
        }
        else if (result && (0,mixins.isDef)(result.length)) {
            coll.reset(result, opts);
        }
        return result;
    };
    ItemManagerModule.prototype.clear = function (opts) {
        if (opts === void 0) { opts = {}; }
        var all = this.all;
        all && all.reset(undefined, opts);
        return this;
    };
    // getAll(): TCollection extends Collection<infer C> ? C[] : TCollection {
    ItemManagerModule.prototype.getAll = function () {
        return __spreadArray([], this.all.models, true);
    };
    ItemManagerModule.prototype.getAllMap = function () {
        return this.getAll().reduce(function (acc, i) {
            acc[i.get(i.idAttribute)] = i;
            return acc;
        }, {});
    };
    ItemManagerModule.prototype.__initListen = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, all = _a.all, em = _a.em, events = _a.events;
        all &&
            em &&
            all
                .on('add', function (m, c, o) { return em.trigger(events.add, m, o); })
                .on('remove', function (m, c, o) { return em.trigger(events.remove, m, o); })
                .on('change', function (p, c) { return em.trigger(events.update, p, p.changedAttributes(), c); })
                .on('all', this.__catchAllEvent, this);
        // Register collections
        this.cls = [all].concat(opts.collections || []);
        // Propagate events
        (opts.propagate || []).forEach(function (_a) {
            var entity = _a.entity, event = _a.event;
            entity.on('all', function (ev, model, coll, opts) {
                var options = opts || coll;
                var opt = __assign({ event: ev }, options);
                [em, all].map(function (md) { return md.trigger(event, model, opt); });
            });
        });
    };
    ItemManagerModule.prototype.__remove = function (model, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        //@ts-ignore
        var md = (0,index_all.isString)(model) ? this.get(model) : model;
        var rm = function () {
            md && _this.all.remove(md, opts);
            return md;
        };
        !opts.silent && (em === null || em === void 0 ? void 0 : em.trigger(this.events.removeBefore, md, rm, opts));
        return !opts.abort && rm();
    };
    ItemManagerModule.prototype.__catchAllEvent = function (event, model, coll, opts) {
        var _a = this, em = _a.em, events = _a.events;
        var options = opts || coll;
        em && events.all && em.trigger(events.all, { event: event, model: model, options: options });
        this.__onAllEvent();
    };
    ItemManagerModule.prototype.__appendTo = function (renderProps) {
        //@ts-ignore
        var elTo = this.config.appendTo;
        if (elTo) {
            var el = (0,index_all.isElement)(elTo) ? elTo : document.querySelector(elTo);
            if (!el)
                return this.__logWarn('"appendTo" element not found');
            // @ts-ignore
            el.appendChild(this.render(renderProps));
        }
    };
    ItemManagerModule.prototype.__onAllEvent = function () { };
    ItemManagerModule.prototype._createId = function (len) {
        if (len === void 0) { len = 16; }
        var all = this.getAll();
        var ln = all.length + len;
        var allMap = this.getAllMap();
        var id;
        do {
            id = (0,mixins.createId)(ln);
        } while (allMap[id]);
        return id;
    };
    ItemManagerModule.prototype.__listenAdd = function (model, event) {
        var _this = this;
        model.on('add', function (m, c, o) { return _this.em.trigger(event, m, o); });
    };
    ItemManagerModule.prototype.__listenRemove = function (model, event) {
        var _this = this;
        model.on('remove', function (m, c, o) { return _this.em.trigger(event, m, o); });
    };
    ItemManagerModule.prototype.__listenUpdate = function (model, event) {
        var _this = this;
        model.on('change', function (p, c) { return _this.em.trigger(event, p, p.changedAttributes(), c); });
    };
    ItemManagerModule.prototype.__destroy = function () {
        var _a;
        this.cls.forEach(function (coll) {
            coll.stopListening();
            coll.reset();
        });
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.remove();
        this.view = undefined;
    };
    return ItemManagerModule;
}(Module));


;// CONCATENATED MODULE: ./src/canvas/config/config.ts
var config_config_config = {
    stylePrefix: 'cv-',
    scripts: [],
    styles: [],
    customBadgeLabel: undefined,
    autoscrollLimit: 50,
    extHl: false,
    frameContent: '<!DOCTYPE html>',
    frameStyle: "\n    body { background-color: #fff }\n    * ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1) }\n    * ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.2) }\n    * ::-webkit-scrollbar { width: 10px }\n  ",
    notTextable: ['button', 'a', 'input[type=checkbox]', 'input[type=radio]'],
    allowExternalDrop: true,
};
/* harmony default export */ const canvas_config_config = (config_config_config);

// EXTERNAL MODULE: ./src/abstract/ModuleModel.ts
var ModuleModel = __webpack_require__(728);
;// CONCATENATED MODULE: ./src/device_manager/config/config.ts
var device_manager_config_config_config = {
    default: '',
    devices: [
        {
            id: 'desktop',
            name: 'Desktop',
            width: '',
        },
        {
            id: 'tablet',
            name: 'Tablet',
            width: '770px',
            widthMedia: '992px',
        },
        {
            id: 'mobileLandscape',
            name: 'Mobile landscape',
            width: '568px',
            widthMedia: '768px',
        },
        {
            id: 'mobilePortrait',
            name: 'Mobile portrait',
            width: '320px',
            widthMedia: '480px',
        },
    ],
};
/* harmony default export */ const device_manager_config_config = (device_manager_config_config_config);

;// CONCATENATED MODULE: ./src/device_manager/model/Device.ts
var Device_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @typedef Device
 * @property {String} [name=''] Device type, eg. `Mobile`
 * @property {String} [width] Width to set for the editor iframe, eg. '900px'
 * @property {String} [height=''] Height to set for the editor iframe, eg. '600px'
 * @property {String} [widthMedia=''] The width which will be used in media queries, If empty the width will be used
 * @property {Number} [priority=null] Setup the order of media queries
 */
var Device = /** @class */ (function (_super) {
    Device_extends(Device, _super);
    function Device() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Device.prototype.defaults = function () {
        return {
            name: '',
            width: null,
            height: '',
            widthMedia: null,
            priority: null,
        };
    };
    Device.prototype.initialize = function () {
        var _this = this;
        this.get('widthMedia') === null && this.set('widthMedia', this.get('width'));
        this.get('width') === null && this.set('width', this.get('widthMedia'));
        !this.get('priority') && this.set('priority', parseFloat(this.get('widthMedia')) || 0);
        var toCheck = ['width', 'height', 'widthMedia'];
        toCheck.forEach(function (prop) { return _this.checkUnit(prop); });
    };
    Device.prototype.checkUnit = function (prop) {
        var pr = (this.get(prop) || '');
        var noUnit = (parseFloat(pr) || 0).toString() === pr.toString();
        noUnit && this.set(prop, "".concat(pr, "px"));
    };
    Device.prototype.getName = function () {
        return this.get('name') || this.get('id');
    };
    Device.prototype.getWidthMedia = function () {
        return this.get('widthMedia') || '';
    };
    return Device;
}(common/* Model */.Hn));
/* harmony default export */ const model_Device = (Device);

;// CONCATENATED MODULE: ./src/device_manager/model/Devices.ts
var Devices_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Devices = /** @class */ (function (_super) {
    Devices_extends(Devices, _super);
    function Devices() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Devices;
}(common/* Collection */.FE));
/* harmony default export */ const model_Devices = (Devices);
Devices.prototype.model = model_Device;

;// CONCATENATED MODULE: ./src/device_manager/view/DevicesView.ts
var DevicesView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


var DevicesView = /** @class */ (function (_super) {
    DevicesView_extends(DevicesView, _super);
    function DevicesView(o) {
        var _this = _super.call(this, o) || this;
        _this.config = o.config || {};
        _this.em = _this.config.em;
        _this.ppfx = _this.config.pStylePrefix || '';
        _this.listenTo(_this.em, 'change:device', _this.updateSelect);
        return _this;
    }
    DevicesView.prototype.template = function (_a) {
        var ppfx = _a.ppfx, label = _a.label;
        return html(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n      <div class=\"", "device-label\">", "</div>\n      <div class=\"", "field ", "select\">\n        <span id=\"", "input-holder\">\n          <select class=\"", "devices\"></select>\n        </span>\n        <div class=\"", "sel-arrow\">\n          <div class=\"", "d-s-arrow\"></div>\n        </div>\n      </div>\n      <button style=\"display:none\" class=\"", "add-trasp\" data-add-trasp>+</button>\n    "], ["\n      <div class=\"", "device-label\">", "</div>\n      <div class=\"", "field ", "select\">\n        <span id=\"", "input-holder\">\n          <select class=\"", "devices\"></select>\n        </span>\n        <div class=\"", "sel-arrow\">\n          <div class=\"", "d-s-arrow\"></div>\n        </div>\n      </div>\n      <button style=\"display:none\" class=\"", "add-trasp\" data-add-trasp>+</button>\n    "])), ppfx, label, ppfx, ppfx, ppfx, ppfx, ppfx, ppfx, ppfx);
    };
    DevicesView.prototype.events = function () {
        return {
            change: 'updateDevice',
            'click [data-add-trasp]': 'startAdd',
        };
    };
    /**
     * Start adding new device
     * @return {[type]} [description]
     * @private
     */
    DevicesView.prototype.startAdd = function () { };
    /**
     * Update device of the editor
     * @private
     */
    DevicesView.prototype.updateDevice = function () {
        var em = this.em;
        if (em) {
            var devEl = this.devicesEl;
            em.set('device', devEl ? devEl.val() : '');
        }
    };
    /**
     * Update select value on device update
     * @private
     */
    DevicesView.prototype.updateSelect = function () {
        var _a = this, em = _a.em, devicesEl = _a.devicesEl;
        if (em && em.getDeviceModel && devicesEl) {
            var device = em.getDeviceModel();
            devicesEl.val(device ? device.get('id') : '');
        }
    };
    /**
     * Return devices options
     * @return {string} String of options
     * @private
     */
    DevicesView.prototype.getOptions = function () {
        var _a = this, collection = _a.collection, em = _a.em;
        var result = '';
        collection.forEach(function (device) {
            var _a = device.attributes, name = _a.name, id = _a.id;
            var label = (em && em.t && em.t("deviceManager.devices.".concat(id))) || name;
            result += "<option value=\"".concat(id || name, "\">").concat(label, "</option>");
        });
        return result;
    };
    DevicesView.prototype.render = function () {
        var _a = this, em = _a.em, ppfx = _a.ppfx, $el = _a.$el, el = _a.el;
        var label = em && em.t && em.t('deviceManager.device');
        $el.html(this.template({ ppfx: ppfx, label: label }));
        this.devicesEl = $el.find(".".concat(ppfx, "devices"));
        this.devicesEl.append(this.getOptions());
        this.devicesEl.val(em.get('device'));
        el.className = "".concat(ppfx, "devices-c");
        return this;
    };
    return DevicesView;
}(common/* View */.G7));
/* harmony default export */ const view_DevicesView = (DevicesView);
var templateObject_1;

;// CONCATENATED MODULE: ./src/device_manager/index.ts
var device_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var device_manager_assign = (undefined && undefined.__assign) || function () {
    device_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return device_manager_assign.apply(this, arguments);
};
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/device_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  deviceManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const deviceManager = editor.Devices;
 * ```
 * ## Available Events
 * * `device:add` - Added new device. The [Device] is passed as an argument to the callback
 * * `device:remove` - Device removed. The [Device] is passed as an argument to the callback
 * * `device:select` - New device selected. The newly selected [Device] and the previous one, are passed as arguments to the callback
 * * `device:update` - Device updated. The updated [Device] and the object containing changes are passed as arguments to the callback
 * * `device` - Catch-all event for all the events mentioned above. An object containing all the available data about the triggered event is passed as an argument to the callback
 *
 * ## Methods
 * * [add](#add)
 * * [get](#get)
 * * [getDevices](#getdevices)
 * * [remove](#remove)
 * * [select](#select)
 * * [getSelected](#getselected)
 *
 * [Device]: device.html
 *
 * @module Devices
 */






var evAll = 'device';
var evPfx = "".concat(evAll, ":");
var evSelect = "".concat(evPfx, "select");
var evSelectBefore = "".concat(evSelect, ":before");
var evUpdate = "".concat(evPfx, "update");
var evAdd = "".concat(evPfx, "add");
var evAddBefore = "".concat(evAdd, ":before");
var evRemove = "".concat(evPfx, "remove");
var evRemoveBefore = "".concat(evRemove, ":before");
var chnSel = 'change:device';
var deviceEvents = {
    all: evAll,
    select: evSelect,
    update: evUpdate,
    add: evAdd,
    remove: evRemove,
    removeBefore: evRemoveBefore,
};
var DeviceManager = /** @class */ (function (_super) {
    device_manager_extends(DeviceManager, _super);
    function DeviceManager(em) {
        var _a;
        var _this = _super.call(this, em, 'DeviceManager', new model_Devices(), deviceEvents, device_manager_config_config) || this;
        _this.Device = model_Device;
        _this.Devices = model_Devices;
        _this.storageKey = '';
        _this.devices = _this.all;
        (_a = _this.config.devices) === null || _a === void 0 ? void 0 : _a.forEach(function (device) { return _this.add(device, { silent: true }); });
        _this.select(_this.config.default || _this.devices.at(0));
        em.on(chnSel, _this._onSelect, _this);
        return _this;
    }
    DeviceManager.prototype._onSelect = function (m, deviceId, opts) {
        var _a = this, em = _a.em, events = _a.events;
        var prevId = m.previous('device');
        var newDevice = this.get(deviceId);
        var ev = events.select;
        em.trigger(ev, newDevice, this.get(prevId));
        this.__catchAllEvent(ev, newDevice, opts);
    };
    /**
     * Add new device
     * @param {Object} props Device properties
     * @returns {[Device]} Added device
     * @example
     * const device1 = deviceManager.add({
     *  // Without an explicit ID, the `name` will be taken. In case of missing `name`, a random ID will be created.
     *  id: 'tablet',
     *  name: 'Tablet',
     *  width: '900px', // This width will be applied on the canvas frame and for the CSS media
     * });
     * const device2 = deviceManager.add({
     *  id: 'tablet2',
     *  name: 'Tablet 2',
     *  width: '800px', // This width will be applied on the canvas frame
     *  widthMedia: '810px', // This width that will be used for the CSS media
     *  height: '600px', // Height will be applied on the canvas frame
     * });
     */
    DeviceManager.prototype.add = function (props, options) {
        if (options === void 0) { options = {}; }
        var result;
        var opts = options;
        // Support old API
        if ((0,index_all.isString)(props)) {
            var width = options;
            opts = arguments[2] || {};
            result = device_manager_assign(device_manager_assign({}, opts), { id: props, name: opts.name || props, width: width });
        }
        else {
            result = props;
        }
        if (!result.id) {
            result.id = result.name || this._createId();
        }
        return this.devices.add(result, opts);
    };
    /**
     * Return device by ID
     * @param  {String} id ID of the device
     * @returns {[Device]|null}
     * @example
     * const device = deviceManager.get('Tablet');
     * console.log(JSON.stringify(device));
     * // {name: 'Tablet', width: '900px'}
     */
    DeviceManager.prototype.get = function (id) {
        // Support old API
        var byName = this.getAll().filter(function (d) { return d.get('name') === id; })[0];
        return byName || this.devices.get(id) || null;
    };
    /**
     * Remove device
     * @param {String|[Device]} device Device or device id
     * @returns {[Device]} Removed device
     * @example
     * const removed = deviceManager.remove('device-id');
     * // or by passing the Device
     * const device = deviceManager.get('device-id');
     * deviceManager.remove(device);
     */
    DeviceManager.prototype.remove = function (device, opts) {
        if (opts === void 0) { opts = {}; }
        return this.__remove(device, opts);
    };
    /**
     * Return all devices
     * @returns {Array<[Device]>}
     * @example
     * const devices = deviceManager.getDevices();
     * console.log(JSON.stringify(devices));
     * // [{name: 'Desktop', width: ''}, ...]
     */
    DeviceManager.prototype.getDevices = function () {
        return this.devices.models;
    };
    /**
     * Change the selected device. This will update the frame in the canvas
     * @param {String|[Device]} device Device or device id
     * @example
     * deviceManager.select('some-id');
     * // or by passing the page
     * const device = deviceManager.get('some-id');
     * deviceManager.select(device);
     */
    DeviceManager.prototype.select = function (device, opts) {
        if (opts === void 0) { opts = {}; }
        var md = (0,index_all.isString)(device) ? this.get(device) : device;
        md && this.em.set('device', md.get('id'), opts);
        return this;
    };
    /**
     * Get the selected device
     * @returns {[Device]}
     * @example
     * const selected = deviceManager.getSelected();
     */
    DeviceManager.prototype.getSelected = function () {
        return this.get(this.em.get('device'));
    };
    DeviceManager.prototype.getAll = function () {
        return this.devices;
    };
    DeviceManager.prototype.render = function () {
        var _a;
        var em = this.em;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.remove();
        this.view = new view_DevicesView({
            collection: this.devices,
            config: device_manager_assign({ em: em }, this.config),
        });
        return this.view.render().el;
    };
    DeviceManager.prototype.destroy = function () {
        this.__destroy();
    };
    return DeviceManager;
}(ItemManagerModule));
/* harmony default export */ const device_manager = (DeviceManager);

;// CONCATENATED MODULE: ./src/abstract/ModuleCollection.ts
var ModuleCollection_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ModuleCollection = /** @class */ (function (_super) {
    ModuleCollection_extends(ModuleCollection, _super);
    function ModuleCollection(module, models, modelConstructor) {
        return _super.call(this, models, { module: module, modelConstructor: modelConstructor }) || this;
    }
    ModuleCollection.prototype.add = function (model, options) {
        var _this = this;
        var _a;
        //Note: the undefined case needed because backbonejs not handle the reset() correctly
        var models = (0,index_all.isArray)(model) ? model : !(0,index_all.isUndefined)(model) ? [model] : undefined;
        models = (_a = models === null || models === void 0 ? void 0 : models.map(function (m) { return (m instanceof _this.newModel ? m : new _this.newModel(_this.module, m)); })) !== null && _a !== void 0 ? _a : [undefined];
        return _super.prototype.add.call(this, (0,index_all.isArray)(model) ? models : models[0], options);
    };
    ModuleCollection.prototype.preinitialize = function (models, options) {
        this.newModel = options.modelConstructor;
        this.module = options.module;
    };
    return ModuleCollection;
}(common/* Collection */.FE));
/* harmony default export */ const abstract_ModuleCollection = (ModuleCollection);

;// CONCATENATED MODULE: ./src/canvas/model/Frame.ts
var Frame_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Frame_assign = (undefined && undefined.__assign) || function () {
    Frame_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Frame_assign.apply(this, arguments);
};
var Frame_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



var keyAutoW = '__aw';
var keyAutoH = '__ah';
var getDimension = function (frame, type) {
    var _a;
    var dim = frame.get(type);
    var viewDim = (_a = frame.view) === null || _a === void 0 ? void 0 : _a.el[type === 'width' ? 'offsetWidth' : 'offsetHeight'];
    if ((0,index_all.isNumber)(dim)) {
        return dim;
    }
    else if ((0,index_all.isString)(dim) && dim.endsWith('px')) {
        return parseFloat(dim);
    }
    else if (viewDim) {
        return viewDim;
    }
    else {
        return 0;
    }
};
/**
 * @property {Object|String} component Wrapper component definition. You can also pass an HTML string as components of the default wrapper component.
 * @property {String} [width=''] Width of the frame. By default, the canvas width will be taken.
 * @property {String} [height=''] Height of the frame. By default, the canvas height will be taken.
 * @property {Number} [x=0] Horizontal position of the frame in the canvas.
 * @property {Number} [y=0] Vertical position of the frame in the canvas.
 *
 */
var Frame = /** @class */ (function (_super) {
    Frame_extends(Frame, _super);
    /**
     * @hideconstructor
     */
    function Frame(module, attr) {
        var _this = _super.call(this, module, attr) || this;
        var em = _this.em;
        var _a = _this.attributes, styles = _a.styles, component = _a.component;
        var domc = em.Components;
        var conf = domc.getConfig();
        var allRules = em.Css.getAll();
        var idMap = {};
        var modOpts = { em: em, config: conf, frame: _this, idMap: idMap };
        if (!(0,mixins.isComponent)(component)) {
            var wrp = (0,mixins.isObject)(component) ? component : { components: component };
            !wrp.type && (wrp.type = 'wrapper');
            var Wrapper = domc.getType('wrapper').model;
            _this.set('component', new Wrapper(wrp, modOpts));
        }
        if (!styles) {
            _this.set('styles', allRules);
        }
        else if (!(0,mixins.isObject)(styles)) {
            var newStyles = styles;
            // Avoid losing styles on remapped components
            if ((0,index_all.keys)(idMap).length) {
                newStyles = (0,index_all.isString)(newStyles) ? em.Parser.parseCss(newStyles) : newStyles;
                em.Css.checkId(newStyles, { idMap: idMap });
            }
            allRules.add(newStyles);
            _this.set('styles', allRules);
        }
        !attr.width && _this.set(keyAutoW, 1);
        !attr.height && _this.set(keyAutoH, 1);
        !_this.id && _this.set('id', (0,mixins.createId)());
        return _this;
    }
    Frame.prototype.defaults = function () {
        return {
            x: 0,
            y: 0,
            changesCount: 0,
            attributes: {},
            width: null,
            height: null,
            head: [],
            component: '',
            styles: '',
            refFrame: null,
            _undo: true,
            _undoexc: ['changesCount'],
        };
    };
    Object.defineProperty(Frame.prototype, "width", {
        get: function () {
            return getDimension(this, 'width');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Frame.prototype, "height", {
        get: function () {
            return getDimension(this, 'height');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Frame.prototype, "head", {
        get: function () {
            return this.get('head');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Frame.prototype, "refFrame", {
        get: function () {
            return this.get('refFrame');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Frame.prototype, "root", {
        get: function () {
            var refFrame = this.refFrame;
            return (refFrame === null || refFrame === void 0 ? void 0 : refFrame.getComponent()) || this.getComponent();
        },
        enumerable: false,
        configurable: true
    });
    Frame.prototype.initRefs = function () {
        var refFrame = this.refFrame;
        if ((0,index_all.isString)(refFrame)) {
            var frame = this.module.framesById[refFrame];
            frame && this.set({ refFrame: frame }, { silent: true });
        }
    };
    Frame.prototype.getBoxRect = function () {
        var _a = this.attributes, x = _a.x, y = _a.y;
        var _b = this, width = _b.width, height = _b.height;
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    };
    Frame.prototype.onRemove = function () {
        !this.refFrame && this.getComponent().remove({ root: 1 });
    };
    Frame.prototype.changesUp = function (opt) {
        if (opt === void 0) { opt = {}; }
        if (opt.temporary || opt.noCount || opt.avoidStore) {
            return;
        }
        this.set('changesCount', this.get('changesCount') + 1);
    };
    Frame.prototype.getComponent = function () {
        return this.get('component');
    };
    Frame.prototype.getStyles = function () {
        return this.get('styles');
    };
    Frame.prototype.disable = function () {
        this.trigger('disable');
    };
    Frame.prototype.remove = function () {
        var _a;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.remove();
        this.view = undefined;
        var coll = this.collection;
        return coll && coll.remove(this);
    };
    Frame.prototype.getHead = function () {
        return Frame_spreadArray([], this.head, true);
    };
    Frame.prototype.setHead = function (value) {
        return this.set('head', Frame_spreadArray([], value, true));
    };
    Frame.prototype.addHeadItem = function (item) {
        this.head.push(item);
    };
    Frame.prototype.getHeadByAttr = function (attr, value, tag) {
        return this.head.filter(function (item) { return item.attributes && item.attributes[attr] == value && (!tag || tag === item.tag); })[0];
    };
    Frame.prototype.removeHeadByAttr = function (attr, value, tag) {
        var item = this.getHeadByAttr(attr, value, tag);
        var index = this.head.indexOf(item);
        if (index >= 0) {
            this.head.splice(index, 1);
        }
    };
    Frame.prototype.addLink = function (href) {
        var tag = 'link';
        !this.getHeadByAttr('href', href, tag) &&
            this.addHeadItem({
                tag: tag,
                attributes: {
                    href: href,
                    rel: 'stylesheet',
                },
            });
    };
    Frame.prototype.removeLink = function (href) {
        this.removeHeadByAttr('href', href, 'link');
    };
    Frame.prototype.addScript = function (src) {
        var tag = 'script';
        !this.getHeadByAttr('src', src, tag) &&
            this.addHeadItem({
                tag: tag,
                attributes: { src: src },
            });
    };
    Frame.prototype.removeScript = function (src) {
        this.removeHeadByAttr('src', src, 'script');
    };
    Frame.prototype.getPage = function () {
        var _a;
        return (_a = this.collection) === null || _a === void 0 ? void 0 : _a.page;
    };
    Frame.prototype._emitUpdated = function (data) {
        if (data === void 0) { data = {}; }
        this.em.trigger('frame:updated', Frame_assign({ frame: this }, data));
    };
    Frame.prototype.hasAutoHeight = function () {
        var height = this.attributes.height;
        if (height === 'auto' || this.config.infiniteCanvas) {
            return true;
        }
        return false;
    };
    Frame.prototype.toJSON = function (opts) {
        if (opts === void 0) { opts = {}; }
        var obj = ModuleModel/* default */.Z.prototype.toJSON.call(this, opts);
        var defaults = (0,index_all.result)(this, 'defaults');
        if (opts.fromUndo)
            delete obj.component;
        delete obj.styles;
        delete obj.changesCount;
        obj[keyAutoW] && delete obj.width;
        obj[keyAutoH] && delete obj.height;
        if (obj.refFrame) {
            obj.refFrame = obj.refFrame.id;
            delete obj.component;
        }
        // Remove private keys
        (0,index_all.forEach)(obj, function (value, key) {
            key.indexOf('_') === 0 && delete obj[key];
        });
        (0,index_all.forEach)(defaults, function (value, key) {
            if (obj[key] === value)
                delete obj[key];
        });
        (0,index_all.forEach)(['attributes', 'head'], function (prop) {
            if ((0,index_all.isEmpty)(obj[prop]))
                delete obj[prop];
        });
        return obj;
    };
    return Frame;
}(ModuleModel/* default */.Z));
/* harmony default export */ const model_Frame = (Frame);

;// CONCATENATED MODULE: ./src/canvas/model/Frames.ts
var Frames_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var Frames = /** @class */ (function (_super) {
    Frames_extends(Frames, _super);
    function Frames(module, models) {
        if (models === void 0) { models = []; }
        var _this = _super.call(this, module, models, model_Frame) || this;
        _this.loadedItems = 0;
        _this.itemsToLoad = 0;
        (0,index_all.bindAll)(_this, 'itemLoaded');
        _this.on('add', _this.onAdd);
        _this.on('reset', _this.onReset);
        _this.on('remove', _this.onRemove);
        _this.forEach(function (frame) { return _this.onAdd(frame); });
        return _this;
    }
    Frames.prototype.onAdd = function (frame) {
        this.module.framesById[frame.id] = frame;
    };
    Frames.prototype.onReset = function (m, opts) {
        var _this = this;
        var prev = (opts === null || opts === void 0 ? void 0 : opts.previousModels) || [];
        prev.map(function (p) { return _this.onRemove(p); });
    };
    Frames.prototype.onRemove = function (frame) {
        frame.onRemove();
        delete this.module.framesById[frame.id];
    };
    Frames.prototype.initRefs = function () {
        this.forEach(function (frame) { return frame.initRefs(); });
    };
    Frames.prototype.itemLoaded = function () {
        this.loadedItems++;
        if (this.loadedItems >= this.itemsToLoad) {
            this.trigger('loaded:all');
            this.listenToLoadItems(false);
        }
    };
    Frames.prototype.listenToLoad = function () {
        this.loadedItems = 0;
        this.itemsToLoad = this.length;
        this.listenToLoadItems(true);
    };
    Frames.prototype.listenToLoadItems = function (on) {
        var _this = this;
        this.forEach(function (item) { return item[on ? 'on' : 'off']('loaded', _this.itemLoaded); });
    };
    return Frames;
}(abstract_ModuleCollection));
/* harmony default export */ const model_Frames = (Frames);

;// CONCATENATED MODULE: ./src/pages/model/Page.ts
var Page_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var Page = /** @class */ (function (_super) {
    Page_extends(Page, _super);
    function Page(props, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, props, opts) || this;
        var em = opts.em;
        var defFrame = {};
        _this.em = em;
        if (!props.frames) {
            defFrame.component = props.component;
            defFrame.styles = props.styles;
            ['component', 'styles'].map(function (i) { return _this.unset(i); });
        }
        var frms = props.frames || [defFrame];
        var frames = new model_Frames(em.Canvas, frms);
        frames.page = _this;
        _this.set('frames', frames);
        !_this.getId() && _this.set('id', em === null || em === void 0 ? void 0 : em.Pages._createId());
        em === null || em === void 0 ? void 0 : em.UndoManager.add(frames);
        return _this;
    }
    Page.prototype.defaults = function () {
        return {
            name: '',
            frames: [],
            _undo: true,
        };
    };
    Page.prototype.onRemove = function () {
        this.getFrames().reset();
    };
    Page.prototype.getFrames = function () {
        return this.get('frames');
    };
    /**
     * Get page id
     * @returns {String}
     */
    Page.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get page name
     * @returns {String}
     */
    Page.prototype.getName = function () {
        return this.get('name');
    };
    /**
     * Update page name
     * @param {String} name New page name
     * @example
     * page.setName('New name');
     */
    Page.prototype.setName = function (name) {
        return this.set({ name: name });
    };
    /**
     * Get all frames
     * @returns {Array<Frame>}
     * @example
     * const arrayOfFrames = page.getAllFrames();
     */
    Page.prototype.getAllFrames = function () {
        return this.getFrames().models || [];
    };
    /**
     * Get the first frame of the page (identified always as the main one)
     * @returns {Frame}
     * @example
     * const mainFrame = page.getMainFrame();
     */
    Page.prototype.getMainFrame = function () {
        return this.getFrames().at(0);
    };
    /**
     * Get the root component (usually is the `wrapper` component) from the main frame
     * @returns {Component}
     * @example
     * const rootComponent = page.getMainComponent();
     * console.log(rootComponent.toHTML());
     */
    Page.prototype.getMainComponent = function () {
        var frame = this.getMainFrame();
        return frame === null || frame === void 0 ? void 0 : frame.getComponent();
    };
    Page.prototype.toJSON = function (opts) {
        if (opts === void 0) { opts = {}; }
        var obj = common/* Model */.Hn.prototype.toJSON.call(this, opts);
        var defaults = (0,index_all.result)(this, 'defaults');
        // Remove private keys
        (0,index_all.forEach)(obj, function (value, key) {
            key.indexOf('_') === 0 && delete obj[key];
        });
        (0,index_all.forEach)(defaults, function (value, key) {
            if (obj[key] === value)
                delete obj[key];
        });
        return obj;
    };
    return Page;
}(common/* Model */.Hn));
/* harmony default export */ const model_Page = (Page);

;// CONCATENATED MODULE: ./src/pages/model/Pages.ts
var Pages_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Pages_assign = (undefined && undefined.__assign) || function () {
    Pages_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Pages_assign.apply(this, arguments);
};


var Pages = /** @class */ (function (_super) {
    Pages_extends(Pages, _super);
    function Pages(models, em) {
        var _this = _super.call(this, models) || this;
        _this.on('reset', _this.onReset);
        _this.on('remove', _this.onRemove);
        // @ts-ignore We need to inject `em` for pages created on reset from the Storage load
        _this.model = function (props, opts) {
            if (opts === void 0) { opts = {}; }
            return new model_Page(props, Pages_assign(Pages_assign({}, opts), { em: em }));
        };
        return _this;
    }
    Pages.prototype.onReset = function (m, opts) {
        var _this = this;
        var _a;
        (_a = opts === null || opts === void 0 ? void 0 : opts.previousModels) === null || _a === void 0 ? void 0 : _a.map(function (p) { return _this.onRemove(p); });
    };
    Pages.prototype.onRemove = function (removed) {
        removed === null || removed === void 0 ? void 0 : removed.onRemove();
    };
    return Pages;
}(common/* Collection */.FE));
/* harmony default export */ const model_Pages = (Pages);

;// CONCATENATED MODULE: ./src/common/traits/model/Trait.ts
var Trait_assign = (undefined && undefined.__assign) || function () {
    Trait_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Trait_assign.apply(this, arguments);
};
var Trait = /** @class */ (function () {
    function Trait(opts) {
        var _a, _b;
        this.updatingValue = false;
        this.opts = Trait_assign(Trait_assign({}, opts), { default: (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.default) !== null && _b !== void 0 ? _b : '' });
    }
    Object.defineProperty(Trait.prototype, "name", {
        get: function () {
            return this.opts.name;
        },
        enumerable: false,
        configurable: true
    });
    Trait.prototype.registerForUpdateEvent = function (view) {
        this.view = view;
    };
    Object.defineProperty(Trait.prototype, "changeProp", {
        get: function () {
            var _a;
            return (_a = this.opts.changeProp) !== null && _a !== void 0 ? _a : false;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Trait.prototype, "value", {
        get: function () {
            var _a;
            return (_a = this.getValue()) !== null && _a !== void 0 ? _a : this.opts.default;
        },
        set: function (value) {
            this.updatingValue = true;
            this.setValue(value);
            this.updatingValue = false;
        },
        enumerable: false,
        configurable: true
    });
    Trait.prototype.setValueFromModel = function () {
        var _a;
        if (!this.updatingValue) {
            (_a = this.view) === null || _a === void 0 ? void 0 : _a.onUpdateEvent(this.value);
        }
    };
    Trait.prototype.updateOpts = function (opts) {
        this.opts = Trait_assign(Trait_assign({}, this.opts), opts);
    };
    return Trait;
}());
/* harmony default export */ const model_Trait = (Trait);

;// CONCATENATED MODULE: ./src/common/traits/model/TraitGroupItem.ts
var TraitGroupItem_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitGroupItem_assign = (undefined && undefined.__assign) || function () {
    TraitGroupItem_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitGroupItem_assign.apply(this, arguments);
};

var TraitGroupItem = /** @class */ (function (_super) {
    TraitGroupItem_extends(TraitGroupItem, _super);
    function TraitGroupItem(name, parent, opts) {
        var _this = _super.call(this, TraitGroupItem_assign(TraitGroupItem_assign({}, opts), { name: name })) || this;
        // this.opts = opts;
        _this.parent = parent;
        return _this;
    }
    TraitGroupItem.prototype.getValue = function () {
        var name = this.name;
        console.log('getValues');
        var value = this.parent.getParentValue(name);
        return value !== null && value !== void 0 ? value : this.opts.default;
    };
    TraitGroupItem.prototype.setValue = function (value) {
        var _a = this, parent = _a.parent, name = _a.name;
        console.log('TraitGroupItem:setValues');
        parent.setParentValue(name, value);
    };
    return TraitGroupItem;
}(model_Trait));
/* harmony default export */ const model_TraitGroupItem = (TraitGroupItem);

;// CONCATENATED MODULE: ./src/common/traits/model/TraitGroup.ts
var TraitGroup_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitGroup_assign = (undefined && undefined.__assign) || function () {
    TraitGroup_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitGroup_assign.apply(this, arguments);
};



var TraitGroup = /** @class */ (function (_super) {
    TraitGroup_extends(TraitGroup, _super);
    function TraitGroup(name, parent, opts) {
        var _a;
        var _this = _super.call(this, TraitGroup_assign(TraitGroup_assign({}, opts), { name: name, changeProp: true })) || this;
        _this.parent = parent;
        _this.templates = (_a = opts.traits) !== null && _a !== void 0 ? _a : [{ type: 'text' }];
        if (!(0,index_all.isObject)(parent.getParentValue(name))) {
            parent.setParentValue(name, {});
        }
        console.log(_this);
        return _this;
    }
    Object.defineProperty(TraitGroup.prototype, "traits", {
        get: function () {
            var _this = this;
            var value = this.value;
            return this.templates.map(function (tr) { return new model_TraitGroupItem(tr.name, _this, TraitGroup_assign(TraitGroup_assign({}, tr), { value: value[tr.name] })); });
        },
        enumerable: false,
        configurable: true
    });
    TraitGroup.prototype.getParentValue = function (name) {
        return this.value[name];
    };
    TraitGroup.prototype.setParentValue = function (name, value) {
        var _a;
        this.value = TraitGroup_assign(TraitGroup_assign({}, this.value), (_a = {}, _a[name] = value, _a));
        console.log('group setvalue');
    };
    TraitGroup.prototype.getValue = function () {
        var _a = this, parent = _a.parent, name = _a.name;
        console.log(name);
        return parent.getParentValue(name);
    };
    TraitGroup.prototype.setValue = function (values) {
        var _a = this, name = _a.name, parent = _a.parent;
        parent.setParentValue(name, values);
    };
    return TraitGroup;
}(model_Trait));
/* harmony default export */ const model_TraitGroup = (TraitGroup);

;// CONCATENATED MODULE: ./src/common/traits/model/TraitList.ts
var TraitList_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitList_assign = (undefined && undefined.__assign) || function () {
    TraitList_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitList_assign.apply(this, arguments);
};




var TraitList = /** @class */ (function (_super) {
    TraitList_extends(TraitList, _super);
    // traits: (TraitGroupItem|TraitGroup)[];
    function TraitList(name, model, opts) {
        var _a;
        var _this = _super.call(this, TraitList_assign(TraitList_assign({}, opts), { type: 'list', name: name, changeProp: true })) || this;
        model.on('change:' + name, _this.setValueFromModel, _this);
        _this.model = model;
        // this.model.on("all", (e) => console.log(e))
        // this.traits = opts?.traits ?? [{type: "list"}]
        (_a = model.get(name)) !== null && _a !== void 0 ? _a : model.set(name, []);
        // this.value= model.get("values")
        _this.templates = opts.traits;
        return _this;
        //   this.traits = []
        //   this.value.forEach(v => this.traits.push(this.initTrait(v)))
    }
    Object.defineProperty(TraitList.prototype, "traits", {
        get: function () {
            var _this = this;
            return this.value.map(function (v, index) { return _this.initTrait(v, index + ''); });
        },
        enumerable: false,
        configurable: true
    });
    TraitList.prototype.getParentValue = function (name) {
        return this.value[name];
    };
    TraitList.prototype.setParentValue = function (name, value) {
        var values = this.value;
        values[name] = value;
        this.value = values;
        console.log('setvalue');
    };
    TraitList.prototype.initTrait = function (value, index) {
        var templates = this.templates;
        var traits = this.templates;
        // console.log(this.traits)
        // const index = this.traits.length as any
        if ((0,index_all.isArray)(templates) && templates.length > 1) {
            return new model_TraitGroup(index, this, { name: index, traits: traits, value: value });
        }
        else {
            return new model_TraitGroupItem(index, this, TraitList_assign(TraitList_assign({}, traits), { value: value }));
        }
    };
    TraitList.prototype.getValue = function () {
        var _a = this, model = _a.model, name = _a.name;
        return model.get(name);
    };
    TraitList.prototype.setValue = function (values) {
        var _a = this, name = _a.name, model = _a.model;
        console.log('setValue');
        model.set(name, values);
    };
    TraitList.prototype.add = function (key) {
        var _a = this, model = _a.model, name = _a.name;
        this.value.push('');
        model.trigger("change:".concat(name));
    };
    TraitList.prototype.remove = function (key) {
        var _a, _b;
        var index = (_b = (_a = this.traits) === null || _a === void 0 ? void 0 : _a.findIndex(function (tr) { return tr.name == key; })) !== null && _b !== void 0 ? _b : -1;
        //   if (index > -1) {
        //     this.value.splice(index, 1);
        //   }
    };
    return TraitList;
}(model_Trait));
/* harmony default export */ const model_TraitList = (TraitList);

;// CONCATENATED MODULE: ./src/common/traits/model/TraitSingle.ts
var TraitSingle_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitSingle_assign = (undefined && undefined.__assign) || function () {
    TraitSingle_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitSingle_assign.apply(this, arguments);
};

var TraitSingle = /** @class */ (function (_super) {
    TraitSingle_extends(TraitSingle, _super);
    function TraitSingle(name, model, opts) {
        var _this = _super.call(this, TraitSingle_assign(TraitSingle_assign({}, opts), { name: name })) || this;
        model.on('change:' + name, _this.setValueFromModel, _this);
        _this.model = model;
        return _this;
    }
    TraitSingle.prototype.getValue = function () {
        var _a = this, changeProp = _a.changeProp, model = _a.model, name = _a.name;
        var value = changeProp
            ? model.get(name)
            : // TODO update post component update
                model.get('attributes')[name];
        return value;
    };
    TraitSingle.prototype.setValue = function (value) {
        var _a;
        var _b = this, name = _b.name, model = _b.model, changeProp = _b.changeProp;
        if (changeProp) {
            model.set(name, value);
        }
        else {
            model.set('attributes', TraitSingle_assign(TraitSingle_assign({}, model.get('attributes')), (_a = {}, _a[name] = value, _a)));
        }
    };
    return TraitSingle;
}(model_Trait));
/* harmony default export */ const model_TraitSingle = (TraitSingle);

;// CONCATENATED MODULE: ./src/common/traits/model/TraitFactory.ts




var TraiFactory = /** @class */ (function () {
    function TraiFactory() {
    }
    TraiFactory.build = function (model, trait) {
        if (!(trait instanceof model_Trait)) {
            if ((0,index_all.isString)(trait)) {
                return new model_TraitSingle(trait, model, { type: 'text', label: trait });
            }
            else {
                switch (trait.type) {
                    case 'list':
                        return new model_TraitList(trait.name, model, trait);
                    default:
                        return new model_TraitSingle(trait.name, model, trait);
                }
            }
        }
        else {
            return trait;
        }
    };
    return TraiFactory;
}());
/* harmony default export */ const TraitFactory = (TraiFactory);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitView.ts
var TraitView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitView_assign = (undefined && undefined.__assign) || function () {
    TraitView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitView_assign.apply(this, arguments);
};




// type TypeFromTraitView<TView extends TraitView<string>> = TView extends TraitView<infer M> ? M : unknown;
var TraitView = /** @class */ (function (_super) {
    TraitView_extends(TraitView, _super);
    function TraitView(em, opts) {
        var _a;
        var _this = _super.call(this, { el: opts === null || opts === void 0 ? void 0 : opts.el }) || this;
        _this.em = em;
        var config = _this.em.Traits.config;
        _this.ppfx = config.pStylePrefix || '';
        _this.pfx = _this.ppfx + config.stylePrefix || '';
        _this._label = opts === null || opts === void 0 ? void 0 : opts.label;
        _this.noLabel = (_a = ((opts === null || opts === void 0 ? void 0 : opts.noLabel) && (opts === null || opts === void 0 ? void 0 : opts.label) !== false)) !== null && _a !== void 0 ? _a : false;
        return _this;
    }
    Object.defineProperty(TraitView.prototype, "name", {
        get: function () {
            var _a;
            return (_a = this.target) === null || _a === void 0 ? void 0 : _a.opts.name;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TraitView.prototype, "clsField", {
        get: function () {
            var _a = this, ppfx = _a.ppfx, type = _a.type;
            return "".concat(ppfx, "field ").concat(ppfx, "field-").concat(type);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TraitView.prototype, "label", {
        get: function () {
            var _a;
            return (_a = this._label) !== null && _a !== void 0 ? _a : this.name;
        },
        enumerable: false,
        configurable: true
    });
    TraitView.prototype.setTarget = function (target, model, opts) {
        if ((0,index_all.isString)(target) && model !== undefined) {
            target = TraitFactory.build(model, TraitView_assign(TraitView_assign({}, opts), { type: this.type, name: target }));
        }
        this.target = target;
        this.target.registerForUpdateEvent(this);
        return this;
    };
    /**
     * Returns label for the input
     */
    TraitView.prototype.getLabelText = function () {
        var _a = this, em = _a.em, label = _a.label;
        return label && (em.t("traitManager.traits.labels.".concat(label)) || (0,mixins.capitalize)(label).replace(/-/g, ' '));
    };
    TraitView.prototype.hasLabel = function () {
        return !this.noLabel;
    };
    return TraitView;
}(common/* View */.G7));
/* harmony default export */ const view_TraitView = (TraitView);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitInputView.ts
var TraitInputView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitInputView_assign = (undefined && undefined.__assign) || function () {
    TraitInputView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitInputView_assign.apply(this, arguments);
};




var TraitInputView = /** @class */ (function (_super) {
    TraitInputView_extends(TraitInputView, _super);
    function TraitInputView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.appendInput = true;
        return _this;
    }
    Object.defineProperty(TraitInputView.prototype, "clsField", {
        get: function () {
            var _a = this, ppfx = _a.ppfx, type = _a.type;
            return "".concat(ppfx, "field ").concat(ppfx, "field-").concat(type);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TraitInputView.prototype, "clsLabel", {
        get: function () {
            var ppfx = this.ppfx;
            return "".concat(ppfx, "label-wrp");
        },
        enumerable: false,
        configurable: true
    });
    TraitInputView.prototype.events = function () {
        return {
            change: this.onChange,
        };
    };
    TraitInputView.prototype.templateLabel = function () {
        var _a = this, ppfx = _a.ppfx, name = _a.name;
        var label = this.getLabel();
        return "<div class=\"".concat(ppfx, "label\" title=\"").concat(name, "\">").concat(label, "</div>");
    };
    TraitInputView.prototype.templateInput = function (defaultValue) {
        var clsField = this.clsField;
        return "<div class=\"".concat(clsField, "\" data-input></div>");
    };
    /**
     * Fires when the input is changed
     * @private
     */
    TraitInputView.prototype.onChange = function () {
        console.log('traitchange');
        this.target.value = this.inputValue;
    };
    TraitInputView.prototype.onUpdateEvent = function (value) {
        this.inputValue = value;
    };
    /**
     * Render label
     */
    TraitInputView.prototype.renderLabel = function () {
        var $el = this.$el;
        var tpl = this.templateLabel();
        $el.find('[data-label]').append(tpl);
    };
    /**
     * Returns label for the input
     */
    TraitInputView.prototype.getLabel = function () {
        var _a = this, em = _a.em, name = _a.name;
        var label = name !== null && name !== void 0 ? name : this.label;
        return em.t("traitManager.traits.labels.".concat(label)) || (0,mixins.capitalize)(label).replace(/-/g, ' ');
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     */
    TraitInputView.prototype.getInputEl = function () {
        if (!this.$input) {
            var _a = this, em = _a.em, name_1 = _a.name, type = _a.type;
            var value = this.target.value;
            var input = (0,cash_dom["default"])("<input type=\"".concat(type, "\">"));
            var i18nAttr = em.t("traitManager.traits.attributes.".concat(name_1)) || {};
            input.attr(TraitInputView_assign({ placeholder: this.paceholder || value }, i18nAttr));
            if (!(0,index_all.isUndefined)(value)) {
                input.prop('value', value);
            }
            this.$input = input;
        }
        return this.$input.get(0);
    };
    TraitInputView.prototype.getElInput = function () {
        return this.elInput;
    };
    /**
     * Renders input
     * @private
     * */
    TraitInputView.prototype.renderField = function () {
        var _a = this, $el = _a.$el, appendInput = _a.appendInput, elInput = _a.elInput;
        var inputs = $el.find('[data-input]');
        var el = inputs[inputs.length - 1];
        if (!elInput) {
            this.elInput = this.getInputEl();
            appendInput ? el.appendChild(this.elInput) : el.insertBefore(this.elInput, el.firstChild);
        }
    };
    TraitInputView.prototype.rerender = function () {
        delete this.elInput;
        this.render();
    };
    TraitInputView.prototype.render = function () {
        var _a = this, $el = _a.$el, pfx = _a.pfx, ppfx = _a.ppfx, name = _a.name, type = _a.type, clsLabel = _a.clsLabel;
        var hasLabel = this.hasLabel();
        var cls = "".concat(pfx, "trait");
        delete this.$input;
        var tmpl = "<div class=\"".concat(cls, " ").concat(cls, "--").concat(type, "\">\n      ").concat(hasLabel ? "<div class=\"".concat(clsLabel, "\" data-label></div>") : '', "\n      <div class=\"").concat(ppfx, "field-wrp ").concat(ppfx, "field-wrp--").concat(type, "\" data-input>\n        ").concat(this.templateInput(this.target.value), "\n      </div>\n    </div>");
        $el.empty().append(tmpl);
        hasLabel && this.renderLabel();
        this.renderField();
        this.el.className = "".concat(cls, "__wrp ").concat(cls, "__wrp-").concat(name);
        this.setElement(this.el);
        return this;
    };
    return TraitInputView;
}(view_TraitView));
/* harmony default export */ const view_TraitInputView = (TraitInputView);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitTextView.ts
var TraitTextView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var TraitTextView = /** @class */ (function (_super) {
    TraitTextView_extends(TraitTextView, _super);
    function TraitTextView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'text';
        return _this;
    }
    TraitTextView.prototype.getInputElem = function () {
        var _a = this, input = _a.input, $input = _a.$input;
        return input || ($input && $input.get && $input.get(0)) || this.getElInput();
    };
    Object.defineProperty(TraitTextView.prototype, "inputValue", {
        get: function () {
            var _a;
            var el = this.getInputElem();
            return (_a = el === null || el === void 0 ? void 0 : el.value) !== null && _a !== void 0 ? _a : this.target.value;
        },
        set: function (value) {
            var el = this.getInputElem();
            el && (el.value = value);
        },
        enumerable: false,
        configurable: true
    });
    return TraitTextView;
}(view_TraitInputView));
/* harmony default export */ const view_TraitTextView = (TraitTextView);

;// CONCATENATED MODULE: ./src/pages/view/PageView.ts
var PageView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PageView = /** @class */ (function (_super) {
    PageView_extends(PageView, _super);
    function PageView(opt, config) {
        var _this = _super.call(this, opt) || this;
        _this.highlightedClass = 'gjs-three-bg';
        _this.config = config;
        var _a = _this, model = _a.model, pfx = _a.pfx, ppfx = _a.ppfx;
        var type = model.get('type') || 'default';
        _this.className = "".concat(ppfx, "layer ").concat(ppfx, "layer__t-").concat(type, " no-select ").concat(pfx, "two-color");
        return _this;
    }
    PageView.prototype.render = function () {
        var _a = this, em = _a.em, pfx = _a.pfx, ppfx = _a.ppfx, model = _a.model;
        this.$el.attr('class', this.className);
        var input = new view_TraitTextView(em).setTarget('name', this.model, { changeProp: true });
        this.$el.append(input.render().el);
        return this;
    };
    PageView.prototype.events = function () {
        var _this = this;
        return {
            click: function () { return _this.trigger('onClick', _this); },
        };
    };
    Object.defineProperty(PageView.prototype, "em", {
        get: function () {
            return this.config.em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PageView.prototype, "ppfx", {
        get: function () {
            return this.em.getConfig().stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PageView.prototype, "pfx", {
        get: function () {
            return this.config.stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    PageView.prototype.setHighlighted = function (status) {
        status ? this.$el.addClass(this.highlightedClass) : this.$el.removeClass(this.highlightedClass);
    };
    Object.defineProperty(PageView.prototype, "page", {
        get: function () {
            return this.model;
        },
        enumerable: false,
        configurable: true
    });
    return PageView;
}(common/* View */.G7));
/* harmony default export */ const view_PageView = (PageView);

;// CONCATENATED MODULE: ./src/pages/view/PagesView.ts
var PagesView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var PagesView = /** @class */ (function (_super) {
    PagesView_extends(PagesView, _super);
    function PagesView(opts, config) {
        var _this = _super.call(this, opts) || this;
        _this.config = config || {};
        var ppfx = _this.config.pStylePrefix || '';
        _this.ppfx = ppfx;
        var coll = _this.collection;
        _this.listenTo(coll, 'reset', _this.render);
        _this.listenTo(coll, 'remove', _this.render);
        _this.em = _this.config.em;
        return _this;
    }
    PagesView.prototype.events = function () {
        var _a;
        var _b = this, buttonAddId = _b.buttonAddId, buttonRemoveId = _b.buttonRemoveId;
        var buttonAddEvent = 'click #' + buttonAddId;
        var buttonRemoveEvent = 'click #' + buttonRemoveId;
        return _a = {},
            _a[buttonAddEvent] = this.__addPage,
            _a[buttonRemoveEvent] = this.__removePage,
            _a;
    };
    PagesView.prototype.__getModule = function () {
        return this.em.Pages;
    };
    Object.defineProperty(PagesView.prototype, "buttonAddId", {
        get: function () {
            var ppfx = this.ppfx;
            return ppfx + 'button-add';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PagesView.prototype, "buttonRemoveId", {
        get: function () {
            var ppfx = this.ppfx;
            return ppfx + 'button-remove';
        },
        enumerable: false,
        configurable: true
    });
    PagesView.prototype.__addPage = function () {
        var em = this.em;
        this.collection.add(new model_Page({}, { em: em }));
        this.render();
    };
    PagesView.prototype.__removePage = function () {
        if (this.selectedView) {
            this.collection.remove(this.selectedView.model);
        }
    };
    /**
     * Add new model to the collection
     * @param {Model} model
     * @private
     * */
    PagesView.prototype.addTo = function (model) {
        this.collection.add(model);
    };
    /**
     * Render new model inside the view
     * @param {Model} model
     * @param {Object} fragment Fragment collection
     * @private
     * */
    PagesView.prototype.add = function (model, fragment) {
        var _a;
        var config = this.config;
        var view = new view_PageView({
            model: model,
        }, config);
        var rendered = view.render().el;
        if (((_a = this.em.Pages.getSelected()) === null || _a === void 0 ? void 0 : _a.id) == model.id) {
            view.setHighlighted(true);
            this.selectedView = view;
        }
        view.on('onClick', this.selectedHandler, this);
        fragment.appendChild(rendered);
    };
    PagesView.prototype.selectedHandler = function (view) {
        var _a;
        this.em.Pages.select(view.model);
        (_a = this.selectedView) === null || _a === void 0 ? void 0 : _a.setHighlighted(false);
        this.trigger('selected', view.model);
        this.selectedView = view;
        this.selectedView.setHighlighted(true);
    };
    PagesView.prototype.getCommandsNav = function () {
        var _a = this, buttonAddId = _a.buttonAddId, buttonRemoveId = _a.buttonRemoveId;
        return (0,cash_dom["default"])("<div data-val-id=\"\">\n    <div><button id=\"".concat(buttonAddId, "\">Add page</button></div>\n    <div><button id=\"").concat(buttonRemoveId, "\">Delete page</button></div>\n    </div>"));
    };
    PagesView.prototype.render = function () {
        var _this = this;
        this.$el.empty();
        var container = (0,cash_dom["default"])('<div class=""></div>');
        container.className = 'gps-block';
        container.append(this.getCommandsNav());
        var frag = document.createDocumentFragment();
        this.collection.each(function (model) {
            _this.add(model, frag);
        }, this);
        container.append(frag);
        this.$el.append(container);
        this.setElement(this.$el);
        return this;
    };
    return PagesView;
}(common/* View */.G7));
/* harmony default export */ const view_PagesView = (PagesView);

;// CONCATENATED MODULE: ./src/pages/config/config.ts
var pages_config_config_config = {
    stylePrefix: 'pg-',
    appendTo: '',
    optionsTarget: [{ value: false }, { value: '_blank' }],
    custom: false,
};
/* harmony default export */ const pages_config_config = (pages_config_config_config);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitButtonView.ts
var TraitButtonView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var TraitButtonView = /** @class */ (function (_super) {
    TraitButtonView_extends(TraitButtonView, _super);
    function TraitButtonView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'button';
        _this.command = opts.command;
        _this.text = opts.text;
        _this.full = opts.full;
        return _this;
    }
    TraitButtonView.prototype.events = function () {
        return {
            'click button': this.handleClick,
        };
    };
    TraitButtonView.prototype.templateInput = function () {
        return '';
    };
    Object.defineProperty(TraitButtonView.prototype, "inputValue", {
        get: function () {
            return undefined;
        },
        set: function (value) {
            this.handleClick();
        },
        enumerable: false,
        configurable: true
    });
    TraitButtonView.prototype.handleClick = function () {
        var _a = this, model = _a.model, command = _a.command, em = _a.em;
        if (command) {
            if ((0,index_all.isString)(command)) {
                em.Commands.run(command);
            }
            else {
                command(em.Editor, model);
            }
        }
    };
    TraitButtonView.prototype.getInputEl = function () {
        var _a = this, ppfx = _a.ppfx, text = _a.text, full = _a.full;
        var className = "".concat(ppfx, "btn");
        var input = (0,cash_dom["default"])("<button type=\"button\" class=\"".concat(className, "-prim").concat(full ? " ".concat(className, "--full") : '', "\">").concat(text, "</button>"));
        return input.get(0);
    };
    return TraitButtonView;
}(view_TraitInputView));
/* harmony default export */ const view_TraitButtonView = (TraitButtonView);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitCheckboxView.ts
var TraitCheckboxView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var TraitCheckboxView = /** @class */ (function (_super) {
    TraitCheckboxView_extends(TraitCheckboxView, _super);
    function TraitCheckboxView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'checkbox';
        _this.appendInput = false;
        return _this;
    }
    TraitCheckboxView.prototype.templateInput = function () {
        var _a = this, ppfx = _a.ppfx, clsField = _a.clsField;
        return "<label class=\"".concat(clsField, "\" data-input>\n    <i class=\"").concat(ppfx, "chk-icon\"></i>\n  </label>");
    };
    TraitCheckboxView.prototype.getInputElem = function () {
        var _a = this, input = _a.input, $input = _a.$input;
        return input || ($input && $input.get && $input.get(0)) || this.getElInput();
    };
    Object.defineProperty(TraitCheckboxView.prototype, "inputValue", {
        get: function () {
            var _a;
            var el = this.getInputElem();
            return (_a = el === null || el === void 0 ? void 0 : el.checked) !== null && _a !== void 0 ? _a : this.target.value;
        },
        set: function (value) {
            console.log('Text input value ' + value);
            var el = this.getInputElem();
            el && (el.checked = !!value);
        },
        enumerable: false,
        configurable: true
    });
    return TraitCheckboxView;
}(view_TraitInputView));
/* harmony default export */ const view_TraitCheckboxView = (TraitCheckboxView);

;// CONCATENATED MODULE: ./src/utils/ColorPicker.ts
// @ts-nocheck
// Without jquery I have to update few stuff
//
// Spectrum Colorpicker v1.8.0
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT

/* harmony default export */ function ColorPicker($, undefined) {
    'use strict';
    if (!(0,mixins.hasWin)())
        return;
    var defaultOpts = {
        // Callbacks
        beforeShow: noop,
        move: noop,
        change: noop,
        show: noop,
        hide: noop,
        // Options
        color: false,
        flat: false,
        showInput: false,
        allowEmpty: false,
        showButtons: true,
        clickoutFiresChange: true,
        showInitial: false,
        showPalette: false,
        showPaletteOnly: false,
        hideAfterPaletteSelect: false,
        togglePaletteOnly: false,
        showSelectionPalette: true,
        localStorageKey: false,
        appendTo: 'body',
        maxSelectionSize: 7,
        cancelText: 'cancel',
        chooseText: 'choose',
        togglePaletteMoreText: 'more',
        togglePaletteLessText: 'less',
        clearText: 'Clear Color Selection',
        noColorSelectedText: 'No Color Selected',
        preferredFormat: false,
        className: '', // Deprecated - use containerClassName and replacerClassName instead.
        containerClassName: '',
        replacerClassName: '',
        showAlpha: false,
        theme: 'sp-light',
        palette: [['#ffffff', '#000000', '#ff0000', '#ff8000', '#ffff00', '#008000', '#0000ff', '#4b0082', '#9400d3']],
        selectionPalette: [],
        disabled: false,
        offset: null,
    }, spectrums = [], IE = !!/msie/i.exec(window.navigator.userAgent), rgbaSupport = (function () {
        function contains(str, substr) {
            return !!~('' + str).indexOf(substr);
        }
        var elem = document.createElement('div');
        var style = elem.style;
        style.cssText = 'background-color:rgba(0,0,0,.5)';
        return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
    })(), replaceInput = [
        "<div class='sp-replacer'>",
        "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
        "<div class='sp-dd'>&#9660;</div>",
        '</div>',
    ].join(''), markup = (function () {
        // IE does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = '';
        if (IE) {
            for (var i = 1; i <= 6; i++) {
                gradientFix += "<div class='sp-" + i + "'></div>";
            }
        }
        return [
            "<div class='sp-container sp-hidden'>",
            "<div class='sp-palette-container'>",
            "<div class='sp-palette sp-thumb sp-cf'></div>",
            "<div class='sp-palette-button-container sp-cf'>",
            "<button type='button' class='sp-palette-toggle'></button>",
            '</div>',
            '</div>',
            "<div class='sp-picker-container'>",
            "<div class='sp-top sp-cf'>",
            "<div class='sp-fill'></div>",
            "<div class='sp-top-inner'>",
            "<div class='sp-color'>",
            "<div class='sp-sat'>",
            "<div class='sp-val'>",
            "<div class='sp-dragger'></div>",
            '</div>',
            '</div>',
            '</div>',
            "<div class='sp-clear sp-clear-display'>",
            '</div>',
            "<div class='sp-hue'>",
            "<div class='sp-slider'></div>",
            gradientFix,
            '</div>',
            '</div>',
            "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
            '</div>',
            "<div class='sp-input-container sp-cf'>",
            "<input class='sp-input' type='text' spellcheck='false'  />",
            '</div>',
            "<div class='sp-initial sp-thumb sp-cf'></div>",
            "<div class='sp-button-container sp-cf'>",
            "<a class='sp-cancel' href='#'></a>",
            "<button type='button' class='sp-choose'></button>",
            '</div>',
            '</div>',
            '</div>',
        ].join('');
    })();
    function paletteTemplate(p, color, className, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if (current) {
                var tiny = tinycolor(current);
                var c = tiny.toHsl().l < 0.5 ? 'sp-thumb-el sp-thumb-dark' : 'sp-thumb-el sp-thumb-light';
                c += tinycolor.equals(color, current) ? ' sp-thumb-active' : '';
                var formattedString = tiny.toString(opts.preferredFormat || 'rgb');
                var swatchStyle = rgbaSupport ? 'background-color:' + tiny.toRgbString() : 'filter:' + tiny.toFilter();
                html.push('<span title="' +
                    formattedString +
                    '" data-color="' +
                    tiny.toRgbString() +
                    '" class="' +
                    c +
                    '"><span class="sp-thumb-inner" style="' +
                    swatchStyle +
                    ';"></span></span>');
            }
            else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>').attr('title', opts.noColorSelectedText))
                    .html());
            }
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + '</div>';
    }
    function hideAll() {
        for (var i = 0; i < spectrums.length; i++) {
            if (spectrums[i]) {
                spectrums[i].hide();
            }
        }
    }
    function instanceOptions(o, callbackContext) {
        var opts = $.extend({}, defaultOpts, o);
        opts.callbacks = {
            move: bind(opts.move, callbackContext),
            change: bind(opts.change, callbackContext),
            show: bind(opts.show, callbackContext),
            hide: bind(opts.hide, callbackContext),
            beforeShow: bind(opts.beforeShow, callbackContext),
        };
        return opts;
    }
    function spectrum(element, o) {
        var opts = instanceOptions(o, element), flat = opts.flat, showSelectionPalette = opts.showSelectionPalette, localStorageKey = opts.localStorageKey, theme = opts.theme, callbacks = opts.callbacks, resize = throttle(reflow, 10), visible = false, isDragging = false, isDefault = true, dragWidth = 0, dragHeight = 0, dragHelperHeight = 0, slideHeight = 0, slideWidth = 0, alphaWidth = 0, alphaSlideHelperWidth = 0, slideHelperHeight = 0, currentHue = 0, currentSaturation = 0, currentValue = 0, currentAlpha = 1, palette = [], paletteArray = [], paletteLookup = {}, selectionPalette = opts.selectionPalette.slice(0), maxSelectionSize = opts.maxSelectionSize, draggingClass = 'sp-dragging', shiftMovementDirection = null;
        var doc = element.ownerDocument, body = doc.body, boundElement = $(element), disabled = false, container = $(markup, doc).addClass(theme), pickerContainer = container.find('.sp-picker-container'), dragger = container.find('.sp-color'), dragHelper = container.find('.sp-dragger'), slider = container.find('.sp-hue'), slideHelper = container.find('.sp-slider'), alphaSliderInner = container.find('.sp-alpha-inner'), alphaSlider = container.find('.sp-alpha'), alphaSlideHelper = container.find('.sp-alpha-handle'), textInput = container.find('.sp-input'), paletteContainer = container.find('.sp-palette'), initialColorContainer = container.find('.sp-initial'), cancelButton = container.find('.sp-cancel'), clearButton = container.find('.sp-clear'), chooseButton = container.find('.sp-choose'), toggleButton = container.find('.sp-palette-toggle'), isInput = boundElement.is('input'), isInputTypeColor = isInput && boundElement.attr('type') === 'color' && inputTypeColorSupport(), shouldReplace = isInput && !flat, replacer = shouldReplace
            ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName)
            : $([]), offsetElement = shouldReplace ? replacer : boundElement, previewElement = replacer.find('.sp-preview-inner'), initialColor = opts.color || (isInput && boundElement.val()), colorOnShow = false, currentPreferredFormat = opts.preferredFormat, clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange, isEmpty = !initialColor, allowEmpty = opts.allowEmpty && !isInputTypeColor;
        function applyOptions() {
            if (opts.showPaletteOnly) {
                opts.showPalette = true;
            }
            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            if (opts.palette) {
                palette = opts.palette.slice(0);
                paletteArray = $.isArray(palette[0]) ? palette : [palette];
                paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = tinycolor(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }
            }
            container.toggleClass('sp-flat', flat);
            container.toggleClass('sp-input-disabled', !opts.showInput);
            container.toggleClass('sp-alpha-enabled', opts.showAlpha);
            container.toggleClass('sp-clear-enabled', allowEmpty);
            container.toggleClass('sp-buttons-disabled', !opts.showButtons);
            container.toggleClass('sp-palette-buttons-disabled', !opts.togglePaletteOnly);
            container.toggleClass('sp-palette-disabled', !opts.showPalette);
            container.toggleClass('sp-palette-only', opts.showPaletteOnly);
            container.toggleClass('sp-initial-disabled', !opts.showInitial);
            container.addClass(opts.className).addClass(opts.containerClassName);
            reflow();
        }
        function initialize() {
            if (IE) {
                container.find('*:not(input)').attr('unselectable', 'on');
            }
            applyOptions();
            if (shouldReplace) {
                boundElement.after(replacer).hide();
            }
            if (!allowEmpty) {
                clearButton.hide();
            }
            if (flat) {
                boundElement.after(container).hide();
            }
            else {
                var appendTo = opts.appendTo === 'parent' ? boundElement.parent() : $(opts.appendTo);
                if (appendTo.length !== 1) {
                    appendTo = $('body');
                }
                appendTo.append(container);
            }
            updateSelectionPaletteFromStorage();
            offsetElement.bind('click.spectrum touchstart.spectrum', function (e) {
                if (!disabled) {
                    toggle();
                }
                e.stopPropagation();
                if (!$(e.target).is('input')) {
                    e.preventDefault();
                }
            });
            if (boundElement.is(':disabled') || opts.disabled === true) {
                disable();
            }
            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
            container.click(stopPropagation);
            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.bind('paste', function () {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function (e) {
                if (e.keyCode == 13) {
                    setFromTextInput();
                }
            });
            cancelButton.text(opts.cancelText);
            cancelButton.bind('click.spectrum', function (e) {
                e.stopPropagation();
                e.preventDefault();
                revert();
                hide();
            });
            clearButton.attr('title', opts.clearText);
            clearButton.bind('click.spectrum', function (e) {
                e.stopPropagation();
                e.preventDefault();
                isEmpty = true;
                move();
                if (flat) {
                    //for the flat style, this is a change event
                    updateOriginalInput(true);
                }
            });
            chooseButton.text(opts.chooseText);
            chooseButton.bind('click.spectrum', function (e) {
                e.stopPropagation();
                e.preventDefault();
                if (IE && textInput.is(':focus')) {
                    textInput.trigger('change');
                }
                if (isValid()) {
                    updateOriginalInput(true);
                    hide();
                }
            });
            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            toggleButton.bind('click.spectrum', function (e) {
                e.stopPropagation();
                e.preventDefault();
                opts.showPaletteOnly = !opts.showPaletteOnly;
                // To make sure the Picker area is drawn on the right, next to the
                // Palette area (and not below the palette), first move the Palette
                // to the left to make space for the picker, plus 5px extra.
                // The 'applyOptions' function puts the whole container back into place
                // and takes care of the button-text and the sp-palette-only CSS class.
                if (!opts.showPaletteOnly && !flat) {
                    container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                }
                applyOptions();
            });
            draggable(alphaSlider, function (dragX, dragY, e) {
                currentAlpha = dragX / alphaWidth;
                isEmpty = false;
                if (e.shiftKey) {
                    currentAlpha = Math.round(currentAlpha * 10) / 10;
                }
                move();
            }, dragStart, dragStop);
            draggable(slider, function (dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }
                move();
            }, dragStart, dragStop);
            draggable(dragger, function (dragX, dragY, e) {
                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                }
                else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - currentValue * dragHeight;
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);
                    shiftMovementDirection = furtherFromX ? 'x' : 'y';
                }
                var setSaturation = !shiftMovementDirection || shiftMovementDirection === 'x';
                var setValue = !shiftMovementDirection || shiftMovementDirection === 'y';
                if (setSaturation) {
                    currentSaturation = parseFloat(dragX / dragWidth);
                }
                if (setValue) {
                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                }
                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }
                move();
            }, dragStart, dragStop);
            if (!!initialColor) {
                set(initialColor);
                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                updateUI();
                currentPreferredFormat = opts.preferredFormat || tinycolor(initialColor).getFormat();
                addColorToSelectionPalette(initialColor);
            }
            else {
                updateUI();
            }
            if (flat) {
                show();
            }
            function paletteElementClick(e) {
                if (e.data && e.data.ignore) {
                    set($(e.target).closest('.sp-thumb-el').data('color'));
                    move();
                }
                else {
                    set($(e.target).closest('.sp-thumb-el').data('color'));
                    move();
                    if (opts.hideAfterPaletteSelect) {
                        updateOriginalInput(true);
                        hide();
                    }
                }
                return false;
            }
            var paletteEvent = IE ? 'mousedown.spectrum' : 'click.spectrum touchstart.spectrum';
            paletteContainer.delegate('.sp-thumb-el', paletteEvent, paletteElementClick);
            initialColorContainer.delegate('.sp-thumb-el:nth-child(1)', paletteEvent, { ignore: true }, paletteElementClick);
        }
        function updateSelectionPaletteFromStorage() {
            if (localStorageKey && window.localStorage) {
                // Migrate old palettes over to new format.  May want to remove this eventually.
                try {
                    var oldPalette = window.localStorage[localStorageKey].split(',#');
                    if (oldPalette.length > 1) {
                        delete window.localStorage[localStorageKey];
                        $.each(oldPalette, function (i, c) {
                            addColorToSelectionPalette(c);
                        });
                    }
                }
                catch (e) { }
                try {
                    selectionPalette = window.localStorage[localStorageKey].split(';');
                }
                catch (e) { }
            }
        }
        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var rgb = tinycolor(color).toRgbString();
                if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                    selectionPalette.push(rgb);
                    while (selectionPalette.length > maxSelectionSize) {
                        selectionPalette.shift();
                    }
                }
                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(';');
                    }
                    catch (e) { }
                }
            }
        }
        function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
                for (var i = 0; i < selectionPalette.length; i++) {
                    var rgb = tinycolor(selectionPalette[i]).toRgbString();
                    if (!paletteLookup[rgb]) {
                        unique.push(selectionPalette[i]);
                    }
                }
            }
            return unique.reverse().slice(0, opts.maxSelectionSize);
        }
        function drawPalette() {
            var currentColor = get();
            var html = $.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, 'sp-palette-row sp-palette-row-' + i, opts);
            });
            updateSelectionPaletteFromStorage();
            if (selectionPalette) {
                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, 'sp-palette-row sp-palette-row-selection', opts));
            }
            paletteContainer.html(html.join(''));
        }
        function drawInitial() {
            if (opts.showInitial) {
                var initial = colorOnShow;
                var current = get();
                initialColorContainer.html(paletteTemplate([initial, current], current, 'sp-palette-row-initial', opts));
            }
        }
        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                reflow();
            }
            isDragging = true;
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger('dragstart.spectrum', [get()]);
        }
        function dragStop() {
            isDragging = false;
            container.removeClass(draggingClass);
            boundElement.trigger('dragstop.spectrum', [get()]);
        }
        function setFromTextInput() {
            var value = textInput.val();
            if ((value === null || value === '') && allowEmpty) {
                set(null);
                updateOriginalInput(true);
            }
            else {
                var tiny = tinycolor(value);
                if (tiny.isValid()) {
                    set(tiny);
                    updateOriginalInput(true);
                }
                else {
                    textInput.addClass('sp-validation-error');
                }
            }
        }
        function toggle() {
            if (visible) {
                hide();
            }
            else {
                show();
            }
        }
        function show() {
            var event = $.Event('beforeShow.spectrum');
            if (visible) {
                reflow();
                return;
            }
            boundElement.trigger('beforeShow.spectrum', [get()]);
            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                return;
            }
            hideAll();
            visible = true;
            var $doc = $(doc);
            $doc.bind('keydown.spectrum', onkeydown);
            $doc.bind('click.spectrum', clickout);
            $(window).bind('resize.spectrum', resize);
            replacer.addClass('sp-active');
            container.removeClass('sp-hidden');
            reflow();
            updateUI();
            colorOnShow = get();
            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger('show.spectrum', [colorOnShow]);
        }
        function onkeydown(e) {
            // Close on ESC
            if (e.keyCode === 27) {
                hide();
            }
        }
        function clickout(e) {
            // Return on right click.
            if (e.button == 2) {
                return;
            }
            // If a drag event was happening during the mouseup, don't hide
            // on click.
            if (isDragging) {
                return;
            }
            if (clickoutFiresChange) {
                updateOriginalInput(true);
            }
            else {
                revert();
            }
            hide();
        }
        function hide() {
            // Return if hiding is unnecessary
            if (!visible || flat) {
                return;
            }
            visible = false;
            $(doc).unbind('keydown.spectrum', onkeydown);
            $(doc).unbind('click.spectrum', clickout);
            $(window).unbind('resize.spectrum', resize);
            replacer.removeClass('sp-active');
            container.addClass('sp-hidden');
            callbacks.hide(get());
            boundElement.trigger('hide.spectrum', [get()]);
        }
        function revert() {
            set(colorOnShow, true);
        }
        function set(color, ignoreFormatChange) {
            if (tinycolor.equals(color, get())) {
                // Update UI just in case a validation error needs
                // to be cleared.
                updateUI();
                return;
            }
            var newColor, newHsv;
            if (!color && allowEmpty) {
                isEmpty = true;
            }
            else {
                isEmpty = false;
                isDefault = !color; // if no color is available an empty string will be passed.  tinycolor will then set it to #000
                newColor = tinycolor(color);
                newHsv = newColor.toHsv();
                currentHue = (newHsv.h % 360) / 360;
                currentSaturation = newHsv.s;
                currentValue = newHsv.v;
                currentAlpha = newHsv.a;
            }
            updateUI();
            if (newColor && newColor.isValid() && !ignoreFormatChange) {
                currentPreferredFormat = opts.preferredFormat || newColor.getFormat();
            }
        }
        function get(opts) {
            opts = opts || {};
            if (allowEmpty && isEmpty) {
                return null;
            }
            return tinycolor.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue,
                a: Math.round(currentAlpha * 100) / 100,
            }, { format: opts.format || currentPreferredFormat });
        }
        function isValid() {
            return !textInput.hasClass('sp-validation-error');
        }
        function move() {
            updateUI();
            callbacks.move(get());
            boundElement.trigger('move.spectrum', [get()]);
        }
        function updateUI() {
            textInput.removeClass('sp-validation-error');
            updateHelperLocations();
            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css('background-color', flatColor.toHexString());
            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === 'name')) {
                if (format === 'hex' || format === 'hex3' || format === 'hex6' || format === 'name') {
                    format = 'rgb';
                }
            }
            var realColor = get({ format: format }), displayColor = '';
            //reset background info for preview element
            previewElement.removeClass('sp-clear-display');
            previewElement.css('background-color', 'transparent');
            if (!realColor && allowEmpty) {
                // Update the replaced elements background with icon indicating no color selection
                previewElement.addClass('sp-clear-display');
            }
            else {
                var realHex = realColor.toHexString(), realRgb = realColor.toRgbString();
                // Update the replaced elements background color (with actual selected color)
                if (rgbaSupport || realColor.alpha === 1) {
                    previewElement.css('background-color', realRgb);
                }
                else {
                    previewElement.css('background-color', 'transparent');
                    previewElement.css('filter', realColor.toFilter());
                }
                if (opts.showAlpha) {
                    var rgb = realColor.toRgb();
                    rgb.a = 0;
                    var realAlpha = tinycolor(rgb).toRgbString();
                    var gradient = 'linear-gradient(left, ' + realAlpha + ', ' + realHex + ')';
                    if (IE) {
                        alphaSliderInner.css('filter', tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                    }
                    else {
                        alphaSliderInner.css('background', '-webkit-' + gradient);
                        alphaSliderInner.css('background', '-moz-' + gradient);
                        alphaSliderInner.css('background', '-ms-' + gradient);
                        // Use current syntax gradient on unprefixed property.
                        alphaSliderInner.css('background', 'linear-gradient(to right, ' + realAlpha + ', ' + realHex + ')');
                    }
                }
                displayColor = realColor.toString(format);
            }
            // Update the text entry input as it changes happen
            if (opts.showInput) {
                textInput.val(displayColor);
            }
            if (opts.showPalette) {
                drawPalette();
            }
            drawInitial();
        }
        function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;
            if (allowEmpty && isEmpty) {
                //if selected color is empty, hide the helpers
                alphaSlideHelper.hide();
                slideHelper.hide();
                dragHelper.hide();
            }
            else {
                //make sure helpers are visible
                alphaSlideHelper.show();
                slideHelper.show();
                dragHelper.show();
                // Where to show the little circle in that displays your current selected color
                var dragX = s * dragWidth;
                var dragY = dragHeight - v * dragHeight;
                dragX = Math.max(-dragHelperHeight, Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight));
                dragY = Math.max(-dragHelperHeight, Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight));
                dragHelper.css({
                    top: dragY + 'px',
                    left: dragX + 'px',
                });
                var alphaX = currentAlpha * alphaWidth;
                alphaSlideHelper.css({
                    left: alphaX - alphaSlideHelperWidth / 2 + 'px',
                });
                // Where to show the bar that displays your current selected hue
                var slideY = currentHue * slideHeight;
                slideHelper.css({
                    top: slideY - slideHelperHeight + 'px',
                });
            }
        }
        function updateOriginalInput(fireCallback) {
            var color = get(), displayColor = '', hasChanged = isDefault ? true : !tinycolor.equals(color, colorOnShow);
            if (color) {
                displayColor = color.toString(currentPreferredFormat);
                // Update the selection palette with the current color
                !visible && addColorToSelectionPalette(color);
            }
            if (isInput) {
                boundElement.val(displayColor);
            }
            if (fireCallback && hasChanged) {
                callbacks.change(color);
                boundElement.trigger('change', [color]);
            }
        }
        function reflow() {
            if (!visible) {
                return; // Calculations would be useless and wouldn't be reliable anyways
            }
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();
            if (!flat) {
                container.css('position', 'absolute');
                if (opts.offset) {
                    container.offset(opts.offset);
                }
                else {
                    container.offset(getOffset(container, offsetElement));
                }
            }
            updateHelperLocations();
            if (opts.showPalette) {
                drawPalette();
            }
            boundElement.trigger('reflow.spectrum');
        }
        function destroy() {
            boundElement.show();
            offsetElement.unbind('click.spectrum touchstart.spectrum');
            container.remove();
            replacer.remove();
            spectrums[spect.id] = null;
        }
        function option(optionName, optionValue) {
            if (optionName === undefined) {
                return $.extend({}, opts);
            }
            if (optionValue === undefined) {
                return opts[optionName];
            }
            opts[optionName] = optionValue;
            if (optionName === 'preferredFormat') {
                currentPreferredFormat = opts.preferredFormat;
            }
            applyOptions();
        }
        function enable() {
            disabled = false;
            boundElement.attr('disabled', false);
            offsetElement.removeClass('sp-disabled');
        }
        function disable() {
            hide();
            disabled = true;
            boundElement.attr('disabled', true);
            offsetElement.addClass('sp-disabled');
        }
        function setOffset(coord) {
            opts.offset = coord;
            reflow();
        }
        initialize();
        var spect = {
            show: show,
            hide: hide,
            toggle: toggle,
            reflow: reflow,
            option: option,
            enable: enable,
            disable: disable,
            offset: setOffset,
            set: function (c) {
                set(c);
                updateOriginalInput();
            },
            get: get,
            destroy: destroy,
            container: container,
        };
        spect.id = spectrums.push(spect) - 1;
        return spect;
    }
    /**
     * checkOffset - get the offset below/above and left/right element depending on screen position
     * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
     */
    function getOffset(picker, input) {
        var extraY = 0;
        var dpWidth = picker.outerWidth();
        var dpHeight = picker.outerHeight();
        var inputHeight = input.outerHeight();
        var doc = picker[0].ownerDocument;
        var docElem = doc.documentElement;
        var cW = docElem.clientWidth;
        var cH = docElem.clientHeight;
        var scL = $(doc).scrollLeft();
        var scT = $(doc).scrollTop();
        var viewWidth = cW + scL;
        var viewHeight = cH + scT;
        var offset = input.offset();
        offset.top += inputHeight;
        offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
        offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight - extraY) : extraY);
        return offset;
    }
    /**
     * noop - do nothing
     */
    function noop() { }
    /**
     * stopPropagation - makes the code only doing this a little easier to read in line
     */
    function stopPropagation(e) {
        e.stopPropagation();
    }
    /**
     * Create a function bound to a given object
     * Thanks to underscore.js
     */
    function bind(func, obj) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments, 2);
        return function () {
            return func.apply(obj, args.concat(slice.call(arguments)));
        };
    }
    /**
     * Lightweight drag helper.  Handles containment within the element, so that
     * when dragging, the x is within [0,element.width] and y is within [0,element.height]
     */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = 'ontouchstart' in window;
        var duringDragEvents = {};
        duringDragEvents['selectstart'] = prevent;
        duringDragEvents['dragstart'] = prevent;
        duringDragEvents['touchmove mousemove'] = move;
        duringDragEvents['touchend mouseup'] = stop;
        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }
        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (IE && doc.documentMode < 9 && !e.button) {
                    return stop();
                }
                var t0 = e && e.touches && e.touches[0];
                var pageX = (t0 && t0.pageX) || e.pageX;
                var pageY = (t0 && t0.pageY) || e.pageY;
                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));
                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }
                onmove.apply(element, [dragX, dragY, e]);
            }
        }
        function start(e) {
            var rightclick = e.which ? e.which == 3 : e.button == 2;
            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();
                    $(doc).bind(duringDragEvents);
                    $(doc.body).addClass('sp-dragging');
                    move(e);
                    prevent(e);
                }
            }
        }
        function stop() {
            if (dragging) {
                $(doc).unbind(duringDragEvents);
                $(doc.body).removeClass('sp-dragging');
                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                setTimeout(function () {
                    onstop.apply(element, arguments);
                }, 0);
            }
            dragging = false;
        }
        $(element).bind('touchstart mousedown', start);
    }
    function throttle(func, wait, debounce) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var throttler = function () {
                timeout = null;
                func.apply(context, args);
            };
            if (debounce)
                clearTimeout(timeout);
            if (debounce || !timeout)
                timeout = setTimeout(throttler, wait);
        };
    }
    function inputTypeColorSupport() {
        return $.fn.spectrum.inputTypeColorSupport();
    }
    /**
     * Define a jQuery plugin
     */
    var dataID = 'spectrum.id';
    $.fn.spectrum = function (opts, extra) {
        if (typeof opts == 'string') {
            var returnValue = this;
            var args = Array.prototype.slice.call(arguments, 1);
            this.each(function () {
                var spect = spectrums[$(this).data(dataID)];
                if (spect) {
                    var method = spect[opts];
                    if (!method) {
                        throw new Error("Spectrum: no such method: '" + opts + "'");
                    }
                    if (opts == 'get') {
                        returnValue = spect.get();
                    }
                    else if (opts == 'container') {
                        returnValue = spect.container;
                    }
                    else if (opts == 'option') {
                        returnValue = spect.option.apply(spect, args);
                    }
                    else if (opts == 'destroy') {
                        spect.destroy();
                        $(this).removeData(dataID);
                    }
                    else {
                        method.apply(spect, args);
                    }
                }
            });
            return returnValue;
        }
        // Initializing a new instance of spectrum
        return this.spectrum('destroy').each(function () {
            var options = $.extend({}, opts, $(this).data());
            var spect = spectrum(this, options);
            $(this).data(dataID, spect.id);
        });
    };
    $.fn.spectrum.load = true;
    $.fn.spectrum.loadOpts = {};
    $.fn.spectrum.draggable = draggable;
    $.fn.spectrum.defaults = defaultOpts;
    $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
        if (typeof inputTypeColorSupport._cachedResult === 'undefined') {
            var colorInput = $("<input type='color'/>")[0]; // if color element is supported, value will default to not null
            inputTypeColorSupport._cachedResult = colorInput.type === 'color' && colorInput.value !== '';
        }
        return inputTypeColorSupport._cachedResult;
    };
    $.spectrum = {};
    $.spectrum.localization = {};
    $.spectrum.palettes = {};
    $.fn.spectrum.processNativeColorInputs = function () {
        var colorInputs = $('input[type=color]');
        if (colorInputs.length && !inputTypeColorSupport()) {
            colorInputs.spectrum({
                preferredFormat: 'hex6',
            });
        }
    };
    // TinyColor v1.1.2
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License
    //(function() {
    var trimLeft = /^[\s,#]+/, trimRight = /\s+$/, tinyCounter = 0, math = Math, mathRound = math.round, mathMin = math.min, mathMax = math.max, mathRandom = math.random;
    var tinycolor = function (color, opts) {
        color = color ? color : '';
        opts = opts || {};
        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
            return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }
        var rgb = inputToRGB(color);
        (this._originalInput = color),
            (this._r = rgb.r),
            (this._g = rgb.g),
            (this._b = rgb.b),
            (this._a = rgb.a),
            (this._roundA = mathRound(100 * this._a) / 100),
            (this._format = opts.format || rgb.format);
        this._gradientType = opts.gradientType;
        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) {
            this._r = mathRound(this._r);
        }
        if (this._g < 1) {
            this._g = mathRound(this._g);
        }
        if (this._b < 1) {
            this._b = mathRound(this._b);
        }
        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    };
    tinycolor.prototype = {
        isDark: function () {
            return this.getBrightness() < 128;
        },
        isLight: function () {
            return !this.isDark();
        },
        isValid: function () {
            return this._ok;
        },
        getOriginalInput: function () {
            return this._originalInput;
        },
        getFormat: function () {
            return this._format;
        },
        getAlpha: function () {
            return this._a;
        },
        getBrightness: function () {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        setAlpha: function (value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100 * this._a) / 100;
            return this;
        },
        toHsv: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function () {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return this._a == 1
                ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)'
                : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + this._roundA + ')';
        },
        toHsl: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function () {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return this._a == 1
                ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)'
                : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + this._roundA + ')';
        },
        toHex: function (allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function (allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function () {
            return rgbaToHex(this._r, this._g, this._b, this._a);
        },
        toHex8String: function () {
            return '#' + this.toHex8();
        },
        toRgb: function () {
            return {
                r: mathRound(this._r),
                g: mathRound(this._g),
                b: mathRound(this._b),
                a: this._a,
            };
        },
        toRgbString: function () {
            return this._a == 1
                ? 'rgb(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ')'
                : 'rgba(' +
                    mathRound(this._r) +
                    ', ' +
                    mathRound(this._g) +
                    ', ' +
                    mathRound(this._b) +
                    ', ' +
                    this._roundA +
                    ')';
        },
        toPercentageRgb: function () {
            return {
                r: mathRound(bound01(this._r, 255) * 100) + '%',
                g: mathRound(bound01(this._g, 255) * 100) + '%',
                b: mathRound(bound01(this._b, 255) * 100) + '%',
                a: this._a,
            };
        },
        toPercentageRgbString: function () {
            return this._a == 1
                ? 'rgb(' +
                    mathRound(bound01(this._r, 255) * 100) +
                    '%, ' +
                    mathRound(bound01(this._g, 255) * 100) +
                    '%, ' +
                    mathRound(bound01(this._b, 255) * 100) +
                    '%)'
                : 'rgba(' +
                    mathRound(bound01(this._r, 255) * 100) +
                    '%, ' +
                    mathRound(bound01(this._g, 255) * 100) +
                    '%, ' +
                    mathRound(bound01(this._b, 255) * 100) +
                    '%, ' +
                    this._roundA +
                    ')';
        },
        toName: function () {
            if (this._a === 0) {
                return 'transparent';
            }
            if (this._a < 1) {
                return false;
            }
            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function (secondColor) {
            var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? 'GradientType = 1, ' : '';
            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = s.toHex8String();
            }
            return ('progid:DXImageTransform.Microsoft.gradient(' +
                gradientType +
                'startColorstr=' +
                hex8String +
                ',endColorstr=' +
                secondHex8String +
                ')');
        },
        toString: function (format) {
            var formatSet = !!format;
            format = format || this._format;
            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === 'hex' || format === 'hex6' || format === 'hex3' || format === 'name');
            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === 'name' && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === 'rgb') {
                formattedString = this.toRgbString();
            }
            if (format === 'prgb') {
                formattedString = this.toPercentageRgbString();
            }
            if (format === 'hex' || format === 'hex6') {
                formattedString = this.toHexString();
            }
            if (format === 'hex3') {
                formattedString = this.toHexString(true);
            }
            if (format === 'hex8') {
                formattedString = this.toHex8String();
            }
            if (format === 'name') {
                formattedString = this.toName();
            }
            if (format === 'hsl') {
                formattedString = this.toHslString();
            }
            if (format === 'hsv') {
                formattedString = this.toHsvString();
            }
            return formattedString || this.toHexString();
        },
        _applyModification: function (fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function () {
            return this._applyModification(lighten, arguments);
        },
        brighten: function () {
            return this._applyModification(brighten, arguments);
        },
        darken: function () {
            return this._applyModification(darken, arguments);
        },
        desaturate: function () {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function () {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function () {
            return this._applyModification(greyscale, arguments);
        },
        spin: function () {
            return this._applyModification(spin, arguments);
        },
        _applyCombination: function (fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function () {
            return this._applyCombination(analogous, arguments);
        },
        complement: function () {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function () {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function () {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function () {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function () {
            return this._applyCombination(tetrad, arguments);
        },
    };
    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function (color, opts) {
        if (typeof color == 'object') {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === 'a') {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }
        return tinycolor(color, opts);
    };
    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {
        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var ok = false;
        var format = false;
        if (typeof color == 'string') {
            color = stringInputToObject(color);
        }
        if (typeof color == 'object') {
            if (color.hasOwnProperty('r') && color.hasOwnProperty('g') && color.hasOwnProperty('b')) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb';
            }
            else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('v')) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = 'hsv';
            }
            else if (color.hasOwnProperty('h') && color.hasOwnProperty('s') && color.hasOwnProperty('l')) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = 'hsl';
            }
            if (color.hasOwnProperty('a')) {
                a = color.a;
            }
        }
        a = boundAlpha(a);
        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a,
        };
    }
    // Conversion Functions
    // --------------------
    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>
    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b) {
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255,
        };
    }
    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;
        if (max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return { h: h, s: s, l: l };
    }
    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;
        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);
        function hue2rgb(p, q, t) {
            if (t < 0)
                t += 1;
            if (t > 1)
                t -= 1;
            if (t < 1 / 6)
                return p + (q - p) * 6 * t;
            if (t < 1 / 2)
                return q;
            if (t < 2 / 3)
                return p + (q - p) * (2 / 3 - t) * 6;
            return p;
        }
        if (s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
    }
    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {
        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);
        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;
        var d = max - min;
        s = max === 0 ? 0 : d / max;
        if (max == min) {
            h = 0; // achromatic
        }
        else {
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }
    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hsvToRgb(h, s, v) {
        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);
        var i = math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6, r = [v, q, p, p, t, v][mod], g = [t, v, v, q, p, p][mod], b = [p, p, t, v, v, q][mod];
        return { r: r * 255, g: g * 255, b: b * 255 };
    }
    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {
        var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
        // Return a 3 character hex if possible
        if (allow3Char &&
            hex[0].charAt(0) == hex[0].charAt(1) &&
            hex[1].charAt(0) == hex[1].charAt(1) &&
            hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }
        return hex.join('');
    }
    // `rgbaToHex`
    // Converts an RGBA color plus alpha transparency to hex
    // Assumes r, g, b and a are contained in the set [0, 255]
    // Returns an 8 character hex
    function rgbaToHex(r, g, b, a) {
        var hex = [
            pad2(convertDecimalToHex(a)),
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16)),
        ];
        return hex.join('');
    }
    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) {
            return false;
        }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function () {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom(),
        });
    };
    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>
    function desaturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }
    function saturate(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }
    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }
    function lighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }
    function brighten(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))));
        return tinycolor(rgb);
    }
    function darken(color, amount) {
        amount = amount === 0 ? 0 : amount || 10;
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }
    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (mathRound(hsl.h) + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }
    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>
    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }
    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l }),
        ];
    }
    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l }),
        ];
    }
    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l }),
        ];
    }
    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;
        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];
        for (hsl.h = (hsl.h - ((part * results) >> 1) + 720) % 360; --results;) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }
    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;
        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v }));
            v = (v + modification) % 1;
        }
        return ret;
    }
    // Utility Functions
    // ---------------------
    tinycolor.mix = function (color1, color2, amount) {
        amount = amount === 0 ? 0 : amount || 50;
        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();
        var p = amount / 100;
        var w = p * 2 - 1;
        var a = rgb2.a - rgb1.a;
        var w1;
        if (w * a == -1) {
            w1 = w;
        }
        else {
            w1 = (w + a) / (1 + w * a);
        }
        w1 = (w1 + 1) / 2;
        var w2 = 1 - w1;
        var rgba = {
            r: rgb2.r * w1 + rgb1.r * w2,
            g: rgb2.g * w1 + rgb1.g * w2,
            b: rgb2.b * w1 + rgb1.b * w2,
            a: rgb2.a * p + rgb1.a * (1 - p),
        };
        return tinycolor(rgba);
    };
    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/AERT#color-contrast>
    // `readability`
    // Analyze the 2 colors and returns an object with the following properties:
    //    `brightness`: difference in brightness between the two colors
    //    `color`: difference in color/hue between the two colors
    tinycolor.readability = function (color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        var rgb1 = c1.toRgb();
        var rgb2 = c2.toRgb();
        var brightnessA = c1.getBrightness();
        var brightnessB = c2.getBrightness();
        var colorDiff = Math.max(rgb1.r, rgb2.r) -
            Math.min(rgb1.r, rgb2.r) +
            Math.max(rgb1.g, rgb2.g) -
            Math.min(rgb1.g, rgb2.g) +
            Math.max(rgb1.b, rgb2.b) -
            Math.min(rgb1.b, rgb2.b);
        return {
            brightness: Math.abs(brightnessA - brightnessB),
            color: colorDiff,
        };
    };
    // `readable`
    // http://www.w3.org/TR/AERT#color-contrast
    // Ensure that foreground and background color combinations provide sufficient contrast.
    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    tinycolor.isReadable = function (color1, color2) {
        var readability = tinycolor.readability(color1, color2);
        return readability.brightness > 125 && readability.color > 500;
    };
    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // *Example*
    //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
    tinycolor.mostReadable = function (baseColor, colorList) {
        var bestColor = null;
        var bestScore = 0;
        var bestIsReadable = false;
        for (var i = 0; i < colorList.length; i++) {
            // We normalize both around the "acceptable" breaking point,
            // but rank brightness constrast higher than hue.
            var readability = tinycolor.readability(baseColor, colorList[i]);
            var readable = readability.brightness > 125 && readability.color > 500;
            var score = 3 * (readability.brightness / 125) + readability.color / 500;
            if ((readable && !bestIsReadable) ||
                (readable && bestIsReadable && score > bestScore) ||
                (!readable && !bestIsReadable && score > bestScore)) {
                bestIsReadable = readable;
                bestScore = score;
                bestColor = tinycolor(colorList[i]);
            }
        }
        return bestColor;
    };
    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = (tinycolor.names = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '0ff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000',
        blanchedalmond: 'ffebcd',
        blue: '00f',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        burntsienna: 'ea7e5d',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '0ff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkgrey: 'a9a9a9',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkslategrey: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dimgrey: '696969',
        dodgerblue: '1e90ff',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'f0f',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        grey: '808080',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred: 'cd5c5c',
        indigo: '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgray: 'd3d3d3',
        lightgreen: '90ee90',
        lightgrey: 'd3d3d3',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslategray: '789',
        lightslategrey: '789',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '0f0',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'f0f',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370db',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'db7093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        rebeccapurple: '663399',
        red: 'f00',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        slategrey: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        wheat: 'f5deb3',
        white: 'fff',
        whitesmoke: 'f5f5f5',
        yellow: 'ff0',
        yellowgreen: '9acd32',
    });
    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = (tinycolor.hexNames = flip(names));
    // Utilities
    // ---------
    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = {};
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }
    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);
        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }
        return a;
    }
    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) {
            n = '100%';
        }
        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));
        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }
        // Handle floating point rounding errors
        if (math.abs(n - max) < 0.000001) {
            return 1;
        }
        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }
    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }
    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }
    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == 'string' && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }
    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === 'string' && n.indexOf('%') != -1;
    }
    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }
    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = n * 100 + '%';
        }
        return n;
    }
    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return parseIntFromHex(h) / 255;
    }
    var matchers = (function () {
        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = '[-\\+]?\\d+%?';
        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?';
        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')';
        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?';
        var PERMISSIVE_MATCH4 = '[\\s|\\(]+(' +
            CSS_UNIT +
            ')[,|\\s]+(' +
            CSS_UNIT +
            ')[,|\\s]+(' +
            CSS_UNIT +
            ')[,|\\s]+(' +
            CSS_UNIT +
            ')\\s*\\)?';
        return {
            rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
            rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
            hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
            hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
            hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
            hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        };
    })();
    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {
        color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: 'name' };
        }
        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? 'name' : 'hex8',
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? 'name' : 'hex',
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? 'name' : 'hex',
            };
        }
        return false;
    }
    window.tinycolor = tinycolor;
    //})();
    $(function () {
        if ($.fn.spectrum.load) {
            $.fn.spectrum.processNativeColorInputs();
        }
    });
}

;// CONCATENATED MODULE: ./src/common/traits/view/TraitColorView.ts
var TraitColorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitColorView_assign = (undefined && undefined.__assign) || function () {
    TraitColorView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitColorView_assign.apply(this, arguments);
};




cash_dom["default"] && ColorPicker(cash_dom["default"]);
var getColor = function (color) {
    var name = color.getFormat() === 'name' && color.toName();
    var cl = color.getAlpha() == 1 ? color.toHexString() : color.toRgbString();
    return name || cl.replace(/ /g, '');
};
var TraitColorView = /** @class */ (function (_super) {
    TraitColorView_extends(TraitColorView, _super);
    function TraitColorView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'text';
        return _this;
    }
    TraitColorView.prototype.templateInput = function () {
        return '';
    };
    Object.defineProperty(TraitColorView.prototype, "inputValue", {
        get: function () {
            var _a;
            var el = (_a = this.$input) === null || _a === void 0 ? void 0 : _a.get(0);
            return (el === null || el === void 0 ? void 0 : el.value) ? el.value : this.target.value;
        },
        set: function (value) {
            var _a;
            var colorEl = this.getColorEl();
            // Check the color by using the ColorPicker's parser
            if (colorEl) {
                var valueClr = value != 'none' ? value : '';
                colorEl.spectrum('set', valueClr);
                var tc = colorEl.spectrum('get');
                var color = valueClr && getColor(tc);
                colorEl.get(0).style.backgroundColor = valueClr;
                this.noneColor = value == 'none';
                this.movedColor = valueClr;
                var el = (_a = this.$input) === null || _a === void 0 ? void 0 : _a.get(0);
                el && (el.value = color);
            }
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitColorView.prototype.getInputEl = function () {
        if (!this.input) {
            var value = this.target.value;
            var _a = this, ppfx = _a.ppfx, target = _a.target, type = _a.type, paceholder = _a.paceholder;
            console.log(this.$el.get(0));
            var el = (0,cash_dom["default"])(document.createElement('div'));
            el.addClass(this.inputClass());
            el.html(this.template());
            var plh = paceholder || target.value;
            var inputEl = (0,cash_dom["default"])("<input type=\"".concat(type, "\" placeholder=\"").concat(plh, "\">"));
            el.find(".".concat(this.holderClass())).append(inputEl);
            // This will make the color input available on render
            var colorEl = this.getColorEl();
            el.find('[data-colorp-c]').append(colorEl);
            inputEl.val(value);
            this.$input = inputEl;
            return el.get(0);
        }
        return this.input;
    };
    TraitColorView.prototype.template = function () {
        var ppfx = this.ppfx;
        return "\n      <div class=\"".concat(this.holderClass(), "\"></div>\n      <div class=\"").concat(ppfx, "field-colorp\">\n        <div class=\"").concat(ppfx, "field-colorp-c\" data-colorp-c>\n          <div class=\"").concat(ppfx, "checker-bg\"></div>\n        </div>\n      </div>\n    ");
    };
    TraitColorView.prototype.inputClass = function () {
        var ppfx = this.ppfx;
        return "".concat(ppfx, "field ").concat(ppfx, "field-color");
    };
    TraitColorView.prototype.holderClass = function () {
        return "".concat(this.ppfx, "input-holder");
    };
    TraitColorView.prototype.remove = function () {
        _super.prototype.remove.call(this);
        this.colorEl.spectrum('destroy');
        return this;
    };
    /**
     * Set value to the model
     * @param {string} val
     * @param {Object} opts
     */
    TraitColorView.prototype.setValue = function (val, opts) {
        if (opts === void 0) { opts = {}; }
        var model = this.model;
        var def = !(0,index_all.isUndefined)(opts.def) ? opts.def : model.get('defaults');
        var value = !(0,index_all.isUndefined)(val) ? val : !(0,index_all.isUndefined)(def) ? def : '';
        var inputEl = this.getInputEl();
        var colorEl = this.getColorEl();
        var valueClr = value != 'none' ? value : '';
        inputEl.value = value;
        colorEl.get(0).style.backgroundColor = valueClr;
        // This prevents from adding multiple thumbs in spectrum
        if (opts.fromTarget || (opts.fromInput && !opts.avoidStore)) {
            colorEl.spectrum('set', valueClr);
            this.noneColor = value == 'none';
            this.movedColor = valueClr;
        }
    };
    /**
     * Get the color input element
     * @return {HTMLElement}
     */
    TraitColorView.prototype.getColorEl = function () {
        var _this = this;
        if (!this.colorEl) {
            var _a = this, em = _a.em, colorPicker = _a.colorPicker;
            var ppfx = this.ppfx;
            var colorEl = (0,cash_dom["default"])("<div class=\"".concat(this.ppfx, "field-color-picker\"></div>"));
            var cpStyle = colorEl.get(0).style;
            var elToAppend = em && em.config ? em.config.el : '';
            var colorPickerConfig = (em && em.getConfig && em.getConfig().colorPicker) || {};
            this.movedColor = '';
            var changed_1 = false;
            var previousColor_1;
            var handleChange_1 = function (value) {
                _this.inputValue = value;
            };
            colorEl.spectrum(TraitColorView_assign(TraitColorView_assign(TraitColorView_assign({ color: this.target.value || false, containerClassName: "".concat(ppfx, "one-bg ").concat(ppfx, "two-color"), appendTo: elToAppend || 'body', maxSelectionSize: 8, showPalette: true, showAlpha: true, chooseText: 'Ok', cancelText: '⨯', palette: [] }, colorPickerConfig), (colorPicker || {})), { move: function (color) {
                    var cl = getColor(color);
                    _this.movedColor = cl;
                    cpStyle.backgroundColor = cl;
                    handleChange_1(cl);
                }, change: function (color) {
                    changed_1 = true;
                    var cl = getColor(color);
                    cpStyle.backgroundColor = cl;
                    handleChange_1(cl);
                    _this.noneColor = false;
                }, show: function (color) {
                    changed_1 = false;
                    _this.movedColor = '';
                    previousColor_1 = getColor(color);
                }, hide: function () {
                    if (!changed_1 && previousColor_1) {
                        if (_this.noneColor) {
                            previousColor_1 = '';
                        }
                        cpStyle.backgroundColor = previousColor_1;
                        colorEl.spectrum('set', previousColor_1);
                        handleChange_1(previousColor_1);
                    }
                } }));
            this.colorEl = colorEl;
        }
        return this.colorEl;
    };
    return TraitColorView;
}(view_TraitInputView));
/* harmony default export */ const view_TraitColorView = (TraitColorView);

// EXTERNAL MODULE: ./src/utils/dom.ts
var dom = __webpack_require__(968);
;// CONCATENATED MODULE: ./src/common/traits/view/TraitNumberView.ts
var TraitNumberView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var TraitNumberViewAbstract = /** @class */ (function (_super) {
    TraitNumberView_extends(TraitNumberViewAbstract, _super);
    function TraitNumberViewAbstract(em, opts) {
        var _a, _b;
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'number';
        (0,index_all.bindAll)(_this, 'moveIncrement', 'upIncrement');
        _this.step = (_a = opts === null || opts === void 0 ? void 0 : opts.step) !== null && _a !== void 0 ? _a : 1;
        _this.min = opts === null || opts === void 0 ? void 0 : opts.min;
        _this.max = opts === null || opts === void 0 ? void 0 : opts.max;
        _this.fixedValues = (_b = opts === null || opts === void 0 ? void 0 : opts.fixedValues) !== null && _b !== void 0 ? _b : [];
        return _this;
    }
    TraitNumberViewAbstract.prototype.events = function () {
        return {
            'change input': 'handleChange',
            'change select': 'handleUnitChange',
            'click [data-arrow-up]': 'upArrowClick',
            'click [data-arrow-down]': 'downArrowClick',
            'mousedown [data-arrows]': 'downIncrement',
            keydown: 'handleKeyDown',
        };
    };
    Object.defineProperty(TraitNumberViewAbstract.prototype, "inputNumberValue", {
        get: function () {
            var _a;
            var el = (_a = this.$input) === null || _a === void 0 ? void 0 : _a.get(0);
            return (el === null || el === void 0 ? void 0 : el.value) ? parseFloat(el.value) : this.target.value;
        },
        set: function (value) {
            var _a;
            var el = (_a = this.$input) === null || _a === void 0 ? void 0 : _a.get(0);
            el && (el.value = value);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitNumberViewAbstract.prototype.getInputEl = function () {
        var _a = this, ppfx = _a.ppfx, target = _a.target, type = _a.type, paceholder = _a.paceholder;
        var value = this.target.value;
        console.log(this.$el.get(0));
        var el = (0,cash_dom["default"])(document.createElement('div'));
        el.addClass(this.inputClass());
        el.html(this.template());
        var plh = paceholder || target.value;
        var inputEl = (0,cash_dom["default"])("<input type=\"".concat(type, "\" placeholder=\"").concat(plh, "\">"));
        el.find(".".concat("".concat(this.ppfx, "input-holder"))).append(inputEl);
        console.log(el.get(0));
        //   model.set('value', value, { fromTarget: true });
        inputEl.val(value);
        //   this.$el.find('[data-input]').append(el)
        console.log(this.$el.get(0));
        this.$input = inputEl;
        return el.get(0);
    };
    TraitNumberViewAbstract.prototype.template = function () {
        var ppfx = this.ppfx;
        return "\n        <span class=\"".concat(ppfx, "input-holder\"></span>\n        <span class=\"").concat(ppfx, "field-units\"></span>\n        <div class=\"").concat(ppfx, "field-arrows\" data-arrows>\n          <div class=\"").concat(ppfx, "field-arrow-u\" data-arrow-up></div>\n          <div class=\"").concat(ppfx, "field-arrow-d\" data-arrow-down></div>\n        </div>\n      ");
    };
    TraitNumberViewAbstract.prototype.inputClass = function () {
        var ppfx = this.ppfx;
        return "".concat(ppfx, "field-int") || 0;
    };
    /**
     * Set value to the model
     * @param {string} value
     * @param {Object} opts
     */
    TraitNumberViewAbstract.prototype.setValue = function (value) {
        var valid = this.validateInputValue(value, { deepCheck: 1 });
        this.inputNumberValue = valid;
        console.log('SetValue' + this.inputValue);
        this.target.value = this.inputValue;
    };
    /**
     * Handled when the view is changed
     */
    TraitNumberViewAbstract.prototype.handleChange = function (e) {
        e.stopPropagation();
        this.setValue(this.inputNumberValue);
    };
    /**
     * Handled when user uses keyboard
     */
    TraitNumberViewAbstract.prototype.handleKeyDown = function (e) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            this.upArrowClick();
        }
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            this.downArrowClick();
        }
    };
    /**
     * Invoked when the up arrow is clicked
     * */
    TraitNumberViewAbstract.prototype.upArrowClick = function () {
        var _a = this, step = _a.step, inputNumberValue = _a.inputNumberValue;
        this.setValue(this.normalizeValue(inputNumberValue + step));
    };
    /**
     * Invoked when the down arrow is clicked
     * */
    TraitNumberViewAbstract.prototype.downArrowClick = function () {
        var _a = this, step = _a.step, inputNumberValue = _a.inputNumberValue;
        this.setValue(this.normalizeValue(inputNumberValue - step));
    };
    /**
     * Change easily integer input value with click&drag method
     * @param Event
     *
     * @return void
     * */
    TraitNumberViewAbstract.prototype.downIncrement = function (e) {
        e.preventDefault();
        console.log('downIncrement');
        this.moved = false;
        this.inputNumberValue = this.inputNumberValue || 0;
        var value = this.normalizeValue(this.inputNumberValue);
        this.setValue(value);
        this.current = { y: e.pageY, val: value };
        (0,dom.on)(document, 'mousemove', this.moveIncrement);
        (0,dom.on)(document, 'mouseup', this.upIncrement);
    };
    /** While the increment is clicked, moving the mouse will update input value
     * @param Object
     *
     * @return bool
     * */
    TraitNumberViewAbstract.prototype.moveIncrement = function (ev) {
        this.moved = true;
        console.log('moveIncrement');
        var step = this.step;
        var data = this.current;
        var pos = this.normalizeValue(data.val + (data.y - ev.pageY) * step);
        var value = this.validateInputValue(pos);
        this.prValue = value;
        this.inputNumberValue = value;
        return false;
    };
    /**
     * Stop moveIncrement method
     * */
    TraitNumberViewAbstract.prototype.upIncrement = function () {
        console.log('upIncrement');
        (0,dom/* off */.S1)(document, 'mouseup', this.upIncrement);
        (0,dom/* off */.S1)(document, 'mousemove', this.moveIncrement);
        if (this.prValue && this.moved) {
            var value = this.prValue;
            this.setValue(value);
        }
    };
    TraitNumberViewAbstract.prototype.normalizeValue = function (value, defValue) {
        if (defValue === void 0) { defValue = 0; }
        var step = this.step;
        var stepDecimals = 0;
        if (isNaN(value)) {
            return defValue;
        }
        value = parseFloat(value);
        if (Math.floor(value) !== value) {
            var side = step.toString().split('.')[1];
            stepDecimals = side ? side.length : 0;
        }
        return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
    };
    /**
     * Validate input value
     * @param {String} value Raw value
     * @param {Object} opts Options
     * @return {Object} Validated string
     */
    TraitNumberViewAbstract.prototype.validateInputValue = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, min = _a.min, max = _a.max, fixedValues = _a.fixedValues;
        var opt = opts || {};
        var defValue = ''; //model.get('defaults');
        var val = !(0,index_all.isUndefined)(value) ? value : defValue;
        if (opt.deepCheck) {
            if (val) {
                // If the value is one of the fixed values I leave it as it is
                var regFixed = new RegExp('^' + fixedValues.join('|'), 'g');
                if (fixedValues.length && regFixed.test(val)) {
                    val = val.match(regFixed)[0];
                }
                else {
                    val += ''; // Make it suitable for replace
                    val = parseFloat(val.replace(',', '.'));
                    val = !isNaN(val) ? val : defValue;
                }
            }
        }
        if (!(0,index_all.isUndefined)(max))
            val = val > max ? max : val;
        if (!(0,index_all.isUndefined)(min))
            val = val < min ? min : val;
        return val;
    };
    return TraitNumberViewAbstract;
}(view_TraitInputView));
var TraitNumberView = /** @class */ (function (_super) {
    TraitNumberView_extends(TraitNumberView, _super);
    function TraitNumberView(em, opts) {
        return _super.call(this, em, opts) || this;
    }
    Object.defineProperty(TraitNumberView.prototype, "inputValue", {
        get: function () {
            return this.inputNumberValue;
        },
        set: function (value) {
            this.inputNumberValue = value;
        },
        enumerable: false,
        configurable: true
    });
    return TraitNumberView;
}(TraitNumberViewAbstract));

var TraitNumberUnitView = /** @class */ (function (_super) {
    TraitNumberView_extends(TraitNumberUnitView, _super);
    function TraitNumberUnitView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.units = opts.units;
        return _this;
    }
    Object.defineProperty(TraitNumberUnitView.prototype, "inputValue", {
        get: function () {
            var unit = this.inputUnitValue;
            if (this.inputNumberValue === '')
                unit = '';
            return this.inputNumberValue + unit;
        },
        set: function (value) {
            var valueString = value + '';
            var numberRegexp = valueString.match(/^\d*\.?\d*/);
            var number = numberRegexp ? numberRegexp[0] : '';
            this.inputNumberValue = parseFloat(number);
            var unit = valueString.slice(number.length);
            this.inputUnitValue = unit;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TraitNumberUnitView.prototype, "inputUnitValue", {
        get: function () {
            var _a;
            var units = this.units;
            var el = this.unitEl;
            return (_a = el === null || el === void 0 ? void 0 : el.value) !== null && _a !== void 0 ? _a : ((units.length && units[0]) || '');
        },
        set: function (value) {
            var _a = this, unitEl = _a.unitEl, units = _a.units;
            // Check if exists as unit
            var unit = '';
            if ((0,index_all.indexOf)(units, value) >= 0)
                unit = value;
            unitEl && (unitEl.value = unit);
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitNumberUnitView.prototype.getInputEl = function () {
        var el = _super.prototype.getInputEl.call(this);
        this.unitEl = undefined;
        var unit = this.getUnitEl();
        unit && (0,cash_dom["default"])(el).find(".".concat(this.ppfx, "field-units")).get(0).appendChild(unit);
        return el;
    };
    /**
     * Handled when the view is changed
     */
    TraitNumberUnitView.prototype.handleUnitChange = function (e) {
        e.stopPropagation();
        console.log('Unit changed');
        this.target.value = this.inputValue;
    };
    /**
     * Get the unit element
     * @return {HTMLElement}
     */
    TraitNumberUnitView.prototype.getUnitEl = function () {
        var _this = this;
        if (!this.unitEl) {
            var units = this.units;
            if (units.length) {
                var options_1 = ['<option value="" disabled hidden>-</option>'];
                units.forEach(function (unit) {
                    var selected = unit == _this.inputUnitValue ? 'selected' : '';
                    options_1.push("<option ".concat(selected, ">").concat(unit, "</option>"));
                });
                var temp = document.createElement('div');
                temp.innerHTML = "<select class=\"".concat(this.ppfx, "input-unit\">").concat(options_1.join(''), "</select>");
                this.unitEl = temp.firstChild;
            }
        }
        return this.unitEl;
    };
    return TraitNumberUnitView;
}(TraitNumberViewAbstract));


;// CONCATENATED MODULE: ./src/common/traits/view/TraitSelectView.ts
var TraitSelectView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var TraitSelectView = /** @class */ (function (_super) {
    TraitSelectView_extends(TraitSelectView, _super);
    function TraitSelectView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'select';
        _this.options = opts.options;
        return _this;
    }
    TraitSelectView.prototype.getInputElem = function () {
        var _a = this, input = _a.input, $input = _a.$input;
        return input || ($input && $input.get && $input.get(0)) || this.getElInput();
    };
    Object.defineProperty(TraitSelectView.prototype, "inputValue", {
        get: function () {
            var _a;
            var el = this.getInputElem();
            return (_a = el === null || el === void 0 ? void 0 : el.value) !== null && _a !== void 0 ? _a : this.target.value;
        },
        set: function (value) {
            console.log('Text input value ' + value);
            var el = this.getInputElem();
            el && (el.value = value);
        },
        enumerable: false,
        configurable: true
    });
    TraitSelectView.prototype.templateInput = function () {
        var _a = this, ppfx = _a.ppfx, clsField = _a.clsField;
        return "<div class=\"".concat(clsField, "\">\n      <div data-input></div>\n      <div class=\"").concat(ppfx, "sel-arrow\">\n        <div class=\"").concat(ppfx, "d-s-arrow\"></div>\n      </div>\n    </div>");
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitSelectView.prototype.getInputEl = function () {
        if (!this.$input) {
            var _a = this, name_1 = _a.name, options = _a.options, em_1 = _a.em;
            var values_1 = [];
            var input_1 = '<select>';
            options.forEach(function (el) {
                var attrs = '';
                var name, value, style;
                if ((0,index_all.isString)(el)) {
                    name = el;
                    value = el;
                }
                else {
                    name = el.name || el.value;
                    value = "".concat((0,index_all.isUndefined)(el.value) ? el.name : el.value).replace(/"/g, '&quot;');
                    style = el.style ? el.style.replace(/"/g, '&quot;') : '';
                    attrs += style ? " style=\"".concat(style, "\"") : '';
                }
                var resultName = em_1.t("traitManager.traits.options.".concat(name, ".").concat(value)) || name;
                input_1 += "<option value=\"".concat(value, "\"").concat(attrs, ">").concat(resultName, "</option>");
                values_1.push(value);
            });
            input_1 += '</select>';
            this.$input = (0,cash_dom["default"])(input_1);
            var val = this.target.value;
            var valResult = values_1.indexOf(val) >= 0 ? val : '';
            !(0,index_all.isUndefined)(valResult) && this.$input.val(valResult);
        }
        return this.$input.get(0);
    };
    return TraitSelectView;
}(view_TraitInputView));
/* harmony default export */ const view_TraitSelectView = (TraitSelectView);

;// CONCATENATED MODULE: ./src/pages/view/PageEditView.ts
var PageEditView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var PageEditView = /** @class */ (function (_super) {
    PageEditView_extends(PageEditView, _super);
    function PageEditView(model, config) {
        var _this = _super.call(this, { model: model }) || this;
        _this.highlightedClass = 'gjs-three-bg';
        _this.config = config;
        var _a = _this, pfx = _a.pfx, ppfx = _a.ppfx;
        _this.className = "".concat(ppfx, "layer no-select ").concat(pfx, "two-color");
        return _this;
    }
    PageEditView.prototype.render = function () {
        var em = this.em;
        this.$el.empty();
        this.$el.attr('class', this.className);
        if (this.model) {
            var input = new TraitNumberView(em, { min: 0 });
            input.setTarget('name', this.model, { changeProp: true });
            this.$el.append(input.render().el);
            var input3 = new TraitNumberUnitView(em, { min: 0, units: ['px', '%'] });
            input3.setTarget('name', this.model, { changeProp: true });
            this.$el.append(input3.render().el);
            this.$el.append(new view_TraitSelectView(em, { options: ['px', '%'] }).setTarget('name', this.model, { changeProp: true }).render()
                .el);
            this.$el.append(new view_TraitCheckboxView(em).setTarget('name', this.model, { changeProp: true }).render().el);
            this.$el.append(new view_TraitButtonView(em, {
                text: 'Ok',
                command: function () {
                    console.log('click');
                },
                full: true,
            })
                .setTarget('name', this.model, { changeProp: true })
                .render().el);
            this.$el.append(new view_TraitColorView(em, {}).setTarget('name', this.model, { changeProp: true }).render().el);
            var input2 = new view_TraitTextView(em, {}).setTarget('route', this.model, { changeProp: true });
            this.$el.append(input2.render().el);
        }
        return this;
    };
    PageEditView.prototype.events = function () {
        var _this = this;
        return {
            click: function () { return _this.trigger('onClick', _this); },
        };
    };
    PageEditView.prototype.changePage = function (page) {
        this.model = page;
        this.render();
    };
    Object.defineProperty(PageEditView.prototype, "em", {
        get: function () {
            return this.config.em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PageEditView.prototype, "ppfx", {
        get: function () {
            return this.em.getConfig().stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PageEditView.prototype, "pfx", {
        get: function () {
            return this.config.stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    PageEditView.prototype.setHighlighted = function (status) {
        status ? this.$el.addClass(this.highlightedClass) : this.$el.removeClass(this.highlightedClass);
    };
    Object.defineProperty(PageEditView.prototype, "page", {
        get: function () {
            return this.model;
        },
        enumerable: false,
        configurable: true
    });
    return PageEditView;
}(common/* View */.G7));
/* harmony default export */ const view_PageEditView = (PageEditView);

;// CONCATENATED MODULE: ./src/pages/index.ts
/**
 * You can customize the initial state of the module from the editor initialization
 * ```js
 * const editor = grapesjs.init({
 *  ....
 *  pageManager: {
 *    pages: [
 *      {
 *        id: 'page-id',
 *        styles: `.my-class { color: red }`, // or a JSON of styles
 *        component: '<div class="my-class">My element</div>', // or a JSON of components
 *      }
 *   ]
 *  },
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const pageManager = editor.Pages;
 * ```
 *
 * ## Available Events
 * * `page:add` - Added new page. The page is passed as an argument to the callback
 * * `page:remove` - Page removed. The page is passed as an argument to the callback
 * * `page:select` - New page selected. The newly selected page and the previous one, are passed as arguments to the callback
 * * `page:update` - Page updated. The updated page and the object containing changes are passed as arguments to the callback
 * * `page` - Catch-all event for all the events mentioned above. An object containing all the available data about the triggered event is passed as an argument to the callback
 *
 * ## Methods
 * * [add](#add)
 * * [get](#get)
 * * [getAll](#getall)
 * * [getAllWrappers](#getallwrappers)
 * * [getMain](#getmain)
 * * [remove](#remove)
 * * [select](#select)
 * * [getSelected](#getselected)
 *
 * [Page]: page.html
 * [Component]: component.html
 *
 * @module Pages
 */
var pages_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var pages_assign = (undefined && undefined.__assign) || function () {
    pages_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return pages_assign.apply(this, arguments);
};
var pages_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};









var pages_evAll = 'page';
var pages_evPfx = "".concat(pages_evAll, ":");
var evPageSelect = "".concat(pages_evPfx, "select");
var evPageSelectBefore = "".concat(evPageSelect, ":before");
var evPageUpdate = "".concat(pages_evPfx, "update");
var evPageAdd = "".concat(pages_evPfx, "add");
var evPageAddBefore = "".concat(evPageAdd, ":before");
var evPageRemove = "".concat(pages_evPfx, "remove");
var evPageRemoveBefore = "".concat(evPageRemove, ":before");
var pages_chnSel = 'change:selected';
var typeMain = 'main';
var pageEvents = {
    all: pages_evAll,
    select: evPageSelect,
    selectBefore: evPageSelectBefore,
    update: evPageUpdate,
    add: evPageAdd,
    addBefore: evPageAddBefore,
    remove: evPageRemove,
    removeBefore: evPageRemoveBefore,
};
var PageManager = /** @class */ (function (_super) {
    pages_extends(PageManager, _super);
    /**
     * Get all pages
     * @name getAll
     * @function
     * @returns {Array<[Page]>}
     * @example
     * const arrayOfPages = pageManager.getAll();
     */
    /**
     * Initialize module
     * @hideconstructor
     * @param {Object} config Configurations
     */
    function PageManager(em) {
        var _this = _super.call(this, em, 'PageManager', new model_Pages([], em), pageEvents, pages_config_config) || this;
        _this.storageKey = 'pages';
        (0,index_all.bindAll)(_this, '_onPageChange');
        var model = new ModuleModel/* default */.Z({ _undo: true });
        _this.model = model;
        _this.pages.on('reset', function (coll) { return coll.at(0) && _this.select(coll.at(0)); });
        _this.pages.on('all', _this.__onChange, _this);
        model.on(pages_chnSel, _this._onPageChange);
        return _this;
    }
    Object.defineProperty(PageManager.prototype, "pages", {
        get: function () {
            return this.all;
        },
        enumerable: false,
        configurable: true
    });
    PageManager.prototype.getAll = function () {
        // this avoids issues during the TS build (some getAll are inconsistent)
        return pages_spreadArray([], this.all.models, true);
    };
    PageManager.prototype.__onChange = function (event, page, coll, opts) {
        var options = opts || coll;
        this.em.trigger(pages_evAll, { event: event, page: page, options: options });
    };
    PageManager.prototype.onLoad = function () {
        var _a;
        var _b = this, pages = _b.pages, config = _b.config, em = _b.em;
        var opt = { silent: true };
        var configPages = ((_a = config.pages) === null || _a === void 0 ? void 0 : _a.map(function (page) { return new model_Page(page, { em: em, config: config }); })) || [];
        pages.add(configPages, opt);
        var mainPage = !pages.length ? this.add({ type: typeMain }, opt) : this.getMain();
        mainPage && this.select(mainPage, opt);
    };
    PageManager.prototype._onPageChange = function (m, page, opts) {
        var em = this.em;
        var lm = em.Layers;
        var mainComp = page.getMainComponent();
        lm && mainComp && lm.setRoot(mainComp);
        em.trigger(evPageSelect, page, m.previous('selected'));
        this.__onChange(pages_chnSel, page, opts);
    };
    PageManager.prototype.postLoad = function () {
        var _a = this, em = _a.em, model = _a.model, pages = _a.pages;
        var um = em.UndoManager;
        um.add(model);
        um.add(pages);
        pages.on('add remove reset change', function (m, c, o) { return em.changesUp(o || c); });
    };
    /**
     * Add new page
     * @param {Object} props Page properties
     * @param {Object} [opts] Options
     * @returns {[Page]}
     * @example
     * const newPage = pageManager.add({
     *  id: 'new-page-id', // without an explicit ID, a random one will be created
     *  styles: `.my-class { color: red }`, // or a JSON of styles
     *  component: '<div class="my-class">My element</div>', // or a JSON of components
     * });
     */
    PageManager.prototype.add = function (props, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        props.id = props.id || this._createId();
        var add = function () {
            var page = _this.pages.add(new model_Page(props, { em: _this.em, config: _this.config }), opts);
            opts.select && _this.select(page);
            return page;
        };
        !opts.silent && em.trigger(evPageAddBefore, props, add, opts);
        return !opts.abort ? add() : undefined;
    };
    /**
     * Remove page
     * @param {String|[Page]} page Page or page id
     * @returns {[Page]} Removed Page
     * @example
     * const removedPage = pageManager.remove('page-id');
     * // or by passing the page
     * const somePage = pageManager.get('page-id');
     * pageManager.remove(somePage);
     */
    PageManager.prototype.remove = function (page, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var pg = (0,index_all.isString)(page) ? this.get(page) : page;
        var rm = function () {
            pg && _this.pages.remove(pg, opts);
            return pg;
        };
        !opts.silent && em.trigger(evPageRemoveBefore, pg, rm, opts);
        return !opts.abort && rm();
    };
    /**
     * Get page by id
     * @param {String} id Page id
     * @returns {[Page]}
     * @example
     * const somePage = pageManager.get('page-id');
     */
    PageManager.prototype.get = function (id) {
        return this.pages.filter(function (p) { return p.get(p.idAttribute) === id; })[0];
    };
    /**
     * Get main page (the first one available)
     * @returns {[Page]}
     * @example
     * const mainPage = pageManager.getMain();
     */
    PageManager.prototype.getMain = function () {
        var pages = this.pages;
        return pages.filter(function (p) { return p.get('type') === typeMain; })[0] || pages.at(0);
    };
    /**
     * Get wrapper components (aka body) from all pages and frames.
     * @returns {Array<[Component]>}
     * @example
     * const wrappers = pageManager.getAllWrappers();
     * // Get all `image` components from the project
     * const allImages = wrappers.map(wrp => wrp.findType('image')).flat();
     */
    PageManager.prototype.getAllWrappers = function () {
        var pages = this.getAll();
        return (0,index_all.unique)((0,index_all.flatten)(pages.map(function (page) { return page.getAllFrames().map(function (frame) { return frame.getComponent(); }); })));
    };
    /**
     * Change the selected page. This will switch the page rendered in canvas
     * @param {String|[Page]} page Page or page id
     * @returns {this}
     * @example
     * pageManager.select('page-id');
     * // or by passing the page
     * const somePage = pageManager.get('page-id');
     * pageManager.select(somePage);
     */
    PageManager.prototype.select = function (page, opts) {
        if (opts === void 0) { opts = {}; }
        var pg = (0,index_all.isString)(page) ? this.get(page) : page;
        if (pg) {
            this.em.trigger(evPageSelectBefore, pg, opts);
            this.model.set('selected', pg, opts);
        }
        return this;
    };
    /**
     * Get the selected page
     * @returns {[Page]}
     * @example
     * const selectedPage = pageManager.getSelected();
     */
    PageManager.prototype.getSelected = function () {
        return this.model.get('selected');
    };
    PageManager.prototype.destroy = function () {
        var _this = this;
        this.pages.off().reset();
        this.model.stopListening();
        this.model.clear({ silent: true });
        //@ts-ignore
        ['selected', 'model'].map(function (i) { return (_this[i] = 0); });
    };
    PageManager.prototype.store = function () {
        return this.getProjectData();
    };
    PageManager.prototype.load = function (data) {
        var result = this.loadProjectData(data, { all: this.pages, reset: true });
        this.pages.forEach(function (page) { return page.getFrames().initRefs(); });
        return result;
    };
    PageManager.prototype._createId = function () {
        var pages = this.getAll();
        var len = pages.length + 16;
        var pagesMap = this.getAllMap();
        var id;
        do {
            id = (0,mixins.createId)(len);
        } while (pagesMap[id]);
        return id;
    };
    PageManager.prototype.render = function (opts) {
        var config = this.getConfig();
        var em = this.em;
        var pages = this.all;
        var view = new view_PagesView({
            collection: pages,
            module: this,
        }, pages_assign(pages_assign({}, config), { em: em }));
        var selectedView = new view_PageEditView(this.getSelected(), pages_assign(pages_assign({}, config), { em: em }));
        view.on('selected', selectedView.changePage, selectedView);
        var el = document.createElement('div');
        el.append(selectedView.render().el);
        el.append(view.render().el);
        return el;
    };
    return PageManager;
}(ItemManagerModule));
/* harmony default export */ const pages = (PageManager);

;// CONCATENATED MODULE: ./src/canvas/model/Canvas.ts
var Canvas_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var Canvas = /** @class */ (function (_super) {
    Canvas_extends(Canvas, _super);
    function Canvas(module) {
        var _this = this;
        var em = module.em, config = module.config;
        var scripts = config.scripts, styles = config.styles;
        _this = _super.call(this, module, { scripts: scripts, styles: styles }) || this;
        _this.set('frames', new model_Frames(module));
        _this.on('change:zoom', _this.onZoomChange);
        _this.on('change:x change:y', _this.onCoordsChange);
        _this.on('change:pointer change:pointerScreen', _this.onPointerChange);
        _this.listenTo(em, "change:device ".concat(evUpdate), _this.updateDevice);
        _this.listenTo(em, evPageSelect, _this._pageUpdated);
        return _this;
    }
    Canvas.prototype.defaults = function () {
        return {
            frame: '',
            frames: [],
            rulers: false,
            zoom: 100,
            x: 0,
            y: 0,
            // Scripts to apply on all frames
            scripts: [],
            // Styles to apply on all frames
            styles: [],
            pointer: common/* DEFAULT_COORDS */.pH,
            pointerScreen: common/* DEFAULT_COORDS */.pH,
        };
    };
    Object.defineProperty(Canvas.prototype, "frames", {
        get: function () {
            return this.get('frames');
        },
        enumerable: false,
        configurable: true
    });
    Canvas.prototype.init = function () {
        var em = this.em;
        var mainPage = em.Pages.getMain();
        this.set('frames', mainPage.getFrames());
        this.updateDevice({ frame: mainPage.getMainFrame() });
    };
    Canvas.prototype._pageUpdated = function (page, prev) {
        var em = this.em;
        em.setSelected();
        em.get('readyCanvas') && em.stopDefault(); // We have to stop before changing current frames
        prev === null || prev === void 0 ? void 0 : prev.getFrames().map(function (frame) { return frame.disable(); });
        this.set('frames', page.getFrames());
        this.updateDevice({ frame: page.getMainFrame() });
    };
    Canvas.prototype.updateDevice = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var device = em.getDeviceModel();
        var model = opts.frame || em.getCurrentFrameModel();
        if (model && device) {
            var _a = device.attributes, width = _a.width, height = _a.height;
            model.set({ width: width, height: height }, { noUndo: 1 });
        }
    };
    Canvas.prototype.onZoomChange = function () {
        var _a = this, em = _a.em, module = _a.module;
        var zoom = this.get('zoom');
        zoom < 1 && this.set('zoom', 1);
        em.trigger(module.events.zoom);
    };
    Canvas.prototype.onCoordsChange = function () {
        var _a = this, em = _a.em, module = _a.module;
        em.trigger(module.events.coords);
    };
    Canvas.prototype.onPointerChange = function () {
        var _a = this, em = _a.em, module = _a.module;
        em.trigger(module.events.pointer);
    };
    Canvas.prototype.getPointerCoords = function (type) {
        if (type === void 0) { type = common/* CoordinatesTypes */.vA.World; }
        var _a = this.attributes, pointer = _a.pointer, pointerScreen = _a.pointerScreen;
        return type === common/* CoordinatesTypes */.vA.World ? pointer : pointerScreen;
    };
    return Canvas;
}(ModuleModel/* default */.Z));
/* harmony default export */ const model_Canvas = (Canvas);

// EXTERNAL MODULE: ./src/canvas/model/CanvasSpot.ts
var CanvasSpot = __webpack_require__(201);
;// CONCATENATED MODULE: ./src/canvas/model/CanvasSpots.ts
var CanvasSpots_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var CanvasSpots = /** @class */ (function (_super) {
    CanvasSpots_extends(CanvasSpots, _super);
    function CanvasSpots(module, models) {
        if (models === void 0) { models = []; }
        var _this = _super.call(this, module, models, CanvasSpot/* default */.Z) || this;
        _this.on('add', _this.onAdd);
        _this.on('change', _this.onChange);
        _this.on('remove', _this.onRemove);
        var em = _this.em;
        _this.refreshDbn = (0,index_all.debounce)(function () { return _this.refresh(); }, 0);
        var evToRefreshDbn = 'component:resize styleable:change component:input component:update frame:updated undo redo';
        _this.listenTo(em, evToRefreshDbn, function () { return _this.refreshDbn(); });
        return _this;
    }
    Object.defineProperty(CanvasSpots.prototype, "em", {
        get: function () {
            return this.module.em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CanvasSpots.prototype, "events", {
        get: function () {
            return this.module.events;
        },
        enumerable: false,
        configurable: true
    });
    CanvasSpots.prototype.refresh = function () {
        var _a = this, em = _a.em, events = _a.events;
        em.trigger(events.spot);
    };
    CanvasSpots.prototype.onAdd = function (spot) {
        this.__trgEvent(this.events.spotAdd, { spot: spot });
    };
    CanvasSpots.prototype.onChange = function (spot) {
        this.__trgEvent(this.events.spotUpdate, { spot: spot });
    };
    CanvasSpots.prototype.onRemove = function (spot) {
        this.__trgEvent(this.events.spotRemove, { spot: spot });
    };
    CanvasSpots.prototype.__trgEvent = function (event, props) {
        var module = this.module;
        var em = module.em;
        em.trigger(event, props);
        this.refreshDbn();
    };
    return CanvasSpots;
}(abstract_ModuleCollection));
/* harmony default export */ const model_CanvasSpots = (CanvasSpots);

;// CONCATENATED MODULE: ./src/canvas/types.ts
/**{START_EVENTS}*/
var CanvasEvents;
(function (CanvasEvents) {
    /**
     * @event `canvas:dragenter` Something is dragged inside the canvas, `DataTransfer` instance passed as an argument.
     */
    CanvasEvents["dragEnter"] = "canvas:dragenter";
    /**
     * @event `canvas:dragover` Something is dragging on the canvas, `DataTransfer` instance passed as an argument.
     */
    CanvasEvents["dragOver"] = "canvas:dragover";
    /**
     * @event `canvas:dragend` When a drag operation is ended, `DataTransfer` instance passed as an argument.
     */
    CanvasEvents["dragEnd"] = "canvas:dragend";
    /**
     * @event `canvas:dragdata` On any dataTransfer parse, `DataTransfer` instance and the `result` are passed as arguments.
     * By changing `result.content` you're able to customize what is dropped.
     */
    CanvasEvents["dragData"] = "canvas:dragdata";
    /**
     * @event `canvas:drop` Something is dropped in canvas, `DataTransfer` instance and the dropped model are passed as arguments.
     */
    CanvasEvents["drop"] = "canvas:drop";
    /**
     * @event `canvas:spot` Spots updated.
     * @example
     * editor.on('canvas:spot', () => {
     *  console.log('Spots', editor.Canvas.getSpots());
     * });
     */
    CanvasEvents["spot"] = "canvas:spot";
    /**
     * @event `canvas:spot:add` New canvas spot added.
     * @example
     * editor.on('canvas:spot:add', ({ spot }) => {
     *  console.log('Spot added', spot);
     * });
     */
    CanvasEvents["spotAdd"] = "canvas:spot:add";
    /**
     * @event `canvas:spot:update` Canvas spot updated.
     * @example
     * editor.on('canvas:spot:update', ({ spot }) => {
     *  console.log('Spot updated', spot);
     * });
     */
    CanvasEvents["spotUpdate"] = "canvas:spot:update";
    /**
     * @event `canvas:spot:remove` Canvas spot removed.
     * @example
     * editor.on('canvas:spot:remove', ({ spot }) => {
     *  console.log('Spot removed', spot);
     * });
     */
    CanvasEvents["spotRemove"] = "canvas:spot:remove";
    /**
     * @event `canvas:coords` Canvas coordinates updated.
     * @example
     * editor.on('canvas:coords', () => {
     *  console.log('Canvas coordinates updated:', editor.Canvas.getCoords());
     * });
     */
    CanvasEvents["coords"] = "canvas:coords";
    /**
     * @event `canvas:zoom` Canvas zoom updated.
     * @example
     * editor.on('canvas:zoom', () => {
     *  console.log('Canvas zoom updated:', editor.Canvas.getZoom());
     * });
     */
    CanvasEvents["zoom"] = "canvas:zoom";
    /**
     * @event `canvas:pointer` Canvas pointer updated.
     * @example
     * editor.on('canvas:pointer', () => {
     *  console.log('Canvas pointer updated:', editor.Canvas.getPointer());
     * });
     */
    CanvasEvents["pointer"] = "canvas:pointer";
    /**
     * @event `canvas:frame:load` Frame loaded in canvas.
     * The event is triggered right after iframe's `onload`.
     * @example
     * editor.on('canvas:frame:load', ({ window }) => {
     *  console.log('Frame loaded', window);
     * });
     */
    CanvasEvents["frameLoad"] = "canvas:frame:load";
    /**
     * @event `canvas:frame:load:head` Frame head loaded in canvas.
     * The event is triggered right after iframe's finished to load the head elemenets (eg. scripts)
     * @example
     * editor.on('canvas:frame:load:head', ({ window }) => {
     *  console.log('Frame head loaded', window);
     * });
     */
    CanvasEvents["frameLoadHead"] = "canvas:frame:load:head";
    /**
     * @event `canvas:frame:load:body` Frame body loaded in canvas.
     * The event is triggered when the body is rendered with components.
     * @example
     * editor.on('canvas:frame:load:body', ({ window }) => {
     *  console.log('Frame completed the body render', window);
     * });
     */
    CanvasEvents["frameLoadBody"] = "canvas:frame:load:body";
})(CanvasEvents || (CanvasEvents = {}));
/**{END_EVENTS}*/
// need this to avoid the TS documentation generator to break
/* harmony default export */ const types = (CanvasEvents);

;// CONCATENATED MODULE: ./src/abstract/ModuleView.ts
var ModuleView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

// type TCollection<TItem extends ModuleModel | ModuleCollection> = TItem extends ModuleCollection ? TItem : unknown;
var ModuleView = /** @class */ (function (_super) {
    ModuleView_extends(ModuleView, _super);
    function ModuleView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ModuleView.prototype, "pfx", {
        get: function () {
            return this.ppfx + this.config.stylePrefix || '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleView.prototype, "ppfx", {
        get: function () {
            return this.em.config.stylePrefix || '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleView.prototype, "module", {
        get: function () {
            var _a, _b;
            return (_b = (_a = this.model) === null || _a === void 0 ? void 0 : _a.module) !== null && _b !== void 0 ? _b : this.collection.module;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleView.prototype, "em", {
        get: function () {
            return this.module.em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ModuleView.prototype, "config", {
        get: function () {
            return this.module.config;
        },
        enumerable: false,
        configurable: true
    });
    ModuleView.prototype.preinitialize = function (options) {
        this.className = '';
    };
    return ModuleView;
}(common/* View */.G7));
/* harmony default export */ const abstract_ModuleView = (ModuleView);

;// CONCATENATED MODULE: ./src/abstract/ModuleDomainViews.ts
var ModuleDomainViews_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ModuleDomainViews = /** @class */ (function (_super) {
    ModuleDomainViews_extends(ModuleDomainViews, _super);
    function ModuleDomainViews(opts, autoAdd) {
        if (opts === void 0) { opts = {}; }
        if (autoAdd === void 0) { autoAdd = false; }
        var _this = _super.call(this, opts) || this;
        // Defines the View per type
        _this.itemsView = '';
        _this.itemType = 'type';
        _this.reuseView = false;
        _this.viewCollection = [];
        autoAdd && _this.listenTo(_this.collection, 'add', _this.addTo);
        return _this;
    }
    /**
     * Add new model to the collection
     * @param {ModuleModel} model
     * @private
     * */
    ModuleDomainViews.prototype.addTo = function (model) {
        this.add(model);
    };
    ModuleDomainViews.prototype.itemViewNotFound = function (type) {
        /*const { em, ns } = this;
        const warn = `${ns ? `[${ns}]: ` : ''}'${type}' type not found`;
        em?.logWarning(warn);*/
    };
    /**
     * Render new model inside the view
     * @param {ModuleModel} model
     * @param {Object} fragment Fragment collection
     * @private
     * */
    ModuleDomainViews.prototype.add = function (model, fragment) {
        var _a = this, reuseView = _a.reuseView, viewCollection = _a.viewCollection;
        var frag = fragment || null;
        var typeField = model.get(this.itemType);
        var view;
        //@ts-ignore
        if (model.view && reuseView) {
            //@ts-ignore
            view = model.view;
        }
        else {
            view = this.renderView(model, typeField);
        }
        viewCollection.push(view);
        var rendered = view.render().el;
        if (frag)
            frag.appendChild(rendered);
        else
            this.$el.append(rendered);
    };
    ModuleDomainViews.prototype.render = function () {
        var _this = this;
        var frag = document.createDocumentFragment();
        this.clearItems();
        this.$el.empty();
        if (this.collection.length)
            this.collection.each(function (model) { return _this.add(model, frag); });
        this.$el.append(frag);
        this.onRender();
        return this;
    };
    ModuleDomainViews.prototype.onRender = function () { };
    ModuleDomainViews.prototype.onRemoveBefore = function (items, opts) { };
    ModuleDomainViews.prototype.onRemove = function (items, opts) { };
    ModuleDomainViews.prototype.remove = function (opts) {
        if (opts === void 0) { opts = {}; }
        var viewCollection = this.viewCollection;
        this.onRemoveBefore(viewCollection, opts);
        this.clearItems();
        common/* View */.G7.prototype.remove.apply(this, opts);
        this.onRemove(viewCollection, opts);
        return this;
    };
    ModuleDomainViews.prototype.clearItems = function () {
        var items = this.viewCollection || [];
        // TODO Traits do not update the target anymore
        // items.forEach(item => item.remove());
        // this.items = [];
    };
    return ModuleDomainViews;
}(abstract_ModuleView));
/* harmony default export */ const abstract_ModuleDomainViews = (ModuleDomainViews);

;// CONCATENATED MODULE: ./src/css_composer/view/CssRuleView.ts
var CssRuleView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var CssRuleView = /** @class */ (function (_super) {
    CssRuleView_extends(CssRuleView, _super);
    function CssRuleView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        _this.config = o.config || {};
        var model = _this.model;
        _this.listenTo(model, 'change', _this.render);
        _this.listenTo(model, 'destroy remove', _this.remove);
        _this.listenTo(model.get('selectors'), 'change', _this.render);
        return _this;
    }
    // @ts-ignore
    CssRuleView.prototype.tagName = function () {
        return 'style';
    };
    CssRuleView.prototype.render = function () {
        var _a = this, model = _a.model, el = _a.el;
        var important = model.get('important');
        el.innerHTML = model.toCSS({ important: important });
        return this;
    };
    return CssRuleView;
}(common/* View */.G7));
/* harmony default export */ const view_CssRuleView = (CssRuleView);

;// CONCATENATED MODULE: ./src/css_composer/view/CssGroupRuleView.ts
var CssGroupRuleView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var CssGroupRuleView = /** @class */ (function (_super) {
    CssGroupRuleView_extends(CssGroupRuleView, _super);
    function CssGroupRuleView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CssGroupRuleView.prototype._createElement = function () {
        return document.createTextNode('');
    };
    CssGroupRuleView.prototype.render = function () {
        var model = this.model;
        var important = model.get('important');
        this.el.textContent = model.getDeclaration({ important: important });
        return this;
    };
    return CssGroupRuleView;
}(view_CssRuleView));
/* harmony default export */ const view_CssGroupRuleView = (CssGroupRuleView);

;// CONCATENATED MODULE: ./src/css_composer/view/CssRulesView.ts
var CssRulesView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();





var getBlockId = function (pfx, order) { return "".concat(pfx).concat(order ? "-".concat(parseFloat(order)) : ''); };
var CssRulesView = /** @class */ (function (_super) {
    CssRulesView_extends(CssRulesView, _super);
    function CssRulesView(o) {
        var _this = _super.call(this, o) || this;
        (0,index_all.bindAll)(_this, 'sortRules');
        var config = o.config || {};
        _this.atRules = {};
        _this.config = config;
        _this.em = config.em;
        _this.pfx = config.stylePrefix || '';
        _this.className = _this.pfx + 'rules';
        var coll = _this.collection;
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset', _this.render);
        return _this;
    }
    /**
     * Add to collection
     * @param {Object} model
     * @private
     * */
    CssRulesView.prototype.addTo = function (model) {
        this.addToCollection(model);
    };
    /**
     * Add new object to collection
     * @param {Object} model
     * @param {Object} fragmentEl
     * @return {Object}
     * @private
     * */
    CssRulesView.prototype.addToCollection = function (model, fragmentEl) {
        // If the render is not yet started
        if (!this.renderStarted) {
            return;
        }
        var fragment = fragmentEl || null;
        var config = this.config;
        var opts = { model: model, config: config };
        var rendered, view;
        // I have to render keyframes of the same name together
        // Unfortunately at the moment I didn't find the way of appending them
        // if not staticly, via appendData
        if (model.get('atRuleType') === 'keyframes') {
            var atRule = model.getAtRule();
            var atRuleEl = this.atRules[atRule];
            if (!atRuleEl) {
                var styleEl = document.createElement('style');
                atRuleEl = document.createTextNode('');
                styleEl.appendChild(document.createTextNode("".concat(atRule, "{")));
                styleEl.appendChild(atRuleEl);
                styleEl.appendChild(document.createTextNode('}'));
                this.atRules[atRule] = atRuleEl;
                rendered = styleEl;
            }
            view = new view_CssGroupRuleView(opts);
            atRuleEl.appendData(view.render().el.textContent);
        }
        else {
            view = new view_CssRuleView(opts);
            rendered = view.render().el;
        }
        var clsName = this.className;
        var mediaText = model.get('mediaText');
        var defaultBlockId = getBlockId(clsName);
        var blockId = defaultBlockId;
        // If the rule contains a media query it might have a different container
        // for it (eg. rules created with Device Manager)
        if (mediaText) {
            blockId = getBlockId(clsName, this.getMediaWidth(mediaText));
        }
        if (rendered) {
            var container = fragment || this.el;
            var contRules = void 0;
            // Try to find a specific container for the rule (if it
            // containes a media query), otherwise get the default one
            try {
                contRules = container.querySelector("#".concat(blockId));
            }
            catch (e) { }
            if (!contRules) {
                contRules = container.querySelector("#".concat(defaultBlockId));
            }
            contRules === null || contRules === void 0 ? void 0 : contRules.appendChild(rendered);
        }
        return rendered;
    };
    CssRulesView.prototype.getMediaWidth = function (mediaText) {
        return mediaText && mediaText.replace("(".concat(this.em.getConfig().mediaCondition, ": "), '').replace(')', '');
    };
    CssRulesView.prototype.sortRules = function (a, b) {
        var em = this.em;
        var isMobFirst = (em.getConfig().mediaCondition || '').indexOf('min-width') !== -1;
        if (!isMobFirst)
            return 0;
        var left = isMobFirst ? a : b;
        var right = isMobFirst ? b : a;
        return left - right;
    };
    CssRulesView.prototype.render = function () {
        var _this = this;
        this.renderStarted = true;
        this.atRules = {};
        var _a = this, em = _a.em, $el = _a.$el, collection = _a.collection;
        var cls = this.className;
        var frag = document.createDocumentFragment();
        $el.empty();
        // Create devices related DOM structure, ensure also to have a default container
        var prs = em.Devices.getAll().pluck('priority').sort(this.sortRules);
        prs.every(function (pr) { return pr; }) && prs.unshift(0);
        prs.forEach(function (pr) { return frag.appendChild((0,dom/* createEl */.ut)('div', { id: getBlockId(cls, pr) })); });
        collection.each(function (model) { return _this.addToCollection(model, frag); });
        $el.append(frag);
        $el.attr('class', cls);
        return this;
    };
    return CssRulesView;
}(common/* View */.G7));
/* harmony default export */ const view_CssRulesView = (CssRulesView);

;// CONCATENATED MODULE: ./src/utils/Droppable.ts
var Droppable_assign = (undefined && undefined.__assign) || function () {
    Droppable_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Droppable_assign.apply(this, arguments);
};


/**
 * This class makes the canvas droppable
 */
var Droppable = /** @class */ (function () {
    function Droppable(em, rootEl) {
        var _this = this;
        this.em = em;
        this.canvas = em.Canvas;
        var el = rootEl || this.canvas.getFrames().map(function (frame) { return frame.getComponent().getEl(); });
        var els = Array.isArray(el) ? el : [el];
        this.el = els[0];
        this.counter = 0;
        (0,index_all.bindAll)(this, 'handleDragEnter', 'handleDragOver', 'handleDrop', 'handleDragLeave');
        els.forEach(function (el) { return _this.toggleEffects(el, true); });
    }
    Droppable.prototype.toggleEffects = function (el, enable) {
        var methods = { on: dom.on, off: dom/* off */.S1 };
        var method = enable ? 'on' : 'off';
        methods[method](el, 'dragenter', this.handleDragEnter);
        methods[method](el, 'dragover', this.handleDragOver);
        methods[method](el, 'drop', this.handleDrop);
        methods[method](el, 'dragleave', this.handleDragLeave);
    };
    Droppable.prototype.__customTglEff = function (enable) {
        var _a;
        var method = enable ? dom.on : dom/* off */.S1;
        var doc = this.el.ownerDocument;
        var frameEl = (_a = doc.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement;
        this.sortOpts = enable
            ? {
                onStart: function (_a) {
                    var sorter = _a.sorter;
                    (0,dom.on)(frameEl, 'pointermove', sorter.onMove);
                },
                onEnd: function (_a) {
                    var sorter = _a.sorter;
                    (0,dom/* off */.S1)(frameEl, 'pointermove', sorter.onMove);
                },
                customTarget: function (_a) {
                    var event = _a.event;
                    return doc.elementFromPoint(event.clientX, event.clientY);
                },
            }
            : null;
        method(frameEl, 'pointerenter', this.handleDragEnter);
        method(frameEl, 'pointermove', this.handleDragOver);
        method(document, 'pointerup', this.handleDrop);
        method(frameEl, 'pointerout', this.handleDragLeave);
        // Test with touch devices (seems like frameEl is not capturing pointer events).
        // on/off(document, 'pointermove', sorter.onMove); // for the sorter
        // enable && this.handleDragEnter({}); // no way to use pointerenter/pointerout
    };
    Droppable.prototype.startCustom = function () {
        this.__customTglEff(true);
    };
    Droppable.prototype.endCustom = function (cancel) {
        this.over ? this.endDrop(cancel) : this.__customTglEff(false);
    };
    /**
     * This function is expected to be always executed at the end of d&d.
     */
    Droppable.prototype.endDrop = function (cancel, ev) {
        var _a = this, em = _a.em, dragStop = _a.dragStop;
        this.counter = 0;
        dragStop && dragStop(cancel || !this.over);
        this.__customTglEff(false);
        em.trigger('canvas:dragend', ev);
    };
    Droppable.prototype.handleDragLeave = function (ev) {
        this.updateCounter(-1, ev);
    };
    Droppable.prototype.updateCounter = function (value, ev) {
        this.counter += value;
        this.counter === 0 && this.endDrop(true, ev);
    };
    Droppable.prototype.handleDragEnter = function (ev) {
        var _this = this;
        var _a = this, em = _a.em, canvas = _a.canvas;
        var dt = ev.dataTransfer;
        var dragContentOrigin = em.get('dragContent');
        if (!dragContentOrigin && !canvas.getConfig().allowExternalDrop) {
            return;
        }
        this.updateCounter(1, ev);
        if (this.over)
            return;
        this.over = true;
        var utils = em.Utils;
        // For security reason I can't read the drag data on dragenter, but
        // as I need it for the Sorter context I will use `dragContent` or just
        // any not empty element
        var content = dragContentOrigin || '<br>';
        var dragStop;
        var dragContent;
        em.stopDefault();
        // Select the right drag provider
        if (em.inAbsoluteMode()) {
            var wrapper_1 = em.Components.getWrapper();
            var target_1 = wrapper_1.append({})[0];
            var dragger_1 = em.Commands.run('core:component-drag', {
                event: ev,
                guidesInfo: 1,
                center: 1,
                target: target_1,
                onEnd: function (ev, dragger, _a) {
                    var cancelled = _a.cancelled;
                    var comp;
                    if (!cancelled) {
                        comp = wrapper_1.append(content)[0];
                        var canvasOffset = canvas.getOffset();
                        var _b = target_1.getStyle(), top_1 = _b.top, left = _b.left, position = _b.position;
                        var scroll_1 = (0,dom/* getDocumentScroll */.GX)(ev.target);
                        var postLeft = parseInt("".concat(parseFloat(left) + scroll_1.x - canvasOffset.left), 10);
                        var posTop = parseInt("".concat(parseFloat(top_1) + scroll_1.y - canvasOffset.top), 10);
                        comp.addStyle({
                            left: postLeft + 'px',
                            top: posTop + 'px',
                            position: position,
                        });
                    }
                    _this.handleDragEnd(comp, dt);
                    target_1.remove();
                },
            });
            dragStop = function (cancel) { return dragger_1.stop(ev, { cancel: cancel }); };
            dragContent = function (cnt) { return (content = cnt); };
        }
        else {
            var sorter_1 = new utils.Sorter(Droppable_assign({ 
                // @ts-ignore
                em: em, wmargin: 1, nested: 1, canvasRelative: 1, direction: 'a', container: this.el, placer: canvas.getPlacerEl(), containerSel: '*', itemSel: '*', pfx: 'gjs-', onEndMove: function (model) { return _this.handleDragEnd(model, dt); }, document: this.el.ownerDocument }, (this.sortOpts || {})));
            sorter_1.setDropContent(content);
            sorter_1.startSort();
            this.sorter = sorter_1;
            dragStop = function (cancel) {
                cancel && (sorter_1.moved = false);
                sorter_1.endMove();
            };
            dragContent = function (content) { return sorter_1.setDropContent(content); };
        }
        this.dragStop = dragStop;
        this.dragContent = dragContent;
        em.trigger('canvas:dragenter', dt, content);
    };
    Droppable.prototype.handleDragEnd = function (model, dt) {
        var em = this.em;
        this.over = false;
        if (model) {
            em.set('dragResult', model);
            em.trigger('canvas:drop', dt, model);
        }
        em.runDefault({ preserveSelected: 1 });
    };
    /**
     * Always need to have this handler active for enabling the drop
     * @param {Event} ev
     */
    Droppable.prototype.handleDragOver = function (ev) {
        ev.preventDefault();
        this.em.trigger('canvas:dragover', ev);
    };
    /**
     * WARNING: This function might fail to run on drop, for example, when the
     * drop, accidentally, happens on some external element (DOM not inside the iframe)
     */
    Droppable.prototype.handleDrop = function (ev) {
        ev.preventDefault();
        var dragContent = this.dragContent;
        var dt = ev.dataTransfer;
        var content = this.getContentByData(dt).content;
        ev.target.style.border = '';
        content && dragContent && dragContent(content);
        this.endDrop(!content, ev);
    };
    Droppable.prototype.getContentByData = function (dt) {
        var em = this.em;
        var types = dt && dt.types;
        var files = (dt && dt.files) || [];
        var dragContent = em.get('dragContent');
        var content = dt && dt.getData('text');
        if (files.length) {
            content = [];
            for (var i = 0; i < files.length; i++) {
                var file = files[i];
                var type = file.type.split('/')[0];
                if (type == 'image') {
                    content.push({
                        type: type,
                        file: file,
                        attributes: { alt: file.name },
                    });
                }
            }
        }
        else if (dragContent) {
            content = dragContent;
        }
        else if ((0,index_all.indexOf)(types, 'text/html') >= 0) {
            content = dt && dt.getData('text/html').replace(/<\/?meta[^>]*>/g, '');
        }
        else if ((0,index_all.indexOf)(types, 'text/uri-list') >= 0) {
            content = {
                type: 'link',
                attributes: { href: content },
                content: content,
            };
        }
        else if ((0,index_all.indexOf)(types, 'text/json') >= 0) {
            var json = dt && dt.getData('text/json');
            json && (content = JSON.parse(json));
        }
        else if (types.length === 1 && types[0] === 'text/plain') {
            // Avoid dropping non-selectable and non-editable text nodes inside the editor
            content = "<div>".concat(content, "</div>");
        }
        var result = { content: content };
        em.trigger('canvas:dragdata', dt, result);
        return result;
    };
    return Droppable;
}());
/* harmony default export */ const utils_Droppable = (Droppable);

;// CONCATENATED MODULE: ./src/canvas/view/FrameView.ts
var FrameView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FrameView_assign = (undefined && undefined.__assign) || function () {
    FrameView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return FrameView_assign.apply(this, arguments);
};
var FrameView_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};







var FrameView = /** @class */ (function (_super) {
    FrameView_extends(FrameView, _super);
    function FrameView(model, view) {
        var _this = _super.call(this, { model: model }) || this;
        _this.dragging = false;
        _this.loaded = false;
        _this.lastMaxHeight = 0;
        _this.tools = {};
        (0,index_all.bindAll)(_this, 'updateClientY', 'stopAutoscroll', 'autoscroll', '_emitUpdate');
        var el = _this.el;
        //@ts-ignore
        _this.module._config = FrameView_assign(FrameView_assign({}, (_this.config || {})), { 
            //@ts-ignore
            frameView: _this });
        _this.frameWrapView = view;
        _this.showGlobalTools = (0,index_all.debounce)(_this.showGlobalTools.bind(_this), 50);
        var cvModel = _this.getCanvasModel();
        _this.listenTo(model, 'change:head', _this.updateHead);
        _this.listenTo(cvModel, 'change:styles', _this.renderStyles);
        model.view = _this;
        (0,mixins.setViewEl)(el, _this);
        return _this;
    }
    Object.defineProperty(FrameView.prototype, "tagName", {
        /** @ts-ignore */
        get: function () {
            return 'iframe';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FrameView.prototype, "attributes", {
        /** @ts-ignore */
        get: function () {
            return { allowfullscreen: 'allowfullscreen' };
        },
        enumerable: false,
        configurable: true
    });
    FrameView.prototype.getBoxRect = function () {
        var _a = this, el = _a.el, module = _a.module;
        var canvasView = module.getCanvasView();
        var coords = module.getCoords();
        var frameRect = el.getBoundingClientRect();
        var canvasRect = canvasView.getCanvasOffset();
        var vwDelta = canvasView.getViewportDelta();
        var zoomM = module.getZoomMultiplier();
        var x = (frameRect.x - canvasRect.left - vwDelta.x - coords.x) * zoomM;
        var y = (frameRect.y - canvasRect.top - vwDelta.y - coords.y) * zoomM;
        var width = frameRect.width * zoomM;
        var height = frameRect.height * zoomM;
        return {
            x: x,
            y: y,
            width: width,
            height: height,
        };
    };
    /**
     * Update `<head>` content of the frame
     */
    FrameView.prototype.updateHead = function () {
        var model = this.model;
        var headEl = this.getHead();
        var toRemove = [];
        var toAdd = [];
        var current = model.head;
        var prev = model.previous('head');
        var attrStr = function (attr) {
            if (attr === void 0) { attr = {}; }
            return Object.keys(attr)
                .sort()
                .map(function (i) { return "[".concat(i, "=\"").concat(attr[i], "\"]"); })
                .join('');
        };
        var find = function (items, stack, res) {
            items.forEach(function (item) {
                var tag = item.tag, attributes = item.attributes;
                var has = stack.some(function (s) { return s.tag === tag && attrStr(s.attributes) === attrStr(attributes); });
                !has && res.push(item);
            });
        };
        find(current, prev, toAdd);
        find(prev, current, toRemove);
        toRemove.forEach(function (stl) {
            var _a;
            var el = headEl.querySelector("".concat(stl.tag).concat(attrStr(stl.attributes)));
            (_a = el === null || el === void 0 ? void 0 : el.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(el);
        });
        (0,dom/* appendVNodes */.SJ)(headEl, toAdd);
    };
    FrameView.prototype.getEl = function () {
        return this.el;
    };
    FrameView.prototype.getCanvasModel = function () {
        return this.em.Canvas.getModel();
    };
    FrameView.prototype.getWindow = function () {
        return this.getEl().contentWindow;
    };
    FrameView.prototype.getDoc = function () {
        return this.getEl().contentDocument;
    };
    FrameView.prototype.getHead = function () {
        return this.getDoc().querySelector('head');
    };
    FrameView.prototype.getBody = function () {
        return this.getDoc().querySelector('body');
    };
    FrameView.prototype.getWrapper = function () {
        return this.getBody().querySelector('[data-gjs-type=wrapper]');
    };
    FrameView.prototype.getJsContainer = function () {
        if (!this.jsContainer) {
            this.jsContainer = (0,dom/* createEl */.ut)('div', { class: "".concat(this.ppfx, "js-cont") });
        }
        return this.jsContainer;
    };
    FrameView.prototype.getToolsEl = function () {
        var _a;
        return (_a = this.frameWrapView) === null || _a === void 0 ? void 0 : _a.elTools;
    };
    FrameView.prototype.getGlobalToolsEl = function () {
        return this.em.Canvas.getGlobalToolsEl();
    };
    FrameView.prototype.getHighlighter = function () {
        return this._getTool('[data-hl]');
    };
    FrameView.prototype.getBadgeEl = function () {
        return this._getTool('[data-badge]');
    };
    FrameView.prototype.getOffsetViewerEl = function () {
        return this._getTool('[data-offset]');
    };
    FrameView.prototype.getRect = function () {
        if (!this.rect) {
            this.rect = this.el.getBoundingClientRect();
        }
        return this.rect;
    };
    /**
     * Get rect data, not affected by the canvas zoom
     */
    FrameView.prototype.getOffsetRect = function () {
        var el = this.el;
        var _a = this.getBody(), scrollTop = _a.scrollTop, scrollLeft = _a.scrollLeft;
        var height = el.offsetHeight;
        var width = el.offsetWidth;
        return {
            top: el.offsetTop,
            left: el.offsetLeft,
            height: height,
            width: width,
            scrollTop: scrollTop,
            scrollLeft: scrollLeft,
            scrollBottom: scrollTop + height,
            scrollRight: scrollLeft + width,
        };
    };
    FrameView.prototype._getTool = function (name) {
        var tools = this.tools;
        var toolsEl = this.getToolsEl();
        if (!tools[name]) {
            tools[name] = toolsEl.querySelector(name);
        }
        return tools[name];
    };
    FrameView.prototype.remove = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this._toggleEffects(false);
        this.tools = {};
        (_a = this.wrapper) === null || _a === void 0 ? void 0 : _a.remove();
        abstract_ModuleView.prototype.remove.apply(this, args);
        return this;
    };
    FrameView.prototype.startAutoscroll = function () {
        var _this = this;
        this.lastMaxHeight = this.getWrapper().offsetHeight - this.el.offsetHeight;
        // By detaching those from the stack avoid browsers lags
        // Noticeable with "fast" drag of blocks
        setTimeout(function () {
            _this._toggleAutoscrollFx(true);
            requestAnimationFrame(_this.autoscroll);
        }, 0);
    };
    FrameView.prototype.autoscroll = function () {
        if (this.dragging) {
            var lastClientY = this.lastClientY;
            var canvas = this.em.Canvas;
            var win = this.getWindow();
            var actualTop = win.pageYOffset;
            var clientY = lastClientY || 0;
            var limitTop = canvas.getConfig().autoscrollLimit;
            var limitBottom = this.getRect().height - limitTop;
            var nextTop = actualTop;
            if (clientY < limitTop) {
                nextTop -= limitTop - clientY;
            }
            if (clientY > limitBottom) {
                nextTop += clientY - limitBottom;
            }
            if (!(0,index_all.isUndefined)(lastClientY) && // Fixes #3134
                nextTop !== actualTop &&
                nextTop > 0 &&
                nextTop < this.lastMaxHeight) {
                var toolsEl = this.getGlobalToolsEl();
                toolsEl.style.opacity = '0';
                this.showGlobalTools();
                win.scrollTo(0, nextTop);
                canvas.spots.refreshDbn();
            }
            requestAnimationFrame(this.autoscroll);
        }
    };
    FrameView.prototype.updateClientY = function (ev) {
        ev.preventDefault();
        this.lastClientY = (0,dom/* getPointerEvent */.VB)(ev).clientY * this.em.getZoomDecimal();
    };
    FrameView.prototype.showGlobalTools = function () {
        this.getGlobalToolsEl().style.opacity = '';
    };
    FrameView.prototype.stopAutoscroll = function () {
        this.dragging && this._toggleAutoscrollFx(false);
    };
    FrameView.prototype._toggleAutoscrollFx = function (enable) {
        this.dragging = enable;
        var win = this.getWindow();
        var method = enable ? 'on' : 'off';
        var mt = { on: dom.on, off: dom/* off */.S1 };
        mt[method](win, 'mousemove dragover', this.updateClientY);
        mt[method](win, 'mouseup', this.stopAutoscroll);
    };
    FrameView.prototype.render = function () {
        var _a = this, $el = _a.$el, ppfx = _a.ppfx, em = _a.em;
        $el.attr({ class: "".concat(ppfx, "frame") });
        this.renderScripts();
        em.trigger('frame:render', this); // deprecated
        return this;
    };
    FrameView.prototype.renderScripts = function () {
        var _this = this;
        var _a = this, el = _a.el, model = _a.model, em = _a.em;
        var evLoad = 'frame:load';
        var evOpts = { el: el, model: model, view: this };
        var canvas = this.getCanvasModel();
        var appendScript = function (scripts) {
            var _a;
            if (scripts.length > 0) {
                var src = scripts.shift();
                var scriptEl = (0,dom/* createEl */.ut)('script', FrameView_assign({ type: 'text/javascript' }, ((0,index_all.isString)(src) ? { src: src } : src)));
                (_a = el.contentDocument) === null || _a === void 0 ? void 0 : _a.head.appendChild(scriptEl);
                if (scriptEl.hasAttribute('nomodule') && 'noModule' in HTMLScriptElement.prototype) {
                    appendScript(scripts);
                }
                else {
                    scriptEl.onerror = scriptEl.onload = appendScript.bind(null, scripts);
                }
            }
            else {
                em === null || em === void 0 ? void 0 : em.trigger(types.frameLoadHead, evOpts);
                _this.renderBody();
                em === null || em === void 0 ? void 0 : em.trigger(types.frameLoadBody, evOpts);
                em === null || em === void 0 ? void 0 : em.trigger(evLoad, evOpts); // deprecated
            }
        };
        el.onload = function () {
            var frameContent = _this.config.frameContent;
            if (frameContent) {
                var doc = _this.getDoc();
                doc.open();
                doc.write(frameContent);
                doc.close();
            }
            evOpts.window = _this.getWindow();
            em === null || em === void 0 ? void 0 : em.trigger("".concat(evLoad, ":before"), evOpts); // deprecated
            em === null || em === void 0 ? void 0 : em.trigger(types.frameLoad, evOpts);
            appendScript(FrameView_spreadArray([], canvas.get('scripts'), true));
        };
    };
    FrameView.prototype.renderStyles = function (opts) {
        if (opts === void 0) { opts = {}; }
        var head = this.getHead();
        var canvas = this.getCanvasModel();
        var normalize = function (stls) {
            return stls.map(function (href) { return ({
                tag: 'link',
                attributes: FrameView_assign({ rel: 'stylesheet' }, ((0,index_all.isString)(href) ? { href: href } : href)),
            }); });
        };
        var prevStyles = normalize(opts.prev || canvas.previous('styles'));
        var styles = normalize(canvas.get('styles'));
        var toRemove = [];
        var toAdd = [];
        var find = function (items, stack, res) {
            items.forEach(function (item) {
                var href = item.attributes.href;
                var has = stack.some(function (s) { return s.attributes.href === href; });
                !has && res.push(item);
            });
        };
        find(styles, prevStyles, toAdd);
        find(prevStyles, styles, toRemove);
        toRemove.forEach(function (stl) {
            var _a;
            var el = head.querySelector("link[href=\"".concat(stl.attributes.href, "\"]"));
            (_a = el === null || el === void 0 ? void 0 : el.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(el);
        });
        (0,dom/* appendVNodes */.SJ)(head, toAdd);
    };
    FrameView.prototype.renderBody = function () {
        var _this = this;
        var _a, _b;
        var _c = this, config = _c.config, em = _c.em, model = _c.model, ppfx = _c.ppfx;
        var doc = this.getDoc();
        var body = this.getBody();
        var win = this.getWindow();
        var hasAutoHeight = model.hasAutoHeight();
        var conf = em.config;
        //@ts-ignore This could be used inside component-related scripts to check if the
        // script is executed inside the editor.
        win._isEditor = true;
        this.renderStyles({ prev: [] });
        var colorWarn = '#ffca6f';
        (0,dom/* append */.R3)(body, "<style>\n      ".concat(conf.baseCss || config.frameStyle || '', "\n\n      ").concat(hasAutoHeight ? 'body { overflow: hidden }' : '', "\n\n      [data-gjs-type=\"wrapper\"] {\n        ").concat(!hasAutoHeight ? 'min-height: 100vh;' : '', "\n        padding-top: 0.001em;\n      }\n\n      .").concat(ppfx, "dashed *[data-gjs-highlightable] {\n        outline: 1px dashed rgba(170,170,170,0.7);\n        outline-offset: -2px;\n      }\n\n      .").concat(ppfx, "selected {\n        outline: 2px solid #3b97e3 !important;\n        outline-offset: -2px;\n      }\n\n      .").concat(ppfx, "selected-parent {\n        outline: 2px solid ").concat(colorWarn, " !important\n      }\n\n      .").concat(ppfx, "no-select {\n        user-select: none;\n        -webkit-user-select:none;\n        -moz-user-select: none;\n      }\n\n      .").concat(ppfx, "freezed {\n        opacity: 0.5;\n        pointer-events: none;\n      }\n\n      .").concat(ppfx, "no-pointer {\n        pointer-events: none;\n      }\n\n      .").concat(ppfx, "plh-image {\n        background: #f5f5f5;\n        border: none;\n        height: 100px;\n        width: 100px;\n        display: block;\n        outline: 3px solid #ffca6f;\n        cursor: pointer;\n        outline-offset: -2px\n      }\n\n      .").concat(ppfx, "grabbing {\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n      }\n\n      .").concat(ppfx, "is__grabbing {\n        overflow-x: hidden;\n      }\n\n      .").concat(ppfx, "is__grabbing,\n      .").concat(ppfx, "is__grabbing * {\n        cursor: grabbing !important;\n      }\n\n      ").concat(conf.canvasCss || '', "\n      ").concat(conf.protectedCss || '', "\n    </style>"));
        var root = model.root;
        var view = em.Components.getType('wrapper').view;
        this.wrapper = new view({
            model: root,
            config: FrameView_assign(FrameView_assign({}, root.config), { em: em, frameView: this }),
        }).render();
        (0,dom/* append */.R3)(body, (_a = this.wrapper) === null || _a === void 0 ? void 0 : _a.el);
        (0,dom/* append */.R3)(body, new view_CssRulesView({
            collection: model.getStyles(),
            //@ts-ignore
            config: FrameView_assign(FrameView_assign({}, em.Css.getConfig()), { frameView: this }),
        }).render().el);
        (0,dom/* append */.R3)(body, this.getJsContainer());
        // em.trigger('loaded'); // I need to manage only the first one maybe
        //this.updateOffset(); // TOFIX (check if I need it)
        // Avoid some default behaviours
        //@ts-ignore
        (0,dom.on)(body, 'click', function (ev) { var _a; return ev && ((_a = ev.target) === null || _a === void 0 ? void 0 : _a.tagName) == 'A' && ev.preventDefault(); });
        (0,dom.on)(body, 'submit', function (ev) { return ev && ev.preventDefault(); });
        // When the iframe is focused the event dispatcher is not the same so
        // I need to delegate all events to the parent document
        [
            { event: 'keydown keyup keypress', class: 'KeyboardEvent' },
            { event: 'mousedown mousemove mouseup', class: 'MouseEvent' },
            { event: 'pointerdown pointermove pointerup', class: 'PointerEvent' },
            { event: 'wheel', class: 'WheelEvent', opts: { passive: !config.infiniteCanvas } },
        ].forEach(function (obj) {
            return obj.event.split(' ').forEach(function (event) {
                doc.addEventListener(event, function (ev) { return _this.el.dispatchEvent((0,dom/* createCustomEvent */.t3)(ev, obj.class)); }, obj.opts);
            });
        });
        this._toggleEffects(true);
        if ((0,mixins.hasDnd)(em)) {
            this.droppable = new utils_Droppable(em, (_b = this.wrapper) === null || _b === void 0 ? void 0 : _b.el);
        }
        this.loaded = true;
        model.trigger('loaded');
    };
    FrameView.prototype._toggleEffects = function (enable) {
        var method = enable ? dom.on : dom/* off */.S1;
        var win = this.getWindow();
        win && method(win, "".concat(dom/* motionsEv */.G1, " resize"), this._emitUpdate);
    };
    FrameView.prototype._emitUpdate = function () {
        this.model._emitUpdated();
    };
    return FrameView;
}(abstract_ModuleView));
/* harmony default export */ const view_FrameView = (FrameView);

// EXTERNAL MODULE: ./src/utils/Dragger.ts
var Dragger = __webpack_require__(250);
;// CONCATENATED MODULE: ./src/canvas/view/FrameWrapView.ts
var FrameWrapView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FrameWrapView_assign = (undefined && undefined.__assign) || function () {
    FrameWrapView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return FrameWrapView_assign.apply(this, arguments);
};





var FrameWrapView = /** @class */ (function (_super) {
    FrameWrapView_extends(FrameWrapView, _super);
    function FrameWrapView(model, canvasView) {
        var _this = _super.call(this, { model: model }) || this;
        (0,index_all.bindAll)(_this, 'onScroll', 'frameLoaded', 'updateOffset', 'remove', 'startDrag');
        var config = FrameWrapView_assign(FrameWrapView_assign({}, model.config), { frameWrapView: _this });
        _this.cv = canvasView;
        _this.frame = new view_FrameView(model, _this);
        _this.classAnim = "".concat(_this.ppfx, "frame-wrapper--anim");
        _this.updateOffset = (0,index_all.debounce)(_this.updateOffset.bind(_this), 0);
        _this.updateSize = (0,index_all.debounce)(_this.updateSize.bind(_this), 0);
        _this.listenTo(model, 'loaded', _this.frameLoaded);
        _this.listenTo(model, 'change:x change:y', _this.updatePos);
        _this.listenTo(model, 'change:width change:height', _this.updateSize);
        _this.listenTo(model, 'destroy remove', _this.remove);
        _this.updatePos();
        _this.setupDragger();
        return _this;
    }
    FrameWrapView.prototype.events = function () {
        return {
            'click [data-action-remove]': 'remove',
            'mousedown [data-action-move]': 'startDrag',
        };
    };
    FrameWrapView.prototype.setupDragger = function () {
        var _this = this;
        var _a = this, module = _a.module, model = _a.model;
        var dragX, dragY, zoom;
        var toggleEffects = function (on) {
            module.toggleFramesEvents(on);
        };
        this.dragger = new Dragger/* default */.Z({
            onStart: function () {
                var _a = model.attributes, x = _a.x, y = _a.y;
                zoom = _this.em.getZoomMultiplier();
                dragX = x;
                dragY = y;
                toggleEffects(false);
            },
            onEnd: function () { return toggleEffects(true); },
            setPosition: function (posOpts) {
                model.set({
                    x: dragX + posOpts.x * zoom,
                    y: dragY + posOpts.y * zoom,
                });
            },
        });
    };
    FrameWrapView.prototype.startDrag = function (ev) {
        var _a;
        ev && ((_a = this.dragger) === null || _a === void 0 ? void 0 : _a.start(ev));
    };
    FrameWrapView.prototype.__clear = function (opts) {
        var frame = this.frame;
        frame && frame.remove(opts);
        (0,dom/* removeEl */.L_)(this.elTools);
    };
    FrameWrapView.prototype.remove = function (opts) {
        var _this = this;
        this.__clear(opts);
        abstract_ModuleView.prototype.remove.apply(this, opts);
        //@ts-ignore
        ['frame', 'dragger', 'cv', 'elTools'].forEach(function (i) { return (_this[i] = 0); });
        return this;
    };
    FrameWrapView.prototype.updateOffset = function () {
        var _a;
        var _b = this, em = _b.em, $el = _b.$el, frame = _b.frame;
        if (!em || em.destroyed)
            return;
        em.runDefault({ preserveSelected: 1 });
        $el.removeClass(this.classAnim);
        (_a = frame === null || frame === void 0 ? void 0 : frame.model) === null || _a === void 0 ? void 0 : _a._emitUpdated();
    };
    FrameWrapView.prototype.updatePos = function (md) {
        var _a = this, model = _a.model, el = _a.el;
        var _b = model.attributes, x = _b.x, y = _b.y;
        var style = el.style;
        this.frame.rect = undefined;
        style.left = isNaN(x) ? x : "".concat(x, "px");
        style.top = isNaN(y) ? y : "".concat(y, "px");
        md && this.updateOffset();
    };
    FrameWrapView.prototype.updateSize = function () {
        this.updateDim();
    };
    /**
     * Update dimensions of the frame
     * @private
     */
    FrameWrapView.prototype.updateDim = function () {
        var _a = this, em = _a.em, el = _a.el, $el = _a.$el, model = _a.model, classAnim = _a.classAnim, frame = _a.frame;
        if (!frame)
            return;
        frame.rect = undefined;
        $el.addClass(classAnim);
        var _b = this.__handleSize(), noChanges = _b.noChanges, width = _b.width, height = _b.height;
        // Set width and height from DOM (should be done only once)
        if ((0,index_all.isNull)(width) || (0,index_all.isNull)(height)) {
            model.set(FrameWrapView_assign(FrameWrapView_assign({}, (!width ? { width: el.offsetWidth } : {})), (!height ? { height: el.offsetHeight } : {})), { silent: 1 });
        }
        // Prevent fixed highlighting box which appears when on
        // component hover during the animation
        em.stopDefault({ preserveSelected: 1 });
        noChanges ? this.updateOffset() : setTimeout(this.updateOffset, 350);
    };
    FrameWrapView.prototype.onScroll = function () {
        var _a = this, frame = _a.frame, em = _a.em;
        em.trigger('frame:scroll', {
            frame: frame,
            body: frame.getBody(),
            target: frame.getWindow(),
        });
    };
    FrameWrapView.prototype.frameLoaded = function () {
        var _a = this, frame = _a.frame, config = _a.config;
        frame.getWindow().onscroll = this.onScroll;
        this.updateDim();
    };
    FrameWrapView.prototype.__handleSize = function () {
        var _a, _b;
        var un = 'px';
        var _c = this, model = _c.model, el = _c.el;
        var style = el.style;
        var _d = model.attributes, width = _d.width, height = _d.height;
        var currW = style.width || '';
        var currH = style.height || '';
        var newW = width || '';
        var newH = height || '';
        var noChanges = currW == newW && currH == newH;
        var newWidth = (0,index_all.isNumber)(newW) ? "".concat(newW).concat(un) : newW;
        var newHeight = (0,index_all.isNumber)(newH) ? "".concat(newH).concat(un) : newH;
        style.width = newWidth;
        if (model.hasAutoHeight()) {
            var iframe = this.frame.el;
            if (iframe.contentDocument
            // this doesn't work always
            // && !this.sizeObserver
            ) {
                var contentDocument_1 = iframe.contentDocument;
                var observer = new ResizeObserver(function () {
                    style.height = "".concat(contentDocument_1.body.scrollHeight, "px");
                });
                observer.observe(contentDocument_1.body);
                (_a = this.sizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
                this.sizeObserver = observer;
            }
        }
        else {
            style.height = newHeight;
            (_b = this.sizeObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
            delete this.sizeObserver;
        }
        return { noChanges: noChanges, width: width, height: height, newW: newW, newH: newH };
    };
    FrameWrapView.prototype.render = function () {
        var _a = this, frame = _a.frame, $el = _a.$el, ppfx = _a.ppfx, cv = _a.cv, model = _a.model, el = _a.el;
        var onRender = model.attributes.onRender;
        this.__clear();
        this.__handleSize();
        frame.render();
        $el
            .empty()
            .attr({ class: "".concat(ppfx, "frame-wrapper") })
            .append("\n      <div class=\"".concat(ppfx, "frame-wrapper__top gjs-two-color\" data-frame-top>\n        <div class=\"").concat(ppfx, "frame-wrapper__name\" data-action-move>\n          ").concat(model.get('name') || '', "\n        </div>\n        <div class=\"").concat(ppfx, "frame-wrapper__top-r\">\n          <div class=\"").concat(ppfx, "frame-wrapper__icon\" data-action-remove style=\"display: none\">\n            <svg viewBox=\"0 0 24 24\"><path d=\"M19 4h-3.5l-1-1h-5l-1 1H5v2h14M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12z\"></path></svg>\n          </div>\n        </div>\n      </div>\n      <div class=\"").concat(ppfx, "frame-wrapper__right\" data-frame-right></div>\n      <div class=\"").concat(ppfx, "frame-wrapper__left\" data-frame-left></div>\n      <div class=\"").concat(ppfx, "frame-wrapper__bottom\" data-frame-bottom></div>\n      "))
            .append(frame.el);
        var elTools = (0,dom/* createEl */.ut)('div', {
            class: "".concat(ppfx, "tools"),
            style: 'pointer-events:none; display: none',
        }, "\n      <div class=\"".concat(ppfx, "highlighter\" data-hl></div>\n      <div class=\"").concat(ppfx, "badge\" data-badge></div>\n      <div class=\"").concat(ppfx, "placeholder\">\n        <div class=\"").concat(ppfx, "placeholder-int\"></div>\n      </div>\n      <div class=\"").concat(ppfx, "ghost\"></div>\n      <div class=\"").concat(ppfx, "toolbar\" style=\"pointer-events:all\"></div>\n      <div class=\"").concat(ppfx, "resizer\"></div>\n      <div class=\"").concat(ppfx, "offset-v\" data-offset>\n        <div class=\"gjs-marginName\" data-offset-m>\n          <div class=\"gjs-margin-v-el gjs-margin-v-top\" data-offset-m-t></div>\n          <div class=\"gjs-margin-v-el gjs-margin-v-bottom\" data-offset-m-b></div>\n          <div class=\"gjs-margin-v-el gjs-margin-v-left\" data-offset-m-l></div>\n          <div class=\"gjs-margin-v-el gjs-margin-v-right\" data-offset-m-r></div>\n        </div>\n        <div class=\"gjs-paddingName\" data-offset-m>\n          <div class=\"gjs-padding-v-el gjs-padding-v-top\" data-offset-p-t></div>\n          <div class=\"gjs-padding-v-el gjs-padding-v-bottom\" data-offset-p-b></div>\n          <div class=\"gjs-padding-v-el gjs-padding-v-left\" data-offset-p-l></div>\n          <div class=\"gjs-padding-v-el gjs-padding-v-right\" data-offset-p-r></div>\n        </div>\n      </div>\n      <div class=\"").concat(ppfx, "offset-fixed-v\"></div>\n    "));
        this.elTools = elTools;
        var twrp = cv === null || cv === void 0 ? void 0 : cv.toolsWrapper;
        twrp && twrp.appendChild(elTools); // TODO remove on frame remove
        onRender &&
            onRender({
                el: el,
                elTop: el.querySelector('[data-frame-top]'),
                elRight: el.querySelector('[data-frame-right]'),
                elBottom: el.querySelector('[data-frame-bottom]'),
                elLeft: el.querySelector('[data-frame-left]'),
                frame: model,
                frameWrapperView: this,
                remove: this.remove,
                startDrag: this.startDrag,
            });
        return this;
    };
    return FrameWrapView;
}(abstract_ModuleView));
/* harmony default export */ const view_FrameWrapView = (FrameWrapView);

;// CONCATENATED MODULE: ./src/canvas/view/FramesView.ts
var FramesView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var FramesView = /** @class */ (function (_super) {
    FramesView_extends(FramesView, _super);
    function FramesView(opts, config) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, opts, true) || this;
        _this.listenTo(_this.collection, 'reset', _this.render);
        _this.canvasView = config.canvasView;
        _this._module = config.module;
        return _this;
    }
    FramesView.prototype.onRemoveBefore = function (items, opts) {
        if (opts === void 0) { opts = {}; }
        items.forEach(function (item) { return item.remove(opts); });
    };
    FramesView.prototype.onRender = function () {
        var _a = this, $el = _a.$el, ppfx = _a.ppfx;
        $el.attr({ class: "".concat(ppfx, "frames") });
    };
    FramesView.prototype.clearItems = function () {
        var items = this.viewCollection || [];
        items.forEach(function (item) { return item.remove(); });
        this.viewCollection = [];
    };
    FramesView.prototype.renderView = function (item, type) {
        return new view_FrameWrapView(item, this.canvasView);
    };
    return FramesView;
}(abstract_ModuleDomainViews));
/* harmony default export */ const view_FramesView = (FramesView);

;// CONCATENATED MODULE: ./src/canvas/view/CanvasView.ts
var CanvasView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CanvasView_assign = (undefined && undefined.__assign) || function () {
    CanvasView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return CanvasView_assign.apply(this, arguments);
};






var CanvasView = /** @class */ (function (_super) {
    CanvasView_extends(CanvasView, _super);
    function CanvasView(model) {
        var _this = _super.call(this, { model: model }) || this;
        _this.ready = false;
        (0,index_all.bindAll)(_this, 'clearOff', 'onKeyPress', 'onWheel', 'onPointer');
        var _a = _this, em = _a.em, pfx = _a.pfx, ppfx = _a.ppfx;
        var events = _this.module.events;
        _this.className = "".concat(pfx, "canvas ").concat(ppfx, "no-touch-actions").concat(!em.config.customUI ? " ".concat(pfx, "canvas-bg") : '');
        _this.clsUnscale = "".concat(pfx, "unscale");
        _this._initFrames();
        _this.listenTo(em, 'change:canvasOffset', _this.clearOff);
        _this.listenTo(em, 'component:selected', _this.checkSelected);
        _this.listenTo(em, "".concat(events.coords, " ").concat(events.zoom), _this.updateFrames);
        _this.listenTo(model, 'change:frames', _this._onFramesUpdate);
        _this.toggleListeners(true);
        return _this;
    }
    CanvasView.prototype.template = function () {
        var pfx = this.pfx;
        return "\n      <div class=\"".concat(pfx, "canvas__frames\" data-frames>\n        <div class=\"").concat(pfx, "canvas__spots\" data-spots></div>\n      </div>\n      <div id=\"").concat(pfx, "tools\" class=\"").concat(pfx, "canvas__tools\" data-tools></div>\n      <style data-canvas-style></style>\n    ");
    };
    CanvasView.prototype._onFramesUpdate = function () {
        this._initFrames();
        this._renderFrames();
    };
    CanvasView.prototype._initFrames = function () {
        var _a = this, frames = _a.frames, model = _a.model, config = _a.config, em = _a.em;
        var collection = model.frames;
        em.set('readyCanvas', 0);
        collection.once('loaded:all', function () { return em.set('readyCanvas', 1); });
        frames === null || frames === void 0 ? void 0 : frames.remove();
        this.frames = new view_FramesView({ collection: collection }, CanvasView_assign(CanvasView_assign({}, config), { canvasView: this }));
    };
    CanvasView.prototype.checkSelected = function (component, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var scroll = opts.scroll;
        var currFrame = this.em.getCurrentFrame();
        scroll &&
            ((_a = component.views) === null || _a === void 0 ? void 0 : _a.forEach(function (view) {
                view.frameView === currFrame && view.scrollIntoView(scroll);
            }));
    };
    CanvasView.prototype.remove = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (_a = this.frames) === null || _a === void 0 ? void 0 : _a.remove();
        //@ts-ignore
        this.frames = undefined;
        abstract_ModuleView.prototype.remove.apply(this, args);
        this.toggleListeners(false);
        return this;
    };
    CanvasView.prototype.preventDefault = function (ev) {
        var _a;
        if (ev) {
            ev.preventDefault();
            (_a = ev._parentEvent) === null || _a === void 0 ? void 0 : _a.preventDefault();
        }
    };
    CanvasView.prototype.toggleListeners = function (enable) {
        var _a = this, el = _a.el, config = _a.config;
        var fn = enable ? dom.on : dom/* off */.S1;
        fn(document, 'keypress', this.onKeyPress);
        fn(window, 'scroll resize', this.clearOff);
        fn(el, 'wheel', this.onWheel, { passive: !config.infiniteCanvas });
        fn(el, 'pointermove', this.onPointer);
    };
    CanvasView.prototype.screenToWorld = function (x, y) {
        var module = this.module;
        var coords = module.getCoords();
        var zoom = module.getZoomMultiplier();
        var vwDelta = this.getViewportDelta();
        return {
            x: (x - coords.x - vwDelta.x) * zoom,
            y: (y - coords.y - vwDelta.y) * zoom,
        };
    };
    CanvasView.prototype.onPointer = function (ev) {
        if (!this.config.infiniteCanvas)
            return;
        var canvasRect = this.getCanvasOffset();
        var docScroll = (0,dom/* getDocumentScroll */.GX)();
        var screenCoords = {
            x: ev.clientX - canvasRect.left + docScroll.x,
            y: ev.clientY - canvasRect.top + docScroll.y,
        };
        if (ev._parentEvent) {
            // with _parentEvent means was triggered from the iframe
            var frameRect = ev.target.getBoundingClientRect();
            var zoom = this.module.getZoomDecimal();
            screenCoords.x = frameRect.left - canvasRect.left + docScroll.x + ev.clientX * zoom;
            screenCoords.y = frameRect.top - canvasRect.top + docScroll.y + ev.clientY * zoom;
        }
        this.model.set({
            pointerScreen: screenCoords,
            pointer: this.screenToWorld(screenCoords.x, screenCoords.y),
        });
    };
    CanvasView.prototype.onKeyPress = function (ev) {
        var em = this.em;
        var key = (0,dom/* getKeyChar */.sN)(ev);
        if (key === ' ' && em.getZoomDecimal() !== 1 && !em.Canvas.isInputFocused()) {
            this.preventDefault(ev);
            em.Editor.runCommand('core:canvas-move');
        }
    };
    CanvasView.prototype.onWheel = function (ev) {
        var _a = this, module = _a.module, config = _a.config;
        if (config.infiniteCanvas) {
            this.preventDefault(ev);
            var deltaX = ev.deltaX, deltaY = ev.deltaY;
            var zoom = module.getZoomDecimal();
            var isZooming = (0,dom/* hasModifierKey */.Vb)(ev);
            var coords = module.getCoords();
            if (isZooming) {
                var newZoom = zoom - deltaY * zoom * 0.01;
                module.setZoom(newZoom * 100);
                // Update coordinates based on pointer
                var pointer = this.model.getPointerCoords(common/* CoordinatesTypes */.vA.Screen);
                var canvasRect = this.getCanvasOffset();
                var pointerX = pointer.x - canvasRect.width / 2;
                var pointerY = pointer.y - canvasRect.height / 2;
                var zoomDelta = newZoom / zoom;
                var x = pointerX - (pointerX - coords.x) * zoomDelta;
                var y = pointerY - (pointerY - coords.y) * zoomDelta;
                module.setCoords(x, y);
            }
            else {
                this.onPointer(ev);
                module.setCoords(coords.x - deltaX, coords.y - deltaY);
            }
        }
    };
    CanvasView.prototype.updateFrames = function (ev) {
        var em = this.em;
        var toolsWrpEl = this.toolsWrapper;
        var defOpts = { preserveSelected: 1 };
        this.updateFramesArea();
        this.clearOff();
        toolsWrpEl.style.display = 'none';
        em.trigger('canvas:update', ev);
        this.timerZoom && clearTimeout(this.timerZoom);
        this.timerZoom = setTimeout(function () {
            em.stopDefault(defOpts);
            em.runDefault(defOpts);
            toolsWrpEl.style.display = '';
        }, 300);
    };
    CanvasView.prototype.updateFramesArea = function () {
        var _a = this, framesArea = _a.framesArea, model = _a.model, module = _a.module, cvStyle = _a.cvStyle, clsUnscale = _a.clsUnscale;
        var mpl = module.getZoomMultiplier();
        if (framesArea) {
            var _b = model.attributes, x = _b.x, y = _b.y;
            var zoomDc = module.getZoomDecimal();
            framesArea.style.transform = "scale(".concat(zoomDc, ") translate(").concat(x * mpl, "px, ").concat(y * mpl, "px)");
        }
        if (cvStyle) {
            cvStyle.innerHTML = "\n        .".concat(clsUnscale, " { scale: ").concat(mpl, " }\n      ");
        }
    };
    CanvasView.prototype.fitViewport = function (opts) {
        var _a, _b;
        if (opts === void 0) { opts = {}; }
        var _c = this, em = _c.em, module = _c.module, model = _c.model;
        var canvasRect = this.getCanvasOffset();
        var el = opts.el;
        var elFrame = el && ((_a = (0,mixins.getComponentView)(el)) === null || _a === void 0 ? void 0 : _a.frameView);
        var frame = elFrame ? elFrame.model : opts.frame || em.getCurrentFrameModel() || model.frames.at(0);
        var _d = frame.attributes, x = _d.x, y = _d.y;
        var boxRect = {
            x: x !== null && x !== void 0 ? x : 0,
            y: y !== null && y !== void 0 ? y : 0,
            width: frame.width,
            height: frame.height,
        };
        if (el) {
            var elRect = this.getElBoxRect(el);
            boxRect.x = boxRect.x + elRect.x;
            boxRect.y = boxRect.y + elRect.y;
            boxRect.width = elRect.width;
            boxRect.height = elRect.height;
        }
        var noHeight = opts.ignoreHeight;
        var gap = (_b = opts.gap) !== null && _b !== void 0 ? _b : 0;
        var gapIsNum = (0,index_all.isNumber)(gap);
        var gapX = gapIsNum ? gap : gap.x;
        var gapY = gapIsNum ? gap : gap.y;
        var boxWidth = boxRect.width + gapX * 2;
        var boxHeight = boxRect.height + gapY * 2;
        var canvasWidth = canvasRect.width;
        var canvasHeight = canvasRect.height;
        var widthRatio = canvasWidth / boxWidth;
        var heightRatio = canvasHeight / boxHeight;
        var zoomRatio = noHeight ? widthRatio : Math.min(widthRatio, heightRatio);
        var zoom = zoomRatio * 100;
        module.setZoom(zoom);
        // check for the frame witdh is necessary as we're centering the frame via CSS
        var coordX = -boxRect.x + (frame.width >= canvasWidth ? canvasWidth / 2 - boxWidth / 2 : -gapX);
        var coordY = -boxRect.y + canvasHeight / 2 - boxHeight / 2;
        var coords = {
            x: (coordX + gapX) * zoomRatio,
            y: (coordY + gapY) * zoomRatio,
        };
        if (noHeight) {
            var zoomMltp = module.getZoomMultiplier();
            var canvasWorldHeight = canvasHeight * zoomMltp;
            var canvasHeightDiff = canvasWorldHeight - canvasHeight;
            var yDelta = canvasHeightDiff / 2;
            coords.y = (-boxRect.y + gapY) * zoomRatio - yDelta / zoomMltp;
        }
        module.setCoords(coords.x, coords.y);
    };
    /**
     * Checks if the element is visible in the canvas's viewport
     * @param  {HTMLElement}  el
     * @return {Boolean}
     */
    CanvasView.prototype.isElInViewport = function (el) {
        var elem = (0,mixins.getElement)(el);
        var rect = (0,dom/* getElRect */.Ut)(elem);
        var frameRect = this.getFrameOffset(elem);
        var rTop = rect.top;
        var rLeft = rect.left;
        return rTop >= 0 && rLeft >= 0 && rTop <= frameRect.height && rLeft <= frameRect.width;
    };
    /**
     * Get the offset of the element
     * @param  {HTMLElement} el
     * @return { {top: number, left: number, width: number, height: number} }
     */
    CanvasView.prototype.offset = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var noScroll = opts.noScroll;
        var rect = (0,dom/* getElRect */.Ut)(el);
        var scroll = noScroll ? { x: 0, y: 0 } : (0,dom/* getDocumentScroll */.GX)(el);
        return {
            top: rect.top + scroll.y,
            left: rect.left + scroll.x,
            width: rect.width,
            height: rect.height,
        };
    };
    CanvasView.prototype.getRectToScreen = function (boxRect) {
        var _a, _b, _c, _d;
        var zoom = this.module.getZoomDecimal();
        var coords = this.module.getCoords();
        var vwDelta = this.getViewportDelta();
        var x = ((_a = boxRect.x) !== null && _a !== void 0 ? _a : 0) * zoom + coords.x + vwDelta.x || 0;
        var y = ((_b = boxRect.y) !== null && _b !== void 0 ? _b : 0) * zoom + coords.y + vwDelta.y || 0;
        return {
            x: x,
            y: y,
            width: ((_c = boxRect.width) !== null && _c !== void 0 ? _c : 0) * zoom,
            height: ((_d = boxRect.height) !== null && _d !== void 0 ? _d : 0) * zoom,
        };
    };
    CanvasView.prototype.getElBoxRect = function (el, opts) {
        var _a, _b, _c;
        if (opts === void 0) { opts = {}; }
        var module = this.module;
        var _d = (0,dom/* getElRect */.Ut)(el), width = _d.width, height = _d.height, left = _d.left, top = _d.top;
        var frameView = (_a = (0,mixins.getComponentView)(el)) === null || _a === void 0 ? void 0 : _a.frameView;
        var frameRect = frameView === null || frameView === void 0 ? void 0 : frameView.getBoxRect();
        var zoomMlt = module.getZoomMultiplier();
        var frameX = (_b = frameRect === null || frameRect === void 0 ? void 0 : frameRect.x) !== null && _b !== void 0 ? _b : 0;
        var frameY = (_c = frameRect === null || frameRect === void 0 ? void 0 : frameRect.y) !== null && _c !== void 0 ? _c : 0;
        var canvasEl = this.el;
        var docScroll = (0,dom/* getDocumentScroll */.GX)();
        var xWithFrame = left + frameX + (canvasEl.scrollLeft + docScroll.x) * zoomMlt;
        var yWithFrame = top + frameY + (canvasEl.scrollTop + docScroll.y) * zoomMlt;
        var boxRect = {
            x: xWithFrame,
            y: yWithFrame,
            width: width,
            height: height,
        };
        if (opts.local) {
            boxRect.x = left;
            boxRect.y = top;
        }
        return opts.toScreen ? this.getRectToScreen(boxRect) : boxRect;
    };
    CanvasView.prototype.getViewportRect = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this.getCanvasOffset(), top = _a.top, left = _a.left, width = _a.width, height = _a.height;
        var module = this.module;
        if (opts.toWorld) {
            var zoom = module.getZoomMultiplier();
            var coords = module.getCoords();
            var vwDelta = this.getViewportDelta();
            var x = -coords.x - vwDelta.x || 0;
            var y = -coords.y - vwDelta.y || 0;
            return {
                x: x * zoom,
                y: y * zoom,
                width: width * zoom,
                height: height * zoom,
            };
        }
        else {
            return {
                x: left,
                y: top,
                width: width,
                height: height,
            };
        }
    };
    CanvasView.prototype.getViewportDelta = function (opts) {
        if (opts === void 0) { opts = {}; }
        var zoom = this.module.getZoomMultiplier();
        var _a = this.getCanvasOffset(), width = _a.width, height = _a.height;
        var worldWidth = width * zoom;
        var worldHeight = height * zoom;
        var widthDelta = worldWidth - width;
        var heightDelta = worldHeight - height;
        return {
            x: widthDelta / 2 / zoom,
            y: heightDelta / 2 / zoom,
        };
    };
    /**
     * Cleare cached offsets
     * @private
     */
    CanvasView.prototype.clearOff = function () {
        this.frmOff = undefined;
        this.cvsOff = undefined;
    };
    /**
     * Return frame offset
     * @return { {top: number, left: number, width: number, height: number} }
     * @public
     */
    CanvasView.prototype.getFrameOffset = function (el) {
        var _a;
        if (!this.frmOff || el) {
            var frame = (_a = this.frame) === null || _a === void 0 ? void 0 : _a.el;
            var winEl = el === null || el === void 0 ? void 0 : el.ownerDocument.defaultView;
            var frEl = winEl ? winEl.frameElement : frame;
            this.frmOff = this.offset(frEl || frame);
        }
        return this.frmOff;
    };
    /**
     * Return canvas offset
     * @return { {top: number, left: number, width: number, height: number} }
     * @public
     */
    CanvasView.prototype.getCanvasOffset = function () {
        if (!this.cvsOff)
            this.cvsOff = this.offset(this.el);
        return this.cvsOff;
    };
    /**
     * Returns element's rect info
     * @param {HTMLElement} el
     * @param {object} opts
     * @return { {top: number, left: number, width: number, height: number, zoom: number, rect: any} }
     * @public
     */
    CanvasView.prototype.getElementPos = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var zoom = this.module.getZoomDecimal();
        var frameOffset = this.getFrameOffset(el);
        var canvasEl = this.el;
        var canvasOffset = this.getCanvasOffset();
        var elRect = this.offset(el, opts);
        var frameTop = opts.avoidFrameOffset ? 0 : frameOffset.top;
        var frameLeft = opts.avoidFrameOffset ? 0 : frameOffset.left;
        var elTop = opts.avoidFrameZoom ? elRect.top : elRect.top * zoom;
        var elLeft = opts.avoidFrameZoom ? elRect.left : elRect.left * zoom;
        var top = opts.avoidFrameOffset ? elTop : elTop + frameTop - canvasOffset.top + canvasEl.scrollTop;
        var left = opts.avoidFrameOffset ? elLeft : elLeft + frameLeft - canvasOffset.left + canvasEl.scrollLeft;
        var height = opts.avoidFrameZoom ? elRect.height : elRect.height * zoom;
        var width = opts.avoidFrameZoom ? elRect.width : elRect.width * zoom;
        return { top: top, left: left, height: height, width: width, zoom: zoom, rect: elRect };
    };
    /**
     * Returns element's offsets like margins and paddings
     * @param {HTMLElement} el
     * @return { MarginPaddingOffsets }
     * @public
     */
    CanvasView.prototype.getElementOffsets = function (el) {
        if (!el || (0,dom/* isTextNode */.BM)(el))
            return {};
        var result = {};
        var styles = window.getComputedStyle(el);
        var zoom = this.module.getZoomDecimal();
        var marginPaddingOffsets = [
            'marginTop',
            'marginRight',
            'marginBottom',
            'marginLeft',
            'paddingTop',
            'paddingRight',
            'paddingBottom',
            'paddingLeft',
        ];
        marginPaddingOffsets.forEach(function (offset) {
            result[offset] = parseFloat(styles[offset]) * zoom;
        });
        return result;
    };
    /**
     * Returns position data of the canvas element
     * @return { {top: number, left: number, width: number, height: number} } obj Position object
     * @public
     */
    CanvasView.prototype.getPosition = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var doc = (_a = this.frame) === null || _a === void 0 ? void 0 : _a.el.contentDocument;
        if (!doc) {
            return {
                top: 0,
                left: 0,
                width: 0,
                height: 0,
            };
        }
        var bEl = doc.body;
        var zoom = this.module.getZoomDecimal();
        var fo = this.getFrameOffset();
        var co = this.getCanvasOffset();
        var noScroll = opts.noScroll;
        return {
            top: fo.top + (noScroll ? 0 : bEl.scrollTop) * zoom - co.top,
            left: fo.left + (noScroll ? 0 : bEl.scrollLeft) * zoom - co.left,
            width: co.width,
            height: co.height,
        };
    };
    /**
     * Update javascript of a specific component passed by its View
     * @param {ModuleView} view Component's View
     * @private
     */
    //TODO change type after the ComponentView was updated to ts
    CanvasView.prototype.updateScript = function (view) {
        var model = view.model;
        var id = model.getId();
        if (!view.scriptContainer) {
            view.scriptContainer = (0,dom/* createEl */.ut)('div', { 'data-id': id });
            var jsEl = this.getJsContainer();
            jsEl === null || jsEl === void 0 ? void 0 : jsEl.appendChild(view.scriptContainer);
        }
        view.el.id = id;
        view.scriptContainer.innerHTML = '';
        // In editor, I make use of setTimeout as during the append process of elements
        // those will not be available immediately, therefore 'item' variable
        var script = document.createElement('script');
        var scriptFn = model.getScriptString();
        var scriptFnStr = model.get('script-props') ? scriptFn : "function(){\n".concat(scriptFn, "\n;}");
        var scriptProps = JSON.stringify(model.__getScriptProps());
        script.innerHTML = "\n      setTimeout(function() {\n        var item = document.getElementById('".concat(id, "');\n        if (!item) return;\n        (").concat(scriptFnStr, ".bind(item))(").concat(scriptProps, ")\n      }, 1);");
        // #873
        // Adding setTimeout will make js components work on init of the editor
        setTimeout(function () {
            var scr = view.scriptContainer;
            scr === null || scr === void 0 ? void 0 : scr.appendChild(script);
        }, 0);
    };
    /**
     * Get javascript container
     * @private
     */
    CanvasView.prototype.getJsContainer = function (view) {
        var frameView = this.getFrameView(view);
        return frameView === null || frameView === void 0 ? void 0 : frameView.getJsContainer();
    };
    CanvasView.prototype.getFrameView = function (view) {
        return (view === null || view === void 0 ? void 0 : view.frameView) || this.em.getCurrentFrame();
    };
    CanvasView.prototype._renderFrames = function () {
        if (!this.ready)
            return;
        var _a = this, model = _a.model, frames = _a.frames, em = _a.em, framesArea = _a.framesArea;
        var frms = model.frames;
        frms.listenToLoad();
        frames.render();
        var mainFrame = frms.at(0);
        var currFrame = mainFrame === null || mainFrame === void 0 ? void 0 : mainFrame.view;
        em.setCurrentFrame(currFrame);
        framesArea === null || framesArea === void 0 ? void 0 : framesArea.appendChild(frames.el);
        this.frame = currFrame;
        this.updateFramesArea();
    };
    CanvasView.prototype.renderFrames = function () {
        this._renderFrames();
    };
    CanvasView.prototype.render = function () {
        var _a = this, el = _a.el, $el = _a.$el, ppfx = _a.ppfx, config = _a.config, em = _a.em;
        $el.html(this.template());
        var $frames = $el.find('[data-frames]');
        this.framesArea = $frames.get(0);
        var toolsWrp = $el.find('[data-tools]');
        this.toolsWrapper = toolsWrp.get(0);
        toolsWrp.append("\n      <div class=\"".concat(ppfx, "tools ").concat(ppfx, "tools-gl\" style=\"pointer-events:none\">\n        <div class=\"").concat(ppfx, "placeholder\">\n          <div class=\"").concat(ppfx, "placeholder-int\"></div>\n        </div>\n      </div>\n      <div id=\"").concat(ppfx, "tools\" style=\"pointer-events:none\">\n        ").concat(config.extHl ? "<div class=\"".concat(ppfx, "highlighter-sel\"></div>") : '', "\n        <div class=\"").concat(ppfx, "badge\"></div>\n        <div class=\"").concat(ppfx, "ghost\"></div>\n        <div class=\"").concat(ppfx, "toolbar\" style=\"pointer-events:all\"></div>\n        <div class=\"").concat(ppfx, "resizer\"></div>\n        <div class=\"").concat(ppfx, "offset-v\"></div>\n        <div class=\"").concat(ppfx, "offset-fixed-v\"></div>\n      </div>\n    "));
        this.toolsEl = el.querySelector("#".concat(ppfx, "tools"));
        this.hlEl = el.querySelector(".".concat(ppfx, "highlighter"));
        this.badgeEl = el.querySelector(".".concat(ppfx, "badge"));
        this.placerEl = el.querySelector(".".concat(ppfx, "placeholder"));
        this.ghostEl = el.querySelector(".".concat(ppfx, "ghost"));
        this.toolbarEl = el.querySelector(".".concat(ppfx, "toolbar"));
        this.resizerEl = el.querySelector(".".concat(ppfx, "resizer"));
        this.offsetEl = el.querySelector(".".concat(ppfx, "offset-v"));
        this.fixedOffsetEl = el.querySelector(".".concat(ppfx, "offset-fixed-v"));
        this.toolsGlobEl = el.querySelector(".".concat(ppfx, "tools-gl"));
        this.spotsEl = el.querySelector('[data-spots]');
        this.cvStyle = el.querySelector('[data-canvas-style]');
        this.el.className = (0,mixins.getUiClass)(em, this.className);
        this.ready = true;
        this._renderFrames();
        return this;
    };
    return CanvasView;
}(abstract_ModuleView));
/* harmony default export */ const view_CanvasView = (CanvasView);

;// CONCATENATED MODULE: ./src/canvas/index.ts
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/canvas/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  canvas: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('canvas:drop', () => { ... });
 *
 * // Use the API
 * const canvas = editor.Canvas;
 * canvas.setCoords(...);
 * ```
 *
 * {REPLACE_EVENTS}
 *
 * [Component]: component.html
 * [Frame]: frame.html
 * [CanvasSpot]: canvas_spot.html
 *
 * @module Canvas
 */
var canvas_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var canvas_assign = (undefined && undefined.__assign) || function () {
    canvas_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return canvas_assign.apply(this, arguments);
};
var canvas_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};










var CanvasModule = /** @class */ (function (_super) {
    canvas_extends(CanvasModule, _super);
    /**
     * Initialize module. Automatically called with a new instance of the editor
     * @param {Object} config Configurations
     * @private
     */
    function CanvasModule(em) {
        var _this = _super.call(this, em, 'Canvas', canvas_config_config) || this;
        _this.events = CanvasEvents;
        _this.framesById = {};
        _this.canvas = new model_Canvas(_this);
        _this.spots = new model_CanvasSpots(_this);
        _this.model = _this.canvas;
        _this.startAutoscroll = _this.startAutoscroll.bind(_this);
        _this.stopAutoscroll = _this.stopAutoscroll.bind(_this);
        return _this;
    }
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Used inside RTE
     * @private
     */
    CanvasModule.prototype.getCanvasView = function () {
        return this.canvasView;
    };
    CanvasModule.prototype.postLoad = function () {
        this.model.init();
    };
    CanvasModule.prototype.getModel = function () {
        return this.canvas;
    };
    /**
     * Get the canvas element
     * @returns {HTMLElement}
     */
    CanvasModule.prototype.getElement = function () {
        return this.getCanvasView().el;
    };
    CanvasModule.prototype.getFrame = function (index) {
        return this.getFrames()[index || 0];
    };
    /**
     * Get the main frame element of the canvas
     * @returns {HTMLIFrameElement}
     */
    CanvasModule.prototype.getFrameEl = function () {
        var frame = (this.canvasView || {}).frame;
        return frame === null || frame === void 0 ? void 0 : frame.el;
    };
    CanvasModule.prototype.getFramesEl = function () {
        var _a;
        return (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.framesArea;
    };
    /**
     * Get the main frame window instance
     * @returns {Window}
     */
    CanvasModule.prototype.getWindow = function () {
        var frame = (this.canvasView || {}).frame;
        return frame === null || frame === void 0 ? void 0 : frame.getWindow();
    };
    /**
     * Get the main frame document element
     * @returns {HTMLDocument}
     */
    CanvasModule.prototype.getDocument = function () {
        var frame = this.getFrameEl();
        return frame === null || frame === void 0 ? void 0 : frame.contentDocument;
    };
    /**
     * Get the main frame body element
     * @return {HTMLBodyElement}
     */
    CanvasModule.prototype.getBody = function () {
        var doc = this.getDocument();
        return doc === null || doc === void 0 ? void 0 : doc.body;
    };
    CanvasModule.prototype._getLocalEl = function (globalEl, compView, method) {
        var result = globalEl;
        var frameView = compView === null || compView === void 0 ? void 0 : compView.frameView;
        result = frameView ? frameView[method]() : result;
        return result;
    };
    /**
     * Returns element containing all global canvas tools
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getGlobalToolsEl = function () {
        var _a;
        return (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.toolsGlobEl;
    };
    /**
     * Returns element containing all canvas tools
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getToolsEl = function (compView) {
        return this._getLocalEl(this.getCanvasView().toolsEl, compView, 'getToolsEl');
    };
    /**
     * Returns highlighter element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getHighlighter = function (compView) {
        return this._getLocalEl(this.getCanvasView().hlEl, compView, 'getHighlighter');
    };
    /**
     * Returns badge element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getBadgeEl = function (compView) {
        return this._getLocalEl(this.getCanvasView().badgeEl, compView, 'getBadgeEl');
    };
    /**
     * Returns placer element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getPlacerEl = function () {
        return this.getCanvasView().placerEl;
    };
    /**
     * Returns ghost element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getGhostEl = function () {
        return this.getCanvasView().ghostEl;
    };
    /**
     * Returns toolbar element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getToolbarEl = function () {
        return this.getCanvasView().toolbarEl;
    };
    /**
     * Returns resizer element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getResizerEl = function () {
        return this.getCanvasView().resizerEl;
    };
    /**
     * Returns offset viewer element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getOffsetViewerEl = function (compView) {
        return this._getLocalEl(this.getCanvasView().offsetEl, compView, 'getOffsetViewerEl');
    };
    /**
     * Returns fixed offset viewer element
     * @returns {HTMLElement}
     * @private
     */
    CanvasModule.prototype.getFixedOffsetViewerEl = function () {
        return this.getCanvasView().fixedOffsetEl;
    };
    CanvasModule.prototype.getSpotsEl = function () {
        var _a;
        return (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.spotsEl;
    };
    CanvasModule.prototype.render = function () {
        var _a;
        (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.remove();
        this.canvasView = new view_CanvasView(this.canvas);
        return this.canvasView.render().el;
    };
    /**
     * Get frame position
     * @returns {Object}
     * @private
     */
    CanvasModule.prototype.getOffset = function () {
        var frameOff = this.offset(this.getFrameEl());
        var canvasOff = this.offset(this.getElement());
        return {
            top: frameOff.top - canvasOff.top,
            left: frameOff.left - canvasOff.left,
        };
    };
    /**
     * Get the offset of the passed component element
     * @param  {HTMLElement} el
     * @returns {Object}
     * @private
     */
    CanvasModule.prototype.offset = function (el) {
        return this.getCanvasView().offset(el);
    };
    /**
     * Set custom badge naming strategy
     * @param  {Function} f
     * @example
     * canvas.setCustomBadgeLabel(function(component){
     *  return component.getName();
     * });
     */
    CanvasModule.prototype.setCustomBadgeLabel = function (f) {
        //@ts-ignore
        this.config.customBadgeLabel = f;
    };
    /**
     * Get element position relative to the canvas
     * @param {HTMLElement} el
     * @returns {Object}
     * @private
     */
    CanvasModule.prototype.getElementPos = function (el, opts) {
        return this.getCanvasView().getElementPos(el, opts);
    };
    /**
     * Returns element's offsets like margins and paddings
     * @param {HTMLElement} el
     * @returns {Object}
     * @private
     */
    CanvasModule.prototype.getElementOffsets = function (el) {
        return this.getCanvasView().getElementOffsets(el);
    };
    /**
     * Get canvas rectangular data
     * @returns {Object}
     */
    CanvasModule.prototype.getRect = function () {
        var _a;
        var _b = (_a = this.getCanvasView().getPosition()) !== null && _a !== void 0 ? _a : {}, _c = _b.top, top = _c === void 0 ? 0 : _c, _d = _b.left, left = _d === void 0 ? 0 : _d;
        return canvas_assign(canvas_assign({}, this.getCanvasView().getCanvasOffset()), { topScroll: top, leftScroll: left });
    };
    /**
     * This method comes handy when you need to attach something like toolbars
     * to elements inside the canvas, dealing with all relative position,
     * offsets, etc. and returning as result the object with positions which are
     * viewable by the user (when the canvas is scrolled the top edge of the element
     * is not viewable by the user anymore so the new top edge is the one of the canvas)
     *
     * The target should be visible before being passed here as invisible elements
     * return empty string as width
     * @param {HTMLElement} target The target in this case could be the toolbar
     * @param {HTMLElement} element The element on which I'd attach the toolbar
     * @param {Object} options Custom options
     * @param {Boolean} options.toRight Set to true if you want the toolbar attached to the right
     * @return {Object}
     * @private
     */
    CanvasModule.prototype.getTargetToElementDim = function (target, element, options) {
        if (options === void 0) { options = {}; }
        var opts = options || {};
        var canvasPos = this.getCanvasView().getPosition();
        if (!canvasPos)
            return;
        var pos = opts.elPos || this.getCanvasView().getElementPos(element);
        var toRight = options.toRight || 0;
        var targetHeight = opts.targetHeight || target.offsetHeight;
        var targetWidth = opts.targetWidth || target.offsetWidth;
        var eventToTrigger = opts.event || null;
        var elTop = pos.top - targetHeight;
        var elLeft = pos.left;
        elLeft += toRight ? pos.width : 0;
        elLeft = toRight ? elLeft - targetWidth : elLeft;
        var leftPos = elLeft < canvasPos.left ? canvasPos.left : elLeft;
        var topPos = elTop < canvasPos.top ? canvasPos.top : elTop;
        topPos = topPos > pos.top + pos.height ? pos.top + pos.height : topPos;
        var result = {
            top: topPos,
            left: leftPos,
            elementTop: pos.top,
            elementLeft: pos.left,
            elementWidth: pos.width,
            elementHeight: pos.height,
            targetWidth: target.offsetWidth,
            targetHeight: target.offsetHeight,
            canvasTop: canvasPos.top,
            canvasLeft: canvasPos.left,
            canvasWidth: canvasPos.width,
            canvasHeight: canvasPos.height,
        };
        // In this way I can catch data and also change the position strategy
        if (eventToTrigger && this.em) {
            this.em.trigger(eventToTrigger, result);
        }
        return result;
    };
    CanvasModule.prototype.canvasRectOffset = function (el, pos, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var getFrameElFromDoc = function (doc) {
            var defaultView = doc.defaultView;
            return defaultView === null || defaultView === void 0 ? void 0 : defaultView.frameElement;
        };
        var rectOff = function (el, top, pos) {
            if (top === void 0) { top = 1; }
            var zoom = _this.em.getZoomDecimal();
            var side = top ? 'top' : 'left';
            var doc = el.ownerDocument;
            var _a = opts.offset ? getFrameElFromDoc(doc) : {}, _b = _a.offsetTop, offsetTop = _b === void 0 ? 0 : _b, _c = _a.offsetLeft, offsetLeft = _c === void 0 ? 0 : _c;
            var _d = doc.body || {}, _e = _d.scrollTop, scrollTop = _e === void 0 ? 0 : _e, _f = _d.scrollLeft, scrollLeft = _f === void 0 ? 0 : _f;
            var scroll = top ? scrollTop : scrollLeft;
            var offset = top ? offsetTop : offsetLeft;
            return pos[side] - (scroll - offset) * zoom;
        };
        return {
            top: rectOff(el, 1, pos),
            left: rectOff(el, 0, pos),
        };
    };
    /**
     *
     * @param {HTMLElement} el The component element in the canvas
     * @param {HTMLElement} targetEl The target element to position (eg. toolbar)
     * @param {Object} opts
     * @private
     */
    CanvasModule.prototype.getTargetToElementFixed = function (el, targetEl, opts) {
        if (opts === void 0) { opts = {}; }
        var elRect = opts.pos || this.getElementPos(el, { noScroll: true });
        var canvasOffset = opts.canvasOff || this.canvasRectOffset(el, elRect);
        var targetHeight = targetEl.offsetHeight || 0;
        var targetWidth = targetEl.offsetWidth || 0;
        var elRight = elRect.left + elRect.width;
        var canvasView = this.getCanvasView();
        var canvasRect = canvasView.getPosition();
        var frameOffset = canvasView.getFrameOffset(el);
        var event = opts.event;
        var top = -targetHeight;
        var left = !(0,index_all.isUndefined)(opts.left) ? opts.left : elRect.width - targetWidth;
        left = elRect.left < -left ? -elRect.left : left;
        left = elRight > canvasRect.width ? left - (elRight - canvasRect.width) : left;
        // Check when the target top edge reaches the top of the viewable canvas
        if (canvasOffset.top < targetHeight) {
            var fullHeight = elRect.height + targetHeight;
            var elIsShort = fullHeight < frameOffset.height;
            // Scroll with the window if the top edge is reached and the
            // element is bigger than the canvas
            if (elIsShort) {
                top = top + fullHeight;
            }
            else {
                top = -canvasOffset.top < elRect.height ? -canvasOffset.top : elRect.height;
            }
        }
        var result = {
            top: top,
            left: left,
            canvasOffsetTop: canvasOffset.top,
            canvasOffsetLeft: canvasOffset.left,
            elRect: elRect,
            canvasOffset: canvasOffset,
            canvasRect: canvasRect,
            targetWidth: targetWidth,
            targetHeight: targetHeight,
        };
        // In this way I can catch data and also change the position strategy
        event && this.em.trigger(event, result);
        return result;
    };
    /**
     * Instead of simply returning e.clientX and e.clientY this function
     * calculates also the offset based on the canvas. This is helpful when you
     * need to get X and Y position while moving between the editor area and
     * canvas area, which is in the iframe
     * @param {Event} e
     * @return {Object}
     * @private
     */
    CanvasModule.prototype.getMouseRelativePos = function (e, opts) {
        if (opts === void 0) { opts = {}; }
        var subWinOffset = opts.subWinOffset;
        var doc = e.target.ownerDocument;
        var win = doc.defaultView || doc.parentWindow;
        var frame = win.frameElement;
        var yOffset = subWinOffset ? win.pageYOffset : 0;
        var xOffset = subWinOffset ? win.pageXOffset : 0;
        var zoomMlt = this.getZoomMultiplier();
        var addTop = 0;
        var addLeft = 0;
        if (frame) {
            var frameRect = frame.getBoundingClientRect();
            addTop = frameRect.top || 0;
            addLeft = frameRect.left || 0;
        }
        return {
            y: (e.clientY + addTop - yOffset) * zoomMlt,
            x: (e.clientX + addLeft - xOffset) * zoomMlt,
        };
    };
    /**
     * X and Y mouse position relative to the canvas
     * @param {Event} ev
     * @return {Object}
     * @private
     */
    CanvasModule.prototype.getMouseRelativeCanvas = function (ev, opts) {
        var _a;
        var zoom = this.getZoomDecimal();
        var _b = (_a = this.getCanvasView().getPosition(opts)) !== null && _a !== void 0 ? _a : {}, _c = _b.top, top = _c === void 0 ? 0 : _c, _d = _b.left, left = _d === void 0 ? 0 : _d;
        return {
            y: ev.clientY * zoom + top,
            x: ev.clientX * zoom + left,
        };
    };
    /**
     * Check if the canvas is focused
     * @returns {Boolean}
     */
    CanvasModule.prototype.hasFocus = function () {
        return this.getDocument().hasFocus();
    };
    /**
     * Detects if some input is focused (input elements, text components, etc.)
     * @return {Boolean}
     * @private
     */
    CanvasModule.prototype.isInputFocused = function () {
        var doc = this.getDocument();
        var frame = this.getFrameEl();
        var toIgnore = canvas_spreadArray(['body'], this.config.notTextable, true);
        var docActive = frame && document.activeElement === frame;
        var focused = docActive ? doc && doc.activeElement : document.activeElement;
        return focused && !toIgnore.some(function (item) { return focused.matches(item); });
    };
    /**
     * Scroll canvas to the element if it's not visible. The scrolling is
     * executed via `scrollIntoView` API and options of this method are
     * passed to it. For instance, you can scroll smoothly by using
     * `{ behavior: 'smooth' }`.
     * @param  {HTMLElement|[Component]} el
     * @param  {Object} [opts={}] Options, same as options for `scrollIntoView`
     * @param  {Boolean} [opts.force=false] Force the scroll, even if the element is already visible
     * @example
     * const selected = editor.getSelected();
     * // Scroll smoothly (this behavior can be polyfilled)
     * canvas.scrollTo(selected, { behavior: 'smooth' });
     * // Force the scroll, even if the element is alredy visible
     * canvas.scrollTo(selected, { force: true });
     */
    CanvasModule.prototype.scrollTo = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var elem = (0,mixins.getElement)(el);
        var view = elem && (0,mixins.getViewEl)(elem);
        view && view.scrollIntoView(opts);
    };
    /**
     * Start autoscroll
     * @private
     */
    CanvasModule.prototype.startAutoscroll = function (frame) {
        var fr = (frame && frame.view) || this.em.getCurrentFrame();
        fr && fr.startAutoscroll();
    };
    /**
     * Stop autoscroll
     * @private
     */
    CanvasModule.prototype.stopAutoscroll = function (frame) {
        var fr = (frame && frame.view) || this.em.getCurrentFrame();
        fr && fr.stopAutoscroll();
    };
    /**
     * Set canvas zoom value
     * @param {Number} value The zoom value, from 0 to 100
     * @returns {this}
     * @example
     * canvas.setZoom(50); // set zoom to 50%
     */
    CanvasModule.prototype.setZoom = function (value) {
        this.canvas.set('zoom', typeof value === 'string' ? parseFloat(value) : value);
        return this;
    };
    /**
     * Get canvas zoom value
     * @returns {Number}
     * @example
     * canvas.setZoom(50); // set zoom to 50%
     * const zoom = canvas.getZoom(); // 50
     */
    CanvasModule.prototype.getZoom = function () {
        return parseFloat(this.canvas.get('zoom'));
    };
    /**
     * Set canvas position coordinates
     * @param {Number} x Horizontal position
     * @param {Number} y Vertical position
     * @returns {this}
     * @example
     * canvas.setCoords(100, 100);
     */
    CanvasModule.prototype.setCoords = function (x, y, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var hasX = x || x === 0;
        var hasY = y || y === 0;
        var coords = {
            x: this.canvas.get('x'),
            y: this.canvas.get('y'),
        };
        if (hasX)
            coords.x = parseFloat("".concat(x));
        if (hasY)
            coords.y = parseFloat("".concat(y));
        if (opts.toWorld) {
            var delta = (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.getViewportDelta();
            if (delta) {
                if (hasX)
                    coords.x = coords.x - delta.x;
                if (hasY)
                    coords.y = coords.y - delta.y;
            }
        }
        this.canvas.set(coords);
        return this;
    };
    /**
     * Get canvas position coordinates
     * @returns {Object} Object containing coordinates
     * @example
     * canvas.setCoords(100, 100);
     * const coords = canvas.getCoords();
     * // { x: 100, y: 100 }
     */
    CanvasModule.prototype.getCoords = function () {
        var _a = this.canvas.attributes, x = _a.x, y = _a.y;
        return { x: x, y: y };
    };
    /**
     * Get canvas pointer position coordinates.
     * @returns {Object} Object containing pointer coordinates
     * @private
     * @example
     * const worldPointer = canvas.getPointer();
     * const screenPointer = canvas.getPointer(true);
     */
    CanvasModule.prototype.getPointer = function (screen) {
        var _a = this.canvas.attributes, pointer = _a.pointer, pointerScreen = _a.pointerScreen;
        return screen ? pointerScreen : pointer;
    };
    CanvasModule.prototype.getZoomDecimal = function () {
        return this.getZoom() / 100;
    };
    CanvasModule.prototype.getZoomMultiplier = function () {
        var zoom = this.getZoomDecimal();
        return zoom ? 1 / zoom : 1;
    };
    CanvasModule.prototype.fitViewport = function (opts) {
        var _a;
        (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.fitViewport(opts);
    };
    CanvasModule.prototype.toggleFramesEvents = function (on) {
        var style = this.getFramesEl().style;
        style.pointerEvents = on ? '' : 'none';
    };
    CanvasModule.prototype.getFrames = function () {
        return this.canvas.frames.map(function (item) { return item; });
    };
    /**
     * Add new frame to the canvas
     * @param {Object} props Frame properties
     * @returns {[Frame]}
     * @private
     * @example
     * canvas.addFrame({
     *   name: 'Mobile home page',
     *   x: 100, // Position in canvas
     *   y: 100,
     *   width: 500, // Frame dimensions
     *   height: 600,
     *   // device: 'DEVICE-ID',
     *   components: [
     *     '<h1 class="testh">Title frame</h1>',
     *     '<p class="testp">Paragraph frame</p>',
     *   ],
     *   styles: `
     *     .testh { color: red; }
     *     .testp { color: blue; }
     *   `,
     * });
     */
    CanvasModule.prototype.addFrame = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        return this.canvas.frames.add(new model_Frame(this, canvas_assign({}, props)), opts);
    };
    /**
     * Get the last created Component from a drag & drop to the canvas.
     * @returns {[Component]|undefined}
     */
    CanvasModule.prototype.getLastDragResult = function () {
        return this.em.get('dragResult');
    };
    /**
     * Add or update canvas spot.
     * @param {Object} props Canvas spot properties.
     * @param opts
     * @returns {[CanvasSpot]}
     * @example
     * // Add new canvas spot
     * const spot = canvas.addSpot({
     *  type: 'select', // 'select' is one of the built-in spots
     *  component: editor.getSelected(),
     * });
     *
     * // Add custom canvas spot
     * const spot = canvas.addSpot({
     *  type: 'my-custom-spot',
     *  component: editor.getSelected(),
     * });
     * // Update the same spot by reusing its ID
     * canvas.addSpot({
     *  id: spot.id,
     *  component: anotherComponent,
     * });
     */
    CanvasModule.prototype.addSpot = function (props, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var spotProps = props;
        var spots = this.getSpots(spotProps);
        if (spots.length) {
            var spot_1 = spots[0];
            spot_1.set(spotProps);
            return spot_1;
        }
        var cmpView = spotProps.componentView || ((_a = spotProps.component) === null || _a === void 0 ? void 0 : _a.view);
        var spot = new CanvasSpot/* default */.Z(this, canvas_assign(canvas_assign({}, spotProps), { id: spotProps.id || "cs_".concat(spotProps.type, "_").concat(cmpView === null || cmpView === void 0 ? void 0 : cmpView.cid), type: spotProps.type || '' }));
        this.spots.add(spot, opts);
        return spot;
    };
    /**
     * Get canvas spots.
     * @param {Object} [spotProps] Canvas spot properties for filtering the result. With no properties, all available spots will be returned.
     * @returns {[CanvasSpot][]}
     * @example
     * canvas.addSpot({ type: 'select', component: cmp1 });
     * canvas.addSpot({ type: 'select', component: cmp2 });
     * canvas.addSpot({ type: 'target', component: cmp3 });
     *
     * // Get all spots
     * const allSpots = canvas.getSpots();
     * allSpots.length; // 3
     *
     * // Get all 'select' spots
     * const allSelectSpots = canvas.getSpots({ type: 'select' });
     * allSelectSpots.length; // 2
     */
    CanvasModule.prototype.getSpots = function (spotProps) {
        if (spotProps === void 0) { spotProps = {}; }
        return this.spots.where(spotProps.id ? { id: spotProps.id } : spotProps);
    };
    /**
     * Remove canvas spots.
     * @param {Object|[CanvasSpot][]} [spotProps] Canvas spot properties for filtering spots to remove or an array of spots to remove. With no properties, all available spots will be removed.
     * @returns {[CanvasSpot][]}
     * @example
     * canvas.addSpot({ type: 'select', component: cmp1 });
     * canvas.addSpot({ type: 'select', component: cmp2 });
     * canvas.addSpot({ type: 'target', component: cmp3 });
     *
     * // Remove all 'select' spots
     * canvas.removeSpots({ type: 'select' });
     *
     * // Remove spots by an array of canvas spots
     * const filteredSpots = canvas.getSpots().filter(spot => myCustomCondition);
     * canvas.removeSpots(filteredSpots);
     *
     * // Remove all spots
     * canvas.removeSpots();
     */
    CanvasModule.prototype.removeSpots = function (spotProps) {
        if (spotProps === void 0) { spotProps = {}; }
        var spots = (0,index_all.isArray)(spotProps) ? spotProps : this.getSpots(spotProps);
        var removed = this.spots.remove(spots);
        return removed;
    };
    /**
     * Check if the built-in canvas spot has a declared custom rendering.
     * @param {String} type Built-in canvas spot type
     * @returns {Boolean}
     * @example
     * grapesjs.init({
     *  // ...
     *  canvas: {
     *    // avoid rendering the built-in 'target' canvas spot
     *    customSpots: { target: true }
     *  }
     * });
     * // ...
     * canvas.hasCustomSpot('select'); // false
     * canvas.hasCustomSpot('target'); // true
     */
    CanvasModule.prototype.hasCustomSpot = function (type) {
        var customSpots = this.config.customSpots;
        if (customSpots === true || (customSpots && type && customSpots[type])) {
            return true;
        }
        return false;
    };
    /**
     * Transform a box rect from the world coordinate system to the screen one.
     * @param {Object} boxRect
     * @returns {Object}
     */
    CanvasModule.prototype.getWorldRectToScreen = function (boxRect) {
        var _a;
        return (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.getRectToScreen(boxRect);
    };
    CanvasModule.prototype.refreshSpots = function () {
        this.spots.refresh();
    };
    CanvasModule.prototype.destroy = function () {
        var _this = this;
        var _a;
        this.canvas.stopListening();
        (_a = this.canvasView) === null || _a === void 0 ? void 0 : _a.remove();
        //[this.canvas, this.canvasView].forEach(i => (i = {}));
        //@ts-ignore
        ['model', 'droppable'].forEach(function (i) { return (_this[i] = {}); });
    };
    return CanvasModule;
}(abstract_Module));
/* harmony default export */ const canvas = (CanvasModule);

;// CONCATENATED MODULE: ./src/dom_components/config/config.ts
/* harmony default export */ const dom_components_config_config = ({
    stylePrefix: 'comp-',
    components: [],
    draggableComponents: true,
    disableTextInnerChilds: false,
    processor: undefined,
    useFrameDoc: false,
    voidElements: [
        'area',
        'base',
        'br',
        'col',
        'embed',
        'hr',
        'img',
        'input',
        'keygen',
        'link',
        'menuitem',
        'meta',
        'param',
        'source',
        'track',
        'wbr',
    ],
});

;// CONCATENATED MODULE: ./src/parser/model/BrowserParserHtml.ts

var htmlType = 'text/html';
var defaultType = htmlType; // 'application/xml';
/* harmony default export */ const BrowserParserHtml = (function (str, config) {
    if (config === void 0) { config = {}; }
    var parser = new DOMParser();
    var mimeType = config.htmlType || defaultType;
    var toHTML = mimeType === htmlType;
    var strF = toHTML ? str : "<div>".concat(str, "</div>");
    var doc = parser.parseFromString(strF, mimeType);
    var res;
    if (toHTML) {
        // Replicate the old parser in order to avoid breaking changes
        var head = doc.head, body_1 = doc.body;
        // Move all scripts at the bottom of the page
        var scripts = head.querySelectorAll('script');
        (0,index_all.each)(scripts, function (node) { return body_1.appendChild(node); });
        // Move inside body all head children
        var hEls_1 = [];
        (0,index_all.each)(head.children, function (n) { return hEls_1.push(n); });
        (0,index_all.each)(hEls_1, function (node, i) { return body_1.insertBefore(node, body_1.children[i]); });
        res = body_1;
    }
    else {
        res = doc.firstChild;
    }
    return res;
});
/**
 * POC, custom html parser specs
 * Parse an HTML string to an array of nodes
 * example
 * parse(`<div class="mycls" data-test>Hello</div><span>World <b>example</b></span>`)
 * // result
 * [
 *  {
 *      tagName: 'div',
 *      attributes: { class: 'mycls', 'data-test': '' },
 *      childNodes: ['Hello'],
 *  },{
 *      tagName: 'span',
 *      childNodes: [
 *          'World ',
 *          {
 *              tagName: 'b',
 *              childNodes: ['example'],
 *          }
 *       ],
 *  }
 * ]
 *

export const parseNodes = nodes => {
  const result = [];

  for (let i = 0; i < nodes.length; i++) {
    result.push(parseNode(nodes[i]));
  }

  return result;
};

export const parseAttributes = attrs => {
  const result = {};

  for (let j = 0; j < attrs.length; j++) {
    const attr = attrs[j];
    const nodeName = attr.nodeName;
    const nodeValue = attr.nodeValue;
    result[nodeName] = nodeValue;
  }

  return result;
};

export const parseNode = el => {
  // Return the string of the textnode element
  if (el.nodeType === 3) {
    return el.nodeValue;
  }

  const tagName = node.tagName ? node.tagName.toLowerCase() : '';
  const attrs = el.attributes || [];
  const nodes = el.childNodes || [];

  return {
    ...(tagName && { tagName }),
    ...(attrs.length && {
      attributes: parseAttributes(attrs)
    }),
    ...(nodes.length && {
      childNodes: parseNodes(nodes)
    })
  };
};

export default (str, config = {}) => {
  const result = [];
  const el = document.createElement('div');
  el.innerHTML = str;
  const nodes = el.childNodes;
  const len = nodes.length;

  for (let i = 0; i < len; i++) {
    result.push(parseNode(nodes[i]));
  }

  return result;
};
 */

;// CONCATENATED MODULE: ./src/parser/model/ParserHtml.ts
var ParserHtml_assign = (undefined && undefined.__assign) || function () {
    ParserHtml_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ParserHtml_assign.apply(this, arguments);
};


var modelAttrStart = 'data-gjs-';
var ParserHtml_event = 'parse:html';
var ParserHtml = function (em, config) {
    if (config === void 0) { config = {}; }
    return {
        compTypes: '',
        modelAttrStart: modelAttrStart,
        getPropAttribute: function (attrName, attrValue) {
            var name = attrName.replace(this.modelAttrStart, '');
            var valueLen = (attrValue === null || attrValue === void 0 ? void 0 : attrValue.length) || 0;
            var firstChar = attrValue === null || attrValue === void 0 ? void 0 : attrValue.substring(0, 1);
            var lastChar = attrValue === null || attrValue === void 0 ? void 0 : attrValue.substring(valueLen - 1);
            var value = attrValue === 'true' ? true : attrValue === 'false' ? false : attrValue;
            // Try to parse JSON where it's possible
            // I can get false positive here (eg. a selector '[data-attr]')
            // so put it under try/catch and let fail silently
            try {
                value =
                    (firstChar == '{' && lastChar == '}') || (firstChar == '[' && lastChar == ']') ? JSON.parse(value) : value;
            }
            catch (e) { }
            return {
                name: name,
                value: value,
            };
        },
        /**
         * Extract component props from an attribute object
         * @param {Object} attr
         * @returns {Object} An object containing props and attributes without them
         */
        splitPropsFromAttr: function (attr) {
            var _this = this;
            if (attr === void 0) { attr = {}; }
            var props = {};
            var attrs = {};
            (0,index_all.each)(attr, function (value, key) {
                if (key.indexOf(_this.modelAttrStart) === 0) {
                    var propsResult = _this.getPropAttribute(key, value);
                    props[propsResult.name] = propsResult.value;
                }
                else {
                    attrs[key] = value;
                }
            });
            return {
                props: props,
                attrs: attrs,
            };
        },
        /**
         * Parse style string to object
         * @param {string} str
         * @return {Object}
         * @example
         * var stl = ParserHtml.parseStyle('color:black; width:100px; test:value;');
         * console.log(stl);
         * // {color: 'black', width: '100px', test: 'value'}
         */
        parseStyle: function (str) {
            var result = {};
            while (str.indexOf('/*') >= 0) {
                var start = str.indexOf('/*');
                var end = str.indexOf('*/') + 2;
                str = str.replace(str.slice(start, end), '');
            }
            var decls = str.split(';');
            for (var i = 0, len = decls.length; i < len; i++) {
                var decl = decls[i].trim();
                if (!decl)
                    continue;
                var prop = decl.split(':');
                var key = prop[0].trim();
                var value = prop.slice(1).join(':').trim();
                // Support multiple values for the same key
                if (result[key]) {
                    if (!(0,index_all.isArray)(result[key])) {
                        result[key] = [result[key]];
                    }
                    result[key].push(value);
                }
                else {
                    result[key] = value;
                }
            }
            return result;
        },
        /**
         * Parse class string to array
         * @param {string} str
         * @return {Array<string>}
         * @example
         * var res = ParserHtml.parseClass('test1 test2 test3');
         * console.log(res);
         * // ['test1', 'test2', 'test3']
         */
        parseClass: function (str) {
            var result = [];
            var cls = str.split(' ');
            for (var i = 0, len = cls.length; i < len; i++) {
                var cl = cls[i].trim();
                if (!cl)
                    continue;
                result.push(cl);
            }
            return result;
        },
        /**
         * Get data from the node element
         * @param  {HTMLElement} el DOM element to traverse
         * @return {Array<Object>}
         */
        parseNode: function (el, opts) {
            if (opts === void 0) { opts = {}; }
            var result = [];
            var nodes = el.childNodes;
            for (var i = 0, len = nodes.length; i < len; i++) {
                var node = nodes[i];
                var attrs = node.attributes || [];
                var attrsLen = attrs.length;
                var nodePrev = result[result.length - 1];
                var nodeChild = node.childNodes.length;
                var ct = this.compTypes;
                var model = {}; // TODO use component properties
                // Start with understanding what kind of component it is
                if (ct) {
                    var obj = '';
                    var type = node.getAttribute && node.getAttribute("".concat(this.modelAttrStart, "type"));
                    // If the type is already defined, use it
                    if (type) {
                        model = { type: type };
                    }
                    else {
                        // Iterate over all available Component Types and
                        // the first with a valid result will be that component
                        for (var it_1 = 0; it_1 < ct.length; it_1++) {
                            var compType = ct[it_1];
                            // @ts-ignore
                            obj = compType.model.isComponent(node, opts);
                            if (obj) {
                                if (typeof obj !== 'object') {
                                    // @ts-ignore
                                    obj = { type: compType.id };
                                }
                                break;
                            }
                        }
                        model = obj;
                    }
                }
                // Set tag name if not yet done
                if (!model.tagName) {
                    var tag = node.tagName || '';
                    var ns = node.namespaceURI || '';
                    model.tagName = tag && ns === 'http://www.w3.org/1999/xhtml' ? tag.toLowerCase() : tag;
                }
                if (attrsLen) {
                    model.attributes = {};
                }
                // Parse attributes
                for (var j = 0; j < attrsLen; j++) {
                    var nodeName = attrs[j].nodeName;
                    var nodeValue = attrs[j].nodeValue;
                    // Isolate attributes
                    if (nodeName == 'style') {
                        model.style = this.parseStyle(nodeValue);
                    }
                    else if (nodeName == 'class') {
                        model.classes = this.parseClass(nodeValue);
                    }
                    else if (nodeName == 'contenteditable') {
                        continue;
                    }
                    else if (nodeName.indexOf(this.modelAttrStart) === 0) {
                        var propsResult = this.getPropAttribute(nodeName, nodeValue);
                        model[propsResult.name] = propsResult.value;
                    }
                    else {
                        // @ts-ignore Check for attributes from props (eg. required, disabled)
                        if (nodeValue === '' && node[nodeName] === true) {
                            nodeValue = true;
                        }
                        model.attributes[nodeName] = nodeValue;
                    }
                }
                // Check for nested elements but avoid it if already provided
                if (nodeChild && !model.components) {
                    // Avoid infinite nested text nodes
                    var firstChild = node.childNodes[0];
                    // If there is only one child and it's a TEXTNODE
                    // just make it content of the current node
                    if (nodeChild === 1 && firstChild.nodeType === 3) {
                        !model.type && (model.type = 'text');
                        model.components = {
                            type: 'textnode',
                            content: firstChild.nodeValue,
                        };
                    }
                    else {
                        model.components = this.parseNode(node, ParserHtml_assign(ParserHtml_assign({}, opts), { inSvg: opts.inSvg || model.type === 'svg' }));
                    }
                }
                // Check if it's a text node and if could be moved to the prevous model
                if (model.type == 'textnode') {
                    if (nodePrev && nodePrev.type == 'textnode') {
                        nodePrev.content += model.content;
                        continue;
                    }
                    // Throw away empty nodes (keep spaces)
                    if (!opts.keepEmptyTextNodes) {
                        var content = node.nodeValue;
                        if (content != ' ' && !content.trim()) {
                            continue;
                        }
                    }
                }
                // Check for custom void elements (valid in XML)
                if (!nodeChild && "".concat(node.outerHTML).slice(-2) === '/>') {
                    model.void = true;
                }
                // If all children are texts and there is some textnode the parent should
                // be text too otherwise I'm unable to edit texnodes
                var comps = model.components;
                if (!model.type && comps) {
                    var allTxt = 1;
                    var foundTextNode = 0;
                    for (var ci = 0; ci < comps.length; ci++) {
                        var comp = comps[ci];
                        var cType = comp.type;
                        if (['text', 'textnode'].indexOf(cType) < 0 && config.textTags.indexOf(comp.tagName) < 0) {
                            allTxt = 0;
                            break;
                        }
                        if (cType == 'textnode') {
                            foundTextNode = 1;
                        }
                    }
                    if (allTxt && foundTextNode) {
                        model.type = 'text';
                    }
                }
                // If tagName is still empty and is not a textnode, do not push it
                if (!model.tagName && model.type != 'textnode') {
                    continue;
                }
                result.push(model);
            }
            return result;
        },
        /**
         * Parse HTML string to a desired model object
         * @param  {string} str HTML string
         * @param  {ParserCss} parserCss In case there is style tags inside HTML
         * @return {Object}
         */
        parse: function (str, parserCss, opts) {
            var _a;
            if (opts === void 0) { opts = {}; }
            var conf = (em === null || em === void 0 ? void 0 : em.get('Config')) || {};
            var res = { html: [] };
            var cf = ParserHtml_assign(ParserHtml_assign({}, config), opts);
            var options = ParserHtml_assign(ParserHtml_assign(ParserHtml_assign({}, config.optionsHtml), { 
                // @ts-ignore Support previous `configParser.htmlType` option
                htmlType: ((_a = config.optionsHtml) === null || _a === void 0 ? void 0 : _a.htmlType) || config.htmlType }), opts);
            var el = (0,index_all.isFunction)(cf.parserHtml) ? cf.parserHtml(str, options) : BrowserParserHtml(str, options);
            var scripts = el.querySelectorAll('script');
            var i = scripts.length;
            // Support previous `configMain.allowScripts` option
            var allowScripts = !(0,index_all.isUndefined)(conf.allowScripts) ? conf.allowScripts : options.allowScripts;
            // Remove script tags
            if (!allowScripts) {
                while (i--)
                    scripts[i].parentNode.removeChild(scripts[i]);
            }
            // Remove unsafe attributes
            if (!options.allowUnsafeAttr) {
                this.__clearUnsafeAttr(el);
            }
            // Detach style tags and parse them
            if (parserCss) {
                var styles = el.querySelectorAll('style');
                var j = styles.length;
                var styleStr = '';
                while (j--) {
                    styleStr = styles[j].innerHTML + styleStr;
                    styles[j].parentNode.removeChild(styles[j]);
                }
                if (styleStr)
                    res.css = parserCss.parse(styleStr);
            }
            em && em.trigger("".concat(ParserHtml_event, ":root"), { input: str, root: el });
            var result = this.parseNode(el, cf);
            // I have to keep it otherwise it breaks the DomComponents.addComponent (returns always array)
            var resHtml = result.length === 1 && !cf.returnArray ? result[0] : result;
            res.html = resHtml;
            em && em.trigger(ParserHtml_event, { input: str, output: res });
            return res;
        },
        __clearUnsafeAttr: function (node) {
            var _this = this;
            var attrs = node.attributes || [];
            var nodes = node.childNodes || [];
            var toRemove = [];
            (0,index_all.each)(attrs, function (attr) {
                var name = attr.nodeName || '';
                name.indexOf('on') === 0 && toRemove.push(name);
            });
            toRemove.map(function (name) { return node.removeAttribute(name); });
            (0,index_all.each)(nodes, function (node) { return _this.__clearUnsafeAttr(node); });
        },
    };
};
/* harmony default export */ const model_ParserHtml = (ParserHtml);

;// CONCATENATED MODULE: ./src/domain_abstract/model/StyleableModel.ts
var StyleableModel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var StyleableModel_assign = (undefined && undefined.__assign) || function () {
    StyleableModel_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return StyleableModel_assign.apply(this, arguments);
};




var parserHtml = model_ParserHtml();
var getLastStyleValue = function (value) {
    return (0,index_all.isArray)(value) ? value[value.length - 1] : value;
};
var StyleableModel = /** @class */ (function (_super) {
    StyleableModel_extends(StyleableModel, _super);
    function StyleableModel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Forward style string to `parseStyle` to be parse to an object
     * @param  {string} str
     * @returns
     */
    StyleableModel.prototype.parseStyle = function (str) {
        return parserHtml.parseStyle(str);
    };
    /**
     * To trigger the style change event on models I have to
     * pass a new object instance
     * @param {Object} prop
     * @return {Object}
     */
    StyleableModel.prototype.extendStyle = function (prop) {
        return StyleableModel_assign(StyleableModel_assign({}, this.getStyle()), prop);
    };
    /**
     * Get style object
     * @return {Object}
     */
    StyleableModel.prototype.getStyle = function (prop) {
        var style = this.get('style') || {};
        var result = StyleableModel_assign({}, style);
        return prop && (0,index_all.isString)(prop) ? result[prop] : result;
    };
    /**
     * Set new style object
     * @param {Object|string} prop
     * @param {Object} opts
     * @return {Object} Applied properties
     */
    StyleableModel.prototype.setStyle = function (prop, opts) {
        var _this = this;
        if (prop === void 0) { prop = {}; }
        if (opts === void 0) { opts = {}; }
        if ((0,index_all.isString)(prop)) {
            prop = this.parseStyle(prop);
        }
        var propOrig = this.getStyle(opts);
        if (opts.partial || opts.avoidStore) {
            opts.avoidStore = true;
            prop.__p = true;
        }
        else {
            delete prop.__p;
        }
        var propNew = StyleableModel_assign({}, prop);
        var newStyle = StyleableModel_assign({}, propNew);
        // Remove empty style properties
        (0,index_all.keys)(newStyle).forEach(function (prop) {
            if (newStyle[prop] === '') {
                delete newStyle[prop];
            }
        });
        this.set('style', newStyle, opts);
        var diff = (0,mixins.shallowDiff)(propOrig, propNew);
        // Delete the property used for partial updates
        delete diff.__p;
        (0,index_all.keys)(diff).forEach(function (pr) {
            // @ts-ignore
            var em = _this.em;
            if (opts.noEvent)
                return;
            _this.trigger("change:style:".concat(pr));
            if (em) {
                em.trigger('styleable:change', _this, pr, opts);
                em.trigger("styleable:change:".concat(pr), _this, pr, opts);
            }
        });
        return propNew;
    };
    /**
     * Add style property
     * @param {Object|string} prop
     * @param {string} value
     * @example
     * this.addStyle({color: 'red'});
     * this.addStyle('color', 'blue');
     */
    StyleableModel.prototype.addStyle = function (prop, value, opts) {
        var _a;
        if (value === void 0) { value = ''; }
        if (opts === void 0) { opts = {}; }
        if (typeof prop == 'string') {
            prop = (_a = {},
                _a[prop] = value,
                _a);
        }
        else {
            opts = value || {};
        }
        opts.addStyle = prop;
        prop = this.extendStyle(prop);
        this.setStyle(prop, opts);
    };
    /**
     * Remove style property
     * @param {string} prop
     */
    StyleableModel.prototype.removeStyle = function (prop) {
        var style = this.getStyle();
        delete style[prop];
        this.setStyle(style);
    };
    /**
     * Returns string of style properties
     * @param {Object} [opts={}] Options
     * @return {String}
     */
    StyleableModel.prototype.styleToString = function (opts) {
        if (opts === void 0) { opts = {}; }
        var result = [];
        var style = this.getStyle(opts);
        var imp = opts.important;
        var _loop_1 = function (prop) {
            var important = (0,index_all.isArray)(imp) ? imp.indexOf(prop) >= 0 : imp;
            var firstChars = prop.substring(0, 2);
            var isPrivate = firstChars === '__';
            if (isPrivate)
                return "continue";
            var value = style[prop];
            var values = (0,index_all.isArray)(value) ? value : [value];
            values.forEach(function (val) {
                var value = "".concat(val).concat(important ? ' !important' : '');
                value && result.push("".concat(prop, ":").concat(value, ";"));
            });
        };
        for (var prop in style) {
            _loop_1(prop);
        }
        return result.join('');
    };
    StyleableModel.prototype.getSelectors = function () {
        return (this.get('selectors') || this.get('classes'));
    };
    StyleableModel.prototype.getSelectorsString = function (opts) {
        // @ts-ignore
        return this.selectorsToString ? this.selectorsToString(opts) : this.getSelectors().getFullString();
    };
    return StyleableModel;
}(common/* Model */.Hn));
/* harmony default export */ const model_StyleableModel = (StyleableModel);

;// CONCATENATED MODULE: ./src/dom_components/model/Components.ts
var Components_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Components_assign = (undefined && undefined.__assign) || function () {
    Components_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Components_assign.apply(this, arguments);
};
var __rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Components_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



var getComponentIds = function (cmp, res) {
    if (res === void 0) { res = []; }
    if (!cmp)
        return [];
    var cmps = ((0,index_all.isArray)(cmp) || (0,index_all.isFunction)(cmp.map) ? cmp : [cmp]);
    cmps.map(function (cmp) {
        res.push(cmp.getId());
        getComponentIds(cmp.components().models, res);
    });
    return res;
};
var getComponentsFromDefs = function (items, all, opts) {
    if (all === void 0) { all = {}; }
    if (opts === void 0) { opts = {}; }
    opts.visitedCmps = opts.visitedCmps || {};
    var visitedCmps = opts.visitedCmps;
    var itms = (0,index_all.isArray)(items) ? items : [items];
    return itms.map(function (item) {
        var _a = item.attributes, attributes = _a === void 0 ? {} : _a, components = item.components, tagName = item.tagName, style = item.style;
        var id = attributes.id, draggable = attributes.draggable, restAttr = __rest(attributes, ["id", "draggable"]);
        var result = item;
        if (id) {
            // Detect components with the same ID
            if (!visitedCmps[id]) {
                visitedCmps[id] = [];
                // Update the component if exists already
                if (all[id]) {
                    result = all[id];
                    var cmp = result;
                    tagName && cmp.set({ tagName: tagName }, Components_assign(Components_assign({}, opts), { silent: true }));
                    (0,index_all.keys)(restAttr).length && cmp.addAttributes(restAttr, Components_assign({}, opts));
                    (0,index_all.keys)(style).length && cmp.addStyle(style, opts);
                }
            }
            else {
                // Found another component with the same ID, treat it as a new component
                visitedCmps[id].push(result);
                id = model_Component.getNewId(all);
                result.attributes.id = id;
            }
        }
        if (components) {
            var newComponents = getComponentsFromDefs(components, all);
            if ((0,index_all.isFunction)(result.components)) {
                var cmps = result.components();
                cmps.length > 0 && cmps.reset(newComponents, opts);
            }
            else {
                result.components = newComponents;
            }
        }
        return result;
    });
};
var Components = /** @class */ (function (_super) {
    Components_extends(Components, _super);
    function Components() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Components.prototype.initialize = function (models, opt) {
        if (opt === void 0) { opt = {}; }
        this.opt = opt;
        this.listenTo(this, 'add', this.onAdd);
        this.listenTo(this, 'remove', this.removeChildren);
        this.listenTo(this, 'reset', this.resetChildren);
        var em = opt.em, config = opt.config;
        this.config = config;
        this.em = em;
        this.domc = opt.domc || (em === null || em === void 0 ? void 0 : em.Components);
    };
    Components.prototype.resetChildren = function (models, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var coll = this;
        var prev = opts.previousModels || [];
        var toRemove = prev.filter(function (prev) { return !models.get(prev.cid); });
        var newIds = getComponentIds(models);
        var idsToKeep = getComponentIds(prev).filter(function (pr) { return newIds.indexOf(pr) >= 0; });
        opts.keepIds = (opts.keepIds || []).concat(idsToKeep);
        toRemove.forEach(function (md) { return _this.removeChildren(md, coll, opts); });
        models.each(function (model) { return _this.onAdd(model); });
    };
    Components.prototype.resetFromString = function (input, opts) {
        var _a, _b;
        if (input === void 0) { input = ''; }
        if (opts === void 0) { opts = {}; }
        opts.keepIds = getComponentIds(this);
        var _c = this, domc = _c.domc, em = _c.em, parent = _c.parent;
        var cssc = em === null || em === void 0 ? void 0 : em.Css;
        var allByID = (domc === null || domc === void 0 ? void 0 : domc.allById()) || {};
        var parsed = this.parseString(input, opts);
        var newCmps = getComponentsFromDefs(parsed, allByID, opts);
        var _d = opts.visitedCmps, visitedCmps = _d === void 0 ? {} : _d;
        // Clone styles for duplicated components
        Object.keys(visitedCmps).forEach(function (id) {
            var cmps = visitedCmps[id];
            if (cmps.length) {
                // Get all available rules of the component
                var rulesToClone_1 = (cssc === null || cssc === void 0 ? void 0 : cssc.getRules("#".concat(id))) || [];
                if (rulesToClone_1.length) {
                    cmps.forEach(function (cmp) {
                        rulesToClone_1.forEach(function (rule) {
                            var newRule = rule.clone();
                            // @ts-ignore
                            newRule.set('selectors', ["#".concat(cmp.attributes.id)]);
                            cssc.getAll().add(newRule);
                        });
                    });
                }
            }
        });
        this.reset(newCmps, opts);
        em === null || em === void 0 ? void 0 : em.trigger('component:content', parent, opts, input);
        (_b = (_a = parent).__checkInnerChilds) === null || _b === void 0 ? void 0 : _b.call(_a);
    };
    Components.prototype.removeChildren = function (removed, coll, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        // Removing a parent component can cause this function
        // to be called with an already removed child element
        if (!removed) {
            return;
        }
        var _a = this, domc = _a.domc, em = _a.em;
        var isTemp = opts.temporary || opts.fromUndo;
        removed.prevColl = this; // This one is required for symbols
        if (!isTemp) {
            // Remove the component from the global list
            var id_1 = removed.getId();
            var sels = em.Selectors.getAll();
            var rules = em.Css.getAll();
            var canRemoveStyle = (opts.keepIds || []).indexOf(id_1) < 0;
            var allByID = domc ? domc.allById() : {};
            delete allByID[id_1];
            // Remove all component related styles
            var rulesRemoved = (canRemoveStyle
                ? rules.remove(rules.filter(function (r) { return r.getSelectors().getFullString() === "#".concat(id_1); }), opts)
                : []);
            // Clean selectors
            sels.remove(rulesRemoved.map(function (rule) { return rule.getSelectors().at(0); }));
            if (!removed.opt.temporary) {
                em.Commands.run('core:component-style-clear', {
                    target: removed,
                });
                removed.removed();
                removed.trigger('removed');
                em.trigger('component:remove', removed);
            }
            var inner_1 = removed.components();
            inner_1.forEach(function (it) { return _this.removeChildren(it, coll, opts); });
        }
        // Remove stuff registered in DomComponents.handleChanges
        var inner = removed.components();
        em.stopListening(inner);
        em.stopListening(removed);
        em.stopListening(removed.get('classes'));
        removed.__postRemove();
    };
    /** @ts-ignore */
    Components.prototype.model = function (attrs, options) {
        var opt = options.collection.opt;
        var em = opt.em;
        var model;
        var df = em.Components.componentTypes;
        options.em = em;
        options.config = opt.config;
        options.componentTypes = df;
        options.domc = opt.domc;
        for (var it_1 = 0; it_1 < df.length; it_1++) {
            var dfId = df[it_1].id;
            if (dfId == attrs.type) {
                model = df[it_1].model;
                break;
            }
        }
        // If no model found, get the default one
        if (!model) {
            model = df[df.length - 1].model;
            em &&
                attrs.type &&
                em.logWarning("Component type '".concat(attrs.type, "' not found"), {
                    attrs: attrs,
                    options: options,
                });
        }
        return new model(attrs, options);
    };
    Components.prototype.parseString = function (value, opt) {
        if (opt === void 0) { opt = {}; }
        var _a = this, em = _a.em, domc = _a.domc;
        var cssc = em.Css;
        var parsed = em.Parser.parseHtml(value);
        // We need this to avoid duplicate IDs
        model_Component.checkId(parsed.html, parsed.css, domc.componentsById, opt);
        if (parsed.css && cssc && !opt.temporary) {
            var at = opt.at, optsToPass = __rest(opt, ["at"]);
            cssc.addCollection(parsed.css, Components_assign(Components_assign({}, optsToPass), { extend: 1 }));
        }
        return parsed.html;
    };
    /** @ts-ignore */
    Components.prototype.add = function (models, opt) {
        var _this = this;
        if (opt === void 0) { opt = {}; }
        opt.keepIds = Components_spreadArray(Components_spreadArray([], (opt.keepIds || []), true), getComponentIds(opt.previousModels), true);
        if ((0,index_all.isString)(models)) {
            models = this.parseString(models, opt);
        }
        else if ((0,index_all.isArray)(models)) {
            models = Components_spreadArray([], models, true);
            models.forEach(function (item, index) {
                if ((0,index_all.isString)(item)) {
                    var nodes = _this.parseString(item, opt);
                    models[index] = (0,index_all.isArray)(nodes) && !nodes.length ? null : nodes;
                }
            });
        }
        var isMult = (0,index_all.isArray)(models);
        // @ts-ignore
        models = (isMult ? models : [models]).filter(Boolean).map(function (model) { return _this.processDef(model); });
        // @ts-ignore
        models = isMult ? (0,index_all.flatten)(models, 1) : models[0];
        var result = common/* Collection */.FE.prototype.add.apply(this, [models, opt]);
        this.__firstAdd = result;
        return result;
    };
    /**
     * Process component definition.
     */
    Components.prototype.processDef = function (mdl) {
        // Avoid processing Models
        if (mdl.cid && mdl.ccid)
            return mdl;
        var _a = this, em = _a.em, _b = _a.config, config = _b === void 0 ? {} : _b;
        var processor = config.processor;
        var model = mdl;
        if (processor) {
            model = Components_assign({}, model); // Avoid 'Cannot delete property ...'
            var modelPr = processor(model);
            if (modelPr) {
                (0,index_all.each)(model, function (val, key) { return delete model[key]; });
                (0,index_all.extend)(model, modelPr);
            }
        }
        // React JSX preset
        if (model.$$typeof && typeof model.props == 'object') {
            model = Components_assign({}, model);
            model.props = Components_assign({}, model.props);
            var domc = em.Components;
            var parser = em.Parser;
            var parserHtml = parser.parserHtml;
            (0,index_all.each)(model, function (value, key) {
                if (!(0,index_all.includes)(['props', 'type'], key))
                    delete model[key];
            });
            var props = model.props;
            var comps = props.children;
            delete props.children;
            delete model.props;
            var res = parserHtml.splitPropsFromAttr(props);
            model.attributes = res.attrs;
            if (comps) {
                model.components = comps;
            }
            if (!model.type) {
                model.type = 'textnode';
            }
            else if (!domc.getType(model.type)) {
                model.tagName = model.type;
                delete model.type;
            }
            (0,index_all.extend)(model, res.props);
        }
        return model;
    };
    Components.prototype.onAdd = function (model, c, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, domc = _a.domc, em = _a.em;
        var style = model.getStyle();
        var avoidInline = em && em.getConfig().avoidInlineStyle;
        domc && domc.Component.ensureInList(model);
        // @ts-ignore
        if (!(0,index_all.isEmpty)(style) && !avoidInline && em && em.get && em.getConfig().forceClass && !opts.temporary) {
            var name_1 = model.cid;
            em.Css.setClassRule(name_1, style);
            model.setStyle({});
            model.addClass(name_1);
        }
        model.__postAdd({ recursive: true });
        // this.__onAddEnd();
    };
    return Components;
}(common/* Collection */.FE));
/* harmony default export */ const model_Components = (Components);

;// CONCATENATED MODULE: ./src/selector_manager/model/Selector.ts
var Selector_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TYPE_CLASS = 1;
var TYPE_ID = 2;
/**
 * @typedef Selector
 * @property {String} name Selector name, eg. `my-class`
 * @property {String} label Selector label, eg. `My Class`
 * @property {Number} [type=1] Type of the selector. 1 (class) | 2 (id)
 * @property {Boolean} [active=true] If not active, it's not selectable by the Style Manager.
 * @property {Boolean} [private=false] If true, it can't be seen by the Style Manager, but it will be rendered in the canvas and in export code.
 * @property {Boolean} [protected=false] If true, it can't be removed from the attached component.
 */
var Selector = /** @class */ (function (_super) {
    Selector_extends(Selector, _super);
    /**
     * @hideconstructor
     */
    function Selector(props, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, props, opts) || this;
        var _a = opts.config, config = _a === void 0 ? {} : _a;
        var name = _this.get('name');
        var label = _this.get('label');
        if (!name) {
            _this.set('name', label);
        }
        else if (!label) {
            _this.set('label', name);
        }
        var namePreEsc = _this.get('name');
        var escapeName = config.escapeName;
        var nameEsc = escapeName ? escapeName(namePreEsc) : Selector.escapeName(namePreEsc);
        _this.set('name', nameEsc);
        _this.em = opts.em;
        return _this;
    }
    Selector.prototype.defaults = function () {
        return {
            name: '',
            label: '',
            type: TYPE_CLASS,
            active: true,
            private: false,
            protected: false,
            _undo: true,
        };
    };
    Selector.prototype.isId = function () {
        return this.get('type') === TYPE_ID;
    };
    Selector.prototype.isClass = function () {
        return this.get('type') === TYPE_CLASS;
    };
    Selector.prototype.getFullName = function (opts) {
        if (opts === void 0) { opts = {}; }
        var escape = opts.escape;
        var name = this.get('name');
        var pfx = '';
        switch (this.get('type')) {
            case TYPE_CLASS:
                pfx = '.';
                break;
            case TYPE_ID:
                pfx = '#';
                break;
        }
        return pfx + (escape ? escape(name) : name);
    };
    /**
     * Get selector as a string.
     * @returns {String}
     * @example
     * // Given such selector: { name: 'my-selector', type: 2 }
     * console.log(selector.toString());
     * // -> `#my-selector`
     */
    Selector.prototype.toString = function () {
        return this.getFullName();
    };
    /**
     * Get selector name.
     * @returns {String}
     * @example
     * // Given such selector: { name: 'my-selector', label: 'My selector' }
     * console.log(selector.getName());
     * // -> `my-selector`
     */
    Selector.prototype.getName = function () {
        return this.get('name') || '';
    };
    /**
     * Get selector label.
     * @returns {String}
     * @example
     * // Given such selector: { name: 'my-selector', label: 'My selector' }
     * console.log(selector.getLabel());
     * // -> `My selector`
     */
    Selector.prototype.getLabel = function () {
        return this.get('label') || '';
    };
    /**
     * Update selector label.
     * @param {String} label New label
     * @example
     * // Given such selector: { name: 'my-selector', label: 'My selector' }
     * selector.setLabel('New Label')
     * console.log(selector.getLabel());
     * // -> `New Label`
     */
    Selector.prototype.setLabel = function (label) {
        return this.set('label', label);
    };
    /**
     * Get selector active state.
     * @returns {Boolean}
     */
    Selector.prototype.getActive = function () {
        return !!this.get('active');
    };
    /**
     * Update selector active state.
     * @param {Boolean} value New active state
     */
    Selector.prototype.setActive = function (value) {
        return this.set('active', value);
    };
    Selector.prototype.toJSON = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var obj = common/* Model */.Hn.prototype.toJSON.call(this, [opts]);
        var defaults = (0,index_all.result)(this, 'defaults');
        if (em && em.getConfig().avoidDefaults) {
            (0,index_all.forEach)(defaults, function (value, key) {
                if (obj[key] === value) {
                    delete obj[key];
                }
            });
            if (obj.label === obj.name) {
                delete obj.label;
            }
            var objLen = (0,index_all.keys)(obj).length;
            if (objLen === 1 && obj.name) {
                obj = obj.name;
            }
            if (objLen === 2 && obj.name && obj.type) {
                obj = this.getFullName();
            }
        }
        return obj;
    };
    /**
     * Escape string
     * @param {string} name
     * @return {string}
     * @private
     */
    Selector.escapeName = function (name) {
        return "".concat(name).trim().replace(/([^a-z0-9\w-\\:@\\/]+)/gi, '-');
    };
    // Type selectors: https://developer.mozilla.org/it/docs/Web/CSS/CSS_Selectors
    Selector.TYPE_CLASS = TYPE_CLASS;
    Selector.TYPE_ID = TYPE_ID;
    return Selector;
}(common/* Model */.Hn));
/* harmony default export */ const model_Selector = (Selector);
Selector.prototype.idAttribute = 'name';

;// CONCATENATED MODULE: ./src/selector_manager/model/Selectors.ts
var Selectors_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var combine = function (tail, curr) {
    return tail.reduce(function (acc, item, n) {
        return acc.concat(combine(tail.slice(n + 1), "".concat(curr).concat(item)));
    }, [curr]);
};
var Selectors = /** @class */ (function (_super) {
    Selectors_extends(Selectors, _super);
    function Selectors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Selectors.prototype.modelId = function (attr) {
        return "".concat(attr.name, "_").concat(attr.type || model_Selector.TYPE_CLASS);
    };
    Selectors.prototype.getStyleable = function () {
        return (0,index_all.filter)(this.models, function (item) { return item.getActive() && !item.get('private'); });
    };
    Selectors.prototype.getValid = function (_a) {
        var _b = _a === void 0 ? {} : _a, noDisabled = _b.noDisabled;
        return (0,index_all.filter)(this.models, function (item) { return !item.get('private'); }).filter(function (item) { return (noDisabled ? item.get('active') : 1); });
    };
    Selectors.prototype.getFullString = function (collection, opts) {
        if (opts === void 0) { opts = {}; }
        var result = [];
        var coll = collection || this;
        coll.forEach(function (selector) { return result.push(selector.getFullName(opts)); });
        opts.sort && result.sort();
        return result.join('').trim();
    };
    Selectors.prototype.getFullName = function (opts) {
        if (opts === void 0) { opts = {}; }
        var combination = opts.combination, array = opts.array;
        var result = [];
        var sels = this.map(function (s) { return s.getFullName(opts); }).sort();
        if (combination) {
            sels.forEach(function (sel, n) {
                result = result.concat(combine(sels.slice(n + 1), sel));
            });
        }
        else {
            result = sels;
        }
        return (array ? result : combination ? result.join(',') : result.join(''));
    };
    return Selectors;
}(common/* Collection */.FE));
/* harmony default export */ const model_Selectors = (Selectors);
Selectors.prototype.model = model_Selector;

;// CONCATENATED MODULE: ./src/common/traits/view/TraitListView.ts
var TraitListView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitListView_assign = (undefined && undefined.__assign) || function () {
    TraitListView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitListView_assign.apply(this, arguments);
};




var TraitListView = /** @class */ (function (_super) {
    TraitListView_extends(TraitListView, _super);
    function TraitListView(em, opts) {
        var _this = _super.call(this, em, TraitListView_assign({}, opts)) || this;
        _this.type = 'list';
        console.log(opts);
        _this.templates = opts.traits;
        return _this;
    }
    TraitListView.prototype.events = function () {
        return {
            'click [addButton]': this.addItem,
            'click [removeButton]': this.removeItem,
            'click [data-item-title]': this.select,
        };
    };
<<<<<<< HEAD
    TraitListView.prototype.select = function (e) {
        var _a;
        var _b = this, model = _b.model, ppfx = _b.ppfx, selectedEl = _b.selectedEl;
        // model.setOpen(!model.get('open'));
        (_a = this.itemsEl) === null || _a === void 0 ? void 0 : _a.forEach(function (el) {
            el.find('.data-item').get(0).style.display = 'none';
=======
    Trait.prototype.setTarget = function (target) {
        if (target) {
            var _a = this.attributes, name_1 = _a.name, changeProp = _a.changeProp, initValue = _a.value, getValue = _a.getValue;
            this.target = target;
            this.unset('target');
            var targetEvent = changeProp ? "change:".concat(name_1) : "change:attributes:".concat(name_1);
            this.listenTo(target, targetEvent, this.targetUpdated);
            var value = initValue ||
                // Avoid the risk of loops in case the trait has a custom getValue
                (!getValue ? this.getValue() : undefined);
            !(0,index_all.isUndefined)(value) && this.set({ value: value }, { silent: true });
        }
    };
    /**
     * Get the trait id.
     * @returns {String}
     */
    Trait.prototype.getId = function () {
        return this.get('id');
    };
    /**
     * Get the trait type.
     * @returns {String}
     */
    Trait.prototype.getType = function () {
        return this.get('type');
    };
    /**
     * Get the trait name.
     * @returns {String}
     */
    Trait.prototype.getName = function () {
        return this.get('name');
    };
    /**
     * Get the trait label.
     * @param {Object} [opts={}] Options.
     * @param {Boolean} [opts.locale=true] Use the locale string from i18n module.
     * @returns {String}
     */
    Trait.prototype.getLabel = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = opts.locale, locale = _b === void 0 ? true : _b;
        var id = this.getId();
        var name = this.get('label') || this.getName();
        return (locale && ((_a = this.em) === null || _a === void 0 ? void 0 : _a.t("traitManager.traits.labels.".concat(id)))) || name;
    };
    /**
     * Get the trait value.
     * The value is taken from component attributes by default or from properties if the trait has the `changeProp` enabled.
     * @returns {any}
     */
    Trait.prototype.getValue = function () {
        return this.getTargetValue();
    };
    /**
     * Update the trait value.
     * The value is applied on component attributes by default or on properties if the trait has the `changeProp` enabled.
     * @param {any} value Value of the trait.
     * @param {Object} [opts={}] Options.
     * @param {Boolean} [opts.partial] If `true` the update won't be considered complete (not stored in UndoManager).
     */
    Trait.prototype.setValue = function (value, opts) {
        var _this = this;
        var _a;
        if (opts === void 0) { opts = {}; }
        var valueOpts = {};
        var setValue = this.get('setValue');
        if (setValue) {
            setValue({
                value: value,
                editor: (_a = this.em) === null || _a === void 0 ? void 0 : _a.getEditor(),
                trait: this,
                component: this.target,
                partial: !!opts.partial,
                options: opts,
                emitUpdate: function () { return _this.targetUpdated(); },
            });
            return;
        }
        if (opts.partial) {
            valueOpts.avoidStore = true;
        }
        this.setTargetValue(value, valueOpts);
        if (opts.partial === false) {
            this.setTargetValue('');
            this.setTargetValue(value);
        }
    };
    /**
     * Get default value.
     */
    Trait.prototype.getDefault = function () {
        return this.get('default');
    };
    /**
     * Get trait options.
     */
    Trait.prototype.getOptions = function () {
        return this.get('options') || [];
    };
    /**
     * Get current selected option or by id.
     * @param {String} [id] Option id.
     * @returns {Object | null}
     */
    Trait.prototype.getOption = function (id) {
        var _this = this;
        var idSel = (0,mixins.isDef)(id) ? id : this.getValue();
        return this.getOptions().filter(function (o) { return _this.getOptionId(o) === idSel; })[0];
    };
    /**
     * Get the option id from the option object.
     * @param {Object} option Option object
     * @returns {String} Option id
     */
    Trait.prototype.getOptionId = function (option) {
        return option.id || option.value;
    };
    /**
     * Get option label.
     * @param {String|Object} id Option id or the option object
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.locale=true] Use the locale string from i18n module
     * @returns {String} Option label
     */
    Trait.prototype.getOptionLabel = function (id, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = opts.locale, locale = _b === void 0 ? true : _b;
        var option = ((0,index_all.isString)(id) ? this.getOption(id) : id);
        var optId = this.getOptionId(option);
        var label = option.label || option.name || optId;
        var propName = this.getName();
        return (locale && ((_a = this.em) === null || _a === void 0 ? void 0 : _a.t("traitManager.traits.options.".concat(propName, ".").concat(optId)))) || label;
    };
    Trait.prototype.props = function () {
        return this.attributes;
    };
    Trait.prototype.targetUpdated = function () {
        var _a;
        var value = this.getTargetValue();
        this.set({ value: value }, { fromTarget: 1 });
        (_a = this.em) === null || _a === void 0 ? void 0 : _a.trigger('trait:update', {
            trait: this,
            component: this.target,
>>>>>>> script-module
        });
        if (!(0,index_all.isUndefined)(e)) {
            var selected = (0,cash_dom["default"])(e.target).closest(".".concat(ppfx, "title")).find('.data-item');
            console.log(selected);
            this.selectedEl = selected;
            selected.get(0).style.display = '';
        }
        else if (!(0,index_all.isUndefined)(selectedEl)) {
            selectedEl.get(0).style.display = '';
        }
        console.log(e);
        // $el[isOpen ? 'addClass' : 'removeClass'](`${pfx}open`);
        // this.getPropertiesEl().style.display = isOpen ? '' : 'none';
    };
    TraitListView.prototype.onUpdateEvent = function (value) {
        console.log('Render');
        this.render();
    };
    TraitListView.prototype.addItem = function (e) {
        e.preventDefault();
        this.target.add('');
        // this.render()
        console.log(this.target);
    };
    TraitListView.prototype.removeItem = function (e) {
        e.preventDefault();
        this.target.add('');
        console.log('remove');
        console.log(this.target);
    };
    TraitListView.prototype.renderToolbar = function () {
        if (!this.toolbarEl) {
            var el = document.createElement('div');
            el.append(document.createElement('button'));
            var tmpl = "<div class=\"\">\n      <button addButton> Add </button>\n      <button removeButton> Remove </button>\n    </div>";
            this.toolbarEl = (0,cash_dom["default"])(tmpl).get(0);
        }
        return this.toolbarEl;
    };
    TraitListView.prototype.renderItem = function (trait) {
        var _a = this, em = _a.em, ppfx = _a.ppfx, label = _a.label;
        var icons = em === null || em === void 0 ? void 0 : em.getConfig().icons;
        var iconCaret = (icons === null || icons === void 0 ? void 0 : icons.caret) || '';
        var view = common_traits.buildView(trait, em, TraitListView_assign(TraitListView_assign({}, trait.opts), { noLabel: true })).render();
        var itemEl = document.createElement('div');
        itemEl.setAttribute('data-item-title', '');
        itemEl.className = "".concat(ppfx, "title");
        itemEl.innerHTML = "\n        <div class=\"".concat(ppfx, "caret\">").concat(iconCaret, "</div>\n        \n    ");
        // <div class="${ppfx}label">${label}</div>
        console.log(itemEl);
        var itemDataEl = document.createElement('div');
        itemDataEl.className = 'data-item';
        itemDataEl.append(view.el);
        console.log(itemEl);
        return (0,cash_dom["default"])(itemEl).append(itemDataEl);
    };
    TraitListView.prototype.renderItems = function () {
        var _this = this;
        this.itemsEl = this.target.traits.map(function (trait) { return _this.renderItem(trait); });
    };
    TraitListView.prototype.render = function () {
        var _a;
        var _b = this, $el = _b.$el, pfx = _b.pfx, ppfx = _b.ppfx, name = _b.name, type = _b.type, className = _b.className;
        console.log('render');
        var hasLabel = this.hasLabel();
        var cls = "".concat(pfx, "trait");
        var em = this.em;
        var frag = document.createDocumentFragment();
        this.$el.empty();
        this.renderItems();
        (_a = this.itemsEl) === null || _a === void 0 ? void 0 : _a.forEach(function (el) { return frag.appendChild(el.get(0)); });
        var itemsEl = document.createElement('div');
        itemsEl.className = "".concat(ppfx, "field-").concat(type, "-items");
        itemsEl.append(frag);
        // el.className += model.isFull() ? ` ${className}--full` : '';
        var tmpl = "<div class=\"".concat(cls, " ").concat(cls, "--").concat(type, "\">\n    ").concat(hasLabel ? "<div class=\"".concat(ppfx, "label\" data-label></div>") : '', "\n    <div class=\"").concat(ppfx, "field-wrp ").concat(ppfx, "field-wrp--").concat(type, " gjs-trt-trait--full\" data-input>\n\n    </div>\n  </div>");
        this.$el.append(tmpl);
        this.$el.find('[data-input]').append(this.renderToolbar()).append(itemsEl);
        // ${this.renderToolbar()}
        // ${itemsEl}
        // console.log(frag);
        console.log('render');
        this.select();
        this.setElement(this.el);
        return this;
    };
    return TraitListView;
}(view_TraitView));
/* harmony default export */ const view_TraitListView = (TraitListView);

;// CONCATENATED MODULE: ./src/common/traits/view/TraitsView.ts
var TraitsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var TraitsView_assign = (undefined && undefined.__assign) || function () {
    TraitsView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TraitsView_assign.apply(this, arguments);
};


var TraitsView = /** @class */ (function (_super) {
    TraitsView_extends(TraitsView, _super);
    function TraitsView(em, opts) {
        var _a;
        var _this = _super.call(this, em, TraitsView_assign({}, opts)) || this;
        _this.type = 'list';
        console.log(opts);
        _this.traits = (_a = opts.traits) !== null && _a !== void 0 ? _a : [];
        return _this;
    }
    TraitsView.prototype.onUpdateEvent = function (value) {
        this.render();
    };
    TraitsView.prototype.render = function () {
        var _this = this;
        var frag = document.createDocumentFragment();
        this.$el.empty();
        if (this.traits.length) {
            this.traits.forEach(function (tr) {
                console.log('Building view');
                console.log(tr.opts);
                var view = common_traits.buildView(tr, _this.em, tr.opts);
                var rendered = view.render().el;
                frag.appendChild(rendered);
            });
        }
        this.$el.append(frag);
        this.setElement(this.el);
        return this;
    };
    return TraitsView;
}(view_TraitView));
/* harmony default export */ const view_TraitsView = (TraitsView);

;// CONCATENATED MODULE: ./node_modules/@codemirror/state/dist/index.js
/**
The data structure for documents. @nonabstract
*/
class Text {
    /**
    Get the line description around the given position.
    */
    lineAt(pos) {
        if (pos < 0 || pos > this.length)
            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);
        return this.lineInner(pos, false, 1, 0);
    }
    /**
    Get the description for the given (1-based) line number.
    */
    line(n) {
        if (n < 1 || n > this.lines)
            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
        return this.lineInner(n, true, 1, 0);
    }
    /**
    Replace a range of the text with the given content.
    */
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(0, from, parts, 2 /* Open.To */);
        if (text.length)
            text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);
        this.decompose(to, this.length, parts, 1 /* Open.From */);
        return TextNode.from(parts, this.length - (to - from) + text.length);
    }
    /**
    Append another document to this one.
    */
    append(other) {
        return this.replace(this.length, this.length, other);
    }
    /**
    Retrieve the text between the given points.
    */
    slice(from, to = this.length) {
        [from, to] = clip(this, from, to);
        let parts = [];
        this.decompose(from, to, parts, 0);
        return TextNode.from(parts, to - from);
    }
    /**
    Test whether this text is equal to another instance.
    */
    eq(other) {
        if (other == this)
            return true;
        if (other.length != this.length || other.lines != this.lines)
            return false;
        let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);
        let a = new RawTextCursor(this), b = new RawTextCursor(other);
        for (let skip = start, pos = start;;) {
            a.next(skip);
            b.next(skip);
            skip = 0;
            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)
                return false;
            pos += a.value.length;
            if (a.done || pos >= end)
                return true;
        }
    }
    /**
    Iterate over the text. When `dir` is `-1`, iteration happens
    from end to start. This will return lines and the breaks between
    them as separate strings.
    */
    iter(dir = 1) { return new RawTextCursor(this, dir); }
    /**
    Iterate over a range of the text. When `from` > `to`, the
    iterator will run in reverse.
    */
    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }
    /**
    Return a cursor that iterates over the given range of lines,
    _without_ returning the line breaks between, and yielding empty
    strings for empty lines.
    
    When `from` and `to` are given, they should be 1-based line numbers.
    */
    iterLines(from, to) {
        let inner;
        if (from == null) {
            inner = this.iter();
        }
        else {
            if (to == null)
                to = this.lines + 1;
            let start = this.line(from).from;
            inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to <= 1 ? 0 : this.line(to - 1).to));
        }
        return new LineCursor(inner);
    }
    /**
    Return the document as a string, using newline characters to
    separate lines.
    */
    toString() { return this.sliceString(0); }
    /**
    Convert the document to an array of lines (which can be
    deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
    */
    toJSON() {
        let lines = [];
        this.flatten(lines);
        return lines;
    }
    /**
    @internal
    */
    constructor() { }
    /**
    Create a `Text` instance for the given array of lines.
    */
    static of(text) {
        if (text.length == 0)
            throw new RangeError("A document must have at least one line");
        if (text.length == 1 && !text[0])
            return Text.empty;
        return text.length <= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));
    }
}
// Leaves store an array of line strings. There are always line breaks
// between these strings. Leaves are limited in size and have to be
// contained in TextNode instances for bigger documents.
class TextLeaf extends Text {
    constructor(text, length = textLength(text)) {
        super();
        this.text = text;
        this.length = length;
    }
    get lines() { return this.text.length; }
    get children() { return null; }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let string = this.text[i], end = offset + string.length;
            if ((isLine ? line : end) >= target)
                return new Line(offset, end, line, string);
            offset = end + 1;
            line++;
        }
    }
    decompose(from, to, target, open) {
        let text = from <= 0 && to >= this.length ? this
            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));
        if (open & 1 /* Open.From */) {
            let prev = target.pop();
            let joined = appendText(text.text, prev.text.slice(), 0, text.length);
            if (joined.length <= 32 /* Tree.Branch */) {
                target.push(new TextLeaf(joined, prev.length + text.length));
            }
            else {
                let mid = joined.length >> 1;
                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));
            }
        }
        else {
            target.push(text);
        }
    }
    replace(from, to, text) {
        if (!(text instanceof TextLeaf))
            return super.replace(from, to, text);
        [from, to] = clip(this, from, to);
        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);
        let newLen = this.length + text.length - (to - from);
        if (lines.length <= 32 /* Tree.Branch */)
            return new TextLeaf(lines, newLen);
        return TextNode.from(TextLeaf.split(lines, []), newLen);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {
            let line = this.text[i], end = pos + line.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += line.slice(Math.max(0, from - pos), to - pos);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let line of this.text)
            target.push(line);
    }
    scanIdentical() { return 0; }
    static split(text, target) {
        let part = [], len = -1;
        for (let line of text) {
            part.push(line);
            len += line.length + 1;
            if (part.length == 32 /* Tree.Branch */) {
                target.push(new TextLeaf(part, len));
                part = [];
                len = -1;
            }
        }
        if (len > -1)
            target.push(new TextLeaf(part, len));
        return target;
    }
}
// Nodes provide the tree structure of the `Text` type. They store a
// number of other nodes or leaves, taking care to balance themselves
// on changes. There are implied line breaks _between_ the children of
// a node (but not before the first or after the last child).
class TextNode extends Text {
    constructor(children, length) {
        super();
        this.children = children;
        this.length = length;
        this.lines = 0;
        for (let child of children)
            this.lines += child.lines;
    }
    lineInner(target, isLine, line, offset) {
        for (let i = 0;; i++) {
            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;
            if ((isLine ? endLine : end) >= target)
                return child.lineInner(target, isLine, line, offset);
            offset = end + 1;
            line = endLine + 1;
        }
    }
    decompose(from, to, target, open) {
        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (from <= end && to >= pos) {
                let childOpen = open & ((pos <= from ? 1 /* Open.From */ : 0) | (end >= to ? 2 /* Open.To */ : 0));
                if (pos >= from && end <= to && !childOpen)
                    target.push(child);
                else
                    child.decompose(from - pos, to - pos, target, childOpen);
            }
            pos = end + 1;
        }
    }
    replace(from, to, text) {
        [from, to] = clip(this, from, to);
        if (text.lines < this.lines)
            for (let i = 0, pos = 0; i < this.children.length; i++) {
                let child = this.children[i], end = pos + child.length;
                // Fast path: if the change only affects one child and the
                // child's size remains in the acceptable range, only update
                // that child
                if (from >= pos && to <= end) {
                    let updated = child.replace(from - pos, to - pos, text);
                    let totalLines = this.lines - child.lines + updated.lines;
                    if (updated.lines < (totalLines >> (5 /* Tree.BranchShift */ - 1)) &&
                        updated.lines > (totalLines >> (5 /* Tree.BranchShift */ + 1))) {
                        let copy = this.children.slice();
                        copy[i] = updated;
                        return new TextNode(copy, this.length - (to - from) + text.length);
                    }
                    return super.replace(pos, end, updated);
                }
                pos = end + 1;
            }
        return super.replace(from, to, text);
    }
    sliceString(from, to = this.length, lineSep = "\n") {
        [from, to] = clip(this, from, to);
        let result = "";
        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos > from && i)
                result += lineSep;
            if (from < end && to > pos)
                result += child.sliceString(from - pos, to - pos, lineSep);
            pos = end + 1;
        }
        return result;
    }
    flatten(target) {
        for (let child of this.children)
            child.flatten(target);
    }
    scanIdentical(other, dir) {
        if (!(other instanceof TextNode))
            return 0;
        let length = 0;
        let [iA, iB, eA, eB] = dir > 0 ? [0, 0, this.children.length, other.children.length]
            : [this.children.length - 1, other.children.length - 1, -1, -1];
        for (;; iA += dir, iB += dir) {
            if (iA == eA || iB == eB)
                return length;
            let chA = this.children[iA], chB = other.children[iB];
            if (chA != chB)
                return length + chA.scanIdentical(chB, dir);
            length += chA.length + 1;
        }
    }
    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {
        let lines = 0;
        for (let ch of children)
            lines += ch.lines;
        if (lines < 32 /* Tree.Branch */) {
            let flat = [];
            for (let ch of children)
                ch.flatten(flat);
            return new TextLeaf(flat, length);
        }
        let chunk = Math.max(32 /* Tree.Branch */, lines >> 5 /* Tree.BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;
        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];
        function add(child) {
            let last;
            if (child.lines > maxChunk && child instanceof TextNode) {
                for (let node of child.children)
                    add(node);
            }
            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {
                flush();
                chunked.push(child);
            }
            else if (child instanceof TextLeaf && currentLines &&
                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&
                child.lines + last.lines <= 32 /* Tree.Branch */) {
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);
            }
            else {
                if (currentLines + child.lines > chunk)
                    flush();
                currentLines += child.lines;
                currentLen += child.length + 1;
                currentChunk.push(child);
            }
        }
        function flush() {
            if (currentLines == 0)
                return;
            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));
            currentLen = -1;
            currentLines = currentChunk.length = 0;
        }
        for (let child of children)
            add(child);
        flush();
        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);
    }
}
Text.empty = /*@__PURE__*/new TextLeaf([""], 0);
function textLength(text) {
    let length = -1;
    for (let line of text)
        length += line.length + 1;
    return length;
}
function appendText(text, target, from = 0, to = 1e9) {
    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {
        let line = text[i], end = pos + line.length;
        if (end >= from) {
            if (end > to)
                line = line.slice(0, to - pos);
            if (pos < from)
                line = line.slice(from - pos);
            if (first) {
                target[target.length - 1] += line;
                first = false;
            }
            else
                target.push(line);
        }
        pos = end + 1;
    }
    return target;
}
function sliceText(text, from, to) {
    return appendText(text, [""], from, to);
}
class RawTextCursor {
    constructor(text, dir = 1) {
        this.dir = dir;
        this.done = false;
        this.lineBreak = false;
        this.value = "";
        this.nodes = [text];
        this.offsets = [dir > 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) << 1];
    }
    nextInner(skip, dir) {
        this.done = this.lineBreak = false;
        for (;;) {
            let last = this.nodes.length - 1;
            let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue >> 1;
            let size = top instanceof TextLeaf ? top.text.length : top.children.length;
            if (offset == (dir > 0 ? size : 0)) {
                if (last == 0) {
                    this.done = true;
                    this.value = "";
                    return this;
                }
                if (dir > 0)
                    this.offsets[last - 1]++;
                this.nodes.pop();
                this.offsets.pop();
            }
            else if ((offsetValue & 1) == (dir > 0 ? 0 : 1)) {
                this.offsets[last] += dir;
                if (skip == 0) {
                    this.lineBreak = true;
                    this.value = "\n";
                    return this;
                }
                skip--;
            }
            else if (top instanceof TextLeaf) {
                // Move to the next string
                let next = top.text[offset + (dir < 0 ? -1 : 0)];
                this.offsets[last] += dir;
                if (next.length > Math.max(0, skip)) {
                    this.value = skip == 0 ? next : dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);
                    return this;
                }
                skip -= next.length;
            }
            else {
                let next = top.children[offset + (dir < 0 ? -1 : 0)];
                if (skip > next.length) {
                    skip -= next.length;
                    this.offsets[last] += dir;
                }
                else {
                    if (dir < 0)
                        this.offsets[last]--;
                    this.nodes.push(next);
                    this.offsets.push(dir > 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) << 1);
                }
            }
        }
    }
    next(skip = 0) {
        if (skip < 0) {
            this.nextInner(-skip, (-this.dir));
            skip = this.value.length;
        }
        return this.nextInner(skip, this.dir);
    }
}
class PartialTextCursor {
    constructor(text, start, end) {
        this.value = "";
        this.done = false;
        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);
        this.pos = start > end ? text.length : 0;
        this.from = Math.min(start, end);
        this.to = Math.max(start, end);
    }
    nextInner(skip, dir) {
        if (dir < 0 ? this.pos <= this.from : this.pos >= this.to) {
            this.value = "";
            this.done = true;
            return this;
        }
        skip += Math.max(0, dir < 0 ? this.pos - this.to : this.from - this.pos);
        let limit = dir < 0 ? this.pos - this.from : this.to - this.pos;
        if (skip > limit)
            skip = limit;
        limit -= skip;
        let { value } = this.cursor.next(skip);
        this.pos += (value.length + skip) * dir;
        this.value = value.length <= limit ? value : dir < 0 ? value.slice(value.length - limit) : value.slice(0, limit);
        this.done = !this.value;
        return this;
    }
    next(skip = 0) {
        if (skip < 0)
            skip = Math.max(skip, this.from - this.pos);
        else if (skip > 0)
            skip = Math.min(skip, this.to - this.pos);
        return this.nextInner(skip, this.cursor.dir);
    }
    get lineBreak() { return this.cursor.lineBreak && this.value != ""; }
}
class LineCursor {
    constructor(inner) {
        this.inner = inner;
        this.afterBreak = true;
        this.value = "";
        this.done = false;
    }
    next(skip = 0) {
        let { done, lineBreak, value } = this.inner.next(skip);
        if (done && this.afterBreak) {
            this.value = "";
            this.afterBreak = false;
        }
        else if (done) {
            this.done = true;
            this.value = "";
        }
        else if (lineBreak) {
            if (this.afterBreak) {
                this.value = "";
            }
            else {
                this.afterBreak = true;
                this.next();
            }
        }
        else {
            this.value = value;
            this.afterBreak = false;
        }
        return this;
    }
    get lineBreak() { return false; }
}
if (typeof Symbol != "undefined") {
    Text.prototype[Symbol.iterator] = function () { return this.iter(); };
    RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =
        LineCursor.prototype[Symbol.iterator] = function () { return this; };
}
/**
This type describes a line in the document. It is created
on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).
*/
class Line {
    /**
    @internal
    */
    constructor(
    /**
    The position of the start of the line.
    */
    from, 
    /**
    The position at the end of the line (_before_ the line break,
    or at the end of document for the last line).
    */
    to, 
    /**
    This line's line number (1-based).
    */
    number, 
    /**
    The line's content.
    */
    text) {
        this.from = from;
        this.to = to;
        this.number = number;
        this.text = text;
    }
    /**
    The length of the line (not including any line break after it).
    */
    get length() { return this.to - this.from; }
}
function clip(text, from, to) {
    from = Math.max(0, Math.min(text.length, from));
    return [from, Math.max(from, Math.min(text.length, to))];
}

// Compressed representation of the Grapheme_Cluster_Break=Extend
// information from
// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.
// Each pair of elements represents a range, as an offet from the
// previous range and a length. Numbers are in base-36, with the empty
// string being a shorthand for 1.
let extend = /*@__PURE__*/"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map(s => s ? parseInt(s, 36) : 1);
// Convert offsets into absolute values
for (let i = 1; i < extend.length; i++)
    extend[i] += extend[i - 1];
function isExtendingChar(code) {
    for (let i = 1; i < extend.length; i += 2)
        if (extend[i] > code)
            return extend[i - 1] <= code;
    return false;
}
function isRegionalIndicator(code) {
    return code >= 0x1F1E6 && code <= 0x1F1FF;
}
const ZWJ = 0x200d;
/**
Returns a next grapheme cluster break _after_ (not equal to)
`pos`, if `forward` is true, or before otherwise. Returns `pos`
itself if no further cluster break is available in the string.
Moves across surrogate pairs, extending characters (when
`includeExtending` is true), characters joined with zero-width
joiners, and flag emoji.
*/
function findClusterBreak(str, pos, forward = true, includeExtending = true) {
    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending);
}
function nextClusterBreak(str, pos, includeExtending) {
    if (pos == str.length)
        return pos;
    // If pos is in the middle of a surrogate pair, move to its start
    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))
        pos--;
    let prev = codePointAt(str, pos);
    pos += codePointSize(prev);
    while (pos < str.length) {
        let next = codePointAt(str, pos);
        if (prev == ZWJ || next == ZWJ || includeExtending && isExtendingChar(next)) {
            pos += codePointSize(next);
            prev = next;
        }
        else if (isRegionalIndicator(next)) {
            let countBefore = 0, i = pos - 2;
            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {
                countBefore++;
                i -= 2;
            }
            if (countBefore % 2 == 0)
                break;
            else
                pos += 2;
        }
        else {
            break;
        }
    }
    return pos;
}
function prevClusterBreak(str, pos, includeExtending) {
    while (pos > 0) {
        let found = nextClusterBreak(str, pos - 2, includeExtending);
        if (found < pos)
            return found;
        pos--;
    }
    return 0;
}
function surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }
function surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }
/**
Find the code point at the given position in a string (like the
[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
string method).
*/
function codePointAt(str, pos) {
    let code0 = str.charCodeAt(pos);
    if (!surrogateHigh(code0) || pos + 1 == str.length)
        return code0;
    let code1 = str.charCodeAt(pos + 1);
    if (!surrogateLow(code1))
        return code0;
    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;
}
/**
Given a Unicode codepoint, return the JavaScript string that
respresents it (like
[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).
*/
function fromCodePoint(code) {
    if (code <= 0xffff)
        return String.fromCharCode(code);
    code -= 0x10000;
    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);
}
/**
The amount of positions a character takes up a JavaScript string.
*/
function codePointSize(code) { return code < 0x10000 ? 1 : 2; }

const DefaultSplit = /\r\n?|\n/;
/**
Distinguishes different ways in which positions can be mapped.
*/
var MapMode = /*@__PURE__*/(function (MapMode) {
    /**
    Map a position to a valid new position, even when its context
    was deleted.
    */
    MapMode[MapMode["Simple"] = 0] = "Simple";
    /**
    Return null if deletion happens across the position.
    */
    MapMode[MapMode["TrackDel"] = 1] = "TrackDel";
    /**
    Return null if the character _before_ the position is deleted.
    */
    MapMode[MapMode["TrackBefore"] = 2] = "TrackBefore";
    /**
    Return null if the character _after_ the position is deleted.
    */
    MapMode[MapMode["TrackAfter"] = 3] = "TrackAfter";
return MapMode})(MapMode || (MapMode = {}));
/**
A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)
that doesn't store the inserted text. As such, it can't be
applied, but is cheaper to store and manipulate.
*/
class ChangeDesc {
    // Sections are encoded as pairs of integers. The first is the
    // length in the current document, and the second is -1 for
    // unaffected sections, and the length of the replacement content
    // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
    // 0), and a replacement two positive numbers.
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    sections) {
        this.sections = sections;
    }
    /**
    The length of the document before the change.
    */
    get length() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2)
            result += this.sections[i];
        return result;
    }
    /**
    The length of the document after the change.
    */
    get newLength() {
        let result = 0;
        for (let i = 0; i < this.sections.length; i += 2) {
            let ins = this.sections[i + 1];
            result += ins < 0 ? this.sections[i] : ins;
        }
        return result;
    }
    /**
    False when there are actual changes in this set.
    */
    get empty() { return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0; }
    /**
    Iterate over the unchanged parts left by these changes. `posA`
    provides the position of the range in the old document, `posB`
    the new position in the changed document.
    */
    iterGaps(f) {
        for (let i = 0, posA = 0, posB = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0) {
                f(posA, posB, len);
                posB += len;
            }
            else {
                posB += ins;
            }
            posA += len;
        }
    }
    /**
    Iterate over the ranges changed by these changes. (See
    [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
    variant that also provides you with the inserted text.)
    `fromA`/`toA` provides the extent of the change in the starting
    document, `fromB`/`toB` the extent of the replacement in the
    changed document.
    
    When `individual` is true, adjacent changes (which are kept
    separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
    reported separately.
    */
    iterChangedRanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a description of the inverted form of these changes.
    */
    get invertedDesc() {
        let sections = [];
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            if (ins < 0)
                sections.push(len, ins);
            else
                sections.push(ins, len);
        }
        return new ChangeDesc(sections);
    }
    /**
    Compute the combined effect of applying another set of changes
    after this one. The length of the document after this set should
    match the length before `other`.
    */
    composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }
    /**
    Map this description, which should start with the same document
    as `other`, over another set of changes, so that it can be
    applied after it. When `before` is true, map as if the changes
    in `other` happened before the ones in `this`.
    */
    mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }
    mapPos(pos, assoc = -1, mode = MapMode.Simple) {
        let posA = 0, posB = 0;
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;
            if (ins < 0) {
                if (endA > pos)
                    return posB + (pos - posA);
                posB += len;
            }
            else {
                if (mode != MapMode.Simple && endA >= pos &&
                    (mode == MapMode.TrackDel && posA < pos && endA > pos ||
                        mode == MapMode.TrackBefore && posA < pos ||
                        mode == MapMode.TrackAfter && endA > pos))
                    return null;
                if (endA > pos || endA == pos && assoc < 0 && !len)
                    return pos == posA || assoc < 0 ? posB : posB + ins;
                posB += ins;
            }
            posA = endA;
        }
        if (pos > posA)
            throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);
        return posB;
    }
    /**
    Check whether these changes touch a given range. When one of the
    changes entirely covers the range, the string `"cover"` is
    returned.
    */
    touchesRange(from, to = from) {
        for (let i = 0, pos = 0; i < this.sections.length && pos <= to;) {
            let len = this.sections[i++], ins = this.sections[i++], end = pos + len;
            if (ins >= 0 && pos <= to && end >= from)
                return pos < from && end > to ? "cover" : true;
            pos = end;
        }
        return false;
    }
    /**
    @internal
    */
    toString() {
        let result = "";
        for (let i = 0; i < this.sections.length;) {
            let len = this.sections[i++], ins = this.sections[i++];
            result += (result ? " " : "") + len + (ins >= 0 ? ":" + ins : "");
        }
        return result;
    }
    /**
    Serialize this change desc to a JSON-representable value.
    */
    toJSON() { return this.sections; }
    /**
    Create a change desc from its JSON representation (as produced
    by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json) || json.length % 2 || json.some(a => typeof a != "number"))
            throw new RangeError("Invalid JSON representation of ChangeDesc");
        return new ChangeDesc(json);
    }
    /**
    @internal
    */
    static create(sections) { return new ChangeDesc(sections); }
}
/**
A change set represents a group of modifications to a document. It
stores the document length, and can only be applied to documents
with exactly that length.
*/
class ChangeSet extends ChangeDesc {
    constructor(sections, 
    /**
    @internal
    */
    inserted) {
        super(sections);
        this.inserted = inserted;
    }
    /**
    Apply the changes to a document, returning the modified
    document.
    */
    apply(doc) {
        if (this.length != doc.length)
            throw new RangeError("Applying change set to a document with the wrong length");
        iterChanges(this, (fromA, toA, fromB, _toB, text) => doc = doc.replace(fromB, fromB + (toA - fromA), text), false);
        return doc;
    }
    mapDesc(other, before = false) { return mapSet(this, other, before, true); }
    /**
    Given the document as it existed _before_ the changes, return a
    change set that represents the inverse of this set, which could
    be used to go from the document created by the changes back to
    the document as it existed before the changes.
    */
    invert(doc) {
        let sections = this.sections.slice(), inserted = [];
        for (let i = 0, pos = 0; i < sections.length; i += 2) {
            let len = sections[i], ins = sections[i + 1];
            if (ins >= 0) {
                sections[i] = ins;
                sections[i + 1] = len;
                let index = i >> 1;
                while (inserted.length < index)
                    inserted.push(Text.empty);
                inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);
            }
            pos += len;
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    Combine two subsequent change sets into a single set. `other`
    must start in the document produced by `this`. If `this` goes
    `docA` → `docB` and `other` represents `docB` → `docC`, the
    returned value will represent the change `docA` → `docC`.
    */
    compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }
    /**
    Given another change set starting in the same document, maps this
    change set over the other, producing a new change set that can be
    applied to the document produced by applying `other`. When
    `before` is `true`, order changes as if `this` comes before
    `other`, otherwise (the default) treat `other` as coming first.
    
    Given two changes `A` and `B`, `A.compose(B.map(A))` and
    `B.compose(A.map(B, true))` will produce the same document. This
    provides a basic form of [operational
    transformation](https://en.wikipedia.org/wiki/Operational_transformation),
    and can be used for collaborative editing.
    */
    map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }
    /**
    Iterate over the changed ranges in the document, calling `f` for
    each, with the range in the original document (`fromA`-`toA`)
    and the range that replaces it in the new document
    (`fromB`-`toB`).
    
    When `individual` is true, adjacent changes are reported
    separately.
    */
    iterChanges(f, individual = false) {
        iterChanges(this, f, individual);
    }
    /**
    Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
    set.
    */
    get desc() { return ChangeDesc.create(this.sections); }
    /**
    @internal
    */
    filter(ranges) {
        let resultSections = [], resultInserted = [], filteredSections = [];
        let iter = new SectionIter(this);
        done: for (let i = 0, pos = 0;;) {
            let next = i == ranges.length ? 1e9 : ranges[i++];
            while (pos < next || pos == next && iter.len == 0) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, next - pos);
                addSection(filteredSections, len, -1);
                let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;
                addSection(resultSections, len, ins);
                if (ins > 0)
                    addInsert(resultInserted, resultSections, iter.text);
                iter.forward(len);
                pos += len;
            }
            let end = ranges[i++];
            while (pos < end) {
                if (iter.done)
                    break done;
                let len = Math.min(iter.len, end - pos);
                addSection(resultSections, len, -1);
                addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);
                iter.forward(len);
                pos += len;
            }
        }
        return { changes: new ChangeSet(resultSections, resultInserted),
            filtered: ChangeDesc.create(filteredSections) };
    }
    /**
    Serialize this change set to a JSON-representable value.
    */
    toJSON() {
        let parts = [];
        for (let i = 0; i < this.sections.length; i += 2) {
            let len = this.sections[i], ins = this.sections[i + 1];
            if (ins < 0)
                parts.push(len);
            else if (ins == 0)
                parts.push([len]);
            else
                parts.push([len].concat(this.inserted[i >> 1].toJSON()));
        }
        return parts;
    }
    /**
    Create a change set for the given changes, for a document of the
    given length, using `lineSep` as line separator.
    */
    static of(changes, length, lineSep) {
        let sections = [], inserted = [], pos = 0;
        let total = null;
        function flush(force = false) {
            if (!force && !sections.length)
                return;
            if (pos < length)
                addSection(sections, length - pos, -1);
            let set = new ChangeSet(sections, inserted);
            total = total ? total.compose(set.map(total)) : set;
            sections = [];
            inserted = [];
            pos = 0;
        }
        function process(spec) {
            if (Array.isArray(spec)) {
                for (let sub of spec)
                    process(sub);
            }
            else if (spec instanceof ChangeSet) {
                if (spec.length != length)
                    throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
                flush();
                total = total ? total.compose(spec.map(total)) : spec;
            }
            else {
                let { from, to = from, insert } = spec;
                if (from > to || from < 0 || to > length)
                    throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);
                let insText = !insert ? Text.empty : typeof insert == "string" ? Text.of(insert.split(lineSep || DefaultSplit)) : insert;
                let insLen = insText.length;
                if (from == to && insLen == 0)
                    return;
                if (from < pos)
                    flush();
                if (from > pos)
                    addSection(sections, from - pos, -1);
                addSection(sections, to - from, insLen);
                addInsert(inserted, sections, insText);
                pos = to;
            }
        }
        process(changes);
        flush(!total);
        return total;
    }
    /**
    Create an empty changeset of the given length.
    */
    static empty(length) {
        return new ChangeSet(length ? [length, -1] : [], []);
    }
    /**
    Create a changeset from its JSON representation (as produced by
    [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
    */
    static fromJSON(json) {
        if (!Array.isArray(json))
            throw new RangeError("Invalid JSON representation of ChangeSet");
        let sections = [], inserted = [];
        for (let i = 0; i < json.length; i++) {
            let part = json[i];
            if (typeof part == "number") {
                sections.push(part, -1);
            }
            else if (!Array.isArray(part) || typeof part[0] != "number" || part.some((e, i) => i && typeof e != "string")) {
                throw new RangeError("Invalid JSON representation of ChangeSet");
            }
            else if (part.length == 1) {
                sections.push(part[0], 0);
            }
            else {
                while (inserted.length < i)
                    inserted.push(Text.empty);
                inserted[i] = Text.of(part.slice(1));
                sections.push(part[0], inserted[i].length);
            }
        }
        return new ChangeSet(sections, inserted);
    }
    /**
    @internal
    */
    static createSet(sections, inserted) {
        return new ChangeSet(sections, inserted);
    }
}
function addSection(sections, len, ins, forceJoin = false) {
    if (len == 0 && ins <= 0)
        return;
    let last = sections.length - 2;
    if (last >= 0 && ins <= 0 && ins == sections[last + 1])
        sections[last] += len;
    else if (len == 0 && sections[last] == 0)
        sections[last + 1] += ins;
    else if (forceJoin) {
        sections[last] += len;
        sections[last + 1] += ins;
    }
    else
        sections.push(len, ins);
}
function addInsert(values, sections, value) {
    if (value.length == 0)
        return;
    let index = (sections.length - 2) >> 1;
    if (index < values.length) {
        values[values.length - 1] = values[values.length - 1].append(value);
    }
    else {
        while (values.length < index)
            values.push(Text.empty);
        values.push(value);
    }
}
function iterChanges(desc, f, individual) {
    let inserted = desc.inserted;
    for (let posA = 0, posB = 0, i = 0; i < desc.sections.length;) {
        let len = desc.sections[i++], ins = desc.sections[i++];
        if (ins < 0) {
            posA += len;
            posB += len;
        }
        else {
            let endA = posA, endB = posB, text = Text.empty;
            for (;;) {
                endA += len;
                endB += ins;
                if (ins && inserted)
                    text = text.append(inserted[(i - 2) >> 1]);
                if (individual || i == desc.sections.length || desc.sections[i + 1] < 0)
                    break;
                len = desc.sections[i++];
                ins = desc.sections[i++];
            }
            f(posA, endA, posB, endB, text);
            posA = endA;
            posB = endB;
        }
    }
}
function mapSet(setA, setB, before, mkSet = false) {
    // Produce a copy of setA that applies to the document after setB
    // has been applied (assuming both start at the same document).
    let sections = [], insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    // Iterate over both sets in parallel. inserted tracks, for changes
    // in A that have to be processed piece-by-piece, whether their
    // content has been inserted already, and refers to the section
    // index.
    for (let inserted = -1;;) {
        if (a.ins == -1 && b.ins == -1) {
            // Move across ranges skipped by both sets.
            let len = Math.min(a.len, b.len);
            addSection(sections, len, -1);
            a.forward(len);
            b.forward(len);
        }
        else if (b.ins >= 0 && (a.ins < 0 || inserted == a.i || a.off == 0 && (b.len < a.len || b.len == a.len && !before))) {
            // If there's a change in B that comes before the next change in
            // A (ordered by start pos, then len, then before flag), skip
            // that (and process any changes in A it covers).
            let len = b.len;
            addSection(sections, b.ins, -1);
            while (len) {
                let piece = Math.min(a.len, len);
                if (a.ins >= 0 && inserted < a.i && a.len <= piece) {
                    addSection(sections, 0, a.ins);
                    if (insert)
                        addInsert(insert, sections, a.text);
                    inserted = a.i;
                }
                a.forward(piece);
                len -= piece;
            }
            b.next();
        }
        else if (a.ins >= 0) {
            // Process the part of a change in A up to the start of the next
            // non-deletion change in B (if overlapping).
            let len = 0, left = a.len;
            while (left) {
                if (b.ins == -1) {
                    let piece = Math.min(left, b.len);
                    len += piece;
                    left -= piece;
                    b.forward(piece);
                }
                else if (b.ins == 0 && b.len < left) {
                    left -= b.len;
                    b.next();
                }
                else {
                    break;
                }
            }
            addSection(sections, len, inserted < a.i ? a.ins : 0);
            if (insert && inserted < a.i)
                addInsert(insert, sections, a.text);
            inserted = a.i;
            a.forward(a.len - left);
        }
        else if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else {
            throw new Error("Mismatched change set lengths");
        }
    }
}
function composeSets(setA, setB, mkSet = false) {
    let sections = [];
    let insert = mkSet ? [] : null;
    let a = new SectionIter(setA), b = new SectionIter(setB);
    for (let open = false;;) {
        if (a.done && b.done) {
            return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);
        }
        else if (a.ins == 0) { // Deletion in A
            addSection(sections, a.len, 0, open);
            a.next();
        }
        else if (b.len == 0 && !b.done) { // Insertion in B
            addSection(sections, 0, b.ins, open);
            if (insert)
                addInsert(insert, sections, b.text);
            b.next();
        }
        else if (a.done || b.done) {
            throw new Error("Mismatched change set lengths");
        }
        else {
            let len = Math.min(a.len2, b.len), sectionLen = sections.length;
            if (a.ins == -1) {
                let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;
                addSection(sections, len, insB, open);
                if (insert && insB)
                    addInsert(insert, sections, b.text);
            }
            else if (b.ins == -1) {
                addSection(sections, a.off ? 0 : a.len, len, open);
                if (insert)
                    addInsert(insert, sections, a.textBit(len));
            }
            else {
                addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);
                if (insert && !b.off)
                    addInsert(insert, sections, b.text);
            }
            open = (a.ins > len || b.ins >= 0 && b.len > len) && (open || sections.length > sectionLen);
            a.forward2(len);
            b.forward(len);
        }
    }
}
class SectionIter {
    constructor(set) {
        this.set = set;
        this.i = 0;
        this.next();
    }
    next() {
        let { sections } = this.set;
        if (this.i < sections.length) {
            this.len = sections[this.i++];
            this.ins = sections[this.i++];
        }
        else {
            this.len = 0;
            this.ins = -2;
        }
        this.off = 0;
    }
    get done() { return this.ins == -2; }
    get len2() { return this.ins < 0 ? this.len : this.ins; }
    get text() {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length ? Text.empty : inserted[index];
    }
    textBit(len) {
        let { inserted } = this.set, index = (this.i - 2) >> 1;
        return index >= inserted.length && !len ? Text.empty
            : inserted[index].slice(this.off, len == null ? undefined : this.off + len);
    }
    forward(len) {
        if (len == this.len)
            this.next();
        else {
            this.len -= len;
            this.off += len;
        }
    }
    forward2(len) {
        if (this.ins == -1)
            this.forward(len);
        else if (len == this.ins)
            this.next();
        else {
            this.ins -= len;
            this.off += len;
        }
    }
}

/**
A single selection range. When
[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold
multiple ranges. By default, selections hold exactly one range.
*/
class SelectionRange {
    constructor(
    /**
    The lower boundary of the range.
    */
    from, 
    /**
    The upper boundary of the range.
    */
    to, flags) {
        this.from = from;
        this.to = to;
        this.flags = flags;
    }
    /**
    The anchor of the range—the side that doesn't move when you
    extend it.
    */
    get anchor() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.to : this.from; }
    /**
    The head of the range, which is moved when the range is
    [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
    */
    get head() { return this.flags & 32 /* RangeFlag.Inverted */ ? this.from : this.to; }
    /**
    True when `anchor` and `head` are at the same position.
    */
    get empty() { return this.from == this.to; }
    /**
    If this is a cursor that is explicitly associated with the
    character on one of its sides, this returns the side. -1 means
    the character before its position, 1 the character after, and 0
    means no association.
    */
    get assoc() { return this.flags & 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags & 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }
    /**
    The bidirectional text level associated with this cursor, if
    any.
    */
    get bidiLevel() {
        let level = this.flags & 7 /* RangeFlag.BidiLevelMask */;
        return level == 7 ? null : level;
    }
    /**
    The goal column (stored vertical offset) associated with a
    cursor. This is used to preserve the vertical position when
    [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
    lines of different length.
    */
    get goalColumn() {
        let value = this.flags >> 6 /* RangeFlag.GoalColumnOffset */;
        return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;
    }
    /**
    Map this range through a change, producing a valid range in the
    updated document.
    */
    map(change, assoc = -1) {
        let from, to;
        if (this.empty) {
            from = to = change.mapPos(this.from, assoc);
        }
        else {
            from = change.mapPos(this.from, 1);
            to = change.mapPos(this.to, -1);
        }
        return from == this.from && to == this.to ? this : new SelectionRange(from, to, this.flags);
    }
    /**
    Extend this range to cover at least `from` to `to`.
    */
    extend(from, to = from) {
        if (from <= this.anchor && to >= this.anchor)
            return dist_EditorSelection.range(from, to);
        let head = Math.abs(from - this.anchor) > Math.abs(to - this.anchor) ? from : to;
        return dist_EditorSelection.range(this.anchor, head);
    }
    /**
    Compare this range to another range.
    */
    eq(other) {
        return this.anchor == other.anchor && this.head == other.head;
    }
    /**
    Return a JSON-serializable object representing the range.
    */
    toJSON() { return { anchor: this.anchor, head: this.head }; }
    /**
    Convert a JSON representation of a range to a `SelectionRange`
    instance.
    */
    static fromJSON(json) {
        if (!json || typeof json.anchor != "number" || typeof json.head != "number")
            throw new RangeError("Invalid JSON representation for SelectionRange");
        return dist_EditorSelection.range(json.anchor, json.head);
    }
    /**
    @internal
    */
    static create(from, to, flags) {
        return new SelectionRange(from, to, flags);
    }
}
/**
An editor selection holds one or more selection ranges.
*/
class dist_EditorSelection {
    constructor(
    /**
    The ranges in the selection, sorted by position. Ranges cannot
    overlap (but they may touch, if they aren't empty).
    */
    ranges, 
    /**
    The index of the _main_ range in the selection (which is
    usually the range that was added last).
    */
    mainIndex) {
        this.ranges = ranges;
        this.mainIndex = mainIndex;
    }
    /**
    Map a selection through a change. Used to adjust the selection
    position for changes.
    */
    map(change, assoc = -1) {
        if (change.empty)
            return this;
        return dist_EditorSelection.create(this.ranges.map(r => r.map(change, assoc)), this.mainIndex);
    }
    /**
    Compare this selection to another selection.
    */
    eq(other) {
        if (this.ranges.length != other.ranges.length ||
            this.mainIndex != other.mainIndex)
            return false;
        for (let i = 0; i < this.ranges.length; i++)
            if (!this.ranges[i].eq(other.ranges[i]))
                return false;
        return true;
    }
    /**
    Get the primary selection range. Usually, you should make sure
    your code applies to _all_ ranges, by using methods like
    [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
    */
    get main() { return this.ranges[this.mainIndex]; }
    /**
    Make sure the selection only has one range. Returns a selection
    holding only the main range from this selection.
    */
    asSingle() {
        return this.ranges.length == 1 ? this : new dist_EditorSelection([this.main], 0);
    }
    /**
    Extend this selection with an extra range.
    */
    addRange(range, main = true) {
        return dist_EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);
    }
    /**
    Replace a given range with another range, and then normalize the
    selection to merge and sort ranges if necessary.
    */
    replaceRange(range, which = this.mainIndex) {
        let ranges = this.ranges.slice();
        ranges[which] = range;
        return dist_EditorSelection.create(ranges, this.mainIndex);
    }
    /**
    Convert this selection to an object that can be serialized to
    JSON.
    */
    toJSON() {
        return { ranges: this.ranges.map(r => r.toJSON()), main: this.mainIndex };
    }
    /**
    Create a selection from a JSON representation.
    */
    static fromJSON(json) {
        if (!json || !Array.isArray(json.ranges) || typeof json.main != "number" || json.main >= json.ranges.length)
            throw new RangeError("Invalid JSON representation for EditorSelection");
        return new dist_EditorSelection(json.ranges.map((r) => SelectionRange.fromJSON(r)), json.main);
    }
    /**
    Create a selection holding a single range.
    */
    static single(anchor, head = anchor) {
        return new dist_EditorSelection([dist_EditorSelection.range(anchor, head)], 0);
    }
    /**
    Sort and merge the given set of ranges, creating a valid
    selection.
    */
    static create(ranges, mainIndex = 0) {
        if (ranges.length == 0)
            throw new RangeError("A selection needs at least one range");
        for (let pos = 0, i = 0; i < ranges.length; i++) {
            let range = ranges[i];
            if (range.empty ? range.from <= pos : range.from < pos)
                return dist_EditorSelection.normalized(ranges.slice(), mainIndex);
            pos = range.to;
        }
        return new dist_EditorSelection(ranges, mainIndex);
    }
    /**
    Create a cursor selection range at the given position. You can
    safely ignore the optional arguments in most situations.
    */
    static cursor(pos, assoc = 0, bidiLevel, goalColumn) {
        return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc < 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |
            ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */));
    }
    /**
    Create a selection range.
    */
    static range(anchor, head, goalColumn, bidiLevel) {
        let flags = ((goalColumn !== null && goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) << 6 /* RangeFlag.GoalColumnOffset */) |
            (bidiLevel == null ? 7 : Math.min(6, bidiLevel));
        return head < anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)
            : SelectionRange.create(anchor, head, (head > anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);
    }
    /**
    @internal
    */
    static normalized(ranges, mainIndex = 0) {
        let main = ranges[mainIndex];
        ranges.sort((a, b) => a.from - b.from);
        mainIndex = ranges.indexOf(main);
        for (let i = 1; i < ranges.length; i++) {
            let range = ranges[i], prev = ranges[i - 1];
            if (range.empty ? range.from <= prev.to : range.from < prev.to) {
                let from = prev.from, to = Math.max(range.to, prev.to);
                if (i <= mainIndex)
                    mainIndex--;
                ranges.splice(--i, 2, range.anchor > range.head ? dist_EditorSelection.range(to, from) : dist_EditorSelection.range(from, to));
            }
        }
        return new dist_EditorSelection(ranges, mainIndex);
    }
}
function checkSelection(selection, docLength) {
    for (let range of selection.ranges)
        if (range.to > docLength)
            throw new RangeError("Selection points outside of document");
}

let nextID = 0;
/**
A facet is a labeled value that is associated with an editor
state. It takes inputs from any number of extensions, and combines
those into a single output value.

Examples of uses of facets are the [tab
size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor
attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update
listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).

Note that `Facet` instances can be used anywhere where
[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.
*/
class Facet {
    constructor(
    /**
    @internal
    */
    combine, 
    /**
    @internal
    */
    compareInput, 
    /**
    @internal
    */
    compare, isStatic, enables) {
        this.combine = combine;
        this.compareInput = compareInput;
        this.compare = compare;
        this.isStatic = isStatic;
        /**
        @internal
        */
        this.id = nextID++;
        this.default = combine([]);
        this.extensions = typeof enables == "function" ? enables(this) : enables;
    }
    /**
    Returns a facet reader for this facet, which can be used to
    [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
    */
    get reader() { return this; }
    /**
    Define a new facet.
    */
    static define(config = {}) {
        return new Facet(config.combine || ((a) => a), config.compareInput || ((a, b) => a === b), config.compare || (!config.combine ? sameArray : (a, b) => a === b), !!config.static, config.enables);
    }
    /**
    Returns an extension that adds the given value to this facet.
    */
    of(value) {
        return new FacetProvider([], this, 0 /* Provider.Static */, value);
    }
    /**
    Create an extension that computes a value for the facet from a
    state. You must take care to declare the parts of the state that
    this value depends on, since your function is only called again
    for a new state when one of those parts changed.
    
    In cases where your value depends only on a single field, you'll
    want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
    */
    compute(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 1 /* Provider.Single */, get);
    }
    /**
    Create an extension that computes zero or more values for this
    facet from a state.
    */
    computeN(deps, get) {
        if (this.isStatic)
            throw new Error("Can't compute a static facet");
        return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);
    }
    from(field, get) {
        if (!get)
            get = x => x;
        return this.compute([field], state => get(state.field(field)));
    }
}
function sameArray(a, b) {
    return a == b || a.length == b.length && a.every((e, i) => e === b[i]);
}
class FacetProvider {
    constructor(dependencies, facet, type, value) {
        this.dependencies = dependencies;
        this.facet = facet;
        this.type = type;
        this.value = value;
        this.id = nextID++;
    }
    dynamicSlot(addresses) {
        var _a;
        let getter = this.value;
        let compare = this.facet.compareInput;
        let id = this.id, idx = addresses[id] >> 1, multi = this.type == 2 /* Provider.Multi */;
        let depDoc = false, depSel = false, depAddrs = [];
        for (let dep of this.dependencies) {
            if (dep == "doc")
                depDoc = true;
            else if (dep == "selection")
                depSel = true;
            else if ((((_a = addresses[dep.id]) !== null && _a !== void 0 ? _a : 1) & 1) == 0)
                depAddrs.push(addresses[dep.id]);
        }
        return {
            create(state) {
                state.values[idx] = getter(state);
                return 1 /* SlotStatus.Changed */;
            },
            update(state, tr) {
                if ((depDoc && tr.docChanged) || (depSel && (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {
                    let newVal = getter(state);
                    if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {
                        state.values[idx] = newVal;
                        return 1 /* SlotStatus.Changed */;
                    }
                }
                return 0;
            },
            reconfigure: (state, oldState) => {
                let newVal, oldAddr = oldState.config.address[id];
                if (oldAddr != null) {
                    let oldVal = getAddr(oldState, oldAddr);
                    if (this.dependencies.every(dep => {
                        return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :
                            dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;
                    }) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {
                        state.values[idx] = oldVal;
                        return 0;
                    }
                }
                else {
                    newVal = getter(state);
                }
                state.values[idx] = newVal;
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
}
function compareArray(a, b, compare) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!compare(a[i], b[i]))
            return false;
    return true;
}
function ensureAll(state, addrs) {
    let changed = false;
    for (let addr of addrs)
        if (ensureAddr(state, addr) & 1 /* SlotStatus.Changed */)
            changed = true;
    return changed;
}
function dynamicFacetSlot(addresses, facet, providers) {
    let providerAddrs = providers.map(p => addresses[p.id]);
    let providerTypes = providers.map(p => p.type);
    let dynamic = providerAddrs.filter(p => !(p & 1));
    let idx = addresses[facet.id] >> 1;
    function get(state) {
        let values = [];
        for (let i = 0; i < providerAddrs.length; i++) {
            let value = getAddr(state, providerAddrs[i]);
            if (providerTypes[i] == 2 /* Provider.Multi */)
                for (let val of value)
                    values.push(val);
            else
                values.push(value);
        }
        return facet.combine(values);
    }
    return {
        create(state) {
            for (let addr of providerAddrs)
                ensureAddr(state, addr);
            state.values[idx] = get(state);
            return 1 /* SlotStatus.Changed */;
        },
        update(state, tr) {
            if (!ensureAll(state, dynamic))
                return 0;
            let value = get(state);
            if (facet.compare(value, state.values[idx]))
                return 0;
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        },
        reconfigure(state, oldState) {
            let depChanged = ensureAll(state, providerAddrs);
            let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);
            if (oldProviders && !depChanged && sameArray(providers, oldProviders)) {
                state.values[idx] = oldValue;
                return 0;
            }
            let value = get(state);
            if (facet.compare(value, oldValue)) {
                state.values[idx] = oldValue;
                return 0;
            }
            state.values[idx] = value;
            return 1 /* SlotStatus.Changed */;
        }
    };
}
const initField = /*@__PURE__*/Facet.define({ static: true });
/**
Fields can store additional information in an editor state, and
keep it in sync with the rest of the state.
*/
class StateField {
    constructor(
    /**
    @internal
    */
    id, createF, updateF, compareF, 
    /**
    @internal
    */
    spec) {
        this.id = id;
        this.createF = createF;
        this.updateF = updateF;
        this.compareF = compareF;
        this.spec = spec;
        /**
        @internal
        */
        this.provides = undefined;
    }
    /**
    Define a state field.
    */
    static define(config) {
        let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) => a === b), config);
        if (config.provide)
            field.provides = config.provide(field);
        return field;
    }
    create(state) {
        let init = state.facet(initField).find(i => i.field == this);
        return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);
    }
    /**
    @internal
    */
    slot(addresses) {
        let idx = addresses[this.id] >> 1;
        return {
            create: (state) => {
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            },
            update: (state, tr) => {
                let oldVal = state.values[idx];
                let value = this.updateF(oldVal, tr);
                if (this.compareF(oldVal, value))
                    return 0;
                state.values[idx] = value;
                return 1 /* SlotStatus.Changed */;
            },
            reconfigure: (state, oldState) => {
                if (oldState.config.address[this.id] != null) {
                    state.values[idx] = oldState.field(this);
                    return 0;
                }
                state.values[idx] = this.create(state);
                return 1 /* SlotStatus.Changed */;
            }
        };
    }
    /**
    Returns an extension that enables this field and overrides the
    way it is initialized. Can be useful when you need to provide a
    non-default starting value for the field.
    */
    init(create) {
        return [this, initField.of({ field: this, create })];
    }
    /**
    State field instances can be used as
    [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
    given state.
    */
    get extension() { return this; }
}
const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function prec(value) {
    return (ext) => new PrecExtension(ext, value);
}
/**
By default extensions are registered in the order they are found
in the flattened form of nested array that was provided.
Individual extension values can be assigned a precedence to
override this. Extensions that do not have a precedence set get
the precedence of the nearest parent with a precedence, or
[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The
final ordering of extensions is determined by first sorting by
precedence and then by order within each precedence.
*/
const Prec = {
    /**
    The highest precedence level, for extensions that should end up
    near the start of the precedence ordering.
    */
    highest: /*@__PURE__*/prec(Prec_.highest),
    /**
    A higher-than-default precedence, for extensions that should
    come before those with default precedence.
    */
    high: /*@__PURE__*/prec(Prec_.high),
    /**
    The default precedence, which is also used for extensions
    without an explicit precedence.
    */
    default: /*@__PURE__*/prec(Prec_.default),
    /**
    A lower-than-default precedence.
    */
    low: /*@__PURE__*/prec(Prec_.low),
    /**
    The lowest precedence level. Meant for things that should end up
    near the end of the extension order.
    */
    lowest: /*@__PURE__*/prec(Prec_.lowest)
};
class PrecExtension {
    constructor(inner, prec) {
        this.inner = inner;
        this.prec = prec;
    }
}
/**
Extension compartments can be used to make a configuration
dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your
configuration in a compartment, you can later
[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a
transaction.
*/
class Compartment {
    /**
    Create an instance of this compartment to add to your [state
    configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
    */
    of(ext) { return new CompartmentInstance(this, ext); }
    /**
    Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
    reconfigures this compartment.
    */
    reconfigure(content) {
        return Compartment.reconfigure.of({ compartment: this, extension: content });
    }
    /**
    Get the current content of the compartment in the state, or
    `undefined` if it isn't present.
    */
    get(state) {
        return state.config.compartments.get(this);
    }
}
class CompartmentInstance {
    constructor(compartment, inner) {
        this.compartment = compartment;
        this.inner = inner;
    }
}
class Configuration {
    constructor(base, compartments, dynamicSlots, address, staticValues, facets) {
        this.base = base;
        this.compartments = compartments;
        this.dynamicSlots = dynamicSlots;
        this.address = address;
        this.staticValues = staticValues;
        this.facets = facets;
        this.statusTemplate = [];
        while (this.statusTemplate.length < dynamicSlots.length)
            this.statusTemplate.push(0 /* SlotStatus.Unresolved */);
    }
    staticFacet(facet) {
        let addr = this.address[facet.id];
        return addr == null ? facet.default : this.staticValues[addr >> 1];
    }
    static resolve(base, compartments, oldState) {
        let fields = [];
        let facets = Object.create(null);
        let newCompartments = new Map();
        for (let ext of flatten(base, compartments, newCompartments)) {
            if (ext instanceof StateField)
                fields.push(ext);
            else
                (facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);
        }
        let address = Object.create(null);
        let staticValues = [];
        let dynamicSlots = [];
        for (let field of fields) {
            address[field.id] = dynamicSlots.length << 1;
            dynamicSlots.push(a => field.slot(a));
        }
        let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;
        for (let id in facets) {
            let providers = facets[id], facet = providers[0].facet;
            let oldProviders = oldFacets && oldFacets[id] || [];
            if (providers.every(p => p.type == 0 /* Provider.Static */)) {
                address[facet.id] = (staticValues.length << 1) | 1;
                if (sameArray(oldProviders, providers)) {
                    staticValues.push(oldState.facet(facet));
                }
                else {
                    let value = facet.combine(providers.map(p => p.value));
                    staticValues.push(oldState && facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);
                }
            }
            else {
                for (let p of providers) {
                    if (p.type == 0 /* Provider.Static */) {
                        address[p.id] = (staticValues.length << 1) | 1;
                        staticValues.push(p.value);
                    }
                    else {
                        address[p.id] = dynamicSlots.length << 1;
                        dynamicSlots.push(a => p.dynamicSlot(a));
                    }
                }
                address[facet.id] = dynamicSlots.length << 1;
                dynamicSlots.push(a => dynamicFacetSlot(a, facet, providers));
            }
        }
        let dynamic = dynamicSlots.map(f => f(address));
        return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);
    }
}
function flatten(extension, compartments, newCompartments) {
    let result = [[], [], [], [], []];
    let seen = new Map();
    function inner(ext, prec) {
        let known = seen.get(ext);
        if (known != null) {
            if (known <= prec)
                return;
            let found = result[known].indexOf(ext);
            if (found > -1)
                result[known].splice(found, 1);
            if (ext instanceof CompartmentInstance)
                newCompartments.delete(ext.compartment);
        }
        seen.set(ext, prec);
        if (Array.isArray(ext)) {
            for (let e of ext)
                inner(e, prec);
        }
        else if (ext instanceof CompartmentInstance) {
            if (newCompartments.has(ext.compartment))
                throw new RangeError(`Duplicate use of compartment in extensions`);
            let content = compartments.get(ext.compartment) || ext.inner;
            newCompartments.set(ext.compartment, content);
            inner(content, prec);
        }
        else if (ext instanceof PrecExtension) {
            inner(ext.inner, ext.prec);
        }
        else if (ext instanceof StateField) {
            result[prec].push(ext);
            if (ext.provides)
                inner(ext.provides, prec);
        }
        else if (ext instanceof FacetProvider) {
            result[prec].push(ext);
            if (ext.facet.extensions)
                inner(ext.facet.extensions, Prec_.default);
        }
        else {
            let content = ext.extension;
            if (!content)
                throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
            inner(content, prec);
        }
    }
    inner(extension, Prec_.default);
    return result.reduce((a, b) => a.concat(b));
}
function ensureAddr(state, addr) {
    if (addr & 1)
        return 2 /* SlotStatus.Computed */;
    let idx = addr >> 1;
    let status = state.status[idx];
    if (status == 4 /* SlotStatus.Computing */)
        throw new Error("Cyclic dependency between fields and/or facets");
    if (status & 2 /* SlotStatus.Computed */)
        return status;
    state.status[idx] = 4 /* SlotStatus.Computing */;
    let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);
    return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;
}
function getAddr(state, addr) {
    return addr & 1 ? state.config.staticValues[addr >> 1] : state.values[addr >> 1];
}

const languageData = /*@__PURE__*/Facet.define();
const allowMultipleSelections = /*@__PURE__*/Facet.define({
    combine: values => values.some(v => v),
    static: true
});
const lineSeparator = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : undefined,
    static: true
});
const changeFilter = /*@__PURE__*/Facet.define();
const transactionFilter = /*@__PURE__*/Facet.define();
const transactionExtender = /*@__PURE__*/Facet.define();
const readOnly = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : false
});

/**
Annotations are tagged values that are used to add metadata to
transactions in an extensible way. They should be used to model
things that effect the entire transaction (such as its [time
stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its
[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen
_alongside_ the other changes made by the transaction, [state
effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.
*/
class Annotation {
    /**
    @internal
    */
    constructor(
    /**
    The annotation type.
    */
    type, 
    /**
    The value of this annotation.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Define a new type of annotation.
    */
    static define() { return new AnnotationType(); }
}
/**
Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).
*/
class AnnotationType {
    /**
    Create an instance of this annotation.
    */
    of(value) { return new Annotation(this, value); }
}
/**
Representation of a type of state effect. Defined with
[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).
*/
class StateEffectType {
    /**
    @internal
    */
    constructor(
    // The `any` types in these function types are there to work
    // around TypeScript issue #37631, where the type guard on
    // `StateEffect.is` mysteriously stops working when these properly
    // have type `Value`.
    /**
    @internal
    */
    map) {
        this.map = map;
    }
    /**
    Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
    type.
    */
    of(value) { return new StateEffect(this, value); }
}
/**
State effects can be used to represent additional effects
associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They
are often useful to model changes to custom [state
fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in
document or selection changes.
*/
class StateEffect {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    type, 
    /**
    The value of this effect.
    */
    value) {
        this.type = type;
        this.value = value;
    }
    /**
    Map this effect through a position mapping. Will return
    `undefined` when that ends up deleting the effect.
    */
    map(mapping) {
        let mapped = this.type.map(this.value, mapping);
        return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);
    }
    /**
    Tells you whether this effect object is of a given
    [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
    */
    is(type) { return this.type == type; }
    /**
    Define a new effect type. The type parameter indicates the type
    of values that his effect holds. It should be a type that
    doesn't include `undefined`, since that is used in
    [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
    removed.
    */
    static define(spec = {}) {
        return new StateEffectType(spec.map || (v => v));
    }
    /**
    Map an array of effects through a change set.
    */
    static mapEffects(effects, mapping) {
        if (!effects.length)
            return effects;
        let result = [];
        for (let effect of effects) {
            let mapped = effect.map(mapping);
            if (mapped)
                result.push(mapped);
        }
        return result;
    }
}
/**
This effect can be used to reconfigure the root extensions of
the editor. Doing this will discard any extensions
[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset
the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)
compartments.
*/
StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();
/**
Append extensions to the top-level configuration of the editor.
*/
StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();
/**
Changes to the editor state are grouped into transactions.
Typically, a user action creates a single transaction, which may
contain any number of document changes, may change the selection,
or have other effects. Create a transaction by calling
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately
dispatch one by calling
[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).
*/
class Transaction {
    constructor(
    /**
    The state from which the transaction starts.
    */
    startState, 
    /**
    The document changes made by this transaction.
    */
    changes, 
    /**
    The selection set by this transaction, or undefined if it
    doesn't explicitly set a selection.
    */
    selection, 
    /**
    The effects added to the transaction.
    */
    effects, 
    /**
    @internal
    */
    annotations, 
    /**
    Whether the selection should be scrolled into view after this
    transaction is dispatched.
    */
    scrollIntoView) {
        this.startState = startState;
        this.changes = changes;
        this.selection = selection;
        this.effects = effects;
        this.annotations = annotations;
        this.scrollIntoView = scrollIntoView;
        /**
        @internal
        */
        this._doc = null;
        /**
        @internal
        */
        this._state = null;
        if (selection)
            checkSelection(selection, changes.newLength);
        if (!annotations.some((a) => a.type == Transaction.time))
            this.annotations = annotations.concat(Transaction.time.of(Date.now()));
    }
    /**
    @internal
    */
    static create(startState, changes, selection, effects, annotations, scrollIntoView) {
        return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);
    }
    /**
    The new document produced by the transaction. Contrary to
    [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
    force the entire new state to be computed right away, so it is
    recommended that [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
    when they need to look at the new document.
    */
    get newDoc() {
        return this._doc || (this._doc = this.changes.apply(this.startState.doc));
    }
    /**
    The new selection produced by the transaction. If
    [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
    this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
    current selection through the changes made by the transaction.
    */
    get newSelection() {
        return this.selection || this.startState.selection.map(this.changes);
    }
    /**
    The new state created by the transaction. Computed on demand
    (but retained for subsequent access), so it is recommended not to
    access it in [transaction
    filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
    */
    get state() {
        if (!this._state)
            this.startState.applyTransaction(this);
        return this._state;
    }
    /**
    Get the value of the given annotation type, if any.
    */
    annotation(type) {
        for (let ann of this.annotations)
            if (ann.type == type)
                return ann.value;
        return undefined;
    }
    /**
    Indicates whether the transaction changed the document.
    */
    get docChanged() { return !this.changes.empty; }
    /**
    Indicates whether this transaction reconfigures the state
    (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
    with a top-level configuration
    [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
    */
    get reconfigured() { return this.startState.config != this.state.config; }
    /**
    Returns true if the transaction has a [user
    event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
    or more specific than `event`. For example, if the transaction
    has `"select.pointer"` as user event, `"select"` and
    `"select.pointer"` will match it.
    */
    isUserEvent(event) {
        let e = this.annotation(Transaction.userEvent);
        return !!(e && (e == event || e.length > event.length && e.slice(0, event.length) == event && e[event.length] == "."));
    }
}
/**
Annotation used to store transaction timestamps. Automatically
added to every transaction, holding `Date.now()`.
*/
Transaction.time = /*@__PURE__*/Annotation.define();
/**
Annotation used to associate a transaction with a user interface
event. Holds a string identifying the event, using a
dot-separated format to support attaching more specific
information. The events used by the core libraries are:

 - `"input"` when content is entered
   - `"input.type"` for typed input
     - `"input.type.compose"` for composition
   - `"input.paste"` for pasted input
   - `"input.drop"` when adding content with drag-and-drop
   - `"input.complete"` when autocompleting
 - `"delete"` when the user deletes content
   - `"delete.selection"` when deleting the selection
   - `"delete.forward"` when deleting forward from the selection
   - `"delete.backward"` when deleting backward from the selection
   - `"delete.cut"` when cutting to the clipboard
 - `"move"` when content is moved
   - `"move.drop"` when content is moved within the editor through drag-and-drop
 - `"select"` when explicitly changing the selection
   - `"select.pointer"` when selecting with a mouse or other pointing device
 - `"undo"` and `"redo"` for history actions

Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check
whether the annotation matches a given event.
*/
Transaction.userEvent = /*@__PURE__*/Annotation.define();
/**
Annotation indicating whether a transaction should be added to
the undo history or not.
*/
Transaction.addToHistory = /*@__PURE__*/Annotation.define();
/**
Annotation indicating (when present and true) that a transaction
represents a change made by some other actor, not the user. This
is used, for example, to tag other people's changes in
collaborative editing.
*/
Transaction.remote = /*@__PURE__*/Annotation.define();
function joinRanges(a, b) {
    let result = [];
    for (let iA = 0, iB = 0;;) {
        let from, to;
        if (iA < a.length && (iB == b.length || b[iB] >= a[iA])) {
            from = a[iA++];
            to = a[iA++];
        }
        else if (iB < b.length) {
            from = b[iB++];
            to = b[iB++];
        }
        else
            return result;
        if (!result.length || result[result.length - 1] < from)
            result.push(from, to);
        else if (result[result.length - 1] < to)
            result[result.length - 1] = to;
    }
}
function mergeTransaction(a, b, sequential) {
    var _a;
    let mapForA, mapForB, changes;
    if (sequential) {
        mapForA = b.changes;
        mapForB = ChangeSet.empty(b.changes.length);
        changes = a.changes.compose(b.changes);
    }
    else {
        mapForA = b.changes.map(a.changes);
        mapForB = a.changes.mapDesc(b.changes, true);
        changes = a.changes.compose(mapForA);
    }
    return {
        changes,
        selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),
        effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),
        annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,
        scrollIntoView: a.scrollIntoView || b.scrollIntoView
    };
}
function resolveTransactionInner(state, spec, docSize) {
    let sel = spec.selection, annotations = asArray(spec.annotations);
    if (spec.userEvent)
        annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));
    return {
        changes: spec.changes instanceof ChangeSet ? spec.changes
            : ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),
        selection: sel && (sel instanceof dist_EditorSelection ? sel : dist_EditorSelection.single(sel.anchor, sel.head)),
        effects: asArray(spec.effects),
        annotations,
        scrollIntoView: !!spec.scrollIntoView
    };
}
function resolveTransaction(state, specs, filter) {
    let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);
    if (specs.length && specs[0].filter === false)
        filter = false;
    for (let i = 1; i < specs.length; i++) {
        if (specs[i].filter === false)
            filter = false;
        let seq = !!specs[i].sequential;
        s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);
    }
    let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);
    return extendTransaction(filter ? filterTransaction(tr) : tr);
}
// Finish a transaction by applying filters if necessary.
function filterTransaction(tr) {
    let state = tr.startState;
    // Change filters
    let result = true;
    for (let filter of state.facet(changeFilter)) {
        let value = filter(tr);
        if (value === false) {
            result = false;
            break;
        }
        if (Array.isArray(value))
            result = result === true ? value : joinRanges(result, value);
    }
    if (result !== true) {
        let changes, back;
        if (result === false) {
            back = tr.changes.invertedDesc;
            changes = ChangeSet.empty(state.doc.length);
        }
        else {
            let filtered = tr.changes.filter(result);
            changes = filtered.changes;
            back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;
        }
        tr = Transaction.create(state, changes, tr.selection && tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);
    }
    // Transaction filters
    let filters = state.facet(transactionFilter);
    for (let i = filters.length - 1; i >= 0; i--) {
        let filtered = filters[i](tr);
        if (filtered instanceof Transaction)
            tr = filtered;
        else if (Array.isArray(filtered) && filtered.length == 1 && filtered[0] instanceof Transaction)
            tr = filtered[0];
        else
            tr = resolveTransaction(state, asArray(filtered), false);
    }
    return tr;
}
function extendTransaction(tr) {
    let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;
    for (let i = extenders.length - 1; i >= 0; i--) {
        let extension = extenders[i](tr);
        if (extension && Object.keys(extension).length)
            spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);
    }
    return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);
}
const none = [];
function asArray(value) {
    return value == null ? none : Array.isArray(value) ? value : [value];
}

/**
The categories produced by a [character
categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used
do things like selecting by word.
*/
var dist_CharCategory = /*@__PURE__*/(function (CharCategory) {
    /**
    Word characters.
    */
    CharCategory[CharCategory["Word"] = 0] = "Word";
    /**
    Whitespace.
    */
    CharCategory[CharCategory["Space"] = 1] = "Space";
    /**
    Anything else.
    */
    CharCategory[CharCategory["Other"] = 2] = "Other";
return CharCategory})(dist_CharCategory || (dist_CharCategory = {}));
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let wordChar;
try {
    wordChar = /*@__PURE__*/new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
}
catch (_) { }
function hasWordChar(str) {
    if (wordChar)
        return wordChar.test(str);
    for (let i = 0; i < str.length; i++) {
        let ch = str[i];
        if (/\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))
            return true;
    }
    return false;
}
function makeCategorizer(wordChars) {
    return (char) => {
        if (!/\S/.test(char))
            return dist_CharCategory.Space;
        if (hasWordChar(char))
            return dist_CharCategory.Word;
        for (let i = 0; i < wordChars.length; i++)
            if (char.indexOf(wordChars[i]) > -1)
                return dist_CharCategory.Word;
        return dist_CharCategory.Other;
    };
}

/**
The editor state class is a persistent (immutable) data structure.
To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a
[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state
instance, without modifying the original object.

As such, _never_ mutate properties of a state directly. That'll
just break things.
*/
class EditorState {
    constructor(
    /**
    @internal
    */
    config, 
    /**
    The current document.
    */
    doc, 
    /**
    The current selection.
    */
    selection, 
    /**
    @internal
    */
    values, computeSlot, tr) {
        this.config = config;
        this.doc = doc;
        this.selection = selection;
        this.values = values;
        this.status = config.statusTemplate.slice();
        this.computeSlot = computeSlot;
        // Fill in the computed state immediately, so that further queries
        // for it made during the update return this state
        if (tr)
            tr._state = this;
        for (let i = 0; i < this.config.dynamicSlots.length; i++)
            ensureAddr(this, i << 1);
        this.computeSlot = null;
    }
    field(field, require = true) {
        let addr = this.config.address[field.id];
        if (addr == null) {
            if (require)
                throw new RangeError("Field is not present in this state");
            return undefined;
        }
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
    state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
    can be passed. Unless
    [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
    [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
    are assumed to start in the _current_ document (not the document
    produced by previous specs), and its
    [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
    [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
    to the document created by its _own_ changes. The resulting
    transaction contains the combined effect of all the different
    specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
    specs take precedence over earlier ones.
    */
    update(...specs) {
        return resolveTransaction(this, specs, true);
    }
    /**
    @internal
    */
    applyTransaction(tr) {
        let conf = this.config, { base, compartments } = conf;
        for (let effect of tr.effects) {
            if (effect.is(Compartment.reconfigure)) {
                if (conf) {
                    compartments = new Map;
                    conf.compartments.forEach((val, key) => compartments.set(key, val));
                    conf = null;
                }
                compartments.set(effect.value.compartment, effect.value.extension);
            }
            else if (effect.is(StateEffect.reconfigure)) {
                conf = null;
                base = effect.value;
            }
            else if (effect.is(StateEffect.appendConfig)) {
                conf = null;
                base = asArray(base).concat(effect.value);
            }
        }
        let startValues;
        if (!conf) {
            conf = Configuration.resolve(base, compartments, this);
            let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() => null), (state, slot) => slot.reconfigure(state, this), null);
            startValues = intermediateState.values;
        }
        else {
            startValues = tr.startState.values.slice();
        }
        let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();
        new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) => slot.update(state, tr), tr);
    }
    /**
    Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
    replaces every selection range with the given content.
    */
    replaceSelection(text) {
        if (typeof text == "string")
            text = this.toText(text);
        return this.changeByRange(range => ({ changes: { from: range.from, to: range.to, insert: text },
            range: dist_EditorSelection.cursor(range.from + text.length) }));
    }
    /**
    Create a set of changes and a new selection by running the given
    function for each range in the active selection. The function
    can return an optional set of changes (in the coordinate space
    of the start document), plus an updated range (in the coordinate
    space of the document produced by the call's own changes). This
    method will merge all the changes and ranges into a single
    changeset and selection, and return it as a [transaction
    spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
    [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
    */
    changeByRange(f) {
        let sel = this.selection;
        let result1 = f(sel.ranges[0]);
        let changes = this.changes(result1.changes), ranges = [result1.range];
        let effects = asArray(result1.effects);
        for (let i = 1; i < sel.ranges.length; i++) {
            let result = f(sel.ranges[i]);
            let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);
            for (let j = 0; j < i; j++)
                ranges[j] = ranges[j].map(newMapped);
            let mapBy = changes.mapDesc(newChanges, true);
            ranges.push(result.range.map(mapBy));
            changes = changes.compose(newMapped);
            effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));
        }
        return {
            changes,
            selection: dist_EditorSelection.create(ranges, sel.mainIndex),
            effects
        };
    }
    /**
    Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
    description, taking the state's document length and line
    separator into account.
    */
    changes(spec = []) {
        if (spec instanceof ChangeSet)
            return spec;
        return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));
    }
    /**
    Using the state's [line
    separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
    [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
    */
    toText(string) {
        return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));
    }
    /**
    Return the given range of the document as a string.
    */
    sliceDoc(from = 0, to = this.doc.length) {
        return this.doc.sliceString(from, to, this.lineBreak);
    }
    /**
    Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
    */
    facet(facet) {
        let addr = this.config.address[facet.id];
        if (addr == null)
            return facet.default;
        ensureAddr(this, addr);
        return getAddr(this, addr);
    }
    /**
    Convert this state to a JSON-serializable object. When custom
    fields should be serialized, you can pass them in as an object
    mapping property names (in the resulting object, which should
    not use `doc` or `selection`) to fields.
    */
    toJSON(fields) {
        let result = {
            doc: this.sliceDoc(),
            selection: this.selection.toJSON()
        };
        if (fields)
            for (let prop in fields) {
                let value = fields[prop];
                if (value instanceof StateField && this.config.address[value.id] != null)
                    result[prop] = value.spec.toJSON(this.field(fields[prop]), this);
            }
        return result;
    }
    /**
    Deserialize a state from its JSON representation. When custom
    fields should be deserialized, pass the same object you passed
    to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
    third argument.
    */
    static fromJSON(json, config = {}, fields) {
        if (!json || typeof json.doc != "string")
            throw new RangeError("Invalid JSON representation for EditorState");
        let fieldInit = [];
        if (fields)
            for (let prop in fields) {
                if (Object.prototype.hasOwnProperty.call(json, prop)) {
                    let field = fields[prop], value = json[prop];
                    fieldInit.push(field.init(state => field.spec.fromJSON(value, state)));
                }
            }
        return EditorState.create({
            doc: json.doc,
            selection: dist_EditorSelection.fromJSON(json.selection),
            extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit
        });
    }
    /**
    Create a new state. You'll usually only need this when
    initializing an editor—updated states are created by applying
    transactions.
    */
    static create(config = {}) {
        let configuration = Configuration.resolve(config.extensions || [], new Map);
        let doc = config.doc instanceof Text ? config.doc
            : Text.of((config.doc || "").split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));
        let selection = !config.selection ? dist_EditorSelection.single(0)
            : config.selection instanceof dist_EditorSelection ? config.selection
                : dist_EditorSelection.single(config.selection.anchor, config.selection.head);
        checkSelection(selection, doc.length);
        if (!configuration.staticFacet(allowMultipleSelections))
            selection = selection.asSingle();
        return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() => null), (state, slot) => slot.create(state), null);
    }
    /**
    The size (in columns) of a tab in the document, determined by
    the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
    */
    get tabSize() { return this.facet(EditorState.tabSize); }
    /**
    Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
    string for this state.
    */
    get lineBreak() { return this.facet(EditorState.lineSeparator) || "\n"; }
    /**
    Returns true when the editor is
    [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
    */
    get readOnly() { return this.facet(readOnly); }
    /**
    Look up a translation for the given phrase (via the
    [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
    original string if no translation is found.
    
    If additional arguments are passed, they will be inserted in
    place of markers like `$1` (for the first value) and `$2`, etc.
    A single `$` is equivalent to `$1`, and `$$` will produce a
    literal dollar sign.
    */
    phrase(phrase, ...insert) {
        for (let map of this.facet(EditorState.phrases))
            if (Object.prototype.hasOwnProperty.call(map, phrase)) {
                phrase = map[phrase];
                break;
            }
        if (insert.length)
            phrase = phrase.replace(/\$(\$|\d*)/g, (m, i) => {
                if (i == "$")
                    return "$";
                let n = +(i || 1);
                return !n || n > insert.length ? m : insert[n - 1];
            });
        return phrase;
    }
    /**
    Find the values for a given language data field, provided by the
    the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
    
    Examples of language data fields are...
    
    - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
      comment syntax.
    - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
      for providing language-specific completion sources.
    - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
      characters that should be considered part of words in this
      language.
    - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
      bracket closing behavior.
    */
    languageDataAt(name, pos, side = -1) {
        let values = [];
        for (let provider of this.facet(languageData)) {
            for (let result of provider(this, pos, side)) {
                if (Object.prototype.hasOwnProperty.call(result, name))
                    values.push(result[name]);
            }
        }
        return values;
    }
    /**
    Return a function that can categorize strings (expected to
    represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
    into one of:
    
     - Word (contains an alphanumeric character or a character
       explicitly listed in the local language's `"wordChars"`
       language data, which should be a string)
     - Space (contains only whitespace)
     - Other (anything else)
    */
    charCategorizer(at) {
        return makeCategorizer(this.languageDataAt("wordChars", at).join(""));
    }
    /**
    Find the word at the given position, meaning the range
    containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
    around it. If no word characters are adjacent to the position,
    this returns null.
    */
    wordAt(pos) {
        let { text, from, length } = this.doc.lineAt(pos);
        let cat = this.charCategorizer(pos);
        let start = pos - from, end = pos - from;
        while (start > 0) {
            let prev = findClusterBreak(text, start, false);
            if (cat(text.slice(prev, start)) != dist_CharCategory.Word)
                break;
            start = prev;
        }
        while (end < length) {
            let next = findClusterBreak(text, end);
            if (cat(text.slice(end, next)) != dist_CharCategory.Word)
                break;
            end = next;
        }
        return start == end ? null : dist_EditorSelection.range(start + from, end + from);
    }
}
/**
A facet that, when enabled, causes the editor to allow multiple
ranges to be selected. Be careful though, because by default the
editor relies on the native DOM selection, which cannot handle
multiple selections. An extension like
[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make
secondary selections visible to the user.
*/
EditorState.allowMultipleSelections = allowMultipleSelections;
/**
Configures the tab size to use in this state. The first
(highest-precedence) value of the facet is used. If no value is
given, this defaults to 4.
*/
EditorState.tabSize = /*@__PURE__*/Facet.define({
    combine: values => values.length ? values[0] : 4
});
/**
The line separator to use. By default, any of `"\n"`, `"\r\n"`
and `"\r"` is treated as a separator when splitting lines, and
lines are joined with `"\n"`.

When you configure a value here, only that precise separator
will be used, allowing you to round-trip documents through the
editor without normalizing line separators.
*/
EditorState.lineSeparator = lineSeparator;
/**
This facet controls the value of the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is
consulted by commands and extensions that implement editing
functionality to determine whether they should apply. It
defaults to false, but when its highest-precedence value is
`true`, such functionality disables itself.

Not to be confused with
[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which
controls whether the editor's DOM is set to be editable (and
thus focusable).
*/
EditorState.readOnly = readOnly;
/**
Registers translation phrases. The
[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through
all objects registered with this facet to find translations for
its argument.
*/
EditorState.phrases = /*@__PURE__*/Facet.define({
    compare(a, b) {
        let kA = Object.keys(a), kB = Object.keys(b);
        return kA.length == kB.length && kA.every(k => a[k] == b[k]);
    }
});
/**
A facet used to register [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.
*/
EditorState.languageData = languageData;
/**
Facet used to register change filters, which are called for each
transaction (unless explicitly
[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress
part of the transaction's changes.

Such a function can return `true` to indicate that it doesn't
want to do anything, `false` to completely stop the changes in
the transaction, or a set of ranges in which changes should be
suppressed. Such ranges are represented as an array of numbers,
with each pair of two numbers indicating the start and end of a
range. So for example `[10, 20, 100, 110]` suppresses changes
between 10 and 20, and between 100 and 110.
*/
EditorState.changeFilter = changeFilter;
/**
Facet used to register a hook that gets a chance to update or
replace transaction specs before they are applied. This will
only be applied for transactions that don't have
[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You
can either return a single transaction spec (possibly the input
transaction), or an array of specs (which will be combined in
the same way as the arguments to
[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).

When possible, it is recommended to avoid accessing
[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,
since it will force creation of a state that will then be
discarded again, if the transaction is actually filtered.

(This functionality should be used with care. Indiscriminately
modifying transaction is likely to break something or degrade
the user experience.)
*/
EditorState.transactionFilter = transactionFilter;
/**
This is a more limited form of
[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),
which can only add
[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and
[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type
of filter runs even if the transaction has disabled regular
[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable
for effects that don't need to touch the changes or selection,
but do want to process every transaction.

Extenders run _after_ filters, when both are present.
*/
EditorState.transactionExtender = transactionExtender;
Compartment.reconfigure = /*@__PURE__*/StateEffect.define();

/**
Utility function for combining behaviors to fill in a config
object from an array of provided configs. `defaults` should hold
default values for all optional fields in `Config`.

The function will, by default, error
when a field gets two values that aren't `===`-equal, but you can
provide combine functions per field to do something else.
*/
function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that
combine = {}) {
    let result = {};
    for (let config of configs)
        for (let key of Object.keys(config)) {
            let value = config[key], current = result[key];
            if (current === undefined)
                result[key] = value;
            else if (current === value || value === undefined) ; // No conflict
            else if (Object.hasOwnProperty.call(combine, key))
                result[key] = combine[key](current, value);
            else
                throw new Error("Config merge conflict for field " + key);
        }
    for (let key in defaults)
        if (result[key] === undefined)
            result[key] = defaults[key];
    return result;
}

/**
Each range is associated with a value, which must inherit from
this class.
*/
class RangeValue {
    /**
    Compare this value with another value. Used when comparing
    rangesets. The default implementation compares by identity.
    Unless you are only creating a fixed number of unique instances
    of your value type, it is a good idea to implement this
    properly.
    */
    eq(other) { return this == other; }
    /**
    Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
    */
    range(from, to = from) { return Range.create(from, to, this); }
}
RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;
RangeValue.prototype.point = false;
RangeValue.prototype.mapMode = MapMode.TrackDel;
/**
A range associates a value with a range of positions.
*/
class Range {
    constructor(
    /**
    The range's start position.
    */
    from, 
    /**
    Its end position.
    */
    to, 
    /**
    The value associated with this range.
    */
    value) {
        this.from = from;
        this.to = to;
        this.value = value;
    }
    /**
    @internal
    */
    static create(from, to, value) {
        return new Range(from, to, value);
    }
}
function cmpRange(a, b) {
    return a.from - b.from || a.value.startSide - b.value.startSide;
}
class Chunk {
    constructor(from, to, value, 
    // Chunks are marked with the largest point that occurs
    // in them (or -1 for no points), so that scans that are
    // only interested in points (such as the
    // heightmap-related logic) can skip range-only chunks.
    maxPoint) {
        this.from = from;
        this.to = to;
        this.value = value;
        this.maxPoint = maxPoint;
    }
    get length() { return this.to[this.to.length - 1]; }
    // Find the index of the given position and side. Use the ranges'
    // `from` pos when `end == false`, `to` when `end == true`.
    findIndex(pos, side, end, startAt = 0) {
        let arr = end ? this.to : this.from;
        for (let lo = startAt, hi = arr.length;;) {
            if (lo == hi)
                return lo;
            let mid = (lo + hi) >> 1;
            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;
            if (mid == lo)
                return diff >= 0 ? lo : hi;
            if (diff >= 0)
                hi = mid;
            else
                lo = mid + 1;
        }
    }
    between(offset, from, to, f) {
        for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i < e; i++)
            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)
                return false;
    }
    map(offset, changes) {
        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;
        for (let i = 0; i < this.value.length; i++) {
            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;
            if (curFrom == curTo) {
                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);
                if (mapped == null)
                    continue;
                newFrom = newTo = mapped;
                if (val.startSide != val.endSide) {
                    newTo = changes.mapPos(curFrom, val.endSide);
                    if (newTo < newFrom)
                        continue;
                }
            }
            else {
                newFrom = changes.mapPos(curFrom, val.startSide);
                newTo = changes.mapPos(curTo, val.endSide);
                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)
                    continue;
            }
            if ((newTo - newFrom || val.endSide - val.startSide) < 0)
                continue;
            if (newPos < 0)
                newPos = newFrom;
            if (val.point)
                maxPoint = Math.max(maxPoint, newTo - newFrom);
            value.push(val);
            from.push(newFrom - newPos);
            to.push(newTo - newPos);
        }
        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };
    }
}
/**
A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a
way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and
[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data
structure.
*/
class dist_RangeSet {
    constructor(
    /**
    @internal
    */
    chunkPos, 
    /**
    @internal
    */
    chunk, 
    /**
    @internal
    */
    nextLayer, 
    /**
    @internal
    */
    maxPoint) {
        this.chunkPos = chunkPos;
        this.chunk = chunk;
        this.nextLayer = nextLayer;
        this.maxPoint = maxPoint;
    }
    /**
    @internal
    */
    static create(chunkPos, chunk, nextLayer, maxPoint) {
        return new dist_RangeSet(chunkPos, chunk, nextLayer, maxPoint);
    }
    /**
    @internal
    */
    get length() {
        let last = this.chunk.length - 1;
        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);
    }
    /**
    The number of ranges in the set.
    */
    get size() {
        if (this.isEmpty)
            return 0;
        let size = this.nextLayer.size;
        for (let chunk of this.chunk)
            size += chunk.value.length;
        return size;
    }
    /**
    @internal
    */
    chunkEnd(index) {
        return this.chunkPos[index] + this.chunk[index].length;
    }
    /**
    Update the range set, optionally adding new ranges or filtering
    out existing ones.
    
    (Note: The type parameter is just there as a kludge to work
    around TypeScript variance issues that prevented `RangeSet<X>`
    from being a subtype of `RangeSet<Y>` when `X` is a subtype of
    `Y`.)
    */
    update(updateSpec) {
        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;
        let filter = updateSpec.filter;
        if (add.length == 0 && !filter)
            return this;
        if (sort)
            add = add.slice().sort(cmpRange);
        if (this.isEmpty)
            return add.length ? dist_RangeSet.of(add) : this;
        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];
        let builder = new RangeSetBuilder();
        while (cur.value || i < add.length) {
            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {
                let range = add[i++];
                if (!builder.addInner(range.from, range.to, range.value))
                    spill.push(range);
            }
            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&
                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&
                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&
                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {
                cur.nextChunk();
            }
            else {
                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {
                    if (!builder.addInner(cur.from, cur.to, cur.value))
                        spill.push(Range.create(cur.from, cur.to, cur.value));
                }
                cur.next();
            }
        }
        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? dist_RangeSet.empty
            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));
    }
    /**
    Map this range set through a set of changes, return the new set.
    */
    map(changes) {
        if (changes.empty || this.isEmpty)
            return this;
        let chunks = [], chunkPos = [], maxPoint = -1;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            let touch = changes.touchesRange(start, start + chunk.length);
            if (touch === false) {
                maxPoint = Math.max(maxPoint, chunk.maxPoint);
                chunks.push(chunk);
                chunkPos.push(changes.mapPos(start));
            }
            else if (touch === true) {
                let { mapped, pos } = chunk.map(start, changes);
                if (mapped) {
                    maxPoint = Math.max(maxPoint, mapped.maxPoint);
                    chunks.push(mapped);
                    chunkPos.push(pos);
                }
            }
        }
        let next = this.nextLayer.map(changes);
        return chunks.length == 0 ? next : new dist_RangeSet(chunkPos, chunks, next || dist_RangeSet.empty, maxPoint);
    }
    /**
    Iterate over the ranges that touch the region `from` to `to`,
    calling `f` for each. There is no guarantee that the ranges will
    be reported in any specific order. When the callback returns
    `false`, iteration stops.
    */
    between(from, to, f) {
        if (this.isEmpty)
            return;
        for (let i = 0; i < this.chunk.length; i++) {
            let start = this.chunkPos[i], chunk = this.chunk[i];
            if (to >= start && from <= start + chunk.length &&
                chunk.between(start, from - start, to - start, f) === false)
                return;
        }
        this.nextLayer.between(from, to, f);
    }
    /**
    Iterate over the ranges in this set, in order, including all
    ranges that end at or after `from`.
    */
    iter(from = 0) {
        return HeapCursor.from([this]).goto(from);
    }
    /**
    @internal
    */
    get isEmpty() { return this.nextLayer == this; }
    /**
    Iterate over the ranges in a collection of sets, in order,
    starting from `from`.
    */
    static iter(sets, from = 0) {
        return HeapCursor.from(sets).goto(from);
    }
    /**
    Iterate over two groups of sets, calling methods on `comparator`
    to notify it of possible differences.
    */
    static compare(oldSets, newSets, 
    /**
    This indicates how the underlying data changed between these
    ranges, and is needed to synchronize the iteration.
    */
    textDiff, comparator, 
    /**
    Can be used to ignore all non-point ranges, and points below
    the given size. When -1, all ranges are compared.
    */
    minPointSize = -1) {
        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);
        let sharedChunks = findSharedChunks(a, b, textDiff);
        let sideA = new SpanCursor(a, sharedChunks, minPointSize);
        let sideB = new SpanCursor(b, sharedChunks, minPointSize);
        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));
        if (textDiff.empty && textDiff.length == 0)
            compare(sideA, 0, sideB, 0, 0, comparator);
    }
    /**
    Compare the contents of two groups of range sets, returning true
    if they are equivalent in the given range.
    */
    static eq(oldSets, newSets, from = 0, to) {
        if (to == null)
            to = 1000000000 /* C.Far */ - 1;
        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);
        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);
        if (a.length != b.length)
            return false;
        if (!a.length)
            return true;
        let sharedChunks = findSharedChunks(a, b);
        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);
        for (;;) {
            if (sideA.to != sideB.to ||
                !sameValues(sideA.active, sideB.active) ||
                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))
                return false;
            if (sideA.to > to)
                return true;
            sideA.next();
            sideB.next();
        }
    }
    /**
    Iterate over a group of range sets at the same time, notifying
    the iterator about the ranges covering every given piece of
    content. Returns the open count (see
    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
    of the iteration.
    */
    static spans(sets, from, to, iterator, 
    /**
    When given and greater than -1, only points of at least this
    size are taken into account.
    */
    minPointSize = -1) {
        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;
        let openRanges = cursor.openStart;
        for (;;) {
            let curTo = Math.min(cursor.to, to);
            if (cursor.point) {
                let active = cursor.activeForPoint(cursor.to);
                let openCount = cursor.pointFrom < from ? active.length + 1 : Math.min(active.length, openRanges);
                iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);
                openRanges = Math.min(cursor.openEnd(curTo), active.length);
            }
            else if (curTo > pos) {
                iterator.span(pos, curTo, cursor.active, openRanges);
                openRanges = cursor.openEnd(curTo);
            }
            if (cursor.to > to)
                return openRanges + (cursor.point && cursor.to > to ? 1 : 0);
            pos = cursor.to;
            cursor.next();
        }
    }
    /**
    Create a range set for the given range or array of ranges. By
    default, this expects the ranges to be _sorted_ (by start
    position and, if two start at the same position,
    `value.startSide`). You can pass `true` as second argument to
    cause the method to sort them.
    */
    static of(ranges, sort = false) {
        let build = new RangeSetBuilder();
        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)
            build.add(range.from, range.to, range.value);
        return build.finish();
    }
}
/**
The empty set of ranges.
*/
dist_RangeSet.empty = /*@__PURE__*/new dist_RangeSet([], [], null, -1);
function lazySort(ranges) {
    if (ranges.length > 1)
        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {
            let cur = ranges[i];
            if (cmpRange(prev, cur) > 0)
                return ranges.slice().sort(cmpRange);
            prev = cur;
        }
    return ranges;
}
dist_RangeSet.empty.nextLayer = dist_RangeSet.empty;
/**
A range set builder is a data structure that helps build up a
[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating
an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.
*/
class RangeSetBuilder {
    finishChunk(newArrays) {
        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));
        this.chunkPos.push(this.chunkStart);
        this.chunkStart = -1;
        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);
        this.maxPoint = -1;
        if (newArrays) {
            this.from = [];
            this.to = [];
            this.value = [];
        }
    }
    /**
    Create an empty builder.
    */
    constructor() {
        this.chunks = [];
        this.chunkPos = [];
        this.chunkStart = -1;
        this.last = null;
        this.lastFrom = -1000000000 /* C.Far */;
        this.lastTo = -1000000000 /* C.Far */;
        this.from = [];
        this.to = [];
        this.value = [];
        this.maxPoint = -1;
        this.setMaxPoint = -1;
        this.nextLayer = null;
    }
    /**
    Add a range. Ranges should be added in sorted (by `from` and
    `value.startSide`) order.
    */
    add(from, to, value) {
        if (!this.addInner(from, to, value))
            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);
    }
    /**
    @internal
    */
    addInner(from, to, value) {
        let diff = from - this.lastTo || value.startSide - this.last.endSide;
        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)
            throw new Error("Ranges must be added sorted by `from` position and `startSide`");
        if (diff < 0)
            return false;
        if (this.from.length == 250 /* C.ChunkSize */)
            this.finishChunk(true);
        if (this.chunkStart < 0)
            this.chunkStart = from;
        this.from.push(from - this.chunkStart);
        this.to.push(to - this.chunkStart);
        this.last = value;
        this.lastFrom = from;
        this.lastTo = to;
        this.value.push(value);
        if (value.point)
            this.maxPoint = Math.max(this.maxPoint, to - from);
        return true;
    }
    /**
    @internal
    */
    addChunk(from, chunk) {
        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)
            return false;
        if (this.from.length)
            this.finishChunk(true);
        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);
        this.chunks.push(chunk);
        this.chunkPos.push(from);
        let last = chunk.value.length - 1;
        this.last = chunk.value[last];
        this.lastFrom = chunk.from[last] + from;
        this.lastTo = chunk.to[last] + from;
        return true;
    }
    /**
    Finish the range set. Returns the new set. The builder can't be
    used anymore after this has been called.
    */
    finish() { return this.finishInner(dist_RangeSet.empty); }
    /**
    @internal
    */
    finishInner(next) {
        if (this.from.length)
            this.finishChunk(false);
        if (this.chunks.length == 0)
            return next;
        let result = dist_RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);
        this.from = null; // Make sure further `add` calls produce errors
        return result;
    }
}
function findSharedChunks(a, b, textDiff) {
    let inA = new Map();
    for (let set of a)
        for (let i = 0; i < set.chunk.length; i++)
            if (set.chunk[i].maxPoint <= 0)
                inA.set(set.chunk[i], set.chunkPos[i]);
    let shared = new Set();
    for (let set of b)
        for (let i = 0; i < set.chunk.length; i++) {
            let known = inA.get(set.chunk[i]);
            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&
                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))
                shared.add(set.chunk[i]);
        }
    return shared;
}
class LayerCursor {
    constructor(layer, skip, minPoint, rank = 0) {
        this.layer = layer;
        this.skip = skip;
        this.minPoint = minPoint;
        this.rank = rank;
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    get endSide() { return this.value ? this.value.endSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.chunkIndex = this.rangeIndex = 0;
        this.gotoInner(pos, side, false);
        return this;
    }
    gotoInner(pos, side, forward) {
        while (this.chunkIndex < this.layer.chunk.length) {
            let next = this.layer.chunk[this.chunkIndex];
            if (!(this.skip && this.skip.has(next) ||
                this.layer.chunkEnd(this.chunkIndex) < pos ||
                next.maxPoint < this.minPoint))
                break;
            this.chunkIndex++;
            forward = false;
        }
        if (this.chunkIndex < this.layer.chunk.length) {
            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);
            if (!forward || this.rangeIndex < rangeIndex)
                this.setRangeIndex(rangeIndex);
        }
        this.next();
    }
    forward(pos, side) {
        if ((this.to - pos || this.endSide - side) < 0)
            this.gotoInner(pos, side, true);
    }
    next() {
        for (;;) {
            if (this.chunkIndex == this.layer.chunk.length) {
                this.from = this.to = 1000000000 /* C.Far */;
                this.value = null;
                break;
            }
            else {
                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];
                let from = chunkPos + chunk.from[this.rangeIndex];
                this.from = from;
                this.to = chunkPos + chunk.to[this.rangeIndex];
                this.value = chunk.value[this.rangeIndex];
                this.setRangeIndex(this.rangeIndex + 1);
                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
                    break;
            }
        }
    }
    setRangeIndex(index) {
        if (index == this.layer.chunk[this.chunkIndex].value.length) {
            this.chunkIndex++;
            if (this.skip) {
                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))
                    this.chunkIndex++;
            }
            this.rangeIndex = 0;
        }
        else {
            this.rangeIndex = index;
        }
    }
    nextChunk() {
        this.chunkIndex++;
        this.rangeIndex = 0;
        this.next();
    }
    compare(other) {
        return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||
            this.to - other.to || this.endSide - other.endSide;
    }
}
class HeapCursor {
    constructor(heap) {
        this.heap = heap;
    }
    static from(sets, skip = null, minPoint = -1) {
        let heap = [];
        for (let i = 0; i < sets.length; i++) {
            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {
                if (cur.maxPoint >= minPoint)
                    heap.push(new LayerCursor(cur, skip, minPoint, i));
            }
        }
        return heap.length == 1 ? heap[0] : new HeapCursor(heap);
    }
    get startSide() { return this.value ? this.value.startSide : 0; }
    goto(pos, side = -1000000000 /* C.Far */) {
        for (let cur of this.heap)
            cur.goto(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        this.next();
        return this;
    }
    forward(pos, side) {
        for (let cur of this.heap)
            cur.forward(pos, side);
        for (let i = this.heap.length >> 1; i >= 0; i--)
            heapBubble(this.heap, i);
        if ((this.to - pos || this.value.endSide - side) < 0)
            this.next();
    }
    next() {
        if (this.heap.length == 0) {
            this.from = this.to = 1000000000 /* C.Far */;
            this.value = null;
            this.rank = -1;
        }
        else {
            let top = this.heap[0];
            this.from = top.from;
            this.to = top.to;
            this.value = top.value;
            this.rank = top.rank;
            if (top.value)
                top.next();
            heapBubble(this.heap, 0);
        }
    }
}
function heapBubble(heap, index) {
    for (let cur = heap[index];;) {
        let childIndex = (index << 1) + 1;
        if (childIndex >= heap.length)
            break;
        let child = heap[childIndex];
        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {
            child = heap[childIndex + 1];
            childIndex++;
        }
        if (cur.compare(child) < 0)
            break;
        heap[childIndex] = cur;
        heap[index] = child;
        index = childIndex;
    }
}
class SpanCursor {
    constructor(sets, skip, minPoint) {
        this.minPoint = minPoint;
        this.active = [];
        this.activeTo = [];
        this.activeRank = [];
        this.minActive = -1;
        // A currently active point range, if any
        this.point = null;
        this.pointFrom = 0;
        this.pointRank = 0;
        this.to = -1000000000 /* C.Far */;
        this.endSide = 0;
        // The amount of open active ranges at the start of the iterator.
        // Not including points.
        this.openStart = -1;
        this.cursor = HeapCursor.from(sets, skip, minPoint);
    }
    goto(pos, side = -1000000000 /* C.Far */) {
        this.cursor.goto(pos, side);
        this.active.length = this.activeTo.length = this.activeRank.length = 0;
        this.minActive = -1;
        this.to = pos;
        this.endSide = side;
        this.openStart = -1;
        this.next();
        return this;
    }
    forward(pos, side) {
        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)
            this.removeActive(this.minActive);
        this.cursor.forward(pos, side);
    }
    removeActive(index) {
        remove(this.active, index);
        remove(this.activeTo, index);
        remove(this.activeRank, index);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    addActive(trackOpen) {
        let i = 0, { value, to, rank } = this.cursor;
        while (i < this.activeRank.length && this.activeRank[i] <= rank)
            i++;
        insert(this.active, i, value);
        insert(this.activeTo, i, to);
        insert(this.activeRank, i, rank);
        if (trackOpen)
            insert(trackOpen, i, this.cursor.from);
        this.minActive = findMinIndex(this.active, this.activeTo);
    }
    // After calling this, if `this.point` != null, the next range is a
    // point. Otherwise, it's a regular range, covered by `this.active`.
    next() {
        let from = this.to, wasPoint = this.point;
        this.point = null;
        let trackOpen = this.openStart < 0 ? [] : null;
        for (;;) {
            let a = this.minActive;
            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {
                if (this.activeTo[a] > from) {
                    this.to = this.activeTo[a];
                    this.endSide = this.active[a].endSide;
                    break;
                }
                this.removeActive(a);
                if (trackOpen)
                    remove(trackOpen, a);
            }
            else if (!this.cursor.value) {
                this.to = this.endSide = 1000000000 /* C.Far */;
                break;
            }
            else if (this.cursor.from > from) {
                this.to = this.cursor.from;
                this.endSide = this.cursor.startSide;
                break;
            }
            else {
                let nextVal = this.cursor.value;
                if (!nextVal.point) { // Opening a range
                    this.addActive(trackOpen);
                    this.cursor.next();
                }
                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {
                    // Ignore any non-empty points that end precisely at the end of the prev point
                    this.cursor.next();
                }
                else { // New point
                    this.point = nextVal;
                    this.pointFrom = this.cursor.from;
                    this.pointRank = this.cursor.rank;
                    this.to = this.cursor.to;
                    this.endSide = nextVal.endSide;
                    this.cursor.next();
                    this.forward(this.to, this.endSide);
                    break;
                }
            }
        }
        if (trackOpen) {
            this.openStart = 0;
            for (let i = trackOpen.length - 1; i >= 0 && trackOpen[i] < from; i--)
                this.openStart++;
        }
    }
    activeForPoint(to) {
        if (!this.active.length)
            return this.active;
        let active = [];
        for (let i = this.active.length - 1; i >= 0; i--) {
            if (this.activeRank[i] < this.pointRank)
                break;
            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)
                active.push(this.active[i]);
        }
        return active.reverse();
    }
    openEnd(to) {
        let open = 0;
        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)
            open++;
        return open;
    }
}
function compare(a, startA, b, startB, length, comparator) {
    a.goto(startA);
    b.goto(startB);
    let endB = startB + length;
    let pos = startB, dPos = startB - startA;
    for (;;) {
        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;
        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);
        if (a.point || b.point) {
            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&
                sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))
                comparator.comparePoint(pos, clipEnd, a.point, b.point);
        }
        else {
            if (clipEnd > pos && !sameValues(a.active, b.active))
                comparator.compareRange(pos, clipEnd, a.active, b.active);
        }
        if (end > endB)
            break;
        pos = end;
        if (diff <= 0)
            a.next();
        if (diff >= 0)
            b.next();
    }
}
function sameValues(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (a[i] != b[i] && !a[i].eq(b[i]))
            return false;
    return true;
}
function remove(array, index) {
    for (let i = index, e = array.length - 1; i < e; i++)
        array[i] = array[i + 1];
    array.pop();
}
function insert(array, index, value) {
    for (let i = array.length - 1; i >= index; i--)
        array[i + 1] = array[i];
    array[index] = value;
}
function findMinIndex(value, array) {
    let found = -1, foundPos = 1000000000 /* C.Far */;
    for (let i = 0; i < array.length; i++)
        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {
            found = i;
            foundPos = array[i];
        }
    return found;
}

/**
Count the column position at the given offset into the string,
taking extending characters and tab size into account.
*/
function countColumn(string, tabSize, to = string.length) {
    let n = 0;
    for (let i = 0; i < to;) {
        if (string.charCodeAt(i) == 9) {
            n += tabSize - (n % tabSize);
            i++;
        }
        else {
            n++;
            i = findClusterBreak(string, i);
        }
    }
    return n;
}
/**
Find the offset that corresponds to the given column position in a
string, taking extending characters and tab size into account. By
default, the string length is returned when it is too short to
reach the column. Pass `strict` true to make it return -1 in that
situation.
*/
function findColumn(string, col, tabSize, strict) {
    for (let i = 0, n = 0;;) {
        if (n >= col)
            return i;
        if (i == string.length)
            break;
        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;
        i = findClusterBreak(string, i);
    }
    return strict === true ? -1 : string.length;
}



;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js


function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/style-mod/src/style-mod.js




var C = "\u037C";
var COUNT = typeof Symbol == "undefined" ? "__" + C : Symbol.for(C);
var SET = typeof Symbol == "undefined" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet");
var style_mod_top = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : {};

// :: - Style modules encapsulate a set of CSS rules defined from
// JavaScript. Their definitions are only available in a given DOM
// root after it has been _mounted_ there with `StyleModule.mount`.
//
// Style modules should be created once and stored somewhere, as
// opposed to re-creating them every time you need them. The amount of
// CSS rules generated for a given DOM root is bounded by the amount
// of style modules that were used. So to avoid leaking rules, don't
// create these dynamically, but treat them as one-time allocations.
var StyleModule = /*#__PURE__*/function () {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  function StyleModule(spec, options) {
    _classCallCheck(this, StyleModule);
    this.rules = [];
    var _ref = options || {},
      finish = _ref.finish;
    function splitSelector(selector) {
      return /^@/.test(selector) ? [selector] : selector.split(/,\s*/);
    }
    function render(selectors, spec, target, isKeyframes) {
      var local = [],
        isAt = /^@(\w+)\b/.exec(selectors[0]),
        keyframes = isAt && isAt[1] == "keyframes";
      if (isAt && spec == null) return target.push(selectors[0] + ";");
      for (var prop in spec) {
        var value = spec[prop];
        if (/&/.test(prop)) {
          render(prop.split(/,\s*/).map(function (part) {
            return selectors.map(function (sel) {
              return part.replace(/&/, sel);
            });
          }).reduce(function (a, b) {
            return a.concat(b);
          }), value, target);
        } else if (value && _typeof(value) == "object") {
          if (!isAt) throw new RangeError("The value of a property (" + prop + ") should be a primitive value.");
          render(splitSelector(prop), value, local, keyframes);
        } else if (value != null) {
          local.push(prop.replace(/_.*/, "").replace(/[A-Z]/g, function (l) {
            return "-" + l.toLowerCase();
          }) + ": " + value + ";");
        }
      }
      if (local.length || keyframes) {
        target.push((finish && !isAt && !isKeyframes ? selectors.map(finish) : selectors).join(", ") + " {" + local.join(" ") + "}");
      }
    }
    for (var prop in spec) render(splitSelector(prop), spec[prop], this.rules);
  }

  // :: () → string
  // Returns a string containing the module's CSS rules.
  _createClass(StyleModule, [{
    key: "getRules",
    value: function getRules() {
      return this.rules.join("\n");
    }

    // :: () → string
    // Generate a new unique CSS class name.
  }], [{
    key: "newName",
    value: function newName() {
      var id = style_mod_top[COUNT] || 1;
      style_mod_top[COUNT] = id + 1;
      return C + id.toString(36);
    }

    // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
    //
    // Mount the given set of modules in the given DOM root, which ensures
    // that the CSS rules defined by the module are available in that
    // context.
    //
    // Rules are only added to the document once per root.
    //
    // Rule order will follow the order of the modules, so that rules from
    // modules later in the array take precedence of those from earlier
    // modules. If you call this function multiple times for the same root
    // in a way that changes the order of already mounted modules, the old
    // order will be changed.
    //
    // If a Content Security Policy nonce is provided, it is added to
    // the `<style>` tag generated by the library.
  }, {
    key: "mount",
    value: function mount(root, modules, options) {
      var set = root[SET],
        nonce = options && options.nonce;
      if (!set) set = new StyleSet(root, nonce);else if (nonce) set.setNonce(nonce);
      set.mount(Array.isArray(modules) ? modules : [modules]);
    }
  }]);
  return StyleModule;
}();
var adoptedSet = new Map(); //<Document, StyleSet>
var StyleSet = /*#__PURE__*/function () {
  function StyleSet(root, nonce) {
    _classCallCheck(this, StyleSet);
    var doc = root.ownerDocument || root,
      win = doc.defaultView;
    if (!root.head && root.adoptedStyleSheets && win.CSSStyleSheet) {
      var adopted = adoptedSet.get(doc);
      if (adopted) {
        root.adoptedStyleSheets = [adopted.sheet].concat(_toConsumableArray(root.adoptedStyleSheets));
        return root[SET] = adopted;
      }
      this.sheet = new win.CSSStyleSheet();
      root.adoptedStyleSheets = [this.sheet].concat(_toConsumableArray(root.adoptedStyleSheets));
      adoptedSet.set(doc, this);
    } else {
      this.styleTag = doc.createElement("style");
      if (nonce) this.styleTag.setAttribute("nonce", nonce);
      var target = root.head || root;
      target.insertBefore(this.styleTag, target.firstChild);
    }
    this.modules = [];
    root[SET] = this;
  }
  _createClass(StyleSet, [{
    key: "mount",
    value: function mount(modules) {
      var sheet = this.sheet;
      var pos = 0 /* Current rule offset */,
        j = 0; /* Index into this.modules */
      for (var i = 0; i < modules.length; i++) {
        var mod = modules[i],
          index = this.modules.indexOf(mod);
        if (index < j && index > -1) {
          // Ordering conflict
          this.modules.splice(index, 1);
          j--;
          index = -1;
        }
        if (index == -1) {
          this.modules.splice(j++, 0, mod);
          if (sheet) for (var k = 0; k < mod.rules.length; k++) sheet.insertRule(mod.rules[k], pos++);
        } else {
          while (j < index) pos += this.modules[j++].rules.length;
          pos += mod.rules.length;
          j++;
        }
      }
      if (!sheet) {
        var text = "";
        for (var _i = 0; _i < this.modules.length; _i++) text += this.modules[_i].getRules() + "\n";
        this.styleTag.textContent = text;
      }
    }
  }, {
    key: "setNonce",
    value: function setNonce(nonce) {
      if (this.styleTag && this.styleTag.getAttribute("nonce") != nonce) this.styleTag.setAttribute("nonce", nonce);
    }
  }]);
  return StyleSet;
}(); // Style::Object<union<Style,string>>
//
// A style is an object that, in the simple case, maps CSS property
// names to strings holding their values, as in `{color: "red",
// fontWeight: "bold"}`. The property names can be given in
// camel-case—the library will insert a dash before capital letters
// when converting them to CSS.
//
// If you include an underscore in a property name, it and everything
// after it will be removed from the output, which can be useful when
// providing a property multiple times, for browser compatibility
// reasons.
//
// A property in a style object can also be a sub-selector, which
// extends the current context to add a pseudo-selector or a child
// selector. Such a property should contain a `&` character, which
// will be replaced by the current selector. For example `{"&:before":
// {content: '"hi"'}}`. Sub-selectors and regular properties can
// freely be mixed in a given object. Any property containing a `&` is
// assumed to be a sub-selector.
//
// Finally, a property can specify an @-block to be wrapped around the
// styles defined inside the object that's the property's value. For
// example to create a media query you can do `{"@media screen and
// (min-width: 400px)": {...}}`.
;// CONCATENATED MODULE: ./node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
}

var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
      ie && event.shiftKey && event.key && event.key.length == 1 ||
      event.key == "Unidentified"
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}

;// CONCATENATED MODULE: ./node_modules/@codemirror/view/dist/index.js




function getSelection(root) {
    let target;
    // Browsers differ on whether shadow roots have a getSelection
    // method. If it exists, use that, otherwise, call it on the
    // document.
    if (root.nodeType == 11) { // Shadow root
        target = root.getSelection ? root : root.ownerDocument;
    }
    else {
        target = root;
    }
    return target.getSelection();
}
function contains(dom, node) {
    return node ? dom == node || dom.contains(node.nodeType != 1 ? node.parentNode : node) : false;
}
function deepActiveElement(doc) {
    let elt = doc.activeElement;
    while (elt && elt.shadowRoot)
        elt = elt.shadowRoot.activeElement;
    return elt;
}
function hasSelection(dom, selection) {
    if (!selection.anchorNode)
        return false;
    try {
        // Firefox will raise 'permission denied' errors when accessing
        // properties of `sel.anchorNode` when it's in a generated CSS
        // element.
        return contains(dom, selection.anchorNode);
    }
    catch (_) {
        return false;
    }
}
function clientRectsFor(dom) {
    if (dom.nodeType == 3)
        return textRange(dom, 0, dom.nodeValue.length).getClientRects();
    else if (dom.nodeType == 1)
        return dom.getClientRects();
    else
        return [];
}
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
function isEquivalentPosition(node, off, targetNode, targetOff) {
    return targetNode ? (scanFor(node, off, targetNode, targetOff, -1) ||
        scanFor(node, off, targetNode, targetOff, 1)) : false;
}
function domIndex(node) {
    for (var index = 0;; index++) {
        node = node.previousSibling;
        if (!node)
            return index;
    }
}
function scanFor(node, off, targetNode, targetOff, dir) {
    for (;;) {
        if (node == targetNode && off == targetOff)
            return true;
        if (off == (dir < 0 ? 0 : maxOffset(node))) {
            if (node.nodeName == "DIV")
                return false;
            let parent = node.parentNode;
            if (!parent || parent.nodeType != 1)
                return false;
            off = domIndex(node) + (dir < 0 ? 0 : 1);
            node = parent;
        }
        else if (node.nodeType == 1) {
            node = node.childNodes[off + (dir < 0 ? -1 : 0)];
            if (node.nodeType == 1 && node.contentEditable == "false")
                return false;
            off = dir < 0 ? maxOffset(node) : 0;
        }
        else {
            return false;
        }
    }
}
function maxOffset(node) {
    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function flattenRect(rect, left) {
    let x = left ? rect.left : rect.right;
    return { left: x, right: x, top: rect.top, bottom: rect.bottom };
}
function windowRect(win) {
    return { left: 0, right: win.innerWidth,
        top: 0, bottom: win.innerHeight };
}
function getScale(elt, rect) {
    let scaleX = rect.width / elt.offsetWidth;
    let scaleY = rect.height / elt.offsetHeight;
    if (scaleX > 0.995 && scaleX < 1.005 || !isFinite(scaleX) || Math.abs(rect.width - elt.offsetWidth) < 1)
        scaleX = 1;
    if (scaleY > 0.995 && scaleY < 1.005 || !isFinite(scaleY) || Math.abs(rect.height - elt.offsetHeight) < 1)
        scaleY = 1;
    return { scaleX, scaleY };
}
function scrollRectIntoView(dom, rect, side, x, y, xMargin, yMargin, ltr) {
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    for (let cur = dom, stop = false; cur && !stop;) {
        if (cur.nodeType == 1) { // Element
            let bounding, top = cur == doc.body;
            let scaleX = 1, scaleY = 1;
            if (top) {
                bounding = windowRect(win);
            }
            else {
                if (/^(fixed|sticky)$/.test(getComputedStyle(cur).position))
                    stop = true;
                if (cur.scrollHeight <= cur.clientHeight && cur.scrollWidth <= cur.clientWidth) {
                    cur = cur.assignedSlot || cur.parentNode;
                    continue;
                }
                let rect = cur.getBoundingClientRect();
                ({ scaleX, scaleY } = getScale(cur, rect));
                // Make sure scrollbar width isn't included in the rectangle
                bounding = { left: rect.left, right: rect.left + cur.clientWidth * scaleX,
                    top: rect.top, bottom: rect.top + cur.clientHeight * scaleY };
            }
            let moveX = 0, moveY = 0;
            if (y == "nearest") {
                if (rect.top < bounding.top) {
                    moveY = -(bounding.top - rect.top + yMargin);
                    if (side > 0 && rect.bottom > bounding.bottom + moveY)
                        moveY = rect.bottom - bounding.bottom + moveY + yMargin;
                }
                else if (rect.bottom > bounding.bottom) {
                    moveY = rect.bottom - bounding.bottom + yMargin;
                    if (side < 0 && (rect.top - moveY) < bounding.top)
                        moveY = -(bounding.top + moveY - rect.top + yMargin);
                }
            }
            else {
                let rectHeight = rect.bottom - rect.top, boundingHeight = bounding.bottom - bounding.top;
                let targetTop = y == "center" && rectHeight <= boundingHeight ? rect.top + rectHeight / 2 - boundingHeight / 2 :
                    y == "start" || y == "center" && side < 0 ? rect.top - yMargin :
                        rect.bottom - boundingHeight + yMargin;
                moveY = targetTop - bounding.top;
            }
            if (x == "nearest") {
                if (rect.left < bounding.left) {
                    moveX = -(bounding.left - rect.left + xMargin);
                    if (side > 0 && rect.right > bounding.right + moveX)
                        moveX = rect.right - bounding.right + moveX + xMargin;
                }
                else if (rect.right > bounding.right) {
                    moveX = rect.right - bounding.right + xMargin;
                    if (side < 0 && rect.left < bounding.left + moveX)
                        moveX = -(bounding.left + moveX - rect.left + xMargin);
                }
            }
            else {
                let targetLeft = x == "center" ? rect.left + (rect.right - rect.left) / 2 - (bounding.right - bounding.left) / 2 :
                    (x == "start") == ltr ? rect.left - xMargin :
                        rect.right - (bounding.right - bounding.left) + xMargin;
                moveX = targetLeft - bounding.left;
            }
            if (moveX || moveY) {
                if (top) {
                    win.scrollBy(moveX, moveY);
                }
                else {
                    let movedX = 0, movedY = 0;
                    if (moveY) {
                        let start = cur.scrollTop;
                        cur.scrollTop += moveY / scaleY;
                        movedY = (cur.scrollTop - start) * scaleY;
                    }
                    if (moveX) {
                        let start = cur.scrollLeft;
                        cur.scrollLeft += moveX / scaleX;
                        movedX = (cur.scrollLeft - start) * scaleX;
                    }
                    rect = { left: rect.left - movedX, top: rect.top - movedY,
                        right: rect.right - movedX, bottom: rect.bottom - movedY };
                    if (movedX && Math.abs(movedX - moveX) < 1)
                        x = "nearest";
                    if (movedY && Math.abs(movedY - moveY) < 1)
                        y = "nearest";
                }
            }
            if (top)
                break;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) { // A shadow root
            cur = cur.host;
        }
        else {
            break;
        }
    }
}
function scrollableParent(dom) {
    let doc = dom.ownerDocument;
    for (let cur = dom.parentNode; cur;) {
        if (cur == doc.body) {
            break;
        }
        else if (cur.nodeType == 1) {
            if (cur.scrollHeight > cur.clientHeight || cur.scrollWidth > cur.clientWidth)
                return cur;
            cur = cur.assignedSlot || cur.parentNode;
        }
        else if (cur.nodeType == 11) {
            cur = cur.host;
        }
        else {
            break;
        }
    }
    return null;
}
class DOMSelectionState {
    constructor() {
        this.anchorNode = null;
        this.anchorOffset = 0;
        this.focusNode = null;
        this.focusOffset = 0;
    }
    eq(domSel) {
        return this.anchorNode == domSel.anchorNode && this.anchorOffset == domSel.anchorOffset &&
            this.focusNode == domSel.focusNode && this.focusOffset == domSel.focusOffset;
    }
    setRange(range) {
        let { anchorNode, focusNode } = range;
        // Clip offsets to node size to avoid crashes when Safari reports bogus offsets (#1152)
        this.set(anchorNode, Math.min(range.anchorOffset, anchorNode ? maxOffset(anchorNode) : 0), focusNode, Math.min(range.focusOffset, focusNode ? maxOffset(focusNode) : 0));
    }
    set(anchorNode, anchorOffset, focusNode, focusOffset) {
        this.anchorNode = anchorNode;
        this.anchorOffset = anchorOffset;
        this.focusNode = focusNode;
        this.focusOffset = focusOffset;
    }
}
let preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
    if (dom.setActive)
        return dom.setActive(); // in IE
    if (preventScrollSupported)
        return dom.focus(preventScrollSupported);
    let stack = [];
    for (let cur = dom; cur; cur = cur.parentNode) {
        stack.push(cur, cur.scrollTop, cur.scrollLeft);
        if (cur == cur.ownerDocument)
            break;
    }
    dom.focus(preventScrollSupported == null ? {
        get preventScroll() {
            preventScrollSupported = { preventScroll: true };
            return true;
        }
    } : undefined);
    if (!preventScrollSupported) {
        preventScrollSupported = false;
        for (let i = 0; i < stack.length;) {
            let elt = stack[i++], top = stack[i++], left = stack[i++];
            if (elt.scrollTop != top)
                elt.scrollTop = top;
            if (elt.scrollLeft != left)
                elt.scrollLeft = left;
        }
    }
}
let scratchRange;
function textRange(node, from, to = from) {
    let range = scratchRange || (scratchRange = document.createRange());
    range.setEnd(node, to);
    range.setStart(node, from);
    return range;
}
function dispatchKey(elt, name, code) {
    let options = { key: name, code: name, keyCode: code, which: code, cancelable: true };
    let down = new KeyboardEvent("keydown", options);
    down.synthetic = true;
    elt.dispatchEvent(down);
    let up = new KeyboardEvent("keyup", options);
    up.synthetic = true;
    elt.dispatchEvent(up);
    return down.defaultPrevented || up.defaultPrevented;
}
function getRoot(node) {
    while (node) {
        if (node && (node.nodeType == 9 || node.nodeType == 11 && node.host))
            return node;
        node = node.assignedSlot || node.parentNode;
    }
    return null;
}
function clearAttributes(node) {
    while (node.attributes.length)
        node.removeAttributeNode(node.attributes[0]);
}
function atElementStart(doc, selection) {
    let node = selection.focusNode, offset = selection.focusOffset;
    if (!node || selection.anchorNode != node || selection.anchorOffset != offset)
        return false;
    // Safari can report bogus offsets (#1152)
    offset = Math.min(offset, maxOffset(node));
    for (;;) {
        if (offset) {
            if (node.nodeType != 1)
                return false;
            let prev = node.childNodes[offset - 1];
            if (prev.contentEditable == "false")
                offset--;
            else {
                node = prev;
                offset = maxOffset(node);
            }
        }
        else if (node == doc) {
            return true;
        }
        else {
            offset = domIndex(node);
            node = node.parentNode;
        }
    }
}
function isScrolledToBottom(elt) {
    return elt.scrollTop > Math.max(1, elt.scrollHeight - elt.clientHeight - 4);
}

class DOMPos {
    constructor(node, offset, precise = true) {
        this.node = node;
        this.offset = offset;
        this.precise = precise;
    }
    static before(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom), precise); }
    static after(dom, precise) { return new DOMPos(dom.parentNode, domIndex(dom) + 1, precise); }
}
const noChildren = [];
class ContentView {
    constructor() {
        this.parent = null;
        this.dom = null;
        this.flags = 2 /* ViewFlag.NodeDirty */;
    }
    get overrideDOMText() { return null; }
    get posAtStart() {
        return this.parent ? this.parent.posBefore(this) : 0;
    }
    get posAtEnd() {
        return this.posAtStart + this.length;
    }
    posBefore(view) {
        let pos = this.posAtStart;
        for (let child of this.children) {
            if (child == view)
                return pos;
            pos += child.length + child.breakAfter;
        }
        throw new RangeError("Invalid child in posBefore");
    }
    posAfter(view) {
        return this.posBefore(view) + view.length;
    }
    sync(view, track) {
        if (this.flags & 2 /* ViewFlag.NodeDirty */) {
            let parent = this.dom;
            let prev = null, next;
            for (let child of this.children) {
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    if (!child.dom && (next = prev ? prev.nextSibling : parent.firstChild)) {
                        let contentView = ContentView.get(next);
                        if (!contentView || !contentView.parent && contentView.canReuseDOM(child))
                            child.reuseDOM(next);
                    }
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
                next = prev ? prev.nextSibling : parent.firstChild;
                if (track && !track.written && track.node == parent && next != child.dom)
                    track.written = true;
                if (child.dom.parentNode == parent) {
                    while (next && next != child.dom)
                        next = rm$1(next);
                }
                else {
                    parent.insertBefore(child.dom, next);
                }
                prev = child.dom;
            }
            next = prev ? prev.nextSibling : parent.firstChild;
            if (next && track && track.node == parent)
                track.written = true;
            while (next)
                next = rm$1(next);
        }
        else if (this.flags & 1 /* ViewFlag.ChildDirty */) {
            for (let child of this.children)
                if (child.flags & 7 /* ViewFlag.Dirty */) {
                    child.sync(view, track);
                    child.flags &= ~7 /* ViewFlag.Dirty */;
                }
        }
    }
    reuseDOM(_dom) { }
    localPosFromDOM(node, offset) {
        let after;
        if (node == this.dom) {
            after = this.dom.childNodes[offset];
        }
        else {
            let bias = maxOffset(node) == 0 ? 0 : offset == 0 ? -1 : 1;
            for (;;) {
                let parent = node.parentNode;
                if (parent == this.dom)
                    break;
                if (bias == 0 && parent.firstChild != parent.lastChild) {
                    if (node == parent.firstChild)
                        bias = -1;
                    else
                        bias = 1;
                }
                node = parent;
            }
            if (bias < 0)
                after = node;
            else
                after = node.nextSibling;
        }
        if (after == this.dom.firstChild)
            return 0;
        while (after && !ContentView.get(after))
            after = after.nextSibling;
        if (!after)
            return this.length;
        for (let i = 0, pos = 0;; i++) {
            let child = this.children[i];
            if (child.dom == after)
                return pos;
            pos += child.length + child.breakAfter;
        }
    }
    domBoundsAround(from, to, offset = 0) {
        let fromI = -1, fromStart = -1, toI = -1, toEnd = -1;
        for (let i = 0, pos = offset, prevEnd = offset; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (pos < from && end > to)
                return child.domBoundsAround(from, to, pos);
            if (end >= from && fromI == -1) {
                fromI = i;
                fromStart = pos;
            }
            if (pos > to && child.dom.parentNode == this.dom) {
                toI = i;
                toEnd = prevEnd;
                break;
            }
            prevEnd = end;
            pos = end + child.breakAfter;
        }
        return { from: fromStart, to: toEnd < 0 ? offset + this.length : toEnd,
            startDOM: (fromI ? this.children[fromI - 1].dom.nextSibling : null) || this.dom.firstChild,
            endDOM: toI < this.children.length && toI >= 0 ? this.children[toI].dom : null };
    }
    markDirty(andParent = false) {
        this.flags |= 2 /* ViewFlag.NodeDirty */;
        this.markParentsDirty(andParent);
    }
    markParentsDirty(childList) {
        for (let parent = this.parent; parent; parent = parent.parent) {
            if (childList)
                parent.flags |= 2 /* ViewFlag.NodeDirty */;
            if (parent.flags & 1 /* ViewFlag.ChildDirty */)
                return;
            parent.flags |= 1 /* ViewFlag.ChildDirty */;
            childList = false;
        }
    }
    setParent(parent) {
        if (this.parent != parent) {
            this.parent = parent;
            if (this.flags & 7 /* ViewFlag.Dirty */)
                this.markParentsDirty(true);
        }
    }
    setDOM(dom) {
        if (this.dom == dom)
            return;
        if (this.dom)
            this.dom.cmView = null;
        this.dom = dom;
        dom.cmView = this;
    }
    get rootView() {
        for (let v = this;;) {
            let parent = v.parent;
            if (!parent)
                return v;
            v = parent;
        }
    }
    replaceChildren(from, to, children = noChildren) {
        this.markDirty();
        for (let i = from; i < to; i++) {
            let child = this.children[i];
            if (child.parent == this && children.indexOf(child) < 0)
                child.destroy();
        }
        this.children.splice(from, to - from, ...children);
        for (let i = 0; i < children.length; i++)
            children[i].setParent(this);
    }
    ignoreMutation(_rec) { return false; }
    ignoreEvent(_event) { return false; }
    childCursor(pos = this.length) {
        return new ChildCursor(this.children, pos, this.children.length);
    }
    childPos(pos, bias = 1) {
        return this.childCursor().findPos(pos, bias);
    }
    toString() {
        let name = this.constructor.name.replace("View", "");
        return name + (this.children.length ? "(" + this.children.join() + ")" :
            this.length ? "[" + (name == "Text" ? this.text : this.length) + "]" : "") +
            (this.breakAfter ? "#" : "");
    }
    static get(node) { return node.cmView; }
    get isEditable() { return true; }
    get isWidget() { return false; }
    get isHidden() { return false; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        return false;
    }
    become(other) { return false; }
    canReuseDOM(other) {
        return other.constructor == this.constructor && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    // When this is a zero-length view with a side, this should return a
    // number <= 0 to indicate it is before its position, or a
    // number > 0 when after its position.
    getSide() { return 0; }
    destroy() {
        for (let child of this.children)
            if (child.parent == this)
                child.destroy();
        this.parent = null;
    }
}
ContentView.prototype.breakAfter = 0;
// Remove a DOM node and return its next sibling.
function rm$1(dom) {
    let next = dom.nextSibling;
    dom.parentNode.removeChild(dom);
    return next;
}
class ChildCursor {
    constructor(children, pos, i) {
        this.children = children;
        this.pos = pos;
        this.i = i;
        this.off = 0;
    }
    findPos(pos, bias = 1) {
        for (;;) {
            if (pos > this.pos || pos == this.pos &&
                (bias > 0 || this.i == 0 || this.children[this.i - 1].breakAfter)) {
                this.off = pos - this.pos;
                return this;
            }
            let next = this.children[--this.i];
            this.pos -= next.length + next.breakAfter;
        }
    }
}
function replaceRange(parent, fromI, fromOff, toI, toOff, insert, breakAtStart, openStart, openEnd) {
    let { children } = parent;
    let before = children.length ? children[fromI] : null;
    let last = insert.length ? insert[insert.length - 1] : null;
    let breakAtEnd = last ? last.breakAfter : breakAtStart;
    // Change within a single child
    if (fromI == toI && before && !breakAtStart && !breakAtEnd && insert.length < 2 &&
        before.merge(fromOff, toOff, insert.length ? last : null, fromOff == 0, openStart, openEnd))
        return;
    if (toI < children.length) {
        let after = children[toI];
        // Make sure the end of the child after the update is preserved in `after`
        if (after && (toOff < after.length || after.breakAfter && (last === null || last === void 0 ? void 0 : last.breakAfter))) {
            // If we're splitting a child, separate part of it to avoid that
            // being mangled when updating the child before the update.
            if (fromI == toI) {
                after = after.split(toOff);
                toOff = 0;
            }
            // If the element after the replacement should be merged with
            // the last replacing element, update `content`
            if (!breakAtEnd && last && after.merge(0, toOff, last, true, 0, openEnd)) {
                insert[insert.length - 1] = after;
            }
            else {
                // Remove the start of the after element, if necessary, and
                // add it to `content`.
                if (toOff || after.children.length && !after.children[0].length)
                    after.merge(0, toOff, null, false, 0, openEnd);
                insert.push(after);
            }
        }
        else if (after === null || after === void 0 ? void 0 : after.breakAfter) {
            // The element at `toI` is entirely covered by this range.
            // Preserve its line break, if any.
            if (last)
                last.breakAfter = 1;
            else
                breakAtStart = 1;
        }
        // Since we've handled the next element from the current elements
        // now, make sure `toI` points after that.
        toI++;
    }
    if (before) {
        before.breakAfter = breakAtStart;
        if (fromOff > 0) {
            if (!breakAtStart && insert.length && before.merge(fromOff, before.length, insert[0], false, openStart, 0)) {
                before.breakAfter = insert.shift().breakAfter;
            }
            else if (fromOff < before.length || before.children.length && before.children[before.children.length - 1].length == 0) {
                before.merge(fromOff, before.length, null, false, openStart, 0);
            }
            fromI++;
        }
    }
    // Try to merge widgets on the boundaries of the replacement
    while (fromI < toI && insert.length) {
        if (children[toI - 1].become(insert[insert.length - 1])) {
            toI--;
            insert.pop();
            openEnd = insert.length ? 0 : openStart;
        }
        else if (children[fromI].become(insert[0])) {
            fromI++;
            insert.shift();
            openStart = insert.length ? 0 : openEnd;
        }
        else {
            break;
        }
    }
    if (!insert.length && fromI && toI < children.length && !children[fromI - 1].breakAfter &&
        children[toI].merge(0, 0, children[fromI - 1], false, openStart, openEnd))
        fromI--;
    if (fromI < toI || insert.length)
        parent.replaceChildren(fromI, toI, insert);
}
function mergeChildrenInto(parent, from, to, insert, openStart, openEnd) {
    let cur = parent.childCursor();
    let { i: toI, off: toOff } = cur.findPos(to, 1);
    let { i: fromI, off: fromOff } = cur.findPos(from, -1);
    let dLen = from - to;
    for (let view of insert)
        dLen += view.length;
    parent.length += dLen;
    replaceRange(parent, fromI, fromOff, toI, toOff, insert, 0, openStart, openEnd);
}

let nav = typeof navigator != "undefined" ? navigator : { userAgent: "", vendor: "", platform: "" };
let doc = typeof document != "undefined" ? document : { documentElement: { style: {} } };
const ie_edge = /*@__PURE__*//Edge\/(\d+)/.exec(nav.userAgent);
const ie_upto10 = /*@__PURE__*//MSIE \d/.test(nav.userAgent);
const ie_11up = /*@__PURE__*//Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(nav.userAgent);
const dist_ie = !!(ie_upto10 || ie_11up || ie_edge);
const gecko = !dist_ie && /*@__PURE__*//gecko\/(\d+)/i.test(nav.userAgent);
const chrome = !dist_ie && /*@__PURE__*//Chrome\/(\d+)/.exec(nav.userAgent);
const webkit = "webkitFontSmoothing" in doc.documentElement.style;
const safari = !dist_ie && /*@__PURE__*//Apple Computer/.test(nav.vendor);
const ios = safari && (/*@__PURE__*//Mobile\/\w+/.test(nav.userAgent) || nav.maxTouchPoints > 2);
var browser = {
    mac: ios || /*@__PURE__*//Mac/.test(nav.platform),
    windows: /*@__PURE__*//Win/.test(nav.platform),
    linux: /*@__PURE__*//Linux|X11/.test(nav.platform),
    ie: dist_ie,
    ie_version: ie_upto10 ? doc.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0,
    gecko,
    gecko_version: gecko ? +(/*@__PURE__*//Firefox\/(\d+)/.exec(nav.userAgent) || [0, 0])[1] : 0,
    chrome: !!chrome,
    chrome_version: chrome ? +chrome[1] : 0,
    ios,
    android: /*@__PURE__*//Android\b/.test(nav.userAgent),
    webkit,
    safari,
    webkit_version: webkit ? +(/*@__PURE__*//\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
    tabSize: doc.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};

const MaxJoinLen = 256;
class TextView extends ContentView {
    constructor(text) {
        super();
        this.text = text;
    }
    get length() { return this.text.length; }
    createDOM(textDOM) {
        this.setDOM(textDOM || document.createTextNode(this.text));
    }
    sync(view, track) {
        if (!this.dom)
            this.createDOM();
        if (this.dom.nodeValue != this.text) {
            if (track && track.node == this.dom)
                track.written = true;
            this.dom.nodeValue = this.text;
        }
    }
    reuseDOM(dom) {
        if (dom.nodeType == 3)
            this.createDOM(dom);
    }
    merge(from, to, source) {
        if ((this.flags & 8 /* ViewFlag.Composition */) ||
            source && (!(source instanceof TextView) ||
                this.length - (to - from) + source.length > MaxJoinLen ||
                (source.flags & 8 /* ViewFlag.Composition */)))
            return false;
        this.text = this.text.slice(0, from) + (source ? source.text : "") + this.text.slice(to);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = new TextView(this.text.slice(from));
        this.text = this.text.slice(0, from);
        this.markDirty();
        result.flags |= this.flags & 8 /* ViewFlag.Composition */;
        return result;
    }
    localPosFromDOM(node, offset) {
        return node == this.dom ? offset : offset ? this.text.length : 0;
    }
    domAtPos(pos) { return new DOMPos(this.dom, pos); }
    domBoundsAround(_from, _to, offset) {
        return { from: offset, to: offset + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
    }
    coordsAt(pos, side) {
        return textCoords(this.dom, pos, side);
    }
}
class MarkView extends ContentView {
    constructor(mark, children = [], length = 0) {
        super();
        this.mark = mark;
        this.children = children;
        this.length = length;
        for (let ch of children)
            ch.setParent(this);
    }
    setAttrs(dom) {
        clearAttributes(dom);
        if (this.mark.class)
            dom.className = this.mark.class;
        if (this.mark.attrs)
            for (let name in this.mark.attrs)
                dom.setAttribute(name, this.mark.attrs[name]);
        return dom;
    }
    canReuseDOM(other) {
        return super.canReuseDOM(other) && !((this.flags | other.flags) & 8 /* ViewFlag.Composition */);
    }
    reuseDOM(node) {
        if (node.nodeName == this.mark.tagName.toUpperCase()) {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        if (!this.dom)
            this.setDOM(this.setAttrs(document.createElement(this.mark.tagName)));
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */)
            this.setAttrs(this.dom);
        super.sync(view, track);
    }
    merge(from, to, source, _hasStart, openStart, openEnd) {
        if (source && (!(source instanceof MarkView && source.mark.eq(this.mark)) ||
            (from && openStart <= 0) || (to < this.length && openEnd <= 0)))
            return false;
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart - 1, openEnd - 1);
        this.markDirty();
        return true;
    }
    split(from) {
        let result = [], off = 0, detachFrom = -1, i = 0;
        for (let elt of this.children) {
            let end = off + elt.length;
            if (end > from)
                result.push(off < from ? elt.split(from - off) : elt);
            if (detachFrom < 0 && off >= from)
                detachFrom = i;
            off = end;
            i++;
        }
        let length = this.length - from;
        this.length = from;
        if (detachFrom > -1) {
            this.children.length = detachFrom;
            this.markDirty();
        }
        return new MarkView(this.mark, result, length);
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    coordsAt(pos, side) {
        return coordsInChildren(this, pos, side);
    }
}
function textCoords(text, pos, side) {
    let length = text.nodeValue.length;
    if (pos > length)
        pos = length;
    let from = pos, to = pos, flatten = 0;
    if (pos == 0 && side < 0 || pos == length && side >= 0) {
        if (!(browser.chrome || browser.gecko)) { // These browsers reliably return valid rectangles for empty ranges
            if (pos) {
                from--;
                flatten = 1;
            } // FIXME this is wrong in RTL text
            else if (to < length) {
                to++;
                flatten = -1;
            }
        }
    }
    else {
        if (side < 0)
            from--;
        else if (to < length)
            to++;
    }
    let rects = textRange(text, from, to).getClientRects();
    if (!rects.length)
        return null;
    let rect = rects[(flatten ? flatten < 0 : side >= 0) ? 0 : rects.length - 1];
    if (browser.safari && !flatten && rect.width == 0)
        rect = Array.prototype.find.call(rects, r => r.width) || rect;
    return flatten ? flattenRect(rect, flatten < 0) : rect || null;
}
// Also used for collapsed ranges that don't have a placeholder widget!
class WidgetView extends ContentView {
    static create(widget, length, side) {
        return new WidgetView(widget, length, side);
    }
    constructor(widget, length, side) {
        super();
        this.widget = widget;
        this.length = length;
        this.side = side;
        this.prevWidget = null;
    }
    split(from) {
        let result = WidgetView.create(this.widget, this.length - from, this.side);
        this.length -= from;
        return result;
    }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            this.dom.contentEditable = "false";
        }
    }
    getSide() { return this.side; }
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source && (!(source instanceof WidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    become(other) {
        if (other instanceof WidgetView && other.side == this.side &&
            this.widget.constructor == other.widget.constructor) {
            if (!this.widget.compare(other.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get overrideDOMText() {
        if (this.length == 0)
            return Text.empty;
        let top = this;
        while (top.parent)
            top = top.parent;
        let { view } = top, text = view && view.state.doc, start = this.posAtStart;
        return text ? text.slice(start, start + this.length) : Text.empty;
    }
    domAtPos(pos) {
        return (this.length ? pos == 0 : this.side > 0)
            ? DOMPos.before(this.dom)
            : DOMPos.after(this.dom, pos == this.length);
    }
    domBoundsAround() { return null; }
    coordsAt(pos, side) {
        let custom = this.widget.coordsAt(this.dom, pos, side);
        if (custom)
            return custom;
        let rects = this.dom.getClientRects(), rect = null;
        if (!rects.length)
            return null;
        let fromBack = this.side ? this.side < 0 : pos > 0;
        for (let i = fromBack ? rects.length - 1 : 0;; i += (fromBack ? -1 : 1)) {
            rect = rects[i];
            if (pos > 0 ? i == 0 : i == rects.length - 1 || rect.top < rect.bottom)
                break;
        }
        return flattenRect(rect, !fromBack);
    }
    get isEditable() { return false; }
    get isWidget() { return true; }
    get isHidden() { return this.widget.isHidden; }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
}
// These are drawn around uneditable widgets to avoid a number of
// browser bugs that show up when the cursor is directly next to
// uneditable inline content.
class WidgetBufferView extends ContentView {
    constructor(side) {
        super();
        this.side = side;
    }
    get length() { return 0; }
    merge() { return false; }
    become(other) {
        return other instanceof WidgetBufferView && other.side == this.side;
    }
    split() { return new WidgetBufferView(this.side); }
    sync() {
        if (!this.dom) {
            let dom = document.createElement("img");
            dom.className = "cm-widgetBuffer";
            dom.setAttribute("aria-hidden", "true");
            this.setDOM(dom);
        }
    }
    getSide() { return this.side; }
    domAtPos(pos) { return this.side > 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom); }
    localPosFromDOM() { return 0; }
    domBoundsAround() { return null; }
    coordsAt(pos) {
        return this.dom.getBoundingClientRect();
    }
    get overrideDOMText() {
        return Text.empty;
    }
    get isHidden() { return true; }
}
TextView.prototype.children = WidgetView.prototype.children = WidgetBufferView.prototype.children = noChildren;
function inlineDOMAtPos(parent, pos) {
    let dom = parent.dom, { children } = parent, i = 0;
    for (let off = 0; i < children.length; i++) {
        let child = children[i], end = off + child.length;
        if (end == off && child.getSide() <= 0)
            continue;
        if (pos > off && pos < end && child.dom.parentNode == dom)
            return child.domAtPos(pos - off);
        if (pos <= off)
            break;
        off = end;
    }
    for (let j = i; j > 0; j--) {
        let prev = children[j - 1];
        if (prev.dom.parentNode == dom)
            return prev.domAtPos(prev.length);
    }
    for (let j = i; j < children.length; j++) {
        let next = children[j];
        if (next.dom.parentNode == dom)
            return next.domAtPos(0);
    }
    return new DOMPos(dom, 0);
}
// Assumes `view`, if a mark view, has precisely 1 child.
function joinInlineInto(parent, view, open) {
    let last, { children } = parent;
    if (open > 0 && view instanceof MarkView && children.length &&
        (last = children[children.length - 1]) instanceof MarkView && last.mark.eq(view.mark)) {
        joinInlineInto(last, view.children[0], open - 1);
    }
    else {
        children.push(view);
        view.setParent(parent);
    }
    parent.length += view.length;
}
function coordsInChildren(view, pos, side) {
    let before = null, beforePos = -1, after = null, afterPos = -1;
    function scan(view, pos) {
        for (let i = 0, off = 0; i < view.children.length && off <= pos; i++) {
            let child = view.children[i], end = off + child.length;
            if (end >= pos) {
                if (child.children.length) {
                    scan(child, pos - off);
                }
                else if ((!after || after.isHidden && side > 0) &&
                    (end > pos || off == end && child.getSide() > 0)) {
                    after = child;
                    afterPos = pos - off;
                }
                else if (off < pos || (off == end && child.getSide() < 0) && !child.isHidden) {
                    before = child;
                    beforePos = pos - off;
                }
            }
            off = end;
        }
    }
    scan(view, pos);
    let target = (side < 0 ? before : after) || before || after;
    if (target)
        return target.coordsAt(Math.max(0, target == before ? beforePos : afterPos), side);
    return fallbackRect(view);
}
function fallbackRect(view) {
    let last = view.dom.lastChild;
    if (!last)
        return view.dom.getBoundingClientRect();
    let rects = clientRectsFor(last);
    return rects[rects.length - 1] || null;
}

function combineAttrs(source, target) {
    for (let name in source) {
        if (name == "class" && target.class)
            target.class += " " + source.class;
        else if (name == "style" && target.style)
            target.style += ";" + source.style;
        else
            target[name] = source[name];
    }
    return target;
}
const noAttrs = /*@__PURE__*/Object.create(null);
function attrsEq(a, b, ignore) {
    if (a == b)
        return true;
    if (!a)
        a = noAttrs;
    if (!b)
        b = noAttrs;
    let keysA = Object.keys(a), keysB = Object.keys(b);
    if (keysA.length - (ignore && keysA.indexOf(ignore) > -1 ? 1 : 0) !=
        keysB.length - (ignore && keysB.indexOf(ignore) > -1 ? 1 : 0))
        return false;
    for (let key of keysA) {
        if (key != ignore && (keysB.indexOf(key) == -1 || a[key] !== b[key]))
            return false;
    }
    return true;
}
function updateAttrs(dom, prev, attrs) {
    let changed = false;
    if (prev)
        for (let name in prev)
            if (!(attrs && name in attrs)) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = "";
                else
                    dom.removeAttribute(name);
            }
    if (attrs)
        for (let name in attrs)
            if (!(prev && prev[name] == attrs[name])) {
                changed = true;
                if (name == "style")
                    dom.style.cssText = attrs[name];
                else
                    dom.setAttribute(name, attrs[name]);
            }
    return changed;
}
function getAttrs(dom) {
    let attrs = Object.create(null);
    for (let i = 0; i < dom.attributes.length; i++) {
        let attr = dom.attributes[i];
        attrs[attr.name] = attr.value;
    }
    return attrs;
}

class LineView extends ContentView {
    constructor() {
        super(...arguments);
        this.children = [];
        this.length = 0;
        this.prevAttrs = undefined;
        this.attrs = null;
        this.breakAfter = 0;
    }
    // Consumes source
    merge(from, to, source, hasStart, openStart, openEnd) {
        if (source) {
            if (!(source instanceof LineView))
                return false;
            if (!this.dom)
                source.transferDOM(this); // Reuse source.dom when appropriate
        }
        if (hasStart)
            this.setDeco(source ? source.attrs : null);
        mergeChildrenInto(this, from, to, source ? source.children.slice() : [], openStart, openEnd);
        return true;
    }
    split(at) {
        let end = new LineView;
        end.breakAfter = this.breakAfter;
        if (this.length == 0)
            return end;
        let { i, off } = this.childPos(at);
        if (off) {
            end.append(this.children[i].split(off), 0);
            this.children[i].merge(off, this.children[i].length, null, false, 0, 0);
            i++;
        }
        for (let j = i; j < this.children.length; j++)
            end.append(this.children[j], 0);
        while (i > 0 && this.children[i - 1].length == 0)
            this.children[--i].destroy();
        this.children.length = i;
        this.markDirty();
        this.length = at;
        return end;
    }
    transferDOM(other) {
        if (!this.dom)
            return;
        this.markDirty();
        other.setDOM(this.dom);
        other.prevAttrs = this.prevAttrs === undefined ? this.attrs : this.prevAttrs;
        this.prevAttrs = undefined;
        this.dom = null;
    }
    setDeco(attrs) {
        if (!attrsEq(this.attrs, attrs)) {
            if (this.dom) {
                this.prevAttrs = this.attrs;
                this.markDirty();
            }
            this.attrs = attrs;
        }
    }
    append(child, openStart) {
        joinInlineInto(this, child, openStart);
    }
    // Only called when building a line view in ContentBuilder
    addLineDeco(deco) {
        let attrs = deco.spec.attributes, cls = deco.spec.class;
        if (attrs)
            this.attrs = combineAttrs(attrs, this.attrs || {});
        if (cls)
            this.attrs = combineAttrs({ class: cls }, this.attrs || {});
    }
    domAtPos(pos) {
        return inlineDOMAtPos(this, pos);
    }
    reuseDOM(node) {
        if (node.nodeName == "DIV") {
            this.setDOM(node);
            this.flags |= 4 /* ViewFlag.AttrsDirty */ | 2 /* ViewFlag.NodeDirty */;
        }
    }
    sync(view, track) {
        var _a;
        if (!this.dom) {
            this.setDOM(document.createElement("div"));
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        else if (this.flags & 4 /* ViewFlag.AttrsDirty */) {
            clearAttributes(this.dom);
            this.dom.className = "cm-line";
            this.prevAttrs = this.attrs ? null : undefined;
        }
        if (this.prevAttrs !== undefined) {
            updateAttrs(this.dom, this.prevAttrs, this.attrs);
            this.dom.classList.add("cm-line");
            this.prevAttrs = undefined;
        }
        super.sync(view, track);
        let last = this.dom.lastChild;
        while (last && ContentView.get(last) instanceof MarkView)
            last = last.lastChild;
        if (!last || !this.length ||
            last.nodeName != "BR" && ((_a = ContentView.get(last)) === null || _a === void 0 ? void 0 : _a.isEditable) == false &&
                (!browser.ios || !this.children.some(ch => ch instanceof TextView))) {
            let hack = document.createElement("BR");
            hack.cmIgnore = true;
            this.dom.appendChild(hack);
        }
    }
    measureTextSize() {
        if (this.children.length == 0 || this.length > 20)
            return null;
        let totalWidth = 0, textHeight;
        for (let child of this.children) {
            if (!(child instanceof TextView) || /[^ -~]/.test(child.text))
                return null;
            let rects = clientRectsFor(child.dom);
            if (rects.length != 1)
                return null;
            totalWidth += rects[0].width;
            textHeight = rects[0].height;
        }
        return !totalWidth ? null : {
            lineHeight: this.dom.getBoundingClientRect().height,
            charWidth: totalWidth / this.length,
            textHeight
        };
    }
    coordsAt(pos, side) {
        let rect = coordsInChildren(this, pos, side);
        // Correct rectangle height for empty lines when the returned
        // height is larger than the text height.
        if (!this.children.length && rect && this.parent) {
            let { heightOracle } = this.parent.view.viewState, height = rect.bottom - rect.top;
            if (Math.abs(height - heightOracle.lineHeight) < 2 && heightOracle.textHeight < height) {
                let dist = (height - heightOracle.textHeight) / 2;
                return { top: rect.top + dist, bottom: rect.bottom - dist, left: rect.left, right: rect.left };
            }
        }
        return rect;
    }
    become(_other) { return false; }
    covers() { return true; }
    static find(docView, pos) {
        for (let i = 0, off = 0; i < docView.children.length; i++) {
            let block = docView.children[i], end = off + block.length;
            if (end >= pos) {
                if (block instanceof LineView)
                    return block;
                if (end > pos)
                    break;
            }
            off = end + block.breakAfter;
        }
        return null;
    }
}
class BlockWidgetView extends ContentView {
    constructor(widget, length, deco) {
        super();
        this.widget = widget;
        this.length = length;
        this.deco = deco;
        this.breakAfter = 0;
        this.prevWidget = null;
    }
    merge(from, to, source, _takeDeco, openStart, openEnd) {
        if (source && (!(source instanceof BlockWidgetView) || !this.widget.compare(source.widget) ||
            from > 0 && openStart <= 0 || to < this.length && openEnd <= 0))
            return false;
        this.length = from + (source ? source.length : 0) + (this.length - to);
        return true;
    }
    domAtPos(pos) {
        return pos == 0 ? DOMPos.before(this.dom) : DOMPos.after(this.dom, pos == this.length);
    }
    split(at) {
        let len = this.length - at;
        this.length = at;
        let end = new BlockWidgetView(this.widget, len, this.deco);
        end.breakAfter = this.breakAfter;
        return end;
    }
    get children() { return noChildren; }
    sync(view) {
        if (!this.dom || !this.widget.updateDOM(this.dom, view)) {
            if (this.dom && this.prevWidget)
                this.prevWidget.destroy(this.dom);
            this.prevWidget = null;
            this.setDOM(this.widget.toDOM(view));
            this.dom.contentEditable = "false";
        }
    }
    get overrideDOMText() {
        return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Text.empty;
    }
    domBoundsAround() { return null; }
    become(other) {
        if (other instanceof BlockWidgetView &&
            other.widget.constructor == this.widget.constructor) {
            if (!other.widget.compare(this.widget))
                this.markDirty(true);
            if (this.dom && !this.prevWidget)
                this.prevWidget = this.widget;
            this.widget = other.widget;
            this.length = other.length;
            this.deco = other.deco;
            this.breakAfter = other.breakAfter;
            return true;
        }
        return false;
    }
    ignoreMutation() { return true; }
    ignoreEvent(event) { return this.widget.ignoreEvent(event); }
    get isEditable() { return false; }
    get isWidget() { return true; }
    coordsAt(pos, side) {
        return this.widget.coordsAt(this.dom, pos, side);
    }
    destroy() {
        super.destroy();
        if (this.dom)
            this.widget.destroy(this.dom);
    }
    covers(side) {
        let { startSide, endSide } = this.deco;
        return startSide == endSide ? false : side < 0 ? startSide < 0 : endSide > 0;
    }
}

/**
Widgets added to the content are described by subclasses of this
class. Using a description object like that makes it possible to
delay creating of the DOM structure for a widget until it is
needed, and to avoid redrawing widgets even if the decorations
that define them are recreated.
*/
class WidgetType {
    /**
    Compare this instance to another instance of the same type.
    (TypeScript can't express this, but only instances of the same
    specific class will be passed to this method.) This is used to
    avoid redrawing widgets when they are replaced by a new
    decoration of the same type. The default implementation just
    returns `false`, which will cause new instances of the widget to
    always be redrawn.
    */
    eq(widget) { return false; }
    /**
    Update a DOM element created by a widget of the same type (but
    different, non-`eq` content) to reflect this widget. May return
    true to indicate that it could update, false to indicate it
    couldn't (in which case the widget will be redrawn). The default
    implementation just returns false.
    */
    updateDOM(dom, view) { return false; }
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    The estimated height this widget will have, to be used when
    estimating the height of content that hasn't been drawn. May
    return -1 to indicate you don't know. The default implementation
    returns -1.
    */
    get estimatedHeight() { return -1; }
    /**
    For inline widgets that are displayed inline (as opposed to
    `inline-block`) and introduce line breaks (through `<br>` tags
    or textual newlines), this must indicate the amount of line
    breaks they introduce. Defaults to 0.
    */
    get lineBreaks() { return 0; }
    /**
    Can be used to configure which kinds of events inside the widget
    should be ignored by the editor. The default is to ignore all
    events.
    */
    ignoreEvent(event) { return true; }
    /**
    Override the way screen coordinates for positions at/in the
    widget are found. `pos` will be the offset into the widget, and
    `side` the side of the position that is being queried—less than
    zero for before, greater than zero for after, and zero for
    directly at that position.
    */
    coordsAt(dom, pos, side) { return null; }
    /**
    @internal
    */
    get isHidden() { return false; }
    /**
    This is called when the an instance of the widget is removed
    from the editor view.
    */
    destroy(dom) { }
}
/**
The different types of blocks that can occur in an editor view.
*/
var BlockType = /*@__PURE__*/(function (BlockType) {
    /**
    A line of text.
    */
    BlockType[BlockType["Text"] = 0] = "Text";
    /**
    A block widget associated with the position after it.
    */
    BlockType[BlockType["WidgetBefore"] = 1] = "WidgetBefore";
    /**
    A block widget associated with the position before it.
    */
    BlockType[BlockType["WidgetAfter"] = 2] = "WidgetAfter";
    /**
    A block widget [replacing](https://codemirror.net/6/docs/ref/#view.Decoration^replace) a range of content.
    */
    BlockType[BlockType["WidgetRange"] = 3] = "WidgetRange";
return BlockType})(BlockType || (BlockType = {}));
/**
A decoration provides information on how to draw or style a piece
of content. You'll usually use it wrapped in a
[`Range`](https://codemirror.net/6/docs/ref/#state.Range), which adds a start and end position.
@nonabstract
*/
class Decoration extends RangeValue {
    constructor(
    /**
    @internal
    */
    startSide, 
    /**
    @internal
    */
    endSide, 
    /**
    @internal
    */
    widget, 
    /**
    The config object used to create this decoration. You can
    include additional properties in there to store metadata about
    your decoration.
    */
    spec) {
        super();
        this.startSide = startSide;
        this.endSide = endSide;
        this.widget = widget;
        this.spec = spec;
    }
    /**
    @internal
    */
    get heightRelevant() { return false; }
    /**
    Create a mark decoration, which influences the styling of the
    content in its range. Nested mark decorations will cause nested
    DOM elements to be created. Nesting order is determined by
    precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
    the higher-precedence decorations creating the inner DOM nodes.
    Such elements are split on line boundaries and on the boundaries
    of lower-precedence decorations.
    */
    static mark(spec) {
        return new MarkDecoration(spec);
    }
    /**
    Create a widget decoration, which displays a DOM element at the
    given position.
    */
    static widget(spec) {
        let side = Math.max(-10000, Math.min(10000, spec.side || 0)), block = !!spec.block;
        side += (block && !spec.inlineOrder)
            ? (side > 0 ? 300000000 /* Side.BlockAfter */ : -400000000 /* Side.BlockBefore */)
            : (side > 0 ? 100000000 /* Side.InlineAfter */ : -100000000 /* Side.InlineBefore */);
        return new PointDecoration(spec, side, side, block, spec.widget || null, false);
    }
    /**
    Create a replace decoration which replaces the given range with
    a widget, or simply hides it.
    */
    static replace(spec) {
        let block = !!spec.block, startSide, endSide;
        if (spec.isBlockGap) {
            startSide = -500000000 /* Side.GapStart */;
            endSide = 400000000 /* Side.GapEnd */;
        }
        else {
            let { start, end } = getInclusive(spec, block);
            startSide = (start ? (block ? -300000000 /* Side.BlockIncStart */ : -1 /* Side.InlineIncStart */) : 500000000 /* Side.NonIncStart */) - 1;
            endSide = (end ? (block ? 200000000 /* Side.BlockIncEnd */ : 1 /* Side.InlineIncEnd */) : -600000000 /* Side.NonIncEnd */) + 1;
        }
        return new PointDecoration(spec, startSide, endSide, block, spec.widget || null, true);
    }
    /**
    Create a line decoration, which can add DOM attributes to the
    line starting at the given position.
    */
    static line(spec) {
        return new LineDecoration(spec);
    }
    /**
    Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
    decorated range or ranges. If the ranges aren't already sorted,
    pass `true` for `sort` to make the library sort them for you.
    */
    static set(of, sort = false) {
        return dist_RangeSet.of(of, sort);
    }
    /**
    @internal
    */
    hasHeight() { return this.widget ? this.widget.estimatedHeight > -1 : false; }
}
/**
The empty set of decorations.
*/
Decoration.none = dist_RangeSet.empty;
class MarkDecoration extends Decoration {
    constructor(spec) {
        let { start, end } = getInclusive(spec);
        super(start ? -1 /* Side.InlineIncStart */ : 500000000 /* Side.NonIncStart */, end ? 1 /* Side.InlineIncEnd */ : -600000000 /* Side.NonIncEnd */, null, spec);
        this.tagName = spec.tagName || "span";
        this.class = spec.class || "";
        this.attrs = spec.attributes || null;
    }
    eq(other) {
        var _a, _b;
        return this == other ||
            other instanceof MarkDecoration &&
                this.tagName == other.tagName &&
                (this.class || ((_a = this.attrs) === null || _a === void 0 ? void 0 : _a.class)) == (other.class || ((_b = other.attrs) === null || _b === void 0 ? void 0 : _b.class)) &&
                attrsEq(this.attrs, other.attrs, "class");
    }
    range(from, to = from) {
        if (from >= to)
            throw new RangeError("Mark decorations may not be empty");
        return super.range(from, to);
    }
}
MarkDecoration.prototype.point = false;
class LineDecoration extends Decoration {
    constructor(spec) {
        super(-200000000 /* Side.Line */, -200000000 /* Side.Line */, null, spec);
    }
    eq(other) {
        return other instanceof LineDecoration &&
            this.spec.class == other.spec.class &&
            attrsEq(this.spec.attributes, other.spec.attributes);
    }
    range(from, to = from) {
        if (to != from)
            throw new RangeError("Line decoration ranges must be zero-length");
        return super.range(from, to);
    }
}
LineDecoration.prototype.mapMode = MapMode.TrackBefore;
LineDecoration.prototype.point = true;
class PointDecoration extends Decoration {
    constructor(spec, startSide, endSide, block, widget, isReplace) {
        super(startSide, endSide, widget, spec);
        this.block = block;
        this.isReplace = isReplace;
        this.mapMode = !block ? MapMode.TrackDel : startSide <= 0 ? MapMode.TrackBefore : MapMode.TrackAfter;
    }
    // Only relevant when this.block == true
    get type() {
        return this.startSide != this.endSide ? BlockType.WidgetRange
            : this.startSide <= 0 ? BlockType.WidgetBefore : BlockType.WidgetAfter;
    }
    get heightRelevant() {
        return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
    }
    eq(other) {
        return other instanceof PointDecoration &&
            widgetsEq(this.widget, other.widget) &&
            this.block == other.block &&
            this.startSide == other.startSide && this.endSide == other.endSide;
    }
    range(from, to = from) {
        if (this.isReplace && (from > to || (from == to && this.startSide > 0 && this.endSide <= 0)))
            throw new RangeError("Invalid range for replacement decoration");
        if (!this.isReplace && to != from)
            throw new RangeError("Widget decorations can only have zero-length ranges");
        return super.range(from, to);
    }
}
PointDecoration.prototype.point = true;
function getInclusive(spec, block = false) {
    let { inclusiveStart: start, inclusiveEnd: end } = spec;
    if (start == null)
        start = spec.inclusive;
    if (end == null)
        end = spec.inclusive;
    return { start: start !== null && start !== void 0 ? start : block, end: end !== null && end !== void 0 ? end : block };
}
function widgetsEq(a, b) {
    return a == b || !!(a && b && a.compare(b));
}
function addRange(from, to, ranges, margin = 0) {
    let last = ranges.length - 1;
    if (last >= 0 && ranges[last] + margin >= from)
        ranges[last] = Math.max(ranges[last], to);
    else
        ranges.push(from, to);
}

class ContentBuilder {
    constructor(doc, pos, end, disallowBlockEffectsFor) {
        this.doc = doc;
        this.pos = pos;
        this.end = end;
        this.disallowBlockEffectsFor = disallowBlockEffectsFor;
        this.content = [];
        this.curLine = null;
        this.breakAtStart = 0;
        this.pendingBuffer = 0 /* Buf.No */;
        this.bufferMarks = [];
        // Set to false directly after a widget that covers the position after it
        this.atCursorPos = true;
        this.openStart = -1;
        this.openEnd = -1;
        this.text = "";
        this.textOff = 0;
        this.cursor = doc.iter();
        this.skip = pos;
    }
    posCovered() {
        if (this.content.length == 0)
            return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
        let last = this.content[this.content.length - 1];
        return !(last.breakAfter || last instanceof BlockWidgetView && last.deco.endSide < 0);
    }
    getLine() {
        if (!this.curLine) {
            this.content.push(this.curLine = new LineView);
            this.atCursorPos = true;
        }
        return this.curLine;
    }
    flushBuffer(active = this.bufferMarks) {
        if (this.pendingBuffer) {
            this.curLine.append(wrapMarks(new WidgetBufferView(-1), active), active.length);
            this.pendingBuffer = 0 /* Buf.No */;
        }
    }
    addBlockWidget(view) {
        this.flushBuffer();
        this.curLine = null;
        this.content.push(view);
    }
    finish(openEnd) {
        if (this.pendingBuffer && openEnd <= this.bufferMarks.length)
            this.flushBuffer();
        else
            this.pendingBuffer = 0 /* Buf.No */;
        if (!this.posCovered() &&
            !(openEnd && this.content.length && this.content[this.content.length - 1] instanceof BlockWidgetView))
            this.getLine();
    }
    buildText(length, active, openStart) {
        while (length > 0) {
            if (this.textOff == this.text.length) {
                let { value, lineBreak, done } = this.cursor.next(this.skip);
                this.skip = 0;
                if (done)
                    throw new Error("Ran out of text content when drawing inline views");
                if (lineBreak) {
                    if (!this.posCovered())
                        this.getLine();
                    if (this.content.length)
                        this.content[this.content.length - 1].breakAfter = 1;
                    else
                        this.breakAtStart = 1;
                    this.flushBuffer();
                    this.curLine = null;
                    this.atCursorPos = true;
                    length--;
                    continue;
                }
                else {
                    this.text = value;
                    this.textOff = 0;
                }
            }
            let take = Math.min(this.text.length - this.textOff, length, 512 /* T.Chunk */);
            this.flushBuffer(active.slice(active.length - openStart));
            this.getLine().append(wrapMarks(new TextView(this.text.slice(this.textOff, this.textOff + take)), active), openStart);
            this.atCursorPos = true;
            this.textOff += take;
            length -= take;
            openStart = 0;
        }
    }
    span(from, to, active, openStart) {
        this.buildText(to - from, active, openStart);
        this.pos = to;
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    point(from, to, deco, active, openStart, index) {
        if (this.disallowBlockEffectsFor[index] && deco instanceof PointDecoration) {
            if (deco.block)
                throw new RangeError("Block decorations may not be specified via plugins");
            if (to > this.doc.lineAt(this.pos).to)
                throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
        }
        let len = to - from;
        if (deco instanceof PointDecoration) {
            if (deco.block) {
                if (deco.startSide > 0 && !this.posCovered())
                    this.getLine();
                this.addBlockWidget(new BlockWidgetView(deco.widget || new NullWidget("div"), len, deco));
            }
            else {
                let view = WidgetView.create(deco.widget || new NullWidget("span"), len, len ? 0 : deco.startSide);
                let cursorBefore = this.atCursorPos && !view.isEditable && openStart <= active.length &&
                    (from < to || deco.startSide > 0);
                let cursorAfter = !view.isEditable && (from < to || openStart > active.length || deco.startSide <= 0);
                let line = this.getLine();
                if (this.pendingBuffer == 2 /* Buf.IfCursor */ && !cursorBefore && !view.isEditable)
                    this.pendingBuffer = 0 /* Buf.No */;
                this.flushBuffer(active);
                if (cursorBefore) {
                    line.append(wrapMarks(new WidgetBufferView(1), active), openStart);
                    openStart = active.length + Math.max(0, openStart - active.length);
                }
                line.append(wrapMarks(view, active), openStart);
                this.atCursorPos = cursorAfter;
                this.pendingBuffer = !cursorAfter ? 0 /* Buf.No */ : from < to || openStart > active.length ? 1 /* Buf.Yes */ : 2 /* Buf.IfCursor */;
                if (this.pendingBuffer)
                    this.bufferMarks = active.slice();
            }
        }
        else if (this.doc.lineAt(this.pos).from == this.pos) { // Line decoration
            this.getLine().addLineDeco(deco);
        }
        if (len) {
            // Advance the iterator past the replaced content
            if (this.textOff + len <= this.text.length) {
                this.textOff += len;
            }
            else {
                this.skip += len - (this.text.length - this.textOff);
                this.text = "";
                this.textOff = 0;
            }
            this.pos = to;
        }
        if (this.openStart < 0)
            this.openStart = openStart;
    }
    static build(text, from, to, decorations, dynamicDecorationMap) {
        let builder = new ContentBuilder(text, from, to, dynamicDecorationMap);
        builder.openEnd = dist_RangeSet.spans(decorations, from, to, builder);
        if (builder.openStart < 0)
            builder.openStart = builder.openEnd;
        builder.finish(builder.openEnd);
        return builder;
    }
}
function wrapMarks(view, active) {
    for (let mark of active)
        view = new MarkView(mark, [view], view.length);
    return view;
}
class NullWidget extends WidgetType {
    constructor(tag) {
        super();
        this.tag = tag;
    }
    eq(other) { return other.tag == this.tag; }
    toDOM() { return document.createElement(this.tag); }
    updateDOM(elt) { return elt.nodeName.toLowerCase() == this.tag; }
    get isHidden() { return true; }
}

const clickAddsSelectionRange = /*@__PURE__*/Facet.define();
const dragMovesSelection$1 = /*@__PURE__*/Facet.define();
const mouseSelectionStyle = /*@__PURE__*/Facet.define();
const exceptionSink = /*@__PURE__*/Facet.define();
const updateListener = /*@__PURE__*/Facet.define();
const inputHandler = /*@__PURE__*/Facet.define();
const focusChangeEffect = /*@__PURE__*/Facet.define();
const perLineTextDirection = /*@__PURE__*/Facet.define({
    combine: values => values.some(x => x)
});
const nativeSelectionHidden = /*@__PURE__*/Facet.define({
    combine: values => values.some(x => x)
});
class ScrollTarget {
    constructor(range, y = "nearest", x = "nearest", yMargin = 5, xMargin = 5, 
    // This data structure is abused to also store precise scroll
    // snapshots, instead of a `scrollIntoView` request. When this
    // flag is `true`, `range` points at a position in the reference
    // line, `yMargin` holds the difference between the top of that
    // line and the top of the editor, and `xMargin` holds the
    // editor's `scrollLeft`.
    isSnapshot = false) {
        this.range = range;
        this.y = y;
        this.x = x;
        this.yMargin = yMargin;
        this.xMargin = xMargin;
        this.isSnapshot = isSnapshot;
    }
    map(changes) {
        return changes.empty ? this :
            new ScrollTarget(this.range.map(changes), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
    clip(state) {
        return this.range.to <= state.doc.length ? this :
            new ScrollTarget(dist_EditorSelection.cursor(state.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
    }
}
const scrollIntoView = /*@__PURE__*/StateEffect.define({ map: (t, ch) => t.map(ch) });
/**
Log or report an unhandled exception in client code. Should
probably only be used by extension code that allows client code to
provide functions, and calls those functions in a context where an
exception can't be propagated to calling code in a reasonable way
(for example when in an event handler).

Either calls a handler registered with
[`EditorView.exceptionSink`](https://codemirror.net/6/docs/ref/#view.EditorView^exceptionSink),
`window.onerror`, if defined, or `console.error` (in which case
it'll pass `context`, when given, as first argument).
*/
function dist_logException(state, exception, context) {
    let handler = state.facet(exceptionSink);
    if (handler.length)
        handler[0](exception);
    else if (window.onerror)
        window.onerror(String(exception), context, undefined, undefined, exception);
    else if (context)
        console.error(context + ":", exception);
    else
        console.error(exception);
}
const editable = /*@__PURE__*/Facet.define({ combine: values => values.length ? values[0] : true });
let nextPluginID = 0;
const viewPlugin = /*@__PURE__*/Facet.define();
/**
View plugins associate stateful values with a view. They can
influence the way the content is drawn, and are notified of things
that happen in the view.
*/
class dist_ViewPlugin {
    constructor(
    /**
    @internal
    */
    id, 
    /**
    @internal
    */
    create, 
    /**
    @internal
    */
    domEventHandlers, 
    /**
    @internal
    */
    domEventObservers, buildExtensions) {
        this.id = id;
        this.create = create;
        this.domEventHandlers = domEventHandlers;
        this.domEventObservers = domEventObservers;
        this.extension = buildExtensions(this);
    }
    /**
    Define a plugin from a constructor function that creates the
    plugin's value, given an editor view.
    */
    static define(create, spec) {
        const { eventHandlers, eventObservers, provide, decorations: deco } = spec || {};
        return new dist_ViewPlugin(nextPluginID++, create, eventHandlers, eventObservers, plugin => {
            let ext = [viewPlugin.of(plugin)];
            if (deco)
                ext.push(decorations.of(view => {
                    let pluginInst = view.plugin(plugin);
                    return pluginInst ? deco(pluginInst) : Decoration.none;
                }));
            if (provide)
                ext.push(provide(plugin));
            return ext;
        });
    }
    /**
    Create a plugin for a class whose constructor takes a single
    editor view as argument.
    */
    static fromClass(cls, spec) {
        return dist_ViewPlugin.define(view => new cls(view), spec);
    }
}
class PluginInstance {
    constructor(spec) {
        this.spec = spec;
        // When starting an update, all plugins have this field set to the
        // update object, indicating they need to be updated. When finished
        // updating, it is set to `false`. Retrieving a plugin that needs to
        // be updated with `view.plugin` forces an eager update.
        this.mustUpdate = null;
        // This is null when the plugin is initially created, but
        // initialized on the first update.
        this.value = null;
    }
    update(view) {
        if (!this.value) {
            if (this.spec) {
                try {
                    this.value = this.spec.create(view);
                }
                catch (e) {
                    dist_logException(view.state, e, "CodeMirror plugin crashed");
                    this.deactivate();
                }
            }
        }
        else if (this.mustUpdate) {
            let update = this.mustUpdate;
            this.mustUpdate = null;
            if (this.value.update) {
                try {
                    this.value.update(update);
                }
                catch (e) {
                    dist_logException(update.state, e, "CodeMirror plugin crashed");
                    if (this.value.destroy)
                        try {
                            this.value.destroy();
                        }
                        catch (_) { }
                    this.deactivate();
                }
            }
        }
        return this;
    }
    destroy(view) {
        var _a;
        if ((_a = this.value) === null || _a === void 0 ? void 0 : _a.destroy) {
            try {
                this.value.destroy();
            }
            catch (e) {
                dist_logException(view.state, e, "CodeMirror plugin crashed");
            }
        }
    }
    deactivate() {
        this.spec = this.value = null;
    }
}
const editorAttributes = /*@__PURE__*/Facet.define();
const contentAttributes = /*@__PURE__*/Facet.define();
// Provide decorations
const decorations = /*@__PURE__*/Facet.define();
const atomicRanges = /*@__PURE__*/Facet.define();
const bidiIsolatedRanges = /*@__PURE__*/Facet.define();
function getIsolatedRanges(view, from, to) {
    let isolates = view.state.facet(bidiIsolatedRanges);
    if (!isolates.length)
        return isolates;
    let sets = isolates.map(i => i instanceof Function ? i(view) : i);
    let result = [];
    dist_RangeSet.spans(sets, from, to, {
        point() { },
        span(from, to, active, open) {
            let level = result;
            for (let i = active.length - 1; i >= 0; i--, open--) {
                let iso = active[i].spec.bidiIsolate, update;
                if (iso == null)
                    continue;
                if (open > 0 && level.length &&
                    (update = level[level.length - 1]).to == from && update.direction == iso) {
                    update.to = to;
                    level = update.inner;
                }
                else {
                    let add = { from, to, direction: iso, inner: [] };
                    level.push(add);
                    level = add.inner;
                }
            }
        }
    });
    return result;
}
const scrollMargins = /*@__PURE__*/Facet.define();
function getScrollMargins(view) {
    let left = 0, right = 0, top = 0, bottom = 0;
    for (let source of view.state.facet(scrollMargins)) {
        let m = source(view);
        if (m) {
            if (m.left != null)
                left = Math.max(left, m.left);
            if (m.right != null)
                right = Math.max(right, m.right);
            if (m.top != null)
                top = Math.max(top, m.top);
            if (m.bottom != null)
                bottom = Math.max(bottom, m.bottom);
        }
    }
    return { left, right, top, bottom };
}
const styleModule = /*@__PURE__*/Facet.define();
class ChangedRange {
    constructor(fromA, toA, fromB, toB) {
        this.fromA = fromA;
        this.toA = toA;
        this.fromB = fromB;
        this.toB = toB;
    }
    join(other) {
        return new ChangedRange(Math.min(this.fromA, other.fromA), Math.max(this.toA, other.toA), Math.min(this.fromB, other.fromB), Math.max(this.toB, other.toB));
    }
    addToSet(set) {
        let i = set.length, me = this;
        for (; i > 0; i--) {
            let range = set[i - 1];
            if (range.fromA > me.toA)
                continue;
            if (range.toA < me.fromA)
                break;
            me = me.join(range);
            set.splice(i - 1, 1);
        }
        set.splice(i, 0, me);
        return set;
    }
    static extendWithRanges(diff, ranges) {
        if (ranges.length == 0)
            return diff;
        let result = [];
        for (let dI = 0, rI = 0, posA = 0, posB = 0;; dI++) {
            let next = dI == diff.length ? null : diff[dI], off = posA - posB;
            let end = next ? next.fromB : 1e9;
            while (rI < ranges.length && ranges[rI] < end) {
                let from = ranges[rI], to = ranges[rI + 1];
                let fromB = Math.max(posB, from), toB = Math.min(end, to);
                if (fromB <= toB)
                    new ChangedRange(fromB + off, toB + off, fromB, toB).addToSet(result);
                if (to > end)
                    break;
                else
                    rI += 2;
            }
            if (!next)
                return result;
            new ChangedRange(next.fromA, next.toA, next.fromB, next.toB).addToSet(result);
            posA = next.toA;
            posB = next.toB;
        }
    }
}
/**
View [plugins](https://codemirror.net/6/docs/ref/#view.ViewPlugin) are given instances of this
class, which describe what happened, whenever the view is updated.
*/
class ViewUpdate {
    constructor(
    /**
    The editor view that the update is associated with.
    */
    view, 
    /**
    The new editor state.
    */
    state, 
    /**
    The transactions involved in the update. May be empty.
    */
    transactions) {
        this.view = view;
        this.state = state;
        this.transactions = transactions;
        /**
        @internal
        */
        this.flags = 0;
        this.startState = view.state;
        this.changes = ChangeSet.empty(this.startState.doc.length);
        for (let tr of transactions)
            this.changes = this.changes.compose(tr.changes);
        let changedRanges = [];
        this.changes.iterChangedRanges((fromA, toA, fromB, toB) => changedRanges.push(new ChangedRange(fromA, toA, fromB, toB)));
        this.changedRanges = changedRanges;
    }
    /**
    @internal
    */
    static create(view, state, transactions) {
        return new ViewUpdate(view, state, transactions);
    }
    /**
    Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
    [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
    update.
    */
    get viewportChanged() {
        return (this.flags & 4 /* UpdateFlag.Viewport */) > 0;
    }
    /**
    Indicates whether the height of a block element in the editor
    changed in this update.
    */
    get heightChanged() {
        return (this.flags & 2 /* UpdateFlag.Height */) > 0;
    }
    /**
    Returns true when the document was modified or the size of the
    editor, or elements within the editor, changed.
    */
    get geometryChanged() {
        return this.docChanged || (this.flags & (8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */)) > 0;
    }
    /**
    True when this update indicates a focus change.
    */
    get focusChanged() {
        return (this.flags & 1 /* UpdateFlag.Focus */) > 0;
    }
    /**
    Whether the document changed in this update.
    */
    get docChanged() {
        return !this.changes.empty;
    }
    /**
    Whether the selection was explicitly set in this update.
    */
    get selectionSet() {
        return this.transactions.some(tr => tr.selection);
    }
    /**
    @internal
    */
    get empty() { return this.flags == 0 && this.transactions.length == 0; }
}

/**
Used to indicate [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
*/
var Direction = /*@__PURE__*/(function (Direction) {
    // (These are chosen to match the base levels, in bidi algorithm
    // terms, of spans in that direction.)
    /**
    Left-to-right.
    */
    Direction[Direction["LTR"] = 0] = "LTR";
    /**
    Right-to-left.
    */
    Direction[Direction["RTL"] = 1] = "RTL";
return Direction})(Direction || (Direction = {}));
const LTR = Direction.LTR, RTL = Direction.RTL;
// Decode a string with each type encoded as log2(type)
function dec(str) {
    let result = [];
    for (let i = 0; i < str.length; i++)
        result.push(1 << +str[i]);
    return result;
}
// Character types for codepoints 0 to 0xf8
const LowTypes = /*@__PURE__*/dec("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008");
// Character types for codepoints 0x600 to 0x6f9
const ArabicTypes = /*@__PURE__*/dec("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333");
const Brackets = /*@__PURE__*/Object.create(null), BracketStack = [];
// There's a lot more in
// https://www.unicode.org/Public/UCD/latest/ucd/BidiBrackets.txt,
// which are left out to keep code size down.
for (let p of ["()", "[]", "{}"]) {
    let l = /*@__PURE__*/p.charCodeAt(0), r = /*@__PURE__*/p.charCodeAt(1);
    Brackets[l] = r;
    Brackets[r] = -l;
}
function charType(ch) {
    return ch <= 0xf7 ? LowTypes[ch] :
        0x590 <= ch && ch <= 0x5f4 ? 2 /* T.R */ :
            0x600 <= ch && ch <= 0x6f9 ? ArabicTypes[ch - 0x600] :
                0x6ee <= ch && ch <= 0x8ac ? 4 /* T.AL */ :
                    0x2000 <= ch && ch <= 0x200c ? 256 /* T.NI */ :
                        0xfb50 <= ch && ch <= 0xfdff ? 4 /* T.AL */ : 1 /* T.L */;
}
const BidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
/**
Represents a contiguous range of text that has a single direction
(as in left-to-right or right-to-left).
*/
class BidiSpan {
    /**
    The direction of this span.
    */
    get dir() { return this.level % 2 ? RTL : LTR; }
    /**
    @internal
    */
    constructor(
    /**
    The start of the span (relative to the start of the line).
    */
    from, 
    /**
    The end of the span.
    */
    to, 
    /**
    The ["bidi
    level"](https://unicode.org/reports/tr9/#Basic_Display_Algorithm)
    of the span (in this context, 0 means
    left-to-right, 1 means right-to-left, 2 means left-to-right
    number inside right-to-left text).
    */
    level) {
        this.from = from;
        this.to = to;
        this.level = level;
    }
    /**
    @internal
    */
    side(end, dir) { return (this.dir == dir) == end ? this.to : this.from; }
    /**
    @internal
    */
    static find(order, index, level, assoc) {
        let maybe = -1;
        for (let i = 0; i < order.length; i++) {
            let span = order[i];
            if (span.from <= index && span.to >= index) {
                if (span.level == level)
                    return i;
                // When multiple spans match, if assoc != 0, take the one that
                // covers that side, otherwise take the one with the minimum
                // level.
                if (maybe < 0 || (assoc != 0 ? (assoc < 0 ? span.from < index : span.to > index) : order[maybe].level > span.level))
                    maybe = i;
            }
        }
        if (maybe < 0)
            throw new RangeError("Index out of range");
        return maybe;
    }
}
function isolatesEq(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        let iA = a[i], iB = b[i];
        if (iA.from != iB.from || iA.to != iB.to || iA.direction != iB.direction || !isolatesEq(iA.inner, iB.inner))
            return false;
    }
    return true;
}
// Reused array of character types
const dist_types = [];
// Fill in the character types (in `types`) from `from` to `to` and
// apply W normalization rules.
function computeCharTypes(line, rFrom, rTo, isolates, outerType) {
    for (let iI = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        let prevType = iI ? 256 /* T.NI */ : outerType;
        // W1. Examine each non-spacing mark (NSM) in the level run, and
        // change the type of the NSM to the type of the previous
        // character. If the NSM is at the start of the level run, it will
        // get the type of sor.
        // W2. Search backwards from each instance of a European number
        // until the first strong type (R, L, AL, or sor) is found. If an
        // AL is found, change the type of the European number to Arabic
        // number.
        // W3. Change all ALs to R.
        // (Left after this: L, R, EN, AN, ET, CS, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = charType(line.charCodeAt(i));
            if (type == 512 /* T.NSM */)
                type = prev;
            else if (type == 8 /* T.EN */ && prevStrong == 4 /* T.AL */)
                type = 16 /* T.AN */;
            dist_types[i] = type == 4 /* T.AL */ ? 2 /* T.R */ : type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
            prev = type;
        }
        // W5. A sequence of European terminators adjacent to European
        // numbers changes to all European numbers.
        // W6. Otherwise, separators and terminators change to Other
        // Neutral.
        // W7. Search backwards from each instance of a European number
        // until the first strong type (R, L, or sor) is found. If an L is
        // found, then change the type of the European number to L.
        // (Left after this: L, R, EN+AN, NI)
        for (let i = from, prev = prevType, prevStrong = prevType; i < to; i++) {
            let type = dist_types[i];
            if (type == 128 /* T.CS */) {
                if (i < to - 1 && prev == dist_types[i + 1] && (prev & 24 /* T.Num */))
                    type = dist_types[i] = prev;
                else
                    dist_types[i] = 256 /* T.NI */;
            }
            else if (type == 64 /* T.ET */) {
                let end = i + 1;
                while (end < to && dist_types[end] == 64 /* T.ET */)
                    end++;
                let replace = (i && prev == 8 /* T.EN */) || (end < rTo && dist_types[end] == 8 /* T.EN */) ? (prevStrong == 1 /* T.L */ ? 1 /* T.L */ : 8 /* T.EN */) : 256 /* T.NI */;
                for (let j = i; j < end; j++)
                    dist_types[j] = replace;
                i = end - 1;
            }
            else if (type == 8 /* T.EN */ && prevStrong == 1 /* T.L */) {
                dist_types[i] = 1 /* T.L */;
            }
            prev = type;
            if (type & 7 /* T.Strong */)
                prevStrong = type;
        }
    }
}
// Process brackets throughout a run sequence.
function processBracketPairs(line, rFrom, rTo, isolates, outerType) {
    let oppositeType = outerType == 1 /* T.L */ ? 2 /* T.R */ : 1 /* T.L */;
    for (let iI = 0, sI = 0, context = 0; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N0. Process bracket pairs in an isolating run sequence
        // sequentially in the logical order of the text positions of the
        // opening paired brackets using the logic given below. Within this
        // scope, bidirectional types EN and AN are treated as R.
        for (let i = from, ch, br, type; i < to; i++) {
            // Keeps [startIndex, type, strongSeen] triples for each open
            // bracket on BracketStack.
            if (br = Brackets[ch = line.charCodeAt(i)]) {
                if (br < 0) { // Closing bracket
                    for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                        if (BracketStack[sJ + 1] == -br) {
                            let flags = BracketStack[sJ + 2];
                            let type = (flags & 2 /* Bracketed.EmbedInside */) ? outerType :
                                !(flags & 4 /* Bracketed.OppositeInside */) ? 0 :
                                    (flags & 1 /* Bracketed.OppositeBefore */) ? oppositeType : outerType;
                            if (type)
                                dist_types[i] = dist_types[BracketStack[sJ]] = type;
                            sI = sJ;
                            break;
                        }
                    }
                }
                else if (BracketStack.length == 189 /* Bracketed.MaxDepth */) {
                    break;
                }
                else {
                    BracketStack[sI++] = i;
                    BracketStack[sI++] = ch;
                    BracketStack[sI++] = context;
                }
            }
            else if ((type = dist_types[i]) == 2 /* T.R */ || type == 1 /* T.L */) {
                let embed = type == outerType;
                context = embed ? 0 : 1 /* Bracketed.OppositeBefore */;
                for (let sJ = sI - 3; sJ >= 0; sJ -= 3) {
                    let cur = BracketStack[sJ + 2];
                    if (cur & 2 /* Bracketed.EmbedInside */)
                        break;
                    if (embed) {
                        BracketStack[sJ + 2] |= 2 /* Bracketed.EmbedInside */;
                    }
                    else {
                        if (cur & 4 /* Bracketed.OppositeInside */)
                            break;
                        BracketStack[sJ + 2] |= 4 /* Bracketed.OppositeInside */;
                    }
                }
            }
        }
    }
}
function processNeutrals(rFrom, rTo, isolates, outerType) {
    for (let iI = 0, prev = outerType; iI <= isolates.length; iI++) {
        let from = iI ? isolates[iI - 1].to : rFrom, to = iI < isolates.length ? isolates[iI].from : rTo;
        // N1. A sequence of neutrals takes the direction of the
        // surrounding strong text if the text on both sides has the same
        // direction. European and Arabic numbers act as if they were R in
        // terms of their influence on neutrals. Start-of-level-run (sor)
        // and end-of-level-run (eor) are used at level run boundaries.
        // N2. Any remaining neutrals take the embedding direction.
        // (Left after this: L, R, EN+AN)
        for (let i = from; i < to;) {
            let type = dist_types[i];
            if (type == 256 /* T.NI */) {
                let end = i + 1;
                for (;;) {
                    if (end == to) {
                        if (iI == isolates.length)
                            break;
                        end = isolates[iI++].to;
                        to = iI < isolates.length ? isolates[iI].from : rTo;
                    }
                    else if (dist_types[end] == 256 /* T.NI */) {
                        end++;
                    }
                    else {
                        break;
                    }
                }
                let beforeL = prev == 1 /* T.L */;
                let afterL = (end < rTo ? dist_types[end] : outerType) == 1 /* T.L */;
                let replace = beforeL == afterL ? (beforeL ? 1 /* T.L */ : 2 /* T.R */) : outerType;
                for (let j = end, jI = iI, fromJ = jI ? isolates[jI - 1].to : rFrom; j > i;) {
                    if (j == fromJ) {
                        j = isolates[--jI].from;
                        fromJ = jI ? isolates[jI - 1].to : rFrom;
                    }
                    dist_types[--j] = replace;
                }
                i = end;
            }
            else {
                prev = type;
                i++;
            }
        }
    }
}
// Find the contiguous ranges of character types in a given range, and
// emit spans for them. Flip the order of the spans as appropriate
// based on the level, and call through to compute the spans for
// isolates at the proper point.
function emitSpans(line, from, to, level, baseLevel, isolates, order) {
    let ourType = level % 2 ? 2 /* T.R */ : 1 /* T.L */;
    if ((level % 2) == (baseLevel % 2)) { // Same dir as base direction, don't flip
        for (let iCh = from, iI = 0; iCh < to;) {
            // Scan a section of characters in direction ourType, unless
            // there's another type of char right after iCh, in which case
            // we scan a section of other characters (which, if ourType ==
            // T.L, may contain both T.R and T.AN chars).
            let sameDir = true, isNum = false;
            if (iI == isolates.length || iCh < isolates[iI].from) {
                let next = dist_types[iCh];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            // Holds an array of isolates to pass to a recursive call if we
            // must recurse (to distinguish T.AN inside an RTL section in
            // LTR text), null if we can emit directly
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI < isolates.length && iScan == isolates[iI].from) {
                    if (isNum)
                        break run;
                    let iso = isolates[iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.to, jI = iI + 1;;) {
                            if (upto == to)
                                break run;
                            if (jI < isolates.length && isolates[jI].from == upto)
                                upto = isolates[jI++].to;
                            else if (dist_types[upto] == ourType)
                                break run;
                            else
                                break;
                        }
                    iI++;
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.from > iCh)
                            order.push(new BidiSpan(iCh, iso.from, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.to;
                    }
                    iScan = iso.to;
                }
                else if (iScan == to || (sameDir ? dist_types[iScan] != ourType : dist_types[iScan] == ourType)) {
                    break;
                }
                else {
                    iScan++;
                }
            }
            if (recurse)
                emitSpans(line, iCh, iScan, level + 1, baseLevel, recurse, order);
            else if (iCh < iScan)
                order.push(new BidiSpan(iCh, iScan, localLevel));
            iCh = iScan;
        }
    }
    else {
        // Iterate in reverse to flip the span order. Same code again, but
        // going from the back of the section to the front
        for (let iCh = to, iI = isolates.length; iCh > from;) {
            let sameDir = true, isNum = false;
            if (!iI || iCh > isolates[iI - 1].to) {
                let next = dist_types[iCh - 1];
                if (next != ourType) {
                    sameDir = false;
                    isNum = next == 16 /* T.AN */;
                }
            }
            let recurse = !sameDir && ourType == 1 /* T.L */ ? [] : null;
            let localLevel = sameDir ? level : level + 1;
            let iScan = iCh;
            run: for (;;) {
                if (iI && iScan == isolates[iI - 1].to) {
                    if (isNum)
                        break run;
                    let iso = isolates[--iI];
                    // Scan ahead to verify that there is another char in this dir after the isolate(s)
                    if (!sameDir)
                        for (let upto = iso.from, jI = iI;;) {
                            if (upto == from)
                                break run;
                            if (jI && isolates[jI - 1].to == upto)
                                upto = isolates[--jI].from;
                            else if (dist_types[upto - 1] == ourType)
                                break run;
                            else
                                break;
                        }
                    if (recurse) {
                        recurse.push(iso);
                    }
                    else {
                        if (iso.to < iCh)
                            order.push(new BidiSpan(iso.to, iCh, localLevel));
                        let dirSwap = (iso.direction == LTR) != !(localLevel % 2);
                        computeSectionOrder(line, dirSwap ? level + 1 : level, baseLevel, iso.inner, iso.from, iso.to, order);
                        iCh = iso.from;
                    }
                    iScan = iso.from;
                }
                else if (iScan == from || (sameDir ? dist_types[iScan - 1] != ourType : dist_types[iScan - 1] == ourType)) {
                    break;
                }
                else {
                    iScan--;
                }
            }
            if (recurse)
                emitSpans(line, iScan, iCh, level + 1, baseLevel, recurse, order);
            else if (iScan < iCh)
                order.push(new BidiSpan(iScan, iCh, localLevel));
            iCh = iScan;
        }
    }
}
function computeSectionOrder(line, level, baseLevel, isolates, from, to, order) {
    let outerType = (level % 2 ? 2 /* T.R */ : 1 /* T.L */);
    computeCharTypes(line, from, to, isolates, outerType);
    processBracketPairs(line, from, to, isolates, outerType);
    processNeutrals(from, to, isolates, outerType);
    emitSpans(line, from, to, level, baseLevel, isolates, order);
}
function computeOrder(line, direction, isolates) {
    if (!line)
        return [new BidiSpan(0, 0, direction == RTL ? 1 : 0)];
    if (direction == LTR && !isolates.length && !BidiRE.test(line))
        return trivialOrder(line.length);
    if (isolates.length)
        while (line.length > dist_types.length)
            dist_types[dist_types.length] = 256 /* T.NI */; // Make sure types array has no gaps
    let order = [], level = direction == LTR ? 0 : 1;
    computeSectionOrder(line, level, level, isolates, 0, line.length, order);
    return order;
}
function trivialOrder(length) {
    return [new BidiSpan(0, length, 0)];
}
let movedOver = "";
function moveVisually(line, order, dir, start, forward) {
    var _a;
    let startIndex = start.head - line.from, spanI = -1;
    if (startIndex == 0) {
        if (!forward || !line.length)
            return null;
        if (order[0].level != dir) {
            startIndex = order[0].side(false, dir);
            spanI = 0;
        }
    }
    else if (startIndex == line.length) {
        if (forward)
            return null;
        let last = order[order.length - 1];
        if (last.level != dir) {
            startIndex = last.side(true, dir);
            spanI = order.length - 1;
        }
    }
    if (spanI < 0)
        spanI = BidiSpan.find(order, startIndex, (_a = start.bidiLevel) !== null && _a !== void 0 ? _a : -1, start.assoc);
    let span = order[spanI];
    // End of span. (But not end of line--that was checked for above.)
    if (startIndex == span.side(forward, dir)) {
        span = order[spanI += forward ? 1 : -1];
        startIndex = span.side(!forward, dir);
    }
    let indexForward = forward == (span.dir == dir);
    let nextIndex = findClusterBreak(line.text, startIndex, indexForward);
    movedOver = line.text.slice(Math.min(startIndex, nextIndex), Math.max(startIndex, nextIndex));
    if (nextIndex > span.from && nextIndex < span.to)
        return dist_EditorSelection.cursor(nextIndex + line.from, indexForward ? -1 : 1, span.level);
    let nextSpan = spanI == (forward ? order.length - 1 : 0) ? null : order[spanI + (forward ? 1 : -1)];
    if (!nextSpan && span.level != dir)
        return dist_EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1, dir);
    if (nextSpan && nextSpan.level < span.level)
        return dist_EditorSelection.cursor(nextSpan.side(!forward, dir) + line.from, forward ? 1 : -1, nextSpan.level);
    return dist_EditorSelection.cursor(nextIndex + line.from, forward ? -1 : 1, span.level);
}

class DocView extends ContentView {
    get length() { return this.view.state.doc.length; }
    constructor(view) {
        super();
        this.view = view;
        this.decorations = [];
        this.dynamicDecorationMap = [];
        this.domChanged = null;
        this.hasComposition = null;
        this.markedForComposition = new Set;
        // Track a minimum width for the editor. When measuring sizes in
        // measureVisibleLineHeights, this is updated to point at the width
        // of a given element and its extent in the document. When a change
        // happens in that range, these are reset. That way, once we've seen
        // a line/element of a given length, we keep the editor wide enough
        // to fit at least that element, until it is changed, at which point
        // we forget it again.
        this.minWidth = 0;
        this.minWidthFrom = 0;
        this.minWidthTo = 0;
        // Track whether the DOM selection was set in a lossy way, so that
        // we don't mess it up when reading it back it
        this.impreciseAnchor = null;
        this.impreciseHead = null;
        this.forceSelection = false;
        // Used by the resize observer to ignore resizes that we caused
        // ourselves
        this.lastUpdate = Date.now();
        this.setDOM(view.contentDOM);
        this.children = [new LineView];
        this.children[0].setParent(this);
        this.updateDeco();
        this.updateInner([new ChangedRange(0, 0, 0, view.state.doc.length)], 0, null);
    }
    // Update the document view to a given state.
    update(update) {
        var _a;
        let changedRanges = update.changedRanges;
        if (this.minWidth > 0 && changedRanges.length) {
            if (!changedRanges.every(({ fromA, toA }) => toA < this.minWidthFrom || fromA > this.minWidthTo)) {
                this.minWidth = this.minWidthFrom = this.minWidthTo = 0;
            }
            else {
                this.minWidthFrom = update.changes.mapPos(this.minWidthFrom, 1);
                this.minWidthTo = update.changes.mapPos(this.minWidthTo, 1);
            }
        }
        let readCompositionAt = -1;
        if (this.view.inputState.composing >= 0) {
            if ((_a = this.domChanged) === null || _a === void 0 ? void 0 : _a.newSel)
                readCompositionAt = this.domChanged.newSel.head;
            else if (!touchesComposition(update.changes, this.hasComposition) && !update.selectionSet)
                readCompositionAt = update.state.selection.main.head;
        }
        let composition = readCompositionAt > -1 ? findCompositionRange(this.view, update.changes, readCompositionAt) : null;
        this.domChanged = null;
        if (this.hasComposition) {
            this.markedForComposition.clear();
            let { from, to } = this.hasComposition;
            changedRanges = new ChangedRange(from, to, update.changes.mapPos(from, -1), update.changes.mapPos(to, 1))
                .addToSet(changedRanges.slice());
        }
        this.hasComposition = composition ? { from: composition.range.fromB, to: composition.range.toB } : null;
        // When the DOM nodes around the selection are moved to another
        // parent, Chrome sometimes reports a different selection through
        // getSelection than the one that it actually shows to the user.
        // This forces a selection update when lines are joined to work
        // around that. Issue #54
        if ((browser.ie || browser.chrome) && !composition && update &&
            update.state.doc.lines != update.startState.doc.lines)
            this.forceSelection = true;
        let prevDeco = this.decorations, deco = this.updateDeco();
        let decoDiff = findChangedDeco(prevDeco, deco, update.changes);
        changedRanges = ChangedRange.extendWithRanges(changedRanges, decoDiff);
        if (!(this.flags & 7 /* ViewFlag.Dirty */) && changedRanges.length == 0) {
            return false;
        }
        else {
            this.updateInner(changedRanges, update.startState.doc.length, composition);
            if (update.transactions.length)
                this.lastUpdate = Date.now();
            return true;
        }
    }
    // Used by update and the constructor do perform the actual DOM
    // update
    updateInner(changes, oldLength, composition) {
        this.view.viewState.mustMeasureContent = true;
        this.updateChildren(changes, oldLength, composition);
        let { observer } = this.view;
        observer.ignore(() => {
            // Lock the height during redrawing, since Chrome sometimes
            // messes with the scroll position during DOM mutation (though
            // no relayout is triggered and I cannot imagine how it can
            // recompute the scroll position without a layout)
            this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px";
            this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
            // Chrome will sometimes, when DOM mutations occur directly
            // around the selection, get confused and report a different
            // selection from the one it displays (issue #218). This tries
            // to detect that situation.
            let track = browser.chrome || browser.ios ? { node: observer.selectionRange.focusNode, written: false } : undefined;
            this.sync(this.view, track);
            this.flags &= ~7 /* ViewFlag.Dirty */;
            if (track && (track.written || observer.selectionRange.focusNode != track.node))
                this.forceSelection = true;
            this.dom.style.height = "";
        });
        this.markedForComposition.forEach(cView => cView.flags &= ~8 /* ViewFlag.Composition */);
        let gaps = [];
        if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
            for (let child of this.children)
                if (child instanceof BlockWidgetView && child.widget instanceof BlockGapWidget)
                    gaps.push(child.dom);
        observer.updateGaps(gaps);
    }
    updateChildren(changes, oldLength, composition) {
        let ranges = composition ? composition.range.addToSet(changes.slice()) : changes;
        let cursor = this.childCursor(oldLength);
        for (let i = ranges.length - 1;; i--) {
            let next = i >= 0 ? ranges[i] : null;
            if (!next)
                break;
            let { fromA, toA, fromB, toB } = next, content, breakAtStart, openStart, openEnd;
            if (composition && composition.range.fromB < toB && composition.range.toB > fromB) {
                let before = ContentBuilder.build(this.view.state.doc, fromB, composition.range.fromB, this.decorations, this.dynamicDecorationMap);
                let after = ContentBuilder.build(this.view.state.doc, composition.range.toB, toB, this.decorations, this.dynamicDecorationMap);
                breakAtStart = before.breakAtStart;
                openStart = before.openStart;
                openEnd = after.openEnd;
                let compLine = this.compositionView(composition);
                if (after.breakAtStart) {
                    compLine.breakAfter = 1;
                }
                else if (after.content.length &&
                    compLine.merge(compLine.length, compLine.length, after.content[0], false, after.openStart, 0)) {
                    compLine.breakAfter = after.content[0].breakAfter;
                    after.content.shift();
                }
                if (before.content.length &&
                    compLine.merge(0, 0, before.content[before.content.length - 1], true, 0, before.openEnd)) {
                    before.content.pop();
                }
                content = before.content.concat(compLine).concat(after.content);
            }
            else {
                ({ content, breakAtStart, openStart, openEnd } =
                    ContentBuilder.build(this.view.state.doc, fromB, toB, this.decorations, this.dynamicDecorationMap));
            }
            let { i: toI, off: toOff } = cursor.findPos(toA, 1);
            let { i: fromI, off: fromOff } = cursor.findPos(fromA, -1);
            replaceRange(this, fromI, fromOff, toI, toOff, content, breakAtStart, openStart, openEnd);
        }
        if (composition)
            this.fixCompositionDOM(composition);
    }
    compositionView(composition) {
        let cur = new TextView(composition.text.nodeValue);
        cur.flags |= 8 /* ViewFlag.Composition */;
        for (let { deco } of composition.marks)
            cur = new MarkView(deco, [cur], cur.length);
        let line = new LineView;
        line.append(cur, 0);
        return line;
    }
    fixCompositionDOM(composition) {
        let fix = (dom, cView) => {
            cView.flags |= 8 /* ViewFlag.Composition */ | (cView.children.some(c => c.flags & 7 /* ViewFlag.Dirty */) ? 1 /* ViewFlag.ChildDirty */ : 0);
            this.markedForComposition.add(cView);
            let prev = ContentView.get(dom);
            if (prev && prev != cView)
                prev.dom = null;
            cView.setDOM(dom);
        };
        let pos = this.childPos(composition.range.fromB, 1);
        let cView = this.children[pos.i];
        fix(composition.line, cView);
        for (let i = composition.marks.length - 1; i >= -1; i--) {
            pos = cView.childPos(pos.off, 1);
            cView = cView.children[pos.i];
            fix(i >= 0 ? composition.marks[i].node : composition.text, cView);
        }
    }
    // Sync the DOM selection to this.state.selection
    updateSelection(mustRead = false, fromPointer = false) {
        if (mustRead || !this.view.observer.selectionRange.focusNode)
            this.view.observer.readSelectionRange();
        let activeElt = this.view.root.activeElement, focused = activeElt == this.dom;
        let selectionNotFocus = !focused &&
            hasSelection(this.dom, this.view.observer.selectionRange) && !(activeElt && this.dom.contains(activeElt));
        if (!(focused || fromPointer || selectionNotFocus))
            return;
        let force = this.forceSelection;
        this.forceSelection = false;
        let main = this.view.state.selection.main;
        let anchor = this.moveToLine(this.domAtPos(main.anchor));
        let head = main.empty ? anchor : this.moveToLine(this.domAtPos(main.head));
        // Always reset on Firefox when next to an uneditable node to
        // avoid invisible cursor bugs (#111)
        if (browser.gecko && main.empty && !this.hasComposition && betweenUneditable(anchor)) {
            let dummy = document.createTextNode("");
            this.view.observer.ignore(() => anchor.node.insertBefore(dummy, anchor.node.childNodes[anchor.offset] || null));
            anchor = head = new DOMPos(dummy, 0);
            force = true;
        }
        let domSel = this.view.observer.selectionRange;
        // If the selection is already here, or in an equivalent position, don't touch it
        if (force || !domSel.focusNode ||
            !isEquivalentPosition(anchor.node, anchor.offset, domSel.anchorNode, domSel.anchorOffset) ||
            !isEquivalentPosition(head.node, head.offset, domSel.focusNode, domSel.focusOffset)) {
            this.view.observer.ignore(() => {
                // Chrome Android will hide the virtual keyboard when tapping
                // inside an uneditable node, and not bring it back when we
                // move the cursor to its proper position. This tries to
                // restore the keyboard by cycling focus.
                if (browser.android && browser.chrome && this.dom.contains(domSel.focusNode) &&
                    inUneditable(domSel.focusNode, this.dom)) {
                    this.dom.blur();
                    this.dom.focus({ preventScroll: true });
                }
                let rawSel = getSelection(this.view.root);
                if (!rawSel) ;
                else if (main.empty) {
                    // Work around https://bugzilla.mozilla.org/show_bug.cgi?id=1612076
                    if (browser.gecko) {
                        let nextTo = nextToUneditable(anchor.node, anchor.offset);
                        if (nextTo && nextTo != (1 /* NextTo.Before */ | 2 /* NextTo.After */)) {
                            let text = nearbyTextNode(anchor.node, anchor.offset, nextTo == 1 /* NextTo.Before */ ? 1 : -1);
                            if (text)
                                anchor = new DOMPos(text.node, text.offset);
                        }
                    }
                    rawSel.collapse(anchor.node, anchor.offset);
                    if (main.bidiLevel != null && rawSel.caretBidiLevel !== undefined)
                        rawSel.caretBidiLevel = main.bidiLevel;
                }
                else if (rawSel.extend) {
                    // Selection.extend can be used to create an 'inverted' selection
                    // (one where the focus is before the anchor), but not all
                    // browsers support it yet.
                    rawSel.collapse(anchor.node, anchor.offset);
                    // Safari will ignore the call above when the editor is
                    // hidden, and then raise an error on the call to extend
                    // (#940).
                    try {
                        rawSel.extend(head.node, head.offset);
                    }
                    catch (_) { }
                }
                else {
                    // Primitive (IE) way
                    let range = document.createRange();
                    if (main.anchor > main.head)
                        [anchor, head] = [head, anchor];
                    range.setEnd(head.node, head.offset);
                    range.setStart(anchor.node, anchor.offset);
                    rawSel.removeAllRanges();
                    rawSel.addRange(range);
                }
                if (selectionNotFocus && this.view.root.activeElement == this.dom) {
                    this.dom.blur();
                    if (activeElt)
                        activeElt.focus();
                }
            });
            this.view.observer.setSelectionRange(anchor, head);
        }
        this.impreciseAnchor = anchor.precise ? null : new DOMPos(domSel.anchorNode, domSel.anchorOffset);
        this.impreciseHead = head.precise ? null : new DOMPos(domSel.focusNode, domSel.focusOffset);
    }
    enforceCursorAssoc() {
        if (this.hasComposition)
            return;
        let { view } = this, cursor = view.state.selection.main;
        let sel = getSelection(view.root);
        let { anchorNode, anchorOffset } = view.observer.selectionRange;
        if (!sel || !cursor.empty || !cursor.assoc || !sel.modify)
            return;
        let line = LineView.find(this, cursor.head);
        if (!line)
            return;
        let lineStart = line.posAtStart;
        if (cursor.head == lineStart || cursor.head == lineStart + line.length)
            return;
        let before = this.coordsAt(cursor.head, -1), after = this.coordsAt(cursor.head, 1);
        if (!before || !after || before.bottom > after.top)
            return;
        let dom = this.domAtPos(cursor.head + cursor.assoc);
        sel.collapse(dom.node, dom.offset);
        sel.modify("move", cursor.assoc < 0 ? "forward" : "backward", "lineboundary");
        // This can go wrong in corner cases like single-character lines,
        // so check and reset if necessary.
        view.observer.readSelectionRange();
        let newRange = view.observer.selectionRange;
        if (view.docView.posFromDOM(newRange.anchorNode, newRange.anchorOffset) != cursor.from)
            sel.collapse(anchorNode, anchorOffset);
    }
    // If a position is in/near a block widget, move it to a nearby text
    // line, since we don't want the cursor inside a block widget.
    moveToLine(pos) {
        // Block widgets will return positions before/after them, which
        // are thus directly in the document DOM element.
        let dom = this.dom, newPos;
        if (pos.node != dom)
            return pos;
        for (let i = pos.offset; !newPos && i < dom.childNodes.length; i++) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(0);
        }
        for (let i = pos.offset - 1; !newPos && i >= 0; i--) {
            let view = ContentView.get(dom.childNodes[i]);
            if (view instanceof LineView)
                newPos = view.domAtPos(view.length);
        }
        return newPos ? new DOMPos(newPos.node, newPos.offset, true) : pos;
    }
    nearest(dom) {
        for (let cur = dom; cur;) {
            let domView = ContentView.get(cur);
            if (domView && domView.rootView == this)
                return domView;
            cur = cur.parentNode;
        }
        return null;
    }
    posFromDOM(node, offset) {
        let view = this.nearest(node);
        if (!view)
            throw new RangeError("Trying to find position for a DOM position outside of the document");
        return view.localPosFromDOM(node, offset) + view.posAtStart;
    }
    domAtPos(pos) {
        let { i, off } = this.childCursor().findPos(pos, -1);
        for (; i < this.children.length - 1;) {
            let child = this.children[i];
            if (off < child.length || child instanceof LineView)
                break;
            i++;
            off = 0;
        }
        return this.children[i].domAtPos(off);
    }
    coordsAt(pos, side) {
        let best = null, bestPos = 0;
        for (let off = this.length, i = this.children.length - 1; i >= 0; i--) {
            let child = this.children[i], end = off - child.breakAfter, start = end - child.length;
            if (end < pos)
                break;
            if (start <= pos && (start < pos || child.covers(-1)) && (end > pos || child.covers(1)) &&
                (!best || child instanceof LineView && !(best instanceof LineView && side >= 0))) {
                best = child;
                bestPos = start;
            }
            off = start;
        }
        return best ? best.coordsAt(pos - bestPos, side) : null;
    }
    coordsForChar(pos) {
        let { i, off } = this.childPos(pos, 1), child = this.children[i];
        if (!(child instanceof LineView))
            return null;
        while (child.children.length) {
            let { i, off: childOff } = child.childPos(off, 1);
            for (;; i++) {
                if (i == child.children.length)
                    return null;
                if ((child = child.children[i]).length)
                    break;
            }
            off = childOff;
        }
        if (!(child instanceof TextView))
            return null;
        let end = findClusterBreak(child.text, off);
        if (end == off)
            return null;
        let rects = textRange(child.dom, off, end).getClientRects();
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (i == rects.length - 1 || rect.top < rect.bottom && rect.left < rect.right)
                return rect;
        }
        return null;
    }
    measureVisibleLineHeights(viewport) {
        let result = [], { from, to } = viewport;
        let contentWidth = this.view.contentDOM.clientWidth;
        let isWider = contentWidth > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1;
        let widest = -1, ltr = this.view.textDirection == Direction.LTR;
        for (let pos = 0, i = 0; i < this.children.length; i++) {
            let child = this.children[i], end = pos + child.length;
            if (end > to)
                break;
            if (pos >= from) {
                let childRect = child.dom.getBoundingClientRect();
                result.push(childRect.height);
                if (isWider) {
                    let last = child.dom.lastChild;
                    let rects = last ? clientRectsFor(last) : [];
                    if (rects.length) {
                        let rect = rects[rects.length - 1];
                        let width = ltr ? rect.right - childRect.left : childRect.right - rect.left;
                        if (width > widest) {
                            widest = width;
                            this.minWidth = contentWidth;
                            this.minWidthFrom = pos;
                            this.minWidthTo = end;
                        }
                    }
                }
            }
            pos = end + child.breakAfter;
        }
        return result;
    }
    textDirectionAt(pos) {
        let { i } = this.childPos(pos, 1);
        return getComputedStyle(this.children[i].dom).direction == "rtl" ? Direction.RTL : Direction.LTR;
    }
    measureTextSize() {
        for (let child of this.children) {
            if (child instanceof LineView) {
                let measure = child.measureTextSize();
                if (measure)
                    return measure;
            }
        }
        // If no workable line exists, force a layout of a measurable element
        let dummy = document.createElement("div"), lineHeight, charWidth, textHeight;
        dummy.className = "cm-line";
        dummy.style.width = "99999px";
        dummy.style.position = "absolute";
        dummy.textContent = "abc def ghi jkl mno pqr stu";
        this.view.observer.ignore(() => {
            this.dom.appendChild(dummy);
            let rect = clientRectsFor(dummy.firstChild)[0];
            lineHeight = dummy.getBoundingClientRect().height;
            charWidth = rect ? rect.width / 27 : 7;
            textHeight = rect ? rect.height : lineHeight;
            dummy.remove();
        });
        return { lineHeight, charWidth, textHeight };
    }
    childCursor(pos = this.length) {
        // Move back to start of last element when possible, so that
        // `ChildCursor.findPos` doesn't have to deal with the edge case
        // of being after the last element.
        let i = this.children.length;
        if (i)
            pos -= this.children[--i].length;
        return new ChildCursor(this.children, pos, i);
    }
    computeBlockGapDeco() {
        let deco = [], vs = this.view.viewState;
        for (let pos = 0, i = 0;; i++) {
            let next = i == vs.viewports.length ? null : vs.viewports[i];
            let end = next ? next.from - 1 : this.length;
            if (end > pos) {
                let height = (vs.lineBlockAt(end).bottom - vs.lineBlockAt(pos).top) / this.view.scaleY;
                deco.push(Decoration.replace({
                    widget: new BlockGapWidget(height),
                    block: true,
                    inclusive: true,
                    isBlockGap: true,
                }).range(pos, end));
            }
            if (!next)
                break;
            pos = next.to + 1;
        }
        return Decoration.set(deco);
    }
    updateDeco() {
        let allDeco = this.view.state.facet(decorations).map((d, i) => {
            let dynamic = this.dynamicDecorationMap[i] = typeof d == "function";
            return dynamic ? d(this.view) : d;
        });
        for (let i = allDeco.length; i < allDeco.length + 3; i++)
            this.dynamicDecorationMap[i] = false;
        return this.decorations = [
            ...allDeco,
            this.computeBlockGapDeco(),
            this.view.viewState.lineGapDeco
        ];
    }
    scrollIntoView(target) {
        if (target.isSnapshot) {
            let ref = this.view.viewState.lineBlockAt(target.range.head);
            this.view.scrollDOM.scrollTop = ref.top - target.yMargin;
            this.view.scrollDOM.scrollLeft = target.xMargin;
            return;
        }
        let { range } = target;
        let rect = this.coordsAt(range.head, range.empty ? range.assoc : range.head > range.anchor ? -1 : 1), other;
        if (!rect)
            return;
        if (!range.empty && (other = this.coordsAt(range.anchor, range.anchor > range.head ? -1 : 1)))
            rect = { left: Math.min(rect.left, other.left), top: Math.min(rect.top, other.top),
                right: Math.max(rect.right, other.right), bottom: Math.max(rect.bottom, other.bottom) };
        let margins = getScrollMargins(this.view);
        let targetRect = {
            left: rect.left - margins.left, top: rect.top - margins.top,
            right: rect.right + margins.right, bottom: rect.bottom + margins.bottom
        };
        let { offsetWidth, offsetHeight } = this.view.scrollDOM;
        scrollRectIntoView(this.view.scrollDOM, targetRect, range.head < range.anchor ? -1 : 1, target.x, target.y, Math.max(Math.min(target.xMargin, offsetWidth), -offsetWidth), Math.max(Math.min(target.yMargin, offsetHeight), -offsetHeight), this.view.textDirection == Direction.LTR);
    }
}
function betweenUneditable(pos) {
    return pos.node.nodeType == 1 && pos.node.firstChild &&
        (pos.offset == 0 || pos.node.childNodes[pos.offset - 1].contentEditable == "false") &&
        (pos.offset == pos.node.childNodes.length || pos.node.childNodes[pos.offset].contentEditable == "false");
}
class BlockGapWidget extends WidgetType {
    constructor(height) {
        super();
        this.height = height;
    }
    toDOM() {
        let elt = document.createElement("div");
        this.updateDOM(elt);
        return elt;
    }
    eq(other) { return other.height == this.height; }
    updateDOM(elt) {
        elt.style.height = this.height + "px";
        return true;
    }
    get estimatedHeight() { return this.height; }
}
function findCompositionNode(view, headPos) {
    let sel = view.observer.selectionRange;
    let textNode = sel.focusNode && nearbyTextNode(sel.focusNode, sel.focusOffset, 0);
    if (!textNode)
        return null;
    let from = headPos - textNode.offset;
    return { from, to: from + textNode.node.nodeValue.length, node: textNode.node };
}
function findCompositionRange(view, changes, headPos) {
    let found = findCompositionNode(view, headPos);
    if (!found)
        return null;
    let { node: textNode, from, to } = found, text = textNode.nodeValue;
    // Don't try to preserve multi-line compositions
    if (/[\n\r]/.test(text))
        return null;
    if (view.state.doc.sliceString(found.from, found.to) != text)
        return null;
    let inv = changes.invertedDesc;
    let range = new ChangedRange(inv.mapPos(from), inv.mapPos(to), from, to);
    let marks = [];
    for (let parent = textNode.parentNode;; parent = parent.parentNode) {
        let parentView = ContentView.get(parent);
        if (parentView instanceof MarkView)
            marks.push({ node: parent, deco: parentView.mark });
        else if (parentView instanceof LineView || parent.nodeName == "DIV" && parent.parentNode == view.contentDOM)
            return { range, text: textNode, marks, line: parent };
        else if (parent != view.contentDOM)
            marks.push({ node: parent, deco: new MarkDecoration({
                    inclusive: true,
                    attributes: getAttrs(parent),
                    tagName: parent.tagName.toLowerCase()
                }) });
        else
            return null;
    }
}
function nearbyTextNode(startNode, startOffset, side) {
    if (side <= 0)
        for (let node = startNode, offset = startOffset;;) {
            if (node.nodeType == 3)
                return { node: node, offset: offset };
            if (node.nodeType == 1 && offset > 0) {
                node = node.childNodes[offset - 1];
                offset = maxOffset(node);
            }
            else {
                break;
            }
        }
    if (side >= 0)
        for (let node = startNode, offset = startOffset;;) {
            if (node.nodeType == 3)
                return { node: node, offset: offset };
            if (node.nodeType == 1 && offset < node.childNodes.length && side >= 0) {
                node = node.childNodes[offset];
                offset = 0;
            }
            else {
                break;
            }
        }
    return null;
}
function nextToUneditable(node, offset) {
    if (node.nodeType != 1)
        return 0;
    return (offset && node.childNodes[offset - 1].contentEditable == "false" ? 1 /* NextTo.Before */ : 0) |
        (offset < node.childNodes.length && node.childNodes[offset].contentEditable == "false" ? 2 /* NextTo.After */ : 0);
}
let DecorationComparator$1 = class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange(from, to) { addRange(from, to, this.changes); }
    comparePoint(from, to) { addRange(from, to, this.changes); }
};
function findChangedDeco(a, b, diff) {
    let comp = new DecorationComparator$1;
    dist_RangeSet.compare(a, b, diff, comp);
    return comp.changes;
}
function inUneditable(node, inside) {
    for (let cur = node; cur && cur != inside; cur = cur.assignedSlot || cur.parentNode) {
        if (cur.nodeType == 1 && cur.contentEditable == 'false') {
            return true;
        }
    }
    return false;
}
function touchesComposition(changes, composition) {
    let touched = false;
    if (composition)
        changes.iterChangedRanges((from, to) => {
            if (from < composition.to && to > composition.from)
                touched = true;
        });
    return touched;
}

function groupAt(state, pos, bias = 1) {
    let categorize = state.charCategorizer(pos);
    let line = state.doc.lineAt(pos), linePos = pos - line.from;
    if (line.length == 0)
        return dist_EditorSelection.cursor(pos);
    if (linePos == 0)
        bias = 1;
    else if (linePos == line.length)
        bias = -1;
    let from = linePos, to = linePos;
    if (bias < 0)
        from = findClusterBreak(line.text, linePos, false);
    else
        to = findClusterBreak(line.text, linePos);
    let cat = categorize(line.text.slice(from, to));
    while (from > 0) {
        let prev = findClusterBreak(line.text, from, false);
        if (categorize(line.text.slice(prev, from)) != cat)
            break;
        from = prev;
    }
    while (to < line.length) {
        let next = findClusterBreak(line.text, to);
        if (categorize(line.text.slice(to, next)) != cat)
            break;
        to = next;
    }
    return dist_EditorSelection.range(from + line.from, to + line.from);
}
// Search the DOM for the {node, offset} position closest to the given
// coordinates. Very inefficient and crude, but can usually be avoided
// by calling caret(Position|Range)FromPoint instead.
function getdx(x, rect) {
    return rect.left > x ? rect.left - x : Math.max(0, x - rect.right);
}
function getdy(y, rect) {
    return rect.top > y ? rect.top - y : Math.max(0, y - rect.bottom);
}
function yOverlap(a, b) {
    return a.top < b.bottom - 1 && a.bottom > b.top + 1;
}
function upTop(rect, top) {
    return top < rect.top ? { top, left: rect.left, right: rect.right, bottom: rect.bottom } : rect;
}
function upBot(rect, bottom) {
    return bottom > rect.bottom ? { top: rect.top, left: rect.left, right: rect.right, bottom } : rect;
}
function domPosAtCoords(parent, x, y) {
    let closest, closestRect, closestX, closestY, closestOverlap = false;
    let above, below, aboveRect, belowRect;
    for (let child = parent.firstChild; child; child = child.nextSibling) {
        let rects = clientRectsFor(child);
        for (let i = 0; i < rects.length; i++) {
            let rect = rects[i];
            if (closestRect && yOverlap(closestRect, rect))
                rect = upTop(upBot(rect, closestRect.bottom), closestRect.top);
            let dx = getdx(x, rect), dy = getdy(y, rect);
            if (dx == 0 && dy == 0)
                return child.nodeType == 3 ? domPosInText(child, x, y) : domPosAtCoords(child, x, y);
            if (!closest || closestY > dy || closestY == dy && closestX > dx) {
                closest = child;
                closestRect = rect;
                closestX = dx;
                closestY = dy;
                let side = dy ? (y < rect.top ? -1 : 1) : dx ? (x < rect.left ? -1 : 1) : 0;
                closestOverlap = !side || (side > 0 ? i < rects.length - 1 : i > 0);
            }
            if (dx == 0) {
                if (y > rect.bottom && (!aboveRect || aboveRect.bottom < rect.bottom)) {
                    above = child;
                    aboveRect = rect;
                }
                else if (y < rect.top && (!belowRect || belowRect.top > rect.top)) {
                    below = child;
                    belowRect = rect;
                }
            }
            else if (aboveRect && yOverlap(aboveRect, rect)) {
                aboveRect = upBot(aboveRect, rect.bottom);
            }
            else if (belowRect && yOverlap(belowRect, rect)) {
                belowRect = upTop(belowRect, rect.top);
            }
        }
    }
    if (aboveRect && aboveRect.bottom >= y) {
        closest = above;
        closestRect = aboveRect;
    }
    else if (belowRect && belowRect.top <= y) {
        closest = below;
        closestRect = belowRect;
    }
    if (!closest)
        return { node: parent, offset: 0 };
    let clipX = Math.max(closestRect.left, Math.min(closestRect.right, x));
    if (closest.nodeType == 3)
        return domPosInText(closest, clipX, y);
    if (closestOverlap && closest.contentEditable != "false")
        return domPosAtCoords(closest, clipX, y);
    let offset = Array.prototype.indexOf.call(parent.childNodes, closest) +
        (x >= (closestRect.left + closestRect.right) / 2 ? 1 : 0);
    return { node: parent, offset };
}
function domPosInText(node, x, y) {
    let len = node.nodeValue.length;
    let closestOffset = -1, closestDY = 1e9, generalSide = 0;
    for (let i = 0; i < len; i++) {
        let rects = textRange(node, i, i + 1).getClientRects();
        for (let j = 0; j < rects.length; j++) {
            let rect = rects[j];
            if (rect.top == rect.bottom)
                continue;
            if (!generalSide)
                generalSide = x - rect.left;
            let dy = (rect.top > y ? rect.top - y : y - rect.bottom) - 1;
            if (rect.left - 1 <= x && rect.right + 1 >= x && dy < closestDY) {
                let right = x >= (rect.left + rect.right) / 2, after = right;
                if (browser.chrome || browser.gecko) {
                    // Check for RTL on browsers that support getting client
                    // rects for empty ranges.
                    let rectBefore = textRange(node, i).getBoundingClientRect();
                    if (rectBefore.left == rect.right)
                        after = !right;
                }
                if (dy <= 0)
                    return { node, offset: i + (after ? 1 : 0) };
                closestOffset = i + (after ? 1 : 0);
                closestDY = dy;
            }
        }
    }
    return { node, offset: closestOffset > -1 ? closestOffset : generalSide > 0 ? node.nodeValue.length : 0 };
}
function posAtCoords(view, coords, precise, bias = -1) {
    var _a, _b;
    let content = view.contentDOM.getBoundingClientRect(), docTop = content.top + view.viewState.paddingTop;
    let block, { docHeight } = view.viewState;
    let { x, y } = coords, yOffset = y - docTop;
    if (yOffset < 0)
        return 0;
    if (yOffset > docHeight)
        return view.state.doc.length;
    // Scan for a text block near the queried y position
    for (let halfLine = view.viewState.heightOracle.textHeight / 2, bounced = false;;) {
        block = view.elementAtHeight(yOffset);
        if (block.type == BlockType.Text)
            break;
        for (;;) {
            // Move the y position out of this block
            yOffset = bias > 0 ? block.bottom + halfLine : block.top - halfLine;
            if (yOffset >= 0 && yOffset <= docHeight)
                break;
            // If the document consists entirely of replaced widgets, we
            // won't find a text block, so return 0
            if (bounced)
                return precise ? null : 0;
            bounced = true;
            bias = -bias;
        }
    }
    y = docTop + yOffset;
    let lineStart = block.from;
    // If this is outside of the rendered viewport, we can't determine a position
    if (lineStart < view.viewport.from)
        return view.viewport.from == 0 ? 0 : precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    if (lineStart > view.viewport.to)
        return view.viewport.to == view.state.doc.length ? view.state.doc.length :
            precise ? null : posAtCoordsImprecise(view, content, block, x, y);
    // Prefer ShadowRootOrDocument.elementFromPoint if present, fall back to document if not
    let doc = view.dom.ownerDocument;
    let root = view.root.elementFromPoint ? view.root : doc;
    let element = root.elementFromPoint(x, y);
    if (element && !view.contentDOM.contains(element))
        element = null;
    // If the element is unexpected, clip x at the sides of the content area and try again
    if (!element) {
        x = Math.max(content.left + 1, Math.min(content.right - 1, x));
        element = root.elementFromPoint(x, y);
        if (element && !view.contentDOM.contains(element))
            element = null;
    }
    // There's visible editor content under the point, so we can try
    // using caret(Position|Range)FromPoint as a shortcut
    let node, offset = -1;
    if (element && ((_a = view.docView.nearest(element)) === null || _a === void 0 ? void 0 : _a.isEditable) != false) {
        if (doc.caretPositionFromPoint) {
            let pos = doc.caretPositionFromPoint(x, y);
            if (pos)
                ({ offsetNode: node, offset } = pos);
        }
        else if (doc.caretRangeFromPoint) {
            let range = doc.caretRangeFromPoint(x, y);
            if (range) {
                ({ startContainer: node, startOffset: offset } = range);
                if (!view.contentDOM.contains(node) ||
                    browser.safari && isSuspiciousSafariCaretResult(node, offset, x) ||
                    browser.chrome && isSuspiciousChromeCaretResult(node, offset, x))
                    node = undefined;
            }
        }
    }
    // No luck, do our own (potentially expensive) search
    if (!node || !view.docView.dom.contains(node)) {
        let line = LineView.find(view.docView, lineStart);
        if (!line)
            return yOffset > block.top + block.height / 2 ? block.to : block.from;
        ({ node, offset } = domPosAtCoords(line.dom, x, y));
    }
    let nearest = view.docView.nearest(node);
    if (!nearest)
        return null;
    if (nearest.isWidget && ((_b = nearest.dom) === null || _b === void 0 ? void 0 : _b.nodeType) == 1) {
        let rect = nearest.dom.getBoundingClientRect();
        return coords.y < rect.top || coords.y <= rect.bottom && coords.x <= (rect.left + rect.right) / 2
            ? nearest.posAtStart : nearest.posAtEnd;
    }
    else {
        return nearest.localPosFromDOM(node, offset) + nearest.posAtStart;
    }
}
function posAtCoordsImprecise(view, contentRect, block, x, y) {
    let into = Math.round((x - contentRect.left) * view.defaultCharacterWidth);
    if (view.lineWrapping && block.height > view.defaultLineHeight * 1.5) {
        let textHeight = view.viewState.heightOracle.textHeight;
        let line = Math.floor((y - block.top - (view.defaultLineHeight - textHeight) * 0.5) / textHeight);
        into += line * view.viewState.heightOracle.lineLength;
    }
    let content = view.state.sliceDoc(block.from, block.to);
    return block.from + findColumn(content, into, view.state.tabSize);
}
// In case of a high line height, Safari's caretRangeFromPoint treats
// the space between lines as belonging to the last character of the
// line before. This is used to detect such a result so that it can be
// ignored (issue #401).
function isSuspiciousSafariCaretResult(node, offset, x) {
    let len;
    if (node.nodeType != 3 || offset != (len = node.nodeValue.length))
        return false;
    for (let next = node.nextSibling; next; next = next.nextSibling)
        if (next.nodeType != 1 || next.nodeName != "BR")
            return false;
    return textRange(node, len - 1, len).getBoundingClientRect().left > x;
}
// Chrome will move positions between lines to the start of the next line
function isSuspiciousChromeCaretResult(node, offset, x) {
    if (offset != 0)
        return false;
    for (let cur = node;;) {
        let parent = cur.parentNode;
        if (!parent || parent.nodeType != 1 || parent.firstChild != cur)
            return false;
        if (parent.classList.contains("cm-line"))
            break;
        cur = parent;
    }
    let rect = node.nodeType == 1 ? node.getBoundingClientRect()
        : textRange(node, 0, Math.max(node.nodeValue.length, 1)).getBoundingClientRect();
    return x - rect.left > 5;
}
function blockAt(view, pos) {
    let line = view.lineBlockAt(pos);
    if (Array.isArray(line.type))
        for (let l of line.type) {
            if (l.to > pos || l.to == pos && (l.to == line.to || l.type == BlockType.Text))
                return l;
        }
    return line;
}
function moveToLineBoundary(view, start, forward, includeWrap) {
    let line = blockAt(view, start.head);
    let coords = !includeWrap || line.type != BlockType.Text || !(view.lineWrapping || line.widgetLineBreaks) ? null
        : view.coordsAtPos(start.assoc < 0 && start.head > line.from ? start.head - 1 : start.head);
    if (coords) {
        let editorRect = view.dom.getBoundingClientRect();
        let direction = view.textDirectionAt(line.from);
        let pos = view.posAtCoords({ x: forward == (direction == Direction.LTR) ? editorRect.right - 1 : editorRect.left + 1,
            y: (coords.top + coords.bottom) / 2 });
        if (pos != null)
            return dist_EditorSelection.cursor(pos, forward ? -1 : 1);
    }
    return dist_EditorSelection.cursor(forward ? line.to : line.from, forward ? -1 : 1);
}
function moveByChar(view, start, forward, by) {
    let line = view.state.doc.lineAt(start.head), spans = view.bidiSpans(line);
    let direction = view.textDirectionAt(line.from);
    for (let cur = start, check = null;;) {
        let next = moveVisually(line, spans, direction, cur, forward), char = movedOver;
        if (!next) {
            if (line.number == (forward ? view.state.doc.lines : 1))
                return cur;
            char = "\n";
            line = view.state.doc.line(line.number + (forward ? 1 : -1));
            spans = view.bidiSpans(line);
            next = dist_EditorSelection.cursor(forward ? line.from : line.to);
        }
        if (!check) {
            if (!by)
                return next;
            check = by(char);
        }
        else if (!check(char)) {
            return cur;
        }
        cur = next;
    }
}
function byGroup(view, pos, start) {
    let categorize = view.state.charCategorizer(pos);
    let cat = categorize(start);
    return (next) => {
        let nextCat = categorize(next);
        if (cat == dist_CharCategory.Space)
            cat = nextCat;
        return cat == nextCat;
    };
}
function moveVertically(view, start, forward, distance) {
    let startPos = start.head, dir = forward ? 1 : -1;
    if (startPos == (forward ? view.state.doc.length : 0))
        return dist_EditorSelection.cursor(startPos, start.assoc);
    let goal = start.goalColumn, startY;
    let rect = view.contentDOM.getBoundingClientRect();
    let startCoords = view.coordsAtPos(startPos, start.assoc || -1), docTop = view.documentTop;
    if (startCoords) {
        if (goal == null)
            goal = startCoords.left - rect.left;
        startY = dir < 0 ? startCoords.top : startCoords.bottom;
    }
    else {
        let line = view.viewState.lineBlockAt(startPos);
        if (goal == null)
            goal = Math.min(rect.right - rect.left, view.defaultCharacterWidth * (startPos - line.from));
        startY = (dir < 0 ? line.top : line.bottom) + docTop;
    }
    let resolvedGoal = rect.left + goal;
    let dist = distance !== null && distance !== void 0 ? distance : (view.viewState.heightOracle.textHeight >> 1);
    for (let extra = 0;; extra += 10) {
        let curY = startY + (dist + extra) * dir;
        let pos = posAtCoords(view, { x: resolvedGoal, y: curY }, false, dir);
        if (curY < rect.top || curY > rect.bottom || (dir < 0 ? pos < startPos : pos > startPos)) {
            let charRect = view.docView.coordsForChar(pos);
            let assoc = !charRect || curY < charRect.top ? -1 : 1;
            return dist_EditorSelection.cursor(pos, assoc, undefined, goal);
        }
    }
}
function skipAtomicRanges(atoms, pos, bias) {
    for (;;) {
        let moved = 0;
        for (let set of atoms) {
            set.between(pos - 1, pos + 1, (from, to, value) => {
                if (pos > from && pos < to) {
                    let side = moved || bias || (pos - from < to - pos ? -1 : 1);
                    pos = side < 0 ? from : to;
                    moved = side;
                }
            });
        }
        if (!moved)
            return pos;
    }
}
function skipAtoms(view, oldPos, pos) {
    let newPos = skipAtomicRanges(view.state.facet(atomicRanges).map(f => f(view)), pos.from, oldPos.head > pos.from ? -1 : 1);
    return newPos == pos.from ? pos : dist_EditorSelection.cursor(newPos, newPos < pos.from ? 1 : -1);
}

// This will also be where dragging info and such goes
class InputState {
    setSelectionOrigin(origin) {
        this.lastSelectionOrigin = origin;
        this.lastSelectionTime = Date.now();
    }
    constructor(view) {
        this.view = view;
        this.lastKeyCode = 0;
        this.lastKeyTime = 0;
        this.lastTouchTime = 0;
        this.lastFocusTime = 0;
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        // On iOS, some keys need to have their default behavior happen
        // (after which we retroactively handle them and reset the DOM) to
        // avoid messing up the virtual keyboard state.
        this.pendingIOSKey = undefined;
        this.lastSelectionOrigin = null;
        this.lastSelectionTime = 0;
        this.lastEscPress = 0;
        this.lastContextMenu = 0;
        this.scrollHandlers = [];
        this.handlers = Object.create(null);
        // -1 means not in a composition. Otherwise, this counts the number
        // of changes made during the composition. The count is used to
        // avoid treating the start state of the composition, before any
        // changes have been made, as part of the composition.
        this.composing = -1;
        // Tracks whether the next change should be marked as starting the
        // composition (null means no composition, true means next is the
        // first, false means first has already been marked for this
        // composition)
        this.compositionFirstChange = null;
        // End time of the previous composition
        this.compositionEndedAt = 0;
        // Used in a kludge to detect when an Enter keypress should be
        // considered part of the composition on Safari, which fires events
        // in the wrong order
        this.compositionPendingKey = false;
        // Used to categorize changes as part of a composition, even when
        // the mutation events fire shortly after the compositionend event
        this.compositionPendingChange = false;
        this.mouseSelection = null;
        // When a drag from the editor is active, this points at the range
        // being dragged.
        this.draggedContent = null;
        this.handleEvent = this.handleEvent.bind(this);
        this.notifiedFocused = view.hasFocus;
        // On Safari adding an input event handler somehow prevents an
        // issue where the composition vanishes when you press enter.
        if (browser.safari)
            view.contentDOM.addEventListener("input", () => null);
        if (browser.gecko)
            firefoxCopyCutHack(view.contentDOM.ownerDocument);
    }
    handleEvent(event) {
        if (!eventBelongsToEditor(this.view, event) || this.ignoreDuringComposition(event))
            return;
        if (event.type == "keydown" && this.keydown(event))
            return;
        this.runHandlers(event.type, event);
    }
    runHandlers(type, event) {
        let handlers = this.handlers[type];
        if (handlers) {
            for (let observer of handlers.observers)
                observer(this.view, event);
            for (let handler of handlers.handlers) {
                if (event.defaultPrevented)
                    break;
                if (handler(this.view, event)) {
                    event.preventDefault();
                    break;
                }
            }
        }
    }
    ensureHandlers(plugins) {
        let handlers = computeHandlers(plugins), prev = this.handlers, dom = this.view.contentDOM;
        for (let type in handlers)
            if (type != "scroll") {
                let passive = !handlers[type].handlers.length;
                let exists = prev[type];
                if (exists && passive != !exists.handlers.length) {
                    dom.removeEventListener(type, this.handleEvent);
                    exists = null;
                }
                if (!exists)
                    dom.addEventListener(type, this.handleEvent, { passive });
            }
        for (let type in prev)
            if (type != "scroll" && !handlers[type])
                dom.removeEventListener(type, this.handleEvent);
        this.handlers = handlers;
    }
    keydown(event) {
        // Must always run, even if a custom handler handled the event
        this.lastKeyCode = event.keyCode;
        this.lastKeyTime = Date.now();
        if (event.keyCode == 9 && Date.now() < this.lastEscPress + 2000)
            return true;
        if (event.keyCode != 27 && modifierCodes.indexOf(event.keyCode) < 0)
            this.view.inputState.lastEscPress = 0;
        // Chrome for Android usually doesn't fire proper key events, but
        // occasionally does, usually surrounded by a bunch of complicated
        // composition changes. When an enter or backspace key event is
        // seen, hold off on handling DOM events for a bit, and then
        // dispatch it.
        if (browser.android && browser.chrome && !event.synthetic &&
            (event.keyCode == 13 || event.keyCode == 8)) {
            this.view.observer.delayAndroidKey(event.key, event.keyCode);
            return true;
        }
        // Preventing the default behavior of Enter on iOS makes the
        // virtual keyboard get stuck in the wrong (lowercase)
        // state. So we let it go through, and then, in
        // applyDOMChange, notify key handlers of it and reset to
        // the state they produce.
        let pending;
        if (browser.ios && !event.synthetic && !event.altKey && !event.metaKey &&
            ((pending = PendingKeys.find(key => key.keyCode == event.keyCode)) && !event.ctrlKey ||
                EmacsyPendingKeys.indexOf(event.key) > -1 && event.ctrlKey && !event.shiftKey)) {
            this.pendingIOSKey = pending || event;
            setTimeout(() => this.flushIOSKey(), 250);
            return true;
        }
        if (event.keyCode != 229)
            this.view.observer.forceFlush();
        return false;
    }
    flushIOSKey() {
        let key = this.pendingIOSKey;
        if (!key)
            return false;
        this.pendingIOSKey = undefined;
        return dispatchKey(this.view.contentDOM, key.key, key.keyCode);
    }
    ignoreDuringComposition(event) {
        if (!/^key/.test(event.type))
            return false;
        if (this.composing > 0)
            return true;
        // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
        // On some input method editors (IMEs), the Enter key is used to
        // confirm character selection. On Safari, when Enter is pressed,
        // compositionend and keydown events are sometimes emitted in the
        // wrong order. The key event should still be ignored, even when
        // it happens after the compositionend event.
        if (browser.safari && !browser.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100) {
            this.compositionPendingKey = false;
            return true;
        }
        return false;
    }
    startMouseSelection(mouseSelection) {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
        this.mouseSelection = mouseSelection;
    }
    update(update) {
        if (this.mouseSelection)
            this.mouseSelection.update(update);
        if (this.draggedContent && update.docChanged)
            this.draggedContent = this.draggedContent.map(update.changes);
        if (update.transactions.length)
            this.lastKeyCode = this.lastSelectionTime = 0;
    }
    destroy() {
        if (this.mouseSelection)
            this.mouseSelection.destroy();
    }
}
function bindHandler(plugin, handler) {
    return (view, event) => {
        try {
            return handler.call(plugin, event, view);
        }
        catch (e) {
            dist_logException(view.state, e);
        }
    };
}
function computeHandlers(plugins) {
    let result = Object.create(null);
    function record(type) {
        return result[type] || (result[type] = { observers: [], handlers: [] });
    }
    for (let plugin of plugins) {
        let spec = plugin.spec;
        if (spec && spec.domEventHandlers)
            for (let type in spec.domEventHandlers) {
                let f = spec.domEventHandlers[type];
                if (f)
                    record(type).handlers.push(bindHandler(plugin.value, f));
            }
        if (spec && spec.domEventObservers)
            for (let type in spec.domEventObservers) {
                let f = spec.domEventObservers[type];
                if (f)
                    record(type).observers.push(bindHandler(plugin.value, f));
            }
    }
    for (let type in handlers)
        record(type).handlers.push(handlers[type]);
    for (let type in observers)
        record(type).observers.push(observers[type]);
    return result;
}
const PendingKeys = [
    { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
    { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
    { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
    { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
];
const EmacsyPendingKeys = "dthko";
// Key codes for modifier keys
const modifierCodes = [16, 17, 18, 20, 91, 92, 224, 225];
const dragScrollMargin = 6;
function dragScrollSpeed(dist) {
    return Math.max(0, dist) * 0.7 + 8;
}
function dist(a, b) {
    return Math.max(Math.abs(a.clientX - b.clientX), Math.abs(a.clientY - b.clientY));
}
class MouseSelection {
    constructor(view, startEvent, style, mustSelect) {
        this.view = view;
        this.startEvent = startEvent;
        this.style = style;
        this.mustSelect = mustSelect;
        this.scrollSpeed = { x: 0, y: 0 };
        this.scrolling = -1;
        this.lastEvent = startEvent;
        this.scrollParent = scrollableParent(view.contentDOM);
        this.atoms = view.state.facet(atomicRanges).map(f => f(view));
        let doc = view.contentDOM.ownerDocument;
        doc.addEventListener("mousemove", this.move = this.move.bind(this));
        doc.addEventListener("mouseup", this.up = this.up.bind(this));
        this.extend = startEvent.shiftKey;
        this.multiple = view.state.facet(EditorState.allowMultipleSelections) && addsSelectionRange(view, startEvent);
        this.dragging = isInPrimarySelection(view, startEvent) && getClickType(startEvent) == 1 ? null : false;
    }
    start(event) {
        // When clicking outside of the selection, immediately apply the
        // effect of starting the selection
        if (this.dragging === false)
            this.select(event);
    }
    move(event) {
        var _a;
        if (event.buttons == 0)
            return this.destroy();
        if (this.dragging || this.dragging == null && dist(this.startEvent, event) < 10)
            return;
        this.select(this.lastEvent = event);
        let sx = 0, sy = 0;
        let rect = ((_a = this.scrollParent) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect())
            || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight };
        let margins = getScrollMargins(this.view);
        if (event.clientX - margins.left <= rect.left + dragScrollMargin)
            sx = -dragScrollSpeed(rect.left - event.clientX);
        else if (event.clientX + margins.right >= rect.right - dragScrollMargin)
            sx = dragScrollSpeed(event.clientX - rect.right);
        if (event.clientY - margins.top <= rect.top + dragScrollMargin)
            sy = -dragScrollSpeed(rect.top - event.clientY);
        else if (event.clientY + margins.bottom >= rect.bottom - dragScrollMargin)
            sy = dragScrollSpeed(event.clientY - rect.bottom);
        this.setScrollSpeed(sx, sy);
    }
    up(event) {
        if (this.dragging == null)
            this.select(this.lastEvent);
        if (!this.dragging)
            event.preventDefault();
        this.destroy();
    }
    destroy() {
        this.setScrollSpeed(0, 0);
        let doc = this.view.contentDOM.ownerDocument;
        doc.removeEventListener("mousemove", this.move);
        doc.removeEventListener("mouseup", this.up);
        this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
    }
    setScrollSpeed(sx, sy) {
        this.scrollSpeed = { x: sx, y: sy };
        if (sx || sy) {
            if (this.scrolling < 0)
                this.scrolling = setInterval(() => this.scroll(), 50);
        }
        else if (this.scrolling > -1) {
            clearInterval(this.scrolling);
            this.scrolling = -1;
        }
    }
    scroll() {
        if (this.scrollParent) {
            this.scrollParent.scrollLeft += this.scrollSpeed.x;
            this.scrollParent.scrollTop += this.scrollSpeed.y;
        }
        else {
            this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y);
        }
        if (this.dragging === false)
            this.select(this.lastEvent);
    }
    skipAtoms(sel) {
        let ranges = null;
        for (let i = 0; i < sel.ranges.length; i++) {
            let range = sel.ranges[i], updated = null;
            if (range.empty) {
                let pos = skipAtomicRanges(this.atoms, range.from, 0);
                if (pos != range.from)
                    updated = dist_EditorSelection.cursor(pos, -1);
            }
            else {
                let from = skipAtomicRanges(this.atoms, range.from, -1);
                let to = skipAtomicRanges(this.atoms, range.to, 1);
                if (from != range.from || to != range.to)
                    updated = dist_EditorSelection.range(range.from == range.anchor ? from : to, range.from == range.head ? from : to);
            }
            if (updated) {
                if (!ranges)
                    ranges = sel.ranges.slice();
                ranges[i] = updated;
            }
        }
        return ranges ? dist_EditorSelection.create(ranges, sel.mainIndex) : sel;
    }
    select(event) {
        let { view } = this, selection = this.skipAtoms(this.style.get(event, this.extend, this.multiple));
        if (this.mustSelect || !selection.eq(view.state.selection) ||
            selection.main.assoc != view.state.selection.main.assoc && this.dragging === false)
            this.view.dispatch({
                selection,
                userEvent: "select.pointer"
            });
        this.mustSelect = false;
    }
    update(update) {
        if (this.style.update(update))
            setTimeout(() => this.select(this.lastEvent), 20);
    }
}
function addsSelectionRange(view, event) {
    let facet = view.state.facet(clickAddsSelectionRange);
    return facet.length ? facet[0](event) : browser.mac ? event.metaKey : event.ctrlKey;
}
function dragMovesSelection(view, event) {
    let facet = view.state.facet(dragMovesSelection$1);
    return facet.length ? facet[0](event) : browser.mac ? !event.altKey : !event.ctrlKey;
}
function isInPrimarySelection(view, event) {
    let { main } = view.state.selection;
    if (main.empty)
        return false;
    // On boundary clicks, check whether the coordinates are inside the
    // selection's client rectangles
    let sel = getSelection(view.root);
    if (!sel || sel.rangeCount == 0)
        return true;
    let rects = sel.getRangeAt(0).getClientRects();
    for (let i = 0; i < rects.length; i++) {
        let rect = rects[i];
        if (rect.left <= event.clientX && rect.right >= event.clientX &&
            rect.top <= event.clientY && rect.bottom >= event.clientY)
            return true;
    }
    return false;
}
function eventBelongsToEditor(view, event) {
    if (!event.bubbles)
        return true;
    if (event.defaultPrevented)
        return false;
    for (let node = event.target, cView; node != view.contentDOM; node = node.parentNode)
        if (!node || node.nodeType == 11 || ((cView = ContentView.get(node)) && cView.ignoreEvent(event)))
            return false;
    return true;
}
const handlers = /*@__PURE__*/Object.create(null);
const observers = /*@__PURE__*/Object.create(null);
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
const brokenClipboardAPI = (browser.ie && browser.ie_version < 15) ||
    (browser.ios && browser.webkit_version < 604);
function capturePaste(view) {
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.focus();
    setTimeout(() => {
        view.focus();
        target.remove();
        doPaste(view, target.value);
    }, 50);
}
function doPaste(view, input) {
    let { state } = view, changes, i = 1, text = state.toText(input);
    let byLine = text.lines == state.selection.ranges.length;
    let linewise = lastLinewiseCopy != null && state.selection.ranges.every(r => r.empty) && lastLinewiseCopy == text.toString();
    if (linewise) {
        let lastLine = -1;
        changes = state.changeByRange(range => {
            let line = state.doc.lineAt(range.from);
            if (line.from == lastLine)
                return { range };
            lastLine = line.from;
            let insert = state.toText((byLine ? text.line(i++).text : input) + state.lineBreak);
            return { changes: { from: line.from, insert },
                range: dist_EditorSelection.cursor(range.from + insert.length) };
        });
    }
    else if (byLine) {
        changes = state.changeByRange(range => {
            let line = text.line(i++);
            return { changes: { from: range.from, to: range.to, insert: line.text },
                range: dist_EditorSelection.cursor(range.from + line.length) };
        });
    }
    else {
        changes = state.replaceSelection(text);
    }
    view.dispatch(changes, {
        userEvent: "input.paste",
        scrollIntoView: true
    });
}
observers.scroll = view => {
    view.inputState.lastScrollTop = view.scrollDOM.scrollTop;
    view.inputState.lastScrollLeft = view.scrollDOM.scrollLeft;
};
handlers.keydown = (view, event) => {
    view.inputState.setSelectionOrigin("select");
    if (event.keyCode == 27)
        view.inputState.lastEscPress = Date.now();
    return false;
};
observers.touchstart = (view, e) => {
    view.inputState.lastTouchTime = Date.now();
    view.inputState.setSelectionOrigin("select.pointer");
};
observers.touchmove = view => {
    view.inputState.setSelectionOrigin("select.pointer");
};
handlers.mousedown = (view, event) => {
    view.observer.flush();
    if (view.inputState.lastTouchTime > Date.now() - 2000)
        return false; // Ignore touch interaction
    let style = null;
    for (let makeStyle of view.state.facet(mouseSelectionStyle)) {
        style = makeStyle(view, event);
        if (style)
            break;
    }
    if (!style && event.button == 0)
        style = basicMouseSelection(view, event);
    if (style) {
        let mustFocus = !view.hasFocus;
        view.inputState.startMouseSelection(new MouseSelection(view, event, style, mustFocus));
        if (mustFocus)
            view.observer.ignore(() => focusPreventScroll(view.contentDOM));
        let mouseSel = view.inputState.mouseSelection;
        if (mouseSel) {
            mouseSel.start(event);
            return mouseSel.dragging === false;
        }
    }
    return false;
};
function rangeForClick(view, pos, bias, type) {
    if (type == 1) { // Single click
        return dist_EditorSelection.cursor(pos, bias);
    }
    else if (type == 2) { // Double click
        return groupAt(view.state, pos, bias);
    }
    else { // Triple click
        let visual = LineView.find(view.docView, pos), line = view.state.doc.lineAt(visual ? visual.posAtEnd : pos);
        let from = visual ? visual.posAtStart : line.from, to = visual ? visual.posAtEnd : line.to;
        if (to < view.state.doc.length && to == line.to)
            to++;
        return dist_EditorSelection.range(from, to);
    }
}
let insideY = (y, rect) => y >= rect.top && y <= rect.bottom;
let inside = (x, y, rect) => insideY(y, rect) && x >= rect.left && x <= rect.right;
// Try to determine, for the given coordinates, associated with the
// given position, whether they are related to the element before or
// the element after the position.
function findPositionSide(view, pos, x, y) {
    let line = LineView.find(view.docView, pos);
    if (!line)
        return 1;
    let off = pos - line.posAtStart;
    // Line boundaries point into the line
    if (off == 0)
        return 1;
    if (off == line.length)
        return -1;
    // Positions on top of an element point at that element
    let before = line.coordsAt(off, -1);
    if (before && inside(x, y, before))
        return -1;
    let after = line.coordsAt(off, 1);
    if (after && inside(x, y, after))
        return 1;
    // This is probably a line wrap point. Pick before if the point is
    // beside it.
    return before && insideY(y, before) ? -1 : 1;
}
function queryPos(view, event) {
    let pos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    return { pos, bias: findPositionSide(view, pos, event.clientX, event.clientY) };
}
const BadMouseDetail = browser.ie && browser.ie_version <= 11;
let lastMouseDown = null, lastMouseDownCount = 0, lastMouseDownTime = 0;
function getClickType(event) {
    if (!BadMouseDetail)
        return event.detail;
    let last = lastMouseDown, lastTime = lastMouseDownTime;
    lastMouseDown = event;
    lastMouseDownTime = Date.now();
    return lastMouseDownCount = !last || (lastTime > Date.now() - 400 && Math.abs(last.clientX - event.clientX) < 2 &&
        Math.abs(last.clientY - event.clientY) < 2) ? (lastMouseDownCount + 1) % 3 : 1;
}
function basicMouseSelection(view, event) {
    let start = queryPos(view, event), type = getClickType(event);
    let startSel = view.state.selection;
    return {
        update(update) {
            if (update.docChanged) {
                start.pos = update.changes.mapPos(start.pos);
                startSel = startSel.map(update.changes);
            }
        },
        get(event, extend, multiple) {
            let cur = queryPos(view, event), removed;
            let range = rangeForClick(view, cur.pos, cur.bias, type);
            if (start.pos != cur.pos && !extend) {
                let startRange = rangeForClick(view, start.pos, start.bias, type);
                let from = Math.min(startRange.from, range.from), to = Math.max(startRange.to, range.to);
                range = from < range.from ? dist_EditorSelection.range(from, to) : dist_EditorSelection.range(to, from);
            }
            if (extend)
                return startSel.replaceRange(startSel.main.extend(range.from, range.to));
            else if (multiple && type == 1 && startSel.ranges.length > 1 && (removed = removeRangeAround(startSel, cur.pos)))
                return removed;
            else if (multiple)
                return startSel.addRange(range);
            else
                return dist_EditorSelection.create([range]);
        }
    };
}
function removeRangeAround(sel, pos) {
    for (let i = 0; i < sel.ranges.length; i++) {
        let { from, to } = sel.ranges[i];
        if (from <= pos && to >= pos)
            return dist_EditorSelection.create(sel.ranges.slice(0, i).concat(sel.ranges.slice(i + 1)), sel.mainIndex == i ? 0 : sel.mainIndex - (sel.mainIndex > i ? 1 : 0));
    }
    return null;
}
handlers.dragstart = (view, event) => {
    let { selection: { main: range } } = view.state;
    if (event.target.draggable) {
        let cView = view.docView.nearest(event.target);
        if (cView && cView.isWidget) {
            let from = cView.posAtStart, to = from + cView.length;
            if (from >= range.to || to <= range.from)
                range = dist_EditorSelection.range(from, to);
        }
    }
    let { inputState } = view;
    if (inputState.mouseSelection)
        inputState.mouseSelection.dragging = true;
    inputState.draggedContent = range;
    if (event.dataTransfer) {
        event.dataTransfer.setData("Text", view.state.sliceDoc(range.from, range.to));
        event.dataTransfer.effectAllowed = "copyMove";
    }
    return false;
};
handlers.dragend = view => {
    view.inputState.draggedContent = null;
    return false;
};
function dropText(view, event, text, direct) {
    if (!text)
        return;
    let dropPos = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let { draggedContent } = view.inputState;
    let del = direct && draggedContent && dragMovesSelection(view, event)
        ? { from: draggedContent.from, to: draggedContent.to } : null;
    let ins = { from: dropPos, insert: text };
    let changes = view.state.changes(del ? [del, ins] : ins);
    view.focus();
    view.dispatch({
        changes,
        selection: { anchor: changes.mapPos(dropPos, -1), head: changes.mapPos(dropPos, 1) },
        userEvent: del ? "move.drop" : "input.drop"
    });
    view.inputState.draggedContent = null;
}
handlers.drop = (view, event) => {
    if (!event.dataTransfer)
        return false;
    if (view.state.readOnly)
        return true;
    let files = event.dataTransfer.files;
    if (files && files.length) { // For a file drop, read the file's text.
        let text = Array(files.length), read = 0;
        let finishFile = () => {
            if (++read == files.length)
                dropText(view, event, text.filter(s => s != null).join(view.state.lineBreak), false);
        };
        for (let i = 0; i < files.length; i++) {
            let reader = new FileReader;
            reader.onerror = finishFile;
            reader.onload = () => {
                if (!/[\x00-\x08\x0e-\x1f]{2}/.test(reader.result))
                    text[i] = reader.result;
                finishFile();
            };
            reader.readAsText(files[i]);
        }
        return true;
    }
    else {
        let text = event.dataTransfer.getData("Text");
        if (text) {
            dropText(view, event, text, true);
            return true;
        }
    }
    return false;
};
handlers.paste = (view, event) => {
    if (view.state.readOnly)
        return true;
    view.observer.flush();
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        doPaste(view, data.getData("text/plain") || data.getData("text/uri-text"));
        return true;
    }
    else {
        capturePaste(view);
        return false;
    }
};
function captureCopy(view, text) {
    // The extra wrapper is somehow necessary on IE/Edge to prevent the
    // content from being mangled when it is put onto the clipboard
    let parent = view.dom.parentNode;
    if (!parent)
        return;
    let target = parent.appendChild(document.createElement("textarea"));
    target.style.cssText = "position: fixed; left: -10000px; top: 10px";
    target.value = text;
    target.focus();
    target.selectionEnd = text.length;
    target.selectionStart = 0;
    setTimeout(() => {
        target.remove();
        view.focus();
    }, 50);
}
function copiedRange(state) {
    let content = [], ranges = [], linewise = false;
    for (let range of state.selection.ranges)
        if (!range.empty) {
            content.push(state.sliceDoc(range.from, range.to));
            ranges.push(range);
        }
    if (!content.length) {
        // Nothing selected, do a line-wise copy
        let upto = -1;
        for (let { from } of state.selection.ranges) {
            let line = state.doc.lineAt(from);
            if (line.number > upto) {
                content.push(line.text);
                ranges.push({ from: line.from, to: Math.min(state.doc.length, line.to + 1) });
            }
            upto = line.number;
        }
        linewise = true;
    }
    return { text: content.join(state.lineBreak), ranges, linewise };
}
let lastLinewiseCopy = null;
handlers.copy = handlers.cut = (view, event) => {
    let { text, ranges, linewise } = copiedRange(view.state);
    if (!text && !linewise)
        return false;
    lastLinewiseCopy = linewise ? text : null;
    if (event.type == "cut" && !view.state.readOnly)
        view.dispatch({
            changes: ranges,
            scrollIntoView: true,
            userEvent: "delete.cut"
        });
    let data = brokenClipboardAPI ? null : event.clipboardData;
    if (data) {
        data.clearData();
        data.setData("text/plain", text);
        return true;
    }
    else {
        captureCopy(view, text);
        return false;
    }
};
const isFocusChange = /*@__PURE__*/Annotation.define();
function focusChangeTransaction(state, focus) {
    let effects = [];
    for (let getEffect of state.facet(focusChangeEffect)) {
        let effect = getEffect(state, focus);
        if (effect)
            effects.push(effect);
    }
    return effects ? state.update({ effects, annotations: isFocusChange.of(true) }) : null;
}
function updateForFocusChange(view) {
    setTimeout(() => {
        let focus = view.hasFocus;
        if (focus != view.inputState.notifiedFocused) {
            let tr = focusChangeTransaction(view.state, focus);
            if (tr)
                view.dispatch(tr);
            else
                view.update([]);
        }
    }, 10);
}
observers.focus = view => {
    view.inputState.lastFocusTime = Date.now();
    // When focusing reset the scroll position, move it back to where it was
    if (!view.scrollDOM.scrollTop && (view.inputState.lastScrollTop || view.inputState.lastScrollLeft)) {
        view.scrollDOM.scrollTop = view.inputState.lastScrollTop;
        view.scrollDOM.scrollLeft = view.inputState.lastScrollLeft;
    }
    updateForFocusChange(view);
};
observers.blur = view => {
    view.observer.clearSelectionRange();
    updateForFocusChange(view);
};
observers.compositionstart = observers.compositionupdate = view => {
    if (view.inputState.compositionFirstChange == null)
        view.inputState.compositionFirstChange = true;
    if (view.inputState.composing < 0) {
        // FIXME possibly set a timeout to clear it again on Android
        view.inputState.composing = 0;
    }
};
observers.compositionend = view => {
    view.inputState.composing = -1;
    view.inputState.compositionEndedAt = Date.now();
    view.inputState.compositionPendingKey = true;
    view.inputState.compositionPendingChange = view.observer.pendingRecords().length > 0;
    view.inputState.compositionFirstChange = null;
    if (browser.chrome && browser.android) {
        // Delay flushing for a bit on Android because it'll often fire a
        // bunch of contradictory changes in a row at end of compositon
        view.observer.flushSoon();
    }
    else if (view.inputState.compositionPendingChange) {
        // If we found pending records, schedule a flush.
        Promise.resolve().then(() => view.observer.flush());
    }
    else {
        // Otherwise, make sure that, if no changes come in soon, the
        // composition view is cleared.
        setTimeout(() => {
            if (view.inputState.composing < 0 && view.docView.hasComposition)
                view.update([]);
        }, 50);
    }
};
observers.contextmenu = view => {
    view.inputState.lastContextMenu = Date.now();
};
handlers.beforeinput = (view, event) => {
    var _a;
    // Because Chrome Android doesn't fire useful key events, use
    // beforeinput to detect backspace (and possibly enter and delete,
    // but those usually don't even seem to fire beforeinput events at
    // the moment) and fake a key event for it.
    //
    // (preventDefault on beforeinput, though supported in the spec,
    // seems to do nothing at all on Chrome).
    let pending;
    if (browser.chrome && browser.android && (pending = PendingKeys.find(key => key.inputType == event.inputType))) {
        view.observer.delayAndroidKey(pending.key, pending.keyCode);
        if (pending.key == "Backspace" || pending.key == "Delete") {
            let startViewHeight = ((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0;
            setTimeout(() => {
                var _a;
                // Backspacing near uneditable nodes on Chrome Android sometimes
                // closes the virtual keyboard. This tries to crudely detect
                // that and refocus to get it back.
                if ((((_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.height) || 0) > startViewHeight + 10 && view.hasFocus) {
                    view.contentDOM.blur();
                    view.focus();
                }
            }, 100);
        }
    }
    return false;
};
const appliedFirefoxHack = /*@__PURE__*/new Set;
// In Firefox, when cut/copy handlers are added to the document, that
// somehow avoids a bug where those events aren't fired when the
// selection is empty. See https://github.com/codemirror/dev/issues/1082
// and https://bugzilla.mozilla.org/show_bug.cgi?id=995961
function firefoxCopyCutHack(doc) {
    if (!appliedFirefoxHack.has(doc)) {
        appliedFirefoxHack.add(doc);
        doc.addEventListener("copy", () => { });
        doc.addEventListener("cut", () => { });
    }
}

const wrappingWhiteSpace = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class HeightOracle {
    constructor(lineWrapping) {
        this.lineWrapping = lineWrapping;
        this.doc = Text.empty;
        this.heightSamples = {};
        this.lineHeight = 14; // The height of an entire line (line-height)
        this.charWidth = 7;
        this.textHeight = 14; // The height of the actual font (font-size)
        this.lineLength = 30;
        // Used to track, during updateHeight, if any actual heights changed
        this.heightChanged = false;
    }
    heightForGap(from, to) {
        let lines = this.doc.lineAt(to).number - this.doc.lineAt(from).number + 1;
        if (this.lineWrapping)
            lines += Math.max(0, Math.ceil(((to - from) - (lines * this.lineLength * 0.5)) / this.lineLength));
        return this.lineHeight * lines;
    }
    heightForLine(length) {
        if (!this.lineWrapping)
            return this.lineHeight;
        let lines = 1 + Math.max(0, Math.ceil((length - this.lineLength) / (this.lineLength - 5)));
        return lines * this.lineHeight;
    }
    setDoc(doc) { this.doc = doc; return this; }
    mustRefreshForWrapping(whiteSpace) {
        return (wrappingWhiteSpace.indexOf(whiteSpace) > -1) != this.lineWrapping;
    }
    mustRefreshForHeights(lineHeights) {
        let newHeight = false;
        for (let i = 0; i < lineHeights.length; i++) {
            let h = lineHeights[i];
            if (h < 0) {
                i++;
            }
            else if (!this.heightSamples[Math.floor(h * 10)]) { // Round to .1 pixels
                newHeight = true;
                this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return newHeight;
    }
    refresh(whiteSpace, lineHeight, charWidth, textHeight, lineLength, knownHeights) {
        let lineWrapping = wrappingWhiteSpace.indexOf(whiteSpace) > -1;
        let changed = Math.round(lineHeight) != Math.round(this.lineHeight) || this.lineWrapping != lineWrapping;
        this.lineWrapping = lineWrapping;
        this.lineHeight = lineHeight;
        this.charWidth = charWidth;
        this.textHeight = textHeight;
        this.lineLength = lineLength;
        if (changed) {
            this.heightSamples = {};
            for (let i = 0; i < knownHeights.length; i++) {
                let h = knownHeights[i];
                if (h < 0)
                    i++;
                else
                    this.heightSamples[Math.floor(h * 10)] = true;
            }
        }
        return changed;
    }
}
// This object is used by `updateHeight` to make DOM measurements
// arrive at the right nides. The `heights` array is a sequence of
// block heights, starting from position `from`.
class MeasuredHeights {
    constructor(from, heights) {
        this.from = from;
        this.heights = heights;
        this.index = 0;
    }
    get more() { return this.index < this.heights.length; }
}
/**
Record used to represent information about a block-level element
in the editor view.
*/
class BlockInfo {
    /**
    @internal
    */
    constructor(
    /**
    The start of the element in the document.
    */
    from, 
    /**
    The length of the element.
    */
    length, 
    /**
    The top position of the element (relative to the top of the
    document).
    */
    top, 
    /**
    Its height.
    */
    height, 
    /**
    @internal Weird packed field that holds an array of children
    for composite blocks, a decoration for block widgets, and a
    number indicating the amount of widget-create line breaks for
    text blocks.
    */
    _content) {
        this.from = from;
        this.length = length;
        this.top = top;
        this.height = height;
        this._content = _content;
    }
    /**
    The type of element this is. When querying lines, this may be
    an array of all the blocks that make up the line.
    */
    get type() {
        return typeof this._content == "number" ? BlockType.Text :
            Array.isArray(this._content) ? this._content : this._content.type;
    }
    /**
    The end of the element as a document position.
    */
    get to() { return this.from + this.length; }
    /**
    The bottom position of the element.
    */
    get bottom() { return this.top + this.height; }
    /**
    If this is a widget block, this will return the widget
    associated with it.
    */
    get widget() {
        return this._content instanceof PointDecoration ? this._content.widget : null;
    }
    /**
    If this is a textblock, this holds the number of line breaks
    that appear in widgets inside the block.
    */
    get widgetLineBreaks() {
        return typeof this._content == "number" ? this._content : 0;
    }
    /**
    @internal
    */
    join(other) {
        let content = (Array.isArray(this._content) ? this._content : [this])
            .concat(Array.isArray(other._content) ? other._content : [other]);
        return new BlockInfo(this.from, this.length + other.length, this.top, this.height + other.height, content);
    }
}
var QueryType = /*@__PURE__*/(function (QueryType) {
    QueryType[QueryType["ByPos"] = 0] = "ByPos";
    QueryType[QueryType["ByHeight"] = 1] = "ByHeight";
    QueryType[QueryType["ByPosNoHeight"] = 2] = "ByPosNoHeight";
return QueryType})(QueryType || (QueryType = {}));
const Epsilon = 1e-3;
class HeightMap {
    constructor(length, // The number of characters covered
    height, // Height of this part of the document
    flags = 2 /* Flag.Outdated */) {
        this.length = length;
        this.height = height;
        this.flags = flags;
    }
    get outdated() { return (this.flags & 2 /* Flag.Outdated */) > 0; }
    set outdated(value) { this.flags = (value ? 2 /* Flag.Outdated */ : 0) | (this.flags & ~2 /* Flag.Outdated */); }
    setHeight(oracle, height) {
        if (this.height != height) {
            if (Math.abs(this.height - height) > Epsilon)
                oracle.heightChanged = true;
            this.height = height;
        }
    }
    // Base case is to replace a leaf node, which simply builds a tree
    // from the new nodes and returns that (HeightMapBranch and
    // HeightMapGap override this to actually use from/to)
    replace(_from, _to, nodes) {
        return HeightMap.of(nodes);
    }
    // Again, these are base cases, and are overridden for branch and gap nodes.
    decomposeLeft(_to, result) { result.push(this); }
    decomposeRight(_from, result) { result.push(this); }
    applyChanges(decorations, oldDoc, oracle, changes) {
        let me = this, doc = oracle.doc;
        for (let i = changes.length - 1; i >= 0; i--) {
            let { fromA, toA, fromB, toB } = changes[i];
            let start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle.setDoc(oldDoc), 0, 0);
            let end = start.to >= toA ? start : me.lineAt(toA, QueryType.ByPosNoHeight, oracle, 0, 0);
            toB += end.to - toA;
            toA = end.to;
            while (i > 0 && start.from <= changes[i - 1].toA) {
                fromA = changes[i - 1].fromA;
                fromB = changes[i - 1].fromB;
                i--;
                if (fromA < start.from)
                    start = me.lineAt(fromA, QueryType.ByPosNoHeight, oracle, 0, 0);
            }
            fromB += start.from - fromA;
            fromA = start.from;
            let nodes = NodeBuilder.build(oracle.setDoc(doc), decorations, fromB, toB);
            me = me.replace(fromA, toA, nodes);
        }
        return me.updateHeight(oracle, 0);
    }
    static empty() { return new HeightMapText(0, 0); }
    // nodes uses null values to indicate the position of line breaks.
    // There are never line breaks at the start or end of the array, or
    // two line breaks next to each other, and the array isn't allowed
    // to be empty (same restrictions as return value from the builder).
    static of(nodes) {
        if (nodes.length == 1)
            return nodes[0];
        let i = 0, j = nodes.length, before = 0, after = 0;
        for (;;) {
            if (i == j) {
                if (before > after * 2) {
                    let split = nodes[i - 1];
                    if (split.break)
                        nodes.splice(--i, 1, split.left, null, split.right);
                    else
                        nodes.splice(--i, 1, split.left, split.right);
                    j += 1 + split.break;
                    before -= split.size;
                }
                else if (after > before * 2) {
                    let split = nodes[j];
                    if (split.break)
                        nodes.splice(j, 1, split.left, null, split.right);
                    else
                        nodes.splice(j, 1, split.left, split.right);
                    j += 2 + split.break;
                    after -= split.size;
                }
                else {
                    break;
                }
            }
            else if (before < after) {
                let next = nodes[i++];
                if (next)
                    before += next.size;
            }
            else {
                let next = nodes[--j];
                if (next)
                    after += next.size;
            }
        }
        let brk = 0;
        if (nodes[i - 1] == null) {
            brk = 1;
            i--;
        }
        else if (nodes[i] == null) {
            brk = 1;
            j++;
        }
        return new HeightMapBranch(HeightMap.of(nodes.slice(0, i)), brk, HeightMap.of(nodes.slice(j)));
    }
}
HeightMap.prototype.size = 1;
class HeightMapBlock extends HeightMap {
    constructor(length, height, deco) {
        super(length, height);
        this.deco = deco;
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.deco || 0);
    }
    lineAt(_value, _type, oracle, top, offset) {
        return this.blockAt(0, oracle, top, offset);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        if (from <= offset + this.length && to >= offset)
            f(this.blockAt(0, oracle, top, offset));
    }
    updateHeight(oracle, offset = 0, _force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        this.outdated = false;
        return this;
    }
    toString() { return `block(${this.length})`; }
}
class HeightMapText extends HeightMapBlock {
    constructor(length, height) {
        super(length, height, null);
        this.collapsed = 0; // Amount of collapsed content in the line
        this.widgetHeight = 0; // Maximum inline widget height
        this.breaks = 0; // Number of widget-introduced line breaks on the line
    }
    blockAt(_height, _oracle, top, offset) {
        return new BlockInfo(offset, this.length, top, this.height, this.breaks);
    }
    replace(_from, _to, nodes) {
        let node = nodes[0];
        if (nodes.length == 1 && (node instanceof HeightMapText || node instanceof HeightMapGap && (node.flags & 4 /* Flag.SingleLine */)) &&
            Math.abs(this.length - node.length) < 10) {
            if (node instanceof HeightMapGap)
                node = new HeightMapText(node.length, this.height);
            else
                node.height = this.height;
            if (!this.outdated)
                node.outdated = false;
            return node;
        }
        else {
            return HeightMap.of(nodes);
        }
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        if (measured && measured.from <= offset && measured.more)
            this.setHeight(oracle, measured.heights[measured.index++]);
        else if (force || this.outdated)
            this.setHeight(oracle, Math.max(this.widgetHeight, oracle.heightForLine(this.length - this.collapsed)) +
                this.breaks * oracle.lineHeight);
        this.outdated = false;
        return this;
    }
    toString() {
        return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
    }
}
class HeightMapGap extends HeightMap {
    constructor(length) { super(length, 0); }
    heightMetrics(oracle, offset) {
        let firstLine = oracle.doc.lineAt(offset).number, lastLine = oracle.doc.lineAt(offset + this.length).number;
        let lines = lastLine - firstLine + 1;
        let perLine, perChar = 0;
        if (oracle.lineWrapping) {
            let totalPerLine = Math.min(this.height, oracle.lineHeight * lines);
            perLine = totalPerLine / lines;
            if (this.length > lines + 1)
                perChar = (this.height - totalPerLine) / (this.length - lines - 1);
        }
        else {
            perLine = this.height / lines;
        }
        return { firstLine, lastLine, perLine, perChar };
    }
    blockAt(height, oracle, top, offset) {
        let { firstLine, lastLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        if (oracle.lineWrapping) {
            let guess = offset + Math.round(Math.max(0, Math.min(1, (height - top) / this.height)) * this.length);
            let line = oracle.doc.lineAt(guess), lineHeight = perLine + line.length * perChar;
            let lineTop = Math.max(top, height - lineHeight / 2);
            return new BlockInfo(line.from, line.length, lineTop, lineHeight, 0);
        }
        else {
            let line = Math.max(0, Math.min(lastLine - firstLine, Math.floor((height - top) / perLine)));
            let { from, length } = oracle.doc.line(firstLine + line);
            return new BlockInfo(from, length, top + perLine * line, perLine, 0);
        }
    }
    lineAt(value, type, oracle, top, offset) {
        if (type == QueryType.ByHeight)
            return this.blockAt(value, oracle, top, offset);
        if (type == QueryType.ByPosNoHeight) {
            let { from, to } = oracle.doc.lineAt(value);
            return new BlockInfo(from, to - from, 0, 0, 0);
        }
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        let line = oracle.doc.lineAt(value), lineHeight = perLine + line.length * perChar;
        let linesAbove = line.number - firstLine;
        let lineTop = top + perLine * linesAbove + perChar * (line.from - offset - linesAbove);
        return new BlockInfo(line.from, line.length, Math.max(top, Math.min(lineTop, top + this.height - lineHeight)), lineHeight, 0);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        from = Math.max(from, offset);
        to = Math.min(to, offset + this.length);
        let { firstLine, perLine, perChar } = this.heightMetrics(oracle, offset);
        for (let pos = from, lineTop = top; pos <= to;) {
            let line = oracle.doc.lineAt(pos);
            if (pos == from) {
                let linesAbove = line.number - firstLine;
                lineTop += perLine * linesAbove + perChar * (from - offset - linesAbove);
            }
            let lineHeight = perLine + perChar * line.length;
            f(new BlockInfo(line.from, line.length, lineTop, lineHeight, 0));
            lineTop += lineHeight;
            pos = line.to + 1;
        }
    }
    replace(from, to, nodes) {
        let after = this.length - to;
        if (after > 0) {
            let last = nodes[nodes.length - 1];
            if (last instanceof HeightMapGap)
                nodes[nodes.length - 1] = new HeightMapGap(last.length + after);
            else
                nodes.push(null, new HeightMapGap(after - 1));
        }
        if (from > 0) {
            let first = nodes[0];
            if (first instanceof HeightMapGap)
                nodes[0] = new HeightMapGap(from + first.length);
            else
                nodes.unshift(new HeightMapGap(from - 1), null);
        }
        return HeightMap.of(nodes);
    }
    decomposeLeft(to, result) {
        result.push(new HeightMapGap(to - 1), null);
    }
    decomposeRight(from, result) {
        result.push(null, new HeightMapGap(this.length - from - 1));
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let end = offset + this.length;
        if (measured && measured.from <= offset + this.length && measured.more) {
            // Fill in part of this gap with measured lines. We know there
            // can't be widgets or collapsed ranges in those lines, because
            // they would already have been added to the heightmap (gaps
            // only contain plain text).
            let nodes = [], pos = Math.max(offset, measured.from), singleHeight = -1;
            if (measured.from > offset)
                nodes.push(new HeightMapGap(measured.from - offset - 1).updateHeight(oracle, offset));
            while (pos <= end && measured.more) {
                let len = oracle.doc.lineAt(pos).length;
                if (nodes.length)
                    nodes.push(null);
                let height = measured.heights[measured.index++];
                if (singleHeight == -1)
                    singleHeight = height;
                else if (Math.abs(height - singleHeight) >= Epsilon)
                    singleHeight = -2;
                let line = new HeightMapText(len, height);
                line.outdated = false;
                nodes.push(line);
                pos += len + 1;
            }
            if (pos <= end)
                nodes.push(null, new HeightMapGap(end - pos).updateHeight(oracle, pos));
            let result = HeightMap.of(nodes);
            if (singleHeight < 0 || Math.abs(result.height - this.height) >= Epsilon ||
                Math.abs(singleHeight - this.heightMetrics(oracle, offset).perLine) >= Epsilon)
                oracle.heightChanged = true;
            return result;
        }
        else if (force || this.outdated) {
            this.setHeight(oracle, oracle.heightForGap(offset, offset + this.length));
            this.outdated = false;
        }
        return this;
    }
    toString() { return `gap(${this.length})`; }
}
class HeightMapBranch extends HeightMap {
    constructor(left, brk, right) {
        super(left.length + brk + right.length, left.height + right.height, brk | (left.outdated || right.outdated ? 2 /* Flag.Outdated */ : 0));
        this.left = left;
        this.right = right;
        this.size = left.size + right.size;
    }
    get break() { return this.flags & 1 /* Flag.Break */; }
    blockAt(height, oracle, top, offset) {
        let mid = top + this.left.height;
        return height < mid ? this.left.blockAt(height, oracle, top, offset)
            : this.right.blockAt(height, oracle, mid, offset + this.left.length + this.break);
    }
    lineAt(value, type, oracle, top, offset) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        let left = type == QueryType.ByHeight ? value < rightTop : value < rightOffset;
        let base = left ? this.left.lineAt(value, type, oracle, top, offset)
            : this.right.lineAt(value, type, oracle, rightTop, rightOffset);
        if (this.break || (left ? base.to < rightOffset : base.from > rightOffset))
            return base;
        let subQuery = type == QueryType.ByPosNoHeight ? QueryType.ByPosNoHeight : QueryType.ByPos;
        if (left)
            return base.join(this.right.lineAt(rightOffset, subQuery, oracle, rightTop, rightOffset));
        else
            return this.left.lineAt(rightOffset, subQuery, oracle, top, offset).join(base);
    }
    forEachLine(from, to, oracle, top, offset, f) {
        let rightTop = top + this.left.height, rightOffset = offset + this.left.length + this.break;
        if (this.break) {
            if (from < rightOffset)
                this.left.forEachLine(from, to, oracle, top, offset, f);
            if (to >= rightOffset)
                this.right.forEachLine(from, to, oracle, rightTop, rightOffset, f);
        }
        else {
            let mid = this.lineAt(rightOffset, QueryType.ByPos, oracle, top, offset);
            if (from < mid.from)
                this.left.forEachLine(from, mid.from - 1, oracle, top, offset, f);
            if (mid.to >= from && mid.from <= to)
                f(mid);
            if (to > mid.to)
                this.right.forEachLine(mid.to + 1, to, oracle, rightTop, rightOffset, f);
        }
    }
    replace(from, to, nodes) {
        let rightStart = this.left.length + this.break;
        if (to < rightStart)
            return this.balanced(this.left.replace(from, to, nodes), this.right);
        if (from > this.left.length)
            return this.balanced(this.left, this.right.replace(from - rightStart, to - rightStart, nodes));
        let result = [];
        if (from > 0)
            this.decomposeLeft(from, result);
        let left = result.length;
        for (let node of nodes)
            result.push(node);
        if (from > 0)
            mergeGaps(result, left - 1);
        if (to < this.length) {
            let right = result.length;
            this.decomposeRight(to, result);
            mergeGaps(result, right);
        }
        return HeightMap.of(result);
    }
    decomposeLeft(to, result) {
        let left = this.left.length;
        if (to <= left)
            return this.left.decomposeLeft(to, result);
        result.push(this.left);
        if (this.break) {
            left++;
            if (to >= left)
                result.push(null);
        }
        if (to > left)
            this.right.decomposeLeft(to - left, result);
    }
    decomposeRight(from, result) {
        let left = this.left.length, right = left + this.break;
        if (from >= right)
            return this.right.decomposeRight(from - right, result);
        if (from < left)
            this.left.decomposeRight(from, result);
        if (this.break && from < right)
            result.push(null);
        result.push(this.right);
    }
    balanced(left, right) {
        if (left.size > 2 * right.size || right.size > 2 * left.size)
            return HeightMap.of(this.break ? [left, null, right] : [left, right]);
        this.left = left;
        this.right = right;
        this.height = left.height + right.height;
        this.outdated = left.outdated || right.outdated;
        this.size = left.size + right.size;
        this.length = left.length + this.break + right.length;
        return this;
    }
    updateHeight(oracle, offset = 0, force = false, measured) {
        let { left, right } = this, rightStart = offset + left.length + this.break, rebalance = null;
        if (measured && measured.from <= offset + left.length && measured.more)
            rebalance = left = left.updateHeight(oracle, offset, force, measured);
        else
            left.updateHeight(oracle, offset, force);
        if (measured && measured.from <= rightStart + right.length && measured.more)
            rebalance = right = right.updateHeight(oracle, rightStart, force, measured);
        else
            right.updateHeight(oracle, rightStart, force);
        if (rebalance)
            return this.balanced(left, right);
        this.height = this.left.height + this.right.height;
        this.outdated = false;
        return this;
    }
    toString() { return this.left + (this.break ? " " : "-") + this.right; }
}
function mergeGaps(nodes, around) {
    let before, after;
    if (nodes[around] == null &&
        (before = nodes[around - 1]) instanceof HeightMapGap &&
        (after = nodes[around + 1]) instanceof HeightMapGap)
        nodes.splice(around - 1, 3, new HeightMapGap(before.length + 1 + after.length));
}
const relevantWidgetHeight = 5;
class NodeBuilder {
    constructor(pos, oracle) {
        this.pos = pos;
        this.oracle = oracle;
        this.nodes = [];
        this.lineStart = -1;
        this.lineEnd = -1;
        this.covering = null;
        this.writtenTo = pos;
    }
    get isCovered() {
        return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
    }
    span(_from, to) {
        if (this.lineStart > -1) {
            let end = Math.min(to, this.lineEnd), last = this.nodes[this.nodes.length - 1];
            if (last instanceof HeightMapText)
                last.length += end - this.pos;
            else if (end > this.pos || !this.isCovered)
                this.nodes.push(new HeightMapText(end - this.pos, -1));
            this.writtenTo = end;
            if (to > end) {
                this.nodes.push(null);
                this.writtenTo++;
                this.lineStart = -1;
            }
        }
        this.pos = to;
    }
    point(from, to, deco) {
        if (from < to || deco.heightRelevant) {
            let height = deco.widget ? deco.widget.estimatedHeight : 0;
            let breaks = deco.widget ? deco.widget.lineBreaks : 0;
            if (height < 0)
                height = this.oracle.lineHeight;
            let len = to - from;
            if (deco.block) {
                this.addBlock(new HeightMapBlock(len, height, deco));
            }
            else if (len || breaks || height >= relevantWidgetHeight) {
                this.addLineDeco(height, breaks, len);
            }
        }
        else if (to > from) {
            this.span(from, to);
        }
        if (this.lineEnd > -1 && this.lineEnd < this.pos)
            this.lineEnd = this.oracle.doc.lineAt(this.pos).to;
    }
    enterLine() {
        if (this.lineStart > -1)
            return;
        let { from, to } = this.oracle.doc.lineAt(this.pos);
        this.lineStart = from;
        this.lineEnd = to;
        if (this.writtenTo < from) {
            if (this.writtenTo < from - 1 || this.nodes[this.nodes.length - 1] == null)
                this.nodes.push(this.blankContent(this.writtenTo, from - 1));
            this.nodes.push(null);
        }
        if (this.pos > from)
            this.nodes.push(new HeightMapText(this.pos - from, -1));
        this.writtenTo = this.pos;
    }
    blankContent(from, to) {
        let gap = new HeightMapGap(to - from);
        if (this.oracle.doc.lineAt(from).to == to)
            gap.flags |= 4 /* Flag.SingleLine */;
        return gap;
    }
    ensureLine() {
        this.enterLine();
        let last = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
        if (last instanceof HeightMapText)
            return last;
        let line = new HeightMapText(0, -1);
        this.nodes.push(line);
        return line;
    }
    addBlock(block) {
        this.enterLine();
        let deco = block.deco;
        if (deco && deco.startSide > 0 && !this.isCovered)
            this.ensureLine();
        this.nodes.push(block);
        this.writtenTo = this.pos = this.pos + block.length;
        if (deco && deco.endSide > 0)
            this.covering = block;
    }
    addLineDeco(height, breaks, length) {
        let line = this.ensureLine();
        line.length += length;
        line.collapsed += length;
        line.widgetHeight = Math.max(line.widgetHeight, height);
        line.breaks += breaks;
        this.writtenTo = this.pos = this.pos + length;
    }
    finish(from) {
        let last = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
        if (this.lineStart > -1 && !(last instanceof HeightMapText) && !this.isCovered)
            this.nodes.push(new HeightMapText(0, -1));
        else if (this.writtenTo < this.pos || last == null)
            this.nodes.push(this.blankContent(this.writtenTo, this.pos));
        let pos = from;
        for (let node of this.nodes) {
            if (node instanceof HeightMapText)
                node.updateHeight(this.oracle, pos);
            pos += node ? node.length : 1;
        }
        return this.nodes;
    }
    // Always called with a region that on both sides either stretches
    // to a line break or the end of the document.
    // The returned array uses null to indicate line breaks, but never
    // starts or ends in a line break, or has multiple line breaks next
    // to each other.
    static build(oracle, decorations, from, to) {
        let builder = new NodeBuilder(from, oracle);
        dist_RangeSet.spans(decorations, from, to, builder, 0);
        return builder.finish(from);
    }
}
function heightRelevantDecoChanges(a, b, diff) {
    let comp = new DecorationComparator;
    dist_RangeSet.compare(a, b, diff, comp, 0);
    return comp.changes;
}
class DecorationComparator {
    constructor() {
        this.changes = [];
    }
    compareRange() { }
    comparePoint(from, to, a, b) {
        if (from < to || a && a.heightRelevant || b && b.heightRelevant)
            addRange(from, to, this.changes, 5);
    }
}

function visiblePixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    let doc = dom.ownerDocument, win = doc.defaultView || window;
    let left = Math.max(0, rect.left), right = Math.min(win.innerWidth, rect.right);
    let top = Math.max(0, rect.top), bottom = Math.min(win.innerHeight, rect.bottom);
    for (let parent = dom.parentNode; parent && parent != doc.body;) {
        if (parent.nodeType == 1) {
            let elt = parent;
            let style = window.getComputedStyle(elt);
            if ((elt.scrollHeight > elt.clientHeight || elt.scrollWidth > elt.clientWidth) &&
                style.overflow != "visible") {
                let parentRect = elt.getBoundingClientRect();
                left = Math.max(left, parentRect.left);
                right = Math.min(right, parentRect.right);
                top = Math.max(top, parentRect.top);
                bottom = parent == dom.parentNode ? parentRect.bottom : Math.min(bottom, parentRect.bottom);
            }
            parent = style.position == "absolute" || style.position == "fixed" ? elt.offsetParent : elt.parentNode;
        }
        else if (parent.nodeType == 11) { // Shadow root
            parent = parent.host;
        }
        else {
            break;
        }
    }
    return { left: left - rect.left, right: Math.max(left, right) - rect.left,
        top: top - (rect.top + paddingTop), bottom: Math.max(top, bottom) - (rect.top + paddingTop) };
}
function fullPixelRange(dom, paddingTop) {
    let rect = dom.getBoundingClientRect();
    return { left: 0, right: rect.right - rect.left,
        top: paddingTop, bottom: rect.bottom - (rect.top + paddingTop) };
}
// Line gaps are placeholder widgets used to hide pieces of overlong
// lines within the viewport, as a kludge to keep the editor
// responsive when a ridiculously long line is loaded into it.
class LineGap {
    constructor(from, to, size) {
        this.from = from;
        this.to = to;
        this.size = size;
    }
    static same(a, b) {
        if (a.length != b.length)
            return false;
        for (let i = 0; i < a.length; i++) {
            let gA = a[i], gB = b[i];
            if (gA.from != gB.from || gA.to != gB.to || gA.size != gB.size)
                return false;
        }
        return true;
    }
    draw(viewState, wrapping) {
        return Decoration.replace({
            widget: new LineGapWidget(this.size * (wrapping ? viewState.scaleY : viewState.scaleX), wrapping)
        }).range(this.from, this.to);
    }
}
class LineGapWidget extends WidgetType {
    constructor(size, vertical) {
        super();
        this.size = size;
        this.vertical = vertical;
    }
    eq(other) { return other.size == this.size && other.vertical == this.vertical; }
    toDOM() {
        let elt = document.createElement("div");
        if (this.vertical) {
            elt.style.height = this.size + "px";
        }
        else {
            elt.style.width = this.size + "px";
            elt.style.height = "2px";
            elt.style.display = "inline-block";
        }
        return elt;
    }
    get estimatedHeight() { return this.vertical ? this.size : -1; }
}
class ViewState {
    constructor(state) {
        this.state = state;
        // These are contentDOM-local coordinates
        this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 };
        this.inView = true;
        this.paddingTop = 0; // Padding above the document, scaled
        this.paddingBottom = 0; // Padding below the document, scaled
        this.contentDOMWidth = 0; // contentDOM.getBoundingClientRect().width
        this.contentDOMHeight = 0; // contentDOM.getBoundingClientRect().height
        this.editorHeight = 0; // scrollDOM.clientHeight, unscaled
        this.editorWidth = 0; // scrollDOM.clientWidth, unscaled
        this.scrollTop = 0; // Last seen scrollDOM.scrollTop, scaled
        this.scrolledToBottom = true;
        // The CSS-transformation scale of the editor (transformed size /
        // concrete size)
        this.scaleX = 1;
        this.scaleY = 1;
        // The vertical position (document-relative) to which to anchor the
        // scroll position. -1 means anchor to the end of the document.
        this.scrollAnchorPos = 0;
        // The height at the anchor position. Set by the DOM update phase.
        // -1 means no height available.
        this.scrollAnchorHeight = -1;
        // See VP.MaxDOMHeight
        this.scaler = IdScaler;
        this.scrollTarget = null;
        // Briefly set to true when printing, to disable viewport limiting
        this.printing = false;
        // Flag set when editor content was redrawn, so that the next
        // measure stage knows it must read DOM layout
        this.mustMeasureContent = true;
        this.defaultTextDirection = Direction.LTR;
        this.visibleRanges = [];
        // Cursor 'assoc' is only significant when the cursor is on a line
        // wrap point, where it must stick to the character that it is
        // associated with. Since browsers don't provide a reasonable
        // interface to set or query this, when a selection is set that
        // might cause this to be significant, this flag is set. The next
        // measure phase will check whether the cursor is on a line-wrapping
        // boundary and, if so, reset it to make sure it is positioned in
        // the right place.
        this.mustEnforceCursorAssoc = false;
        let guessWrapping = state.facet(contentAttributes).some(v => typeof v != "function" && v.class == "cm-lineWrapping");
        this.heightOracle = new HeightOracle(guessWrapping);
        this.stateDeco = state.facet(decorations).filter(d => typeof d != "function");
        this.heightMap = HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle.setDoc(state.doc), [new ChangedRange(0, 0, 0, state.doc.length)]);
        this.viewport = this.getViewport(0, null);
        this.updateViewportLines();
        this.updateForViewport();
        this.lineGaps = this.ensureLineGaps([]);
        this.lineGapDeco = Decoration.set(this.lineGaps.map(gap => gap.draw(this, false)));
        this.computeVisibleRanges();
    }
    updateForViewport() {
        let viewports = [this.viewport], { main } = this.state.selection;
        for (let i = 0; i <= 1; i++) {
            let pos = i ? main.head : main.anchor;
            if (!viewports.some(({ from, to }) => pos >= from && pos <= to)) {
                let { from, to } = this.lineBlockAt(pos);
                viewports.push(new Viewport(from, to));
            }
        }
        this.viewports = viewports.sort((a, b) => a.from - b.from);
        this.scaler = this.heightMap.height <= 7000000 /* VP.MaxDOMHeight */ ? IdScaler :
            new BigScaler(this.heightOracle, this.heightMap, this.viewports);
    }
    updateViewportLines() {
        this.viewportLines = [];
        this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, block => {
            this.viewportLines.push(this.scaler.scale == 1 ? block : scaleBlock(block, this.scaler));
        });
    }
    update(update, scrollTarget = null) {
        this.state = update.state;
        let prevDeco = this.stateDeco;
        this.stateDeco = this.state.facet(decorations).filter(d => typeof d != "function");
        let contentChanges = update.changedRanges;
        let heightChanges = ChangedRange.extendWithRanges(contentChanges, heightRelevantDecoChanges(prevDeco, this.stateDeco, update ? update.changes : ChangeSet.empty(this.state.doc.length)));
        let prevHeight = this.heightMap.height;
        let scrollAnchor = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
        this.heightMap = this.heightMap.applyChanges(this.stateDeco, update.startState.doc, this.heightOracle.setDoc(this.state.doc), heightChanges);
        if (this.heightMap.height != prevHeight)
            update.flags |= 2 /* UpdateFlag.Height */;
        if (scrollAnchor) {
            this.scrollAnchorPos = update.changes.mapPos(scrollAnchor.from, -1);
            this.scrollAnchorHeight = scrollAnchor.top;
        }
        else {
            this.scrollAnchorPos = -1;
            this.scrollAnchorHeight = this.heightMap.height;
        }
        let viewport = heightChanges.length ? this.mapViewport(this.viewport, update.changes) : this.viewport;
        if (scrollTarget && (scrollTarget.range.head < viewport.from || scrollTarget.range.head > viewport.to) ||
            !this.viewportIsAppropriate(viewport))
            viewport = this.getViewport(0, scrollTarget);
        let updateLines = !update.changes.empty || (update.flags & 2 /* UpdateFlag.Height */) ||
            viewport.from != this.viewport.from || viewport.to != this.viewport.to;
        this.viewport = viewport;
        this.updateForViewport();
        if (updateLines)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, update.changes)));
        update.flags |= this.computeVisibleRanges();
        if (scrollTarget)
            this.scrollTarget = scrollTarget;
        if (!this.mustEnforceCursorAssoc && update.selectionSet && update.view.lineWrapping &&
            update.state.selection.main.empty && update.state.selection.main.assoc &&
            !update.state.facet(nativeSelectionHidden))
            this.mustEnforceCursorAssoc = true;
    }
    measure(view) {
        let dom = view.contentDOM, style = window.getComputedStyle(dom);
        let oracle = this.heightOracle;
        let whiteSpace = style.whiteSpace;
        this.defaultTextDirection = style.direction == "rtl" ? Direction.RTL : Direction.LTR;
        let refresh = this.heightOracle.mustRefreshForWrapping(whiteSpace);
        let domRect = dom.getBoundingClientRect();
        let measureContent = refresh || this.mustMeasureContent || this.contentDOMHeight != domRect.height;
        this.contentDOMHeight = domRect.height;
        this.mustMeasureContent = false;
        let result = 0, bias = 0;
        if (domRect.width && domRect.height) {
            let { scaleX, scaleY } = getScale(dom, domRect);
            if (this.scaleX != scaleX || this.scaleY != scaleY) {
                this.scaleX = scaleX;
                this.scaleY = scaleY;
                result |= 8 /* UpdateFlag.Geometry */;
                refresh = measureContent = true;
            }
        }
        // Vertical padding
        let paddingTop = (parseInt(style.paddingTop) || 0) * this.scaleY;
        let paddingBottom = (parseInt(style.paddingBottom) || 0) * this.scaleY;
        if (this.paddingTop != paddingTop || this.paddingBottom != paddingBottom) {
            this.paddingTop = paddingTop;
            this.paddingBottom = paddingBottom;
            result |= 8 /* UpdateFlag.Geometry */ | 2 /* UpdateFlag.Height */;
        }
        if (this.editorWidth != view.scrollDOM.clientWidth) {
            if (oracle.lineWrapping)
                measureContent = true;
            this.editorWidth = view.scrollDOM.clientWidth;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        let scrollTop = view.scrollDOM.scrollTop * this.scaleY;
        if (this.scrollTop != scrollTop) {
            this.scrollAnchorHeight = -1;
            this.scrollTop = scrollTop;
        }
        this.scrolledToBottom = isScrolledToBottom(view.scrollDOM);
        // Pixel viewport
        let pixelViewport = (this.printing ? fullPixelRange : visiblePixelRange)(dom, this.paddingTop);
        let dTop = pixelViewport.top - this.pixelViewport.top, dBottom = pixelViewport.bottom - this.pixelViewport.bottom;
        this.pixelViewport = pixelViewport;
        let inView = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
        if (inView != this.inView) {
            this.inView = inView;
            if (inView)
                measureContent = true;
        }
        if (!this.inView && !this.scrollTarget)
            return 0;
        let contentWidth = domRect.width;
        if (this.contentDOMWidth != contentWidth || this.editorHeight != view.scrollDOM.clientHeight) {
            this.contentDOMWidth = domRect.width;
            this.editorHeight = view.scrollDOM.clientHeight;
            result |= 8 /* UpdateFlag.Geometry */;
        }
        if (measureContent) {
            let lineHeights = view.docView.measureVisibleLineHeights(this.viewport);
            if (oracle.mustRefreshForHeights(lineHeights))
                refresh = true;
            if (refresh || oracle.lineWrapping && Math.abs(contentWidth - this.contentDOMWidth) > oracle.charWidth) {
                let { lineHeight, charWidth, textHeight } = view.docView.measureTextSize();
                refresh = lineHeight > 0 && oracle.refresh(whiteSpace, lineHeight, charWidth, textHeight, contentWidth / charWidth, lineHeights);
                if (refresh) {
                    view.docView.minWidth = 0;
                    result |= 8 /* UpdateFlag.Geometry */;
                }
            }
            if (dTop > 0 && dBottom > 0)
                bias = Math.max(dTop, dBottom);
            else if (dTop < 0 && dBottom < 0)
                bias = Math.min(dTop, dBottom);
            oracle.heightChanged = false;
            for (let vp of this.viewports) {
                let heights = vp.from == this.viewport.from ? lineHeights : view.docView.measureVisibleLineHeights(vp);
                this.heightMap = (refresh ? HeightMap.empty().applyChanges(this.stateDeco, Text.empty, this.heightOracle, [new ChangedRange(0, 0, 0, view.state.doc.length)]) : this.heightMap).updateHeight(oracle, 0, refresh, new MeasuredHeights(vp.from, heights));
            }
            if (oracle.heightChanged)
                result |= 2 /* UpdateFlag.Height */;
        }
        let viewportChange = !this.viewportIsAppropriate(this.viewport, bias) ||
            this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from ||
                this.scrollTarget.range.head > this.viewport.to);
        if (viewportChange)
            this.viewport = this.getViewport(bias, this.scrollTarget);
        this.updateForViewport();
        if ((result & 2 /* UpdateFlag.Height */) || viewportChange)
            this.updateViewportLines();
        if (this.lineGaps.length || this.viewport.to - this.viewport.from > (2000 /* LG.Margin */ << 1))
            this.updateLineGaps(this.ensureLineGaps(refresh ? [] : this.lineGaps, view));
        result |= this.computeVisibleRanges();
        if (this.mustEnforceCursorAssoc) {
            this.mustEnforceCursorAssoc = false;
            // This is done in the read stage, because moving the selection
            // to a line end is going to trigger a layout anyway, so it
            // can't be a pure write. It should be rare that it does any
            // writing.
            view.docView.enforceCursorAssoc();
        }
        return result;
    }
    get visibleTop() { return this.scaler.fromDOM(this.pixelViewport.top); }
    get visibleBottom() { return this.scaler.fromDOM(this.pixelViewport.bottom); }
    getViewport(bias, scrollTarget) {
        // This will divide VP.Margin between the top and the
        // bottom, depending on the bias (the change in viewport position
        // since the last update). It'll hold a number between 0 and 1
        let marginTop = 0.5 - Math.max(-0.5, Math.min(0.5, bias / 1000 /* VP.Margin */ / 2));
        let map = this.heightMap, oracle = this.heightOracle;
        let { visibleTop, visibleBottom } = this;
        let viewport = new Viewport(map.lineAt(visibleTop - marginTop * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(visibleBottom + (1 - marginTop) * 1000 /* VP.Margin */, QueryType.ByHeight, oracle, 0, 0).to);
        // If scrollTarget is given, make sure the viewport includes that position
        if (scrollTarget) {
            let { head } = scrollTarget.range;
            if (head < viewport.from || head > viewport.to) {
                let viewHeight = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top);
                let block = map.lineAt(head, QueryType.ByPos, oracle, 0, 0), topPos;
                if (scrollTarget.y == "center")
                    topPos = (block.top + block.bottom) / 2 - viewHeight / 2;
                else if (scrollTarget.y == "start" || scrollTarget.y == "nearest" && head < viewport.from)
                    topPos = block.top;
                else
                    topPos = block.bottom - viewHeight;
                viewport = new Viewport(map.lineAt(topPos - 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).from, map.lineAt(topPos + viewHeight + 1000 /* VP.Margin */ / 2, QueryType.ByHeight, oracle, 0, 0).to);
            }
        }
        return viewport;
    }
    mapViewport(viewport, changes) {
        let from = changes.mapPos(viewport.from, -1), to = changes.mapPos(viewport.to, 1);
        return new Viewport(this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0).to);
    }
    // Checks if a given viewport covers the visible part of the
    // document and not too much beyond that.
    viewportIsAppropriate({ from, to }, bias = 0) {
        if (!this.inView)
            return true;
        let { top } = this.heightMap.lineAt(from, QueryType.ByPos, this.heightOracle, 0, 0);
        let { bottom } = this.heightMap.lineAt(to, QueryType.ByPos, this.heightOracle, 0, 0);
        let { visibleTop, visibleBottom } = this;
        return (from == 0 || top <= visibleTop - Math.max(10 /* VP.MinCoverMargin */, Math.min(-bias, 250 /* VP.MaxCoverMargin */))) &&
            (to == this.state.doc.length ||
                bottom >= visibleBottom + Math.max(10 /* VP.MinCoverMargin */, Math.min(bias, 250 /* VP.MaxCoverMargin */))) &&
            (top > visibleTop - 2 * 1000 /* VP.Margin */ && bottom < visibleBottom + 2 * 1000 /* VP.Margin */);
    }
    mapLineGaps(gaps, changes) {
        if (!gaps.length || changes.empty)
            return gaps;
        let mapped = [];
        for (let gap of gaps)
            if (!changes.touchesRange(gap.from, gap.to))
                mapped.push(new LineGap(changes.mapPos(gap.from), changes.mapPos(gap.to), gap.size));
        return mapped;
    }
    // Computes positions in the viewport where the start or end of a
    // line should be hidden, trying to reuse existing line gaps when
    // appropriate to avoid unneccesary redraws.
    // Uses crude character-counting for the positioning and sizing,
    // since actual DOM coordinates aren't always available and
    // predictable. Relies on generous margins (see LG.Margin) to hide
    // the artifacts this might produce from the user.
    ensureLineGaps(current, mayMeasure) {
        let wrapping = this.heightOracle.lineWrapping;
        let margin = wrapping ? 10000 /* LG.MarginWrap */ : 2000 /* LG.Margin */, halfMargin = margin >> 1, doubleMargin = margin << 1;
        // The non-wrapping logic won't work at all in predominantly right-to-left text.
        if (this.defaultTextDirection != Direction.LTR && !wrapping)
            return [];
        let gaps = [];
        let addGap = (from, to, line, structure) => {
            if (to - from < halfMargin)
                return;
            let sel = this.state.selection.main, avoid = [sel.from];
            if (!sel.empty)
                avoid.push(sel.to);
            for (let pos of avoid) {
                if (pos > from && pos < to) {
                    addGap(from, pos - 10 /* LG.SelectionMargin */, line, structure);
                    addGap(pos + 10 /* LG.SelectionMargin */, to, line, structure);
                    return;
                }
            }
            let gap = find(current, gap => gap.from >= line.from && gap.to <= line.to &&
                Math.abs(gap.from - from) < halfMargin && Math.abs(gap.to - to) < halfMargin &&
                !avoid.some(pos => gap.from < pos && gap.to > pos));
            if (!gap) {
                // When scrolling down, snap gap ends to line starts to avoid shifts in wrapping
                if (to < line.to && mayMeasure && wrapping &&
                    mayMeasure.visibleRanges.some(r => r.from <= to && r.to >= to)) {
                    let lineStart = mayMeasure.moveToLineBoundary(dist_EditorSelection.cursor(to), false, true).head;
                    if (lineStart > from)
                        to = lineStart;
                }
                gap = new LineGap(from, to, this.gapSize(line, from, to, structure));
            }
            gaps.push(gap);
        };
        for (let line of this.viewportLines) {
            if (line.length < doubleMargin)
                continue;
            let structure = lineStructure(line.from, line.to, this.stateDeco);
            if (structure.total < doubleMargin)
                continue;
            let target = this.scrollTarget ? this.scrollTarget.range.head : null;
            let viewFrom, viewTo;
            if (wrapping) {
                let marginHeight = (margin / this.heightOracle.lineLength) * this.heightOracle.lineHeight;
                let top, bot;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.visibleBottom - this.visibleTop) / 2 + marginHeight) / line.height;
                    top = targetFrac - spaceFrac;
                    bot = targetFrac + spaceFrac;
                }
                else {
                    top = (this.visibleTop - line.top - marginHeight) / line.height;
                    bot = (this.visibleBottom - line.top + marginHeight) / line.height;
                }
                viewFrom = findPosition(structure, top);
                viewTo = findPosition(structure, bot);
            }
            else {
                let totalWidth = structure.total * this.heightOracle.charWidth;
                let marginWidth = margin * this.heightOracle.charWidth;
                let left, right;
                if (target != null) {
                    let targetFrac = findFraction(structure, target);
                    let spaceFrac = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + marginWidth) / totalWidth;
                    left = targetFrac - spaceFrac;
                    right = targetFrac + spaceFrac;
                }
                else {
                    left = (this.pixelViewport.left - marginWidth) / totalWidth;
                    right = (this.pixelViewport.right + marginWidth) / totalWidth;
                }
                viewFrom = findPosition(structure, left);
                viewTo = findPosition(structure, right);
            }
            if (viewFrom > line.from)
                addGap(line.from, viewFrom, line, structure);
            if (viewTo < line.to)
                addGap(viewTo, line.to, line, structure);
        }
        return gaps;
    }
    gapSize(line, from, to, structure) {
        let fraction = findFraction(structure, to) - findFraction(structure, from);
        if (this.heightOracle.lineWrapping) {
            return line.height * fraction;
        }
        else {
            return structure.total * this.heightOracle.charWidth * fraction;
        }
    }
    updateLineGaps(gaps) {
        if (!LineGap.same(gaps, this.lineGaps)) {
            this.lineGaps = gaps;
            this.lineGapDeco = Decoration.set(gaps.map(gap => gap.draw(this, this.heightOracle.lineWrapping)));
        }
    }
    computeVisibleRanges() {
        let deco = this.stateDeco;
        if (this.lineGaps.length)
            deco = deco.concat(this.lineGapDeco);
        let ranges = [];
        dist_RangeSet.spans(deco, this.viewport.from, this.viewport.to, {
            span(from, to) { ranges.push({ from, to }); },
            point() { }
        }, 20);
        let changed = ranges.length != this.visibleRanges.length ||
            this.visibleRanges.some((r, i) => r.from != ranges[i].from || r.to != ranges[i].to);
        this.visibleRanges = ranges;
        return changed ? 4 /* UpdateFlag.Viewport */ : 0;
    }
    lineBlockAt(pos) {
        return (pos >= this.viewport.from && pos <= this.viewport.to && this.viewportLines.find(b => b.from <= pos && b.to >= pos)) ||
            scaleBlock(this.heightMap.lineAt(pos, QueryType.ByPos, this.heightOracle, 0, 0), this.scaler);
    }
    lineBlockAtHeight(height) {
        return scaleBlock(this.heightMap.lineAt(this.scaler.fromDOM(height), QueryType.ByHeight, this.heightOracle, 0, 0), this.scaler);
    }
    scrollAnchorAt(scrollTop) {
        let block = this.lineBlockAtHeight(scrollTop + 8);
        return block.from >= this.viewport.from || this.viewportLines[0].top - scrollTop > 200 ? block : this.viewportLines[0];
    }
    elementAtHeight(height) {
        return scaleBlock(this.heightMap.blockAt(this.scaler.fromDOM(height), this.heightOracle, 0, 0), this.scaler);
    }
    get docHeight() {
        return this.scaler.toDOM(this.heightMap.height);
    }
    get contentHeight() {
        return this.docHeight + this.paddingTop + this.paddingBottom;
    }
}
class Viewport {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
function lineStructure(from, to, stateDeco) {
    let ranges = [], pos = from, total = 0;
    dist_RangeSet.spans(stateDeco, from, to, {
        span() { },
        point(from, to) {
            if (from > pos) {
                ranges.push({ from: pos, to: from });
                total += from - pos;
            }
            pos = to;
        }
    }, 20); // We're only interested in collapsed ranges of a significant size
    if (pos < to) {
        ranges.push({ from: pos, to });
        total += to - pos;
    }
    return { total, ranges };
}
function findPosition({ total, ranges }, ratio) {
    if (ratio <= 0)
        return ranges[0].from;
    if (ratio >= 1)
        return ranges[ranges.length - 1].to;
    let dist = Math.floor(total * ratio);
    for (let i = 0;; i++) {
        let { from, to } = ranges[i], size = to - from;
        if (dist <= size)
            return from + dist;
        dist -= size;
    }
}
function findFraction(structure, pos) {
    let counted = 0;
    for (let { from, to } of structure.ranges) {
        if (pos <= to) {
            counted += pos - from;
            break;
        }
        counted += to - from;
    }
    return counted / structure.total;
}
function find(array, f) {
    for (let val of array)
        if (f(val))
            return val;
    return undefined;
}
// Don't scale when the document height is within the range of what
// the DOM can handle.
const IdScaler = {
    toDOM(n) { return n; },
    fromDOM(n) { return n; },
    scale: 1
};
// When the height is too big (> VP.MaxDOMHeight), scale down the
// regions outside the viewports so that the total height is
// VP.MaxDOMHeight.
class BigScaler {
    constructor(oracle, heightMap, viewports) {
        let vpHeight = 0, base = 0, domBase = 0;
        this.viewports = viewports.map(({ from, to }) => {
            let top = heightMap.lineAt(from, QueryType.ByPos, oracle, 0, 0).top;
            let bottom = heightMap.lineAt(to, QueryType.ByPos, oracle, 0, 0).bottom;
            vpHeight += bottom - top;
            return { from, to, top, bottom, domTop: 0, domBottom: 0 };
        });
        this.scale = (7000000 /* VP.MaxDOMHeight */ - vpHeight) / (heightMap.height - vpHeight);
        for (let obj of this.viewports) {
            obj.domTop = domBase + (obj.top - base) * this.scale;
            domBase = obj.domBottom = obj.domTop + (obj.bottom - obj.top);
            base = obj.bottom;
        }
    }
    toDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.top)
                return domBase + (n - base) * this.scale;
            if (n <= vp.bottom)
                return vp.domTop + (n - vp.top);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
    fromDOM(n) {
        for (let i = 0, base = 0, domBase = 0;; i++) {
            let vp = i < this.viewports.length ? this.viewports[i] : null;
            if (!vp || n < vp.domTop)
                return base + (n - domBase) / this.scale;
            if (n <= vp.domBottom)
                return vp.top + (n - vp.domTop);
            base = vp.bottom;
            domBase = vp.domBottom;
        }
    }
}
function scaleBlock(block, scaler) {
    if (scaler.scale == 1)
        return block;
    let bTop = scaler.toDOM(block.top), bBottom = scaler.toDOM(block.bottom);
    return new BlockInfo(block.from, block.length, bTop, bBottom - bTop, Array.isArray(block._content) ? block._content.map(b => scaleBlock(b, scaler)) : block._content);
}

const theme = /*@__PURE__*/Facet.define({ combine: strs => strs.join(" ") });
const darkTheme = /*@__PURE__*/Facet.define({ combine: values => values.indexOf(true) > -1 });
const baseThemeID = /*@__PURE__*/StyleModule.newName(), baseLightID = /*@__PURE__*/StyleModule.newName(), baseDarkID = /*@__PURE__*/StyleModule.newName();
const lightDarkIDs = { "&light": "." + baseLightID, "&dark": "." + baseDarkID };
function buildTheme(main, spec, scopes) {
    return new StyleModule(spec, {
        finish(sel) {
            return /&/.test(sel) ? sel.replace(/&\w*/, m => {
                if (m == "&")
                    return main;
                if (!scopes || !scopes[m])
                    throw new RangeError(`Unsupported selector: ${m}`);
                return scopes[m];
            }) : main + " " + sel;
        }
    });
}
const baseTheme$1 = /*@__PURE__*/buildTheme("." + baseThemeID, {
    "&": {
        position: "relative !important",
        boxSizing: "border-box",
        "&.cm-focused": {
            // Provide a simple default outline to make sure a focused
            // editor is visually distinct. Can't leave the default behavior
            // because that will apply to the content element, which is
            // inside the scrollable container and doesn't include the
            // gutters. We also can't use an 'auto' outline, since those
            // are, for some reason, drawn behind the element content, which
            // will cause things like the active line background to cover
            // the outline (#297).
            outline: "1px dotted #212121"
        },
        display: "flex !important",
        flexDirection: "column"
    },
    ".cm-scroller": {
        display: "flex !important",
        alignItems: "flex-start !important",
        fontFamily: "monospace",
        lineHeight: 1.4,
        height: "100%",
        overflowX: "auto",
        position: "relative",
        zIndex: 0
    },
    ".cm-content": {
        margin: 0,
        flexGrow: 2,
        flexShrink: 0,
        display: "block",
        whiteSpace: "pre",
        wordWrap: "normal", // https://github.com/codemirror/dev/issues/456
        boxSizing: "border-box",
        minHeight: "100%",
        padding: "4px 0",
        outline: "none",
        "&[contenteditable=true]": {
            WebkitUserModify: "read-write-plaintext-only",
        }
    },
    ".cm-lineWrapping": {
        whiteSpace_fallback: "pre-wrap", // For IE
        whiteSpace: "break-spaces",
        wordBreak: "break-word", // For Safari, which doesn't support overflow-wrap: anywhere
        overflowWrap: "anywhere",
        flexShrink: 1
    },
    "&light .cm-content": { caretColor: "black" },
    "&dark .cm-content": { caretColor: "white" },
    ".cm-line": {
        display: "block",
        padding: "0 2px 0 6px"
    },
    ".cm-layer": {
        position: "absolute",
        left: 0,
        top: 0,
        contain: "size style",
        "& > *": {
            position: "absolute"
        }
    },
    "&light .cm-selectionBackground": {
        background: "#d9d9d9"
    },
    "&dark .cm-selectionBackground": {
        background: "#222"
    },
    "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#d7d4f0"
    },
    "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
        background: "#233"
    },
    ".cm-cursorLayer": {
        pointerEvents: "none"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
        animation: "steps(1) cm-blink 1.2s infinite"
    },
    // Two animations defined so that we can switch between them to
    // restart the animation without forcing another style
    // recomputation.
    "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
    ".cm-cursor, .cm-dropCursor": {
        borderLeft: "1.2px solid black",
        marginLeft: "-0.6px",
        pointerEvents: "none",
    },
    ".cm-cursor": {
        display: "none"
    },
    "&dark .cm-cursor": {
        borderLeftColor: "#444"
    },
    ".cm-dropCursor": {
        position: "absolute"
    },
    "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
        display: "block"
    },
    ".cm-announced": {
        position: "fixed",
        top: "-10000px"
    },
    "@media print": {
        ".cm-announced": { display: "none" }
    },
    "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
    "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
    "&light .cm-specialChar": { color: "red" },
    "&dark .cm-specialChar": { color: "#f78" },
    ".cm-gutters": {
        flexShrink: 0,
        display: "flex",
        height: "100%",
        boxSizing: "border-box",
        insetInlineStart: 0,
        zIndex: 200
    },
    "&light .cm-gutters": {
        backgroundColor: "#f5f5f5",
        color: "#6c6c6c",
        borderRight: "1px solid #ddd"
    },
    "&dark .cm-gutters": {
        backgroundColor: "#333338",
        color: "#ccc"
    },
    ".cm-gutter": {
        display: "flex !important", // Necessary -- prevents margin collapsing
        flexDirection: "column",
        flexShrink: 0,
        boxSizing: "border-box",
        minHeight: "100%",
        overflow: "hidden"
    },
    ".cm-gutterElement": {
        boxSizing: "border-box"
    },
    ".cm-lineNumbers .cm-gutterElement": {
        padding: "0 3px 0 5px",
        minWidth: "20px",
        textAlign: "right",
        whiteSpace: "nowrap"
    },
    "&light .cm-activeLineGutter": {
        backgroundColor: "#e2f2ff"
    },
    "&dark .cm-activeLineGutter": {
        backgroundColor: "#222227"
    },
    ".cm-panels": {
        boxSizing: "border-box",
        position: "sticky",
        left: 0,
        right: 0
    },
    "&light .cm-panels": {
        backgroundColor: "#f5f5f5",
        color: "black"
    },
    "&light .cm-panels-top": {
        borderBottom: "1px solid #ddd"
    },
    "&light .cm-panels-bottom": {
        borderTop: "1px solid #ddd"
    },
    "&dark .cm-panels": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tab": {
        display: "inline-block",
        overflow: "hidden",
        verticalAlign: "bottom"
    },
    ".cm-widgetBuffer": {
        verticalAlign: "text-top",
        height: "1em",
        width: 0,
        display: "inline"
    },
    ".cm-placeholder": {
        color: "#888",
        display: "inline-block",
        verticalAlign: "top",
    },
    ".cm-highlightSpace:before": {
        content: "attr(data-display)",
        position: "absolute",
        pointerEvents: "none",
        color: "#888"
    },
    ".cm-highlightTab": {
        backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
        backgroundSize: "auto 100%",
        backgroundPosition: "right 90%",
        backgroundRepeat: "no-repeat"
    },
    ".cm-trailingSpace": {
        backgroundColor: "#ff332255"
    },
    ".cm-button": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        padding: ".2em 1em",
        borderRadius: "1px"
    },
    "&light .cm-button": {
        backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
        }
    },
    "&dark .cm-button": {
        backgroundImage: "linear-gradient(#393939, #111)",
        border: "1px solid #888",
        "&:active": {
            backgroundImage: "linear-gradient(#111, #333)"
        }
    },
    ".cm-textfield": {
        verticalAlign: "middle",
        color: "inherit",
        fontSize: "70%",
        border: "1px solid silver",
        padding: ".2em .5em"
    },
    "&light .cm-textfield": {
        backgroundColor: "white"
    },
    "&dark .cm-textfield": {
        border: "1px solid #555",
        backgroundColor: "inherit"
    }
}, lightDarkIDs);

const LineBreakPlaceholder = "\uffff";
class DOMReader {
    constructor(points, state) {
        this.points = points;
        this.text = "";
        this.lineSeparator = state.facet(EditorState.lineSeparator);
    }
    append(text) {
        this.text += text;
    }
    lineBreak() {
        this.text += LineBreakPlaceholder;
    }
    readRange(start, end) {
        if (!start)
            return this;
        let parent = start.parentNode;
        for (let cur = start;;) {
            this.findPointBefore(parent, cur);
            let oldLen = this.text.length;
            this.readNode(cur);
            let next = cur.nextSibling;
            if (next == end)
                break;
            let view = ContentView.get(cur), nextView = ContentView.get(next);
            if (view && nextView ? view.breakAfter :
                (view ? view.breakAfter : isBlockElement(cur)) ||
                    (isBlockElement(next) && (cur.nodeName != "BR" || cur.cmIgnore) && this.text.length > oldLen))
                this.lineBreak();
            cur = next;
        }
        this.findPointBefore(parent, end);
        return this;
    }
    readTextNode(node) {
        let text = node.nodeValue;
        for (let point of this.points)
            if (point.node == node)
                point.pos = this.text.length + Math.min(point.offset, text.length);
        for (let off = 0, re = this.lineSeparator ? null : /\r\n?|\n/g;;) {
            let nextBreak = -1, breakSize = 1, m;
            if (this.lineSeparator) {
                nextBreak = text.indexOf(this.lineSeparator, off);
                breakSize = this.lineSeparator.length;
            }
            else if (m = re.exec(text)) {
                nextBreak = m.index;
                breakSize = m[0].length;
            }
            this.append(text.slice(off, nextBreak < 0 ? text.length : nextBreak));
            if (nextBreak < 0)
                break;
            this.lineBreak();
            if (breakSize > 1)
                for (let point of this.points)
                    if (point.node == node && point.pos > this.text.length)
                        point.pos -= breakSize - 1;
            off = nextBreak + breakSize;
        }
    }
    readNode(node) {
        if (node.cmIgnore)
            return;
        let view = ContentView.get(node);
        let fromView = view && view.overrideDOMText;
        if (fromView != null) {
            this.findPointInside(node, fromView.length);
            for (let i = fromView.iter(); !i.next().done;) {
                if (i.lineBreak)
                    this.lineBreak();
                else
                    this.append(i.value);
            }
        }
        else if (node.nodeType == 3) {
            this.readTextNode(node);
        }
        else if (node.nodeName == "BR") {
            if (node.nextSibling)
                this.lineBreak();
        }
        else if (node.nodeType == 1) {
            this.readRange(node.firstChild, null);
        }
    }
    findPointBefore(node, next) {
        for (let point of this.points)
            if (point.node == node && node.childNodes[point.offset] == next)
                point.pos = this.text.length;
    }
    findPointInside(node, length) {
        for (let point of this.points)
            if (node.nodeType == 3 ? point.node == node : node.contains(point.node))
                point.pos = this.text.length + (isAtEnd(node, point.node, point.offset) ? length : 0);
    }
}
function isAtEnd(parent, node, offset) {
    for (;;) {
        if (!node || offset < maxOffset(node))
            return false;
        if (node == parent)
            return true;
        offset = domIndex(node) + 1;
        node = node.parentNode;
    }
}
function isBlockElement(node) {
    return node.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(node.nodeName);
}
class DOMPoint {
    constructor(node, offset) {
        this.node = node;
        this.offset = offset;
        this.pos = -1;
    }
}

class DOMChange {
    constructor(view, start, end, typeOver) {
        this.typeOver = typeOver;
        this.bounds = null;
        this.text = "";
        let { impreciseHead: iHead, impreciseAnchor: iAnchor } = view.docView;
        if (view.state.readOnly && start > -1) {
            // Ignore changes when the editor is read-only
            this.newSel = null;
        }
        else if (start > -1 && (this.bounds = view.docView.domBoundsAround(start, end, 0))) {
            let selPoints = iHead || iAnchor ? [] : selectionPoints(view);
            let reader = new DOMReader(selPoints, view.state);
            reader.readRange(this.bounds.startDOM, this.bounds.endDOM);
            this.text = reader.text;
            this.newSel = selectionFromPoints(selPoints, this.bounds.from);
        }
        else {
            let domSel = view.observer.selectionRange;
            let head = iHead && iHead.node == domSel.focusNode && iHead.offset == domSel.focusOffset ||
                !contains(view.contentDOM, domSel.focusNode)
                ? view.state.selection.main.head
                : view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
            let anchor = iAnchor && iAnchor.node == domSel.anchorNode && iAnchor.offset == domSel.anchorOffset ||
                !contains(view.contentDOM, domSel.anchorNode)
                ? view.state.selection.main.anchor
                : view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
            this.newSel = dist_EditorSelection.single(anchor, head);
        }
    }
}
function applyDOMChange(view, domChange) {
    let change;
    let { newSel } = domChange, sel = view.state.selection.main;
    let lastKey = view.inputState.lastKeyTime > Date.now() - 100 ? view.inputState.lastKeyCode : -1;
    if (domChange.bounds) {
        let { from, to } = domChange.bounds;
        let preferredPos = sel.from, preferredSide = null;
        // Prefer anchoring to end when Backspace is pressed (or, on
        // Android, when something was deleted)
        if (lastKey === 8 || browser.android && domChange.text.length < to - from) {
            preferredPos = sel.to;
            preferredSide = "end";
        }
        let diff = findDiff(view.state.doc.sliceString(from, to, LineBreakPlaceholder), domChange.text, preferredPos - from, preferredSide);
        if (diff) {
            // Chrome inserts two newlines when pressing shift-enter at the
            // end of a line. DomChange drops one of those.
            if (browser.chrome && lastKey == 13 &&
                diff.toB == diff.from + 2 && domChange.text.slice(diff.from, diff.toB) == LineBreakPlaceholder + LineBreakPlaceholder)
                diff.toB--;
            change = { from: from + diff.from, to: from + diff.toA,
                insert: Text.of(domChange.text.slice(diff.from, diff.toB).split(LineBreakPlaceholder)) };
        }
    }
    else if (newSel && (!view.hasFocus && view.state.facet(editable) || newSel.main.eq(sel))) {
        newSel = null;
    }
    if (!change && !newSel)
        return false;
    if (!change && domChange.typeOver && !sel.empty && newSel && newSel.main.empty) {
        // Heuristic to notice typing over a selected character
        change = { from: sel.from, to: sel.to, insert: view.state.doc.slice(sel.from, sel.to) };
    }
    else if (change && change.from >= sel.from && change.to <= sel.to &&
        (change.from != sel.from || change.to != sel.to) &&
        (sel.to - sel.from) - (change.to - change.from) <= 4) {
        // If the change is inside the selection and covers most of it,
        // assume it is a selection replace (with identical characters at
        // the start/end not included in the diff)
        change = {
            from: sel.from, to: sel.to,
            insert: view.state.doc.slice(sel.from, change.from).append(change.insert).append(view.state.doc.slice(change.to, sel.to))
        };
    }
    else if ((browser.mac || browser.android) && change && change.from == change.to && change.from == sel.head - 1 &&
        /^\. ?$/.test(change.insert.toString()) && view.contentDOM.getAttribute("autocorrect") == "off") {
        // Detect insert-period-on-double-space Mac and Android behavior,
        // and transform it into a regular space insert.
        if (newSel && change.insert.length == 2)
            newSel = dist_EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    else if (browser.chrome && change && change.from == change.to && change.from == sel.head &&
        change.insert.toString() == "\n " && view.lineWrapping) {
        // In Chrome, if you insert a space at the start of a wrapped
        // line, it will actually insert a newline and a space, causing a
        // bogus new line to be created in CodeMirror (#968)
        if (newSel)
            newSel = dist_EditorSelection.single(newSel.main.anchor - 1, newSel.main.head - 1);
        change = { from: sel.from, to: sel.to, insert: Text.of([" "]) };
    }
    if (change) {
        if (browser.ios && view.inputState.flushIOSKey())
            return true;
        // Android browsers don't fire reasonable key events for enter,
        // backspace, or delete. So this detects changes that look like
        // they're caused by those keys, and reinterprets them as key
        // events. (Some of these keys are also handled by beforeinput
        // events and the pendingAndroidKey mechanism, but that's not
        // reliable in all situations.)
        if (browser.android &&
            ((change.from == sel.from && change.to == sel.to &&
                change.insert.length == 1 && change.insert.lines == 2 &&
                dispatchKey(view.contentDOM, "Enter", 13)) ||
                ((change.from == sel.from - 1 && change.to == sel.to && change.insert.length == 0 ||
                    lastKey == 8 && change.insert.length < change.to - change.from && change.to > sel.head) &&
                    dispatchKey(view.contentDOM, "Backspace", 8)) ||
                (change.from == sel.from && change.to == sel.to + 1 && change.insert.length == 0 &&
                    dispatchKey(view.contentDOM, "Delete", 46))))
            return true;
        let text = change.insert.toString();
        if (view.inputState.composing >= 0)
            view.inputState.composing++;
        let defaultTr;
        let defaultInsert = () => defaultTr || (defaultTr = applyDefaultInsert(view, change, newSel));
        if (!view.state.facet(inputHandler).some(h => h(view, change.from, change.to, text, defaultInsert)))
            view.dispatch(defaultInsert());
        return true;
    }
    else if (newSel && !newSel.main.eq(sel)) {
        let scrollIntoView = false, userEvent = "select";
        if (view.inputState.lastSelectionTime > Date.now() - 50) {
            if (view.inputState.lastSelectionOrigin == "select")
                scrollIntoView = true;
            userEvent = view.inputState.lastSelectionOrigin;
        }
        view.dispatch({ selection: newSel, scrollIntoView, userEvent });
        return true;
    }
    else {
        return false;
    }
}
function applyDefaultInsert(view, change, newSel) {
    let tr, startState = view.state, sel = startState.selection.main;
    if (change.from >= sel.from && change.to <= sel.to && change.to - change.from >= (sel.to - sel.from) / 3 &&
        (!newSel || newSel.main.empty && newSel.main.from == change.from + change.insert.length) &&
        view.inputState.composing < 0) {
        let before = sel.from < change.from ? startState.sliceDoc(sel.from, change.from) : "";
        let after = sel.to > change.to ? startState.sliceDoc(change.to, sel.to) : "";
        tr = startState.replaceSelection(view.state.toText(before + change.insert.sliceString(0, undefined, view.state.lineBreak) + after));
    }
    else {
        let changes = startState.changes(change);
        let mainSel = newSel && newSel.main.to <= changes.newLength ? newSel.main : undefined;
        // Try to apply a composition change to all cursors
        if (startState.selection.ranges.length > 1 && view.inputState.composing >= 0 &&
            change.to <= sel.to && change.to >= sel.to - 10) {
            let replaced = view.state.sliceDoc(change.from, change.to);
            let compositionRange, composition = newSel && findCompositionNode(view, newSel.main.head);
            if (composition) {
                let dLen = change.insert.length - (change.to - change.from);
                compositionRange = { from: composition.from, to: composition.to - dLen };
            }
            else {
                compositionRange = view.state.doc.lineAt(sel.head);
            }
            let offset = sel.to - change.to, size = sel.to - sel.from;
            tr = startState.changeByRange(range => {
                if (range.from == sel.from && range.to == sel.to)
                    return { changes, range: mainSel || range.map(changes) };
                let to = range.to - offset, from = to - replaced.length;
                if (range.to - range.from != size || view.state.sliceDoc(from, to) != replaced ||
                    // Unfortunately, there's no way to make multiple
                    // changes in the same node work without aborting
                    // composition, so cursors in the composition range are
                    // ignored.
                    range.to >= compositionRange.from && range.from <= compositionRange.to)
                    return { range };
                let rangeChanges = startState.changes({ from, to, insert: change.insert }), selOff = range.to - sel.to;
                return {
                    changes: rangeChanges,
                    range: !mainSel ? range.map(rangeChanges) :
                        dist_EditorSelection.range(Math.max(0, mainSel.anchor + selOff), Math.max(0, mainSel.head + selOff))
                };
            });
        }
        else {
            tr = {
                changes,
                selection: mainSel && startState.selection.replaceRange(mainSel)
            };
        }
    }
    let userEvent = "input.type";
    if (view.composing ||
        view.inputState.compositionPendingChange && view.inputState.compositionEndedAt > Date.now() - 50) {
        view.inputState.compositionPendingChange = false;
        userEvent += ".compose";
        if (view.inputState.compositionFirstChange) {
            userEvent += ".start";
            view.inputState.compositionFirstChange = false;
        }
    }
    return startState.update(tr, { userEvent, scrollIntoView: true });
}
function findDiff(a, b, preferredPos, preferredSide) {
    let minLen = Math.min(a.length, b.length);
    let from = 0;
    while (from < minLen && a.charCodeAt(from) == b.charCodeAt(from))
        from++;
    if (from == minLen && a.length == b.length)
        return null;
    let toA = a.length, toB = b.length;
    while (toA > 0 && toB > 0 && a.charCodeAt(toA - 1) == b.charCodeAt(toB - 1)) {
        toA--;
        toB--;
    }
    if (preferredSide == "end") {
        let adjust = Math.max(0, from - Math.min(toA, toB));
        preferredPos -= toA + adjust - from;
    }
    if (toA < from && a.length < b.length) {
        let move = preferredPos <= from && preferredPos >= toA ? from - preferredPos : 0;
        from -= move;
        toB = from + (toB - toA);
        toA = from;
    }
    else if (toB < from) {
        let move = preferredPos <= from && preferredPos >= toB ? from - preferredPos : 0;
        from -= move;
        toA = from + (toA - toB);
        toB = from;
    }
    return { from, toA, toB };
}
function selectionPoints(view) {
    let result = [];
    if (view.root.activeElement != view.contentDOM)
        return result;
    let { anchorNode, anchorOffset, focusNode, focusOffset } = view.observer.selectionRange;
    if (anchorNode) {
        result.push(new DOMPoint(anchorNode, anchorOffset));
        if (focusNode != anchorNode || focusOffset != anchorOffset)
            result.push(new DOMPoint(focusNode, focusOffset));
    }
    return result;
}
function selectionFromPoints(points, base) {
    if (points.length == 0)
        return null;
    let anchor = points[0].pos, head = points.length == 2 ? points[1].pos : anchor;
    return anchor > -1 && head > -1 ? dist_EditorSelection.single(anchor + base, head + base) : null;
}

const observeOptions = {
    childList: true,
    characterData: true,
    subtree: true,
    attributes: true,
    characterDataOldValue: true
};
// IE11 has very broken mutation observers, so we also listen to
// DOMCharacterDataModified there
const useCharData = browser.ie && browser.ie_version <= 11;
class DOMObserver {
    constructor(view) {
        this.view = view;
        this.active = false;
        // The known selection. Kept in our own object, as opposed to just
        // directly accessing the selection because:
        //  - Safari doesn't report the right selection in shadow DOM
        //  - Reading from the selection forces a DOM layout
        //  - This way, we can ignore selectionchange events if we have
        //    already seen the 'new' selection
        this.selectionRange = new DOMSelectionState;
        // Set when a selection change is detected, cleared on flush
        this.selectionChanged = false;
        this.delayedFlush = -1;
        this.resizeTimeout = -1;
        this.queue = [];
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
        this.lastChange = 0;
        this.scrollTargets = [];
        this.intersection = null;
        this.resizeScroll = null;
        this.intersecting = false;
        this.gapIntersection = null;
        this.gaps = [];
        // Timeout for scheduling check of the parents that need scroll handlers
        this.parentCheck = -1;
        this.dom = view.contentDOM;
        this.observer = new MutationObserver(mutations => {
            for (let mut of mutations)
                this.queue.push(mut);
            // IE11 will sometimes (on typing over a selection or
            // backspacing out a single character text node) call the
            // observer callback before actually updating the DOM.
            //
            // Unrelatedly, iOS Safari will, when ending a composition,
            // sometimes first clear it, deliver the mutations, and then
            // reinsert the finished text. CodeMirror's handling of the
            // deletion will prevent the reinsertion from happening,
            // breaking composition.
            if ((browser.ie && browser.ie_version <= 11 || browser.ios && view.composing) &&
                mutations.some(m => m.type == "childList" && m.removedNodes.length ||
                    m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
                this.flushSoon();
            else
                this.flush();
        });
        if (useCharData)
            this.onCharData = (event) => {
                this.queue.push({ target: event.target,
                    type: "characterData",
                    oldValue: event.prevValue });
                this.flushSoon();
            };
        this.onSelectionChange = this.onSelectionChange.bind(this);
        this.onResize = this.onResize.bind(this);
        this.onPrint = this.onPrint.bind(this);
        this.onScroll = this.onScroll.bind(this);
        if (typeof ResizeObserver == "function") {
            this.resizeScroll = new ResizeObserver(() => {
                var _a;
                if (((_a = this.view.docView) === null || _a === void 0 ? void 0 : _a.lastUpdate) < Date.now() - 75)
                    this.onResize();
            });
            this.resizeScroll.observe(view.scrollDOM);
        }
        this.addWindowListeners(this.win = view.win);
        this.start();
        if (typeof IntersectionObserver == "function") {
            this.intersection = new IntersectionObserver(entries => {
                if (this.parentCheck < 0)
                    this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1000);
                if (entries.length > 0 && (entries[entries.length - 1].intersectionRatio > 0) != this.intersecting) {
                    this.intersecting = !this.intersecting;
                    if (this.intersecting != this.view.inView)
                        this.onScrollChanged(document.createEvent("Event"));
                }
            }, { threshold: [0, .001] });
            this.intersection.observe(this.dom);
            this.gapIntersection = new IntersectionObserver(entries => {
                if (entries.length > 0 && entries[entries.length - 1].intersectionRatio > 0)
                    this.onScrollChanged(document.createEvent("Event"));
            }, {});
        }
        this.listenForScroll();
        this.readSelectionRange();
    }
    onScrollChanged(e) {
        this.view.inputState.runHandlers("scroll", e);
        if (this.intersecting)
            this.view.measure();
    }
    onScroll(e) {
        if (this.intersecting)
            this.flush(false);
        this.onScrollChanged(e);
    }
    onResize() {
        if (this.resizeTimeout < 0)
            this.resizeTimeout = setTimeout(() => {
                this.resizeTimeout = -1;
                this.view.requestMeasure();
            }, 50);
    }
    onPrint() {
        this.view.viewState.printing = true;
        this.view.measure();
        setTimeout(() => {
            this.view.viewState.printing = false;
            this.view.requestMeasure();
        }, 500);
    }
    updateGaps(gaps) {
        if (this.gapIntersection && (gaps.length != this.gaps.length || this.gaps.some((g, i) => g != gaps[i]))) {
            this.gapIntersection.disconnect();
            for (let gap of gaps)
                this.gapIntersection.observe(gap);
            this.gaps = gaps;
        }
    }
    onSelectionChange(event) {
        let wasChanged = this.selectionChanged;
        if (!this.readSelectionRange() || this.delayedAndroidKey)
            return;
        let { view } = this, sel = this.selectionRange;
        if (view.state.facet(editable) ? view.root.activeElement != this.dom : !hasSelection(view.dom, sel))
            return;
        let context = sel.anchorNode && view.docView.nearest(sel.anchorNode);
        if (context && context.ignoreEvent(event)) {
            if (!wasChanged)
                this.selectionChanged = false;
            return;
        }
        // Deletions on IE11 fire their events in the wrong order, giving
        // us a selection change event before the DOM changes are
        // reported.
        // Chrome Android has a similar issue when backspacing out a
        // selection (#645).
        if ((browser.ie && browser.ie_version <= 11 || browser.android && browser.chrome) && !view.state.selection.main.empty &&
            // (Selection.isCollapsed isn't reliable on IE)
            sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
            this.flushSoon();
        else
            this.flush(false);
    }
    readSelectionRange() {
        let { view } = this;
        // The Selection object is broken in shadow roots in Safari. See
        // https://github.com/codemirror/dev/issues/414
        let range = browser.safari && view.root.nodeType == 11 &&
            deepActiveElement(this.dom.ownerDocument) == this.dom &&
            safariSelectionRangeHack(this.view) || getSelection(view.root);
        if (!range || this.selectionRange.eq(range))
            return false;
        let local = hasSelection(this.dom, range);
        // Detect the situation where the browser has, on focus, moved the
        // selection to the start of the content element. Reset it to the
        // position from the editor state.
        if (local && !this.selectionChanged &&
            view.inputState.lastFocusTime > Date.now() - 200 &&
            view.inputState.lastTouchTime < Date.now() - 300 &&
            atElementStart(this.dom, range)) {
            this.view.inputState.lastFocusTime = 0;
            view.docView.updateSelection();
            return false;
        }
        this.selectionRange.setRange(range);
        if (local)
            this.selectionChanged = true;
        return true;
    }
    setSelectionRange(anchor, head) {
        this.selectionRange.set(anchor.node, anchor.offset, head.node, head.offset);
        this.selectionChanged = false;
    }
    clearSelectionRange() {
        this.selectionRange.set(null, 0, null, 0);
    }
    listenForScroll() {
        this.parentCheck = -1;
        let i = 0, changed = null;
        for (let dom = this.dom; dom;) {
            if (dom.nodeType == 1) {
                if (!changed && i < this.scrollTargets.length && this.scrollTargets[i] == dom)
                    i++;
                else if (!changed)
                    changed = this.scrollTargets.slice(0, i);
                if (changed)
                    changed.push(dom);
                dom = dom.assignedSlot || dom.parentNode;
            }
            else if (dom.nodeType == 11) { // Shadow root
                dom = dom.host;
            }
            else {
                break;
            }
        }
        if (i < this.scrollTargets.length && !changed)
            changed = this.scrollTargets.slice(0, i);
        if (changed) {
            for (let dom of this.scrollTargets)
                dom.removeEventListener("scroll", this.onScroll);
            for (let dom of this.scrollTargets = changed)
                dom.addEventListener("scroll", this.onScroll);
        }
    }
    ignore(f) {
        if (!this.active)
            return f();
        try {
            this.stop();
            return f();
        }
        finally {
            this.start();
            this.clear();
        }
    }
    start() {
        if (this.active)
            return;
        this.observer.observe(this.dom, observeOptions);
        if (useCharData)
            this.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
        this.active = true;
    }
    stop() {
        if (!this.active)
            return;
        this.active = false;
        this.observer.disconnect();
        if (useCharData)
            this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    }
    // Throw away any pending changes
    clear() {
        this.processRecords();
        this.queue.length = 0;
        this.selectionChanged = false;
    }
    // Chrome Android, especially in combination with GBoard, not only
    // doesn't reliably fire regular key events, but also often
    // surrounds the effect of enter or backspace with a bunch of
    // composition events that, when interrupted, cause text duplication
    // or other kinds of corruption. This hack makes the editor back off
    // from handling DOM changes for a moment when such a key is
    // detected (via beforeinput or keydown), and then tries to flush
    // them or, if that has no effect, dispatches the given key.
    delayAndroidKey(key, keyCode) {
        var _a;
        if (!this.delayedAndroidKey) {
            let flush = () => {
                let key = this.delayedAndroidKey;
                if (key) {
                    this.clearDelayedAndroidKey();
                    this.view.inputState.lastKeyCode = key.keyCode;
                    this.view.inputState.lastKeyTime = Date.now();
                    let flushed = this.flush();
                    if (!flushed && key.force)
                        dispatchKey(this.dom, key.key, key.keyCode);
                }
            };
            this.flushingAndroidKey = this.view.win.requestAnimationFrame(flush);
        }
        // Since backspace beforeinput is sometimes signalled spuriously,
        // Enter always takes precedence.
        if (!this.delayedAndroidKey || key == "Enter")
            this.delayedAndroidKey = {
                key, keyCode,
                // Only run the key handler when no changes are detected if
                // this isn't coming right after another change, in which case
                // it is probably part of a weird chain of updates, and should
                // be ignored if it returns the DOM to its previous state.
                force: this.lastChange < Date.now() - 50 || !!((_a = this.delayedAndroidKey) === null || _a === void 0 ? void 0 : _a.force)
            };
    }
    clearDelayedAndroidKey() {
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
        this.delayedAndroidKey = null;
        this.flushingAndroidKey = -1;
    }
    flushSoon() {
        if (this.delayedFlush < 0)
            this.delayedFlush = this.view.win.requestAnimationFrame(() => { this.delayedFlush = -1; this.flush(); });
    }
    forceFlush() {
        if (this.delayedFlush >= 0) {
            this.view.win.cancelAnimationFrame(this.delayedFlush);
            this.delayedFlush = -1;
        }
        this.flush();
    }
    pendingRecords() {
        for (let mut of this.observer.takeRecords())
            this.queue.push(mut);
        return this.queue;
    }
    processRecords() {
        let records = this.pendingRecords();
        if (records.length)
            this.queue = [];
        let from = -1, to = -1, typeOver = false;
        for (let record of records) {
            let range = this.readMutation(record);
            if (!range)
                continue;
            if (range.typeOver)
                typeOver = true;
            if (from == -1) {
                ({ from, to } = range);
            }
            else {
                from = Math.min(range.from, from);
                to = Math.max(range.to, to);
            }
        }
        return { from, to, typeOver };
    }
    readChange() {
        let { from, to, typeOver } = this.processRecords();
        let newSel = this.selectionChanged && hasSelection(this.dom, this.selectionRange);
        if (from < 0 && !newSel)
            return null;
        if (from > -1)
            this.lastChange = Date.now();
        this.view.inputState.lastFocusTime = 0;
        this.selectionChanged = false;
        let change = new DOMChange(this.view, from, to, typeOver);
        this.view.docView.domChanged = { newSel: change.newSel ? change.newSel.main : null };
        return change;
    }
    // Apply pending changes, if any
    flush(readSelection = true) {
        // Completely hold off flushing when pending keys are set—the code
        // managing those will make sure processRecords is called and the
        // view is resynchronized after
        if (this.delayedFlush >= 0 || this.delayedAndroidKey)
            return false;
        if (readSelection)
            this.readSelectionRange();
        let domChange = this.readChange();
        if (!domChange) {
            this.view.requestMeasure();
            return false;
        }
        let startState = this.view.state;
        let handled = applyDOMChange(this.view, domChange);
        // The view wasn't updated
        if (this.view.state == startState)
            this.view.update([]);
        return handled;
    }
    readMutation(rec) {
        let cView = this.view.docView.nearest(rec.target);
        if (!cView || cView.ignoreMutation(rec))
            return null;
        cView.markDirty(rec.type == "attributes");
        if (rec.type == "attributes")
            cView.flags |= 4 /* ViewFlag.AttrsDirty */;
        if (rec.type == "childList") {
            let childBefore = findChild(cView, rec.previousSibling || rec.target.previousSibling, -1);
            let childAfter = findChild(cView, rec.nextSibling || rec.target.nextSibling, 1);
            return { from: childBefore ? cView.posAfter(childBefore) : cView.posAtStart,
                to: childAfter ? cView.posBefore(childAfter) : cView.posAtEnd, typeOver: false };
        }
        else if (rec.type == "characterData") {
            return { from: cView.posAtStart, to: cView.posAtEnd, typeOver: rec.target.nodeValue == rec.oldValue };
        }
        else {
            return null;
        }
    }
    setWindow(win) {
        if (win != this.win) {
            this.removeWindowListeners(this.win);
            this.win = win;
            this.addWindowListeners(this.win);
        }
    }
    addWindowListeners(win) {
        win.addEventListener("resize", this.onResize);
        win.addEventListener("beforeprint", this.onPrint);
        win.addEventListener("scroll", this.onScroll);
        win.document.addEventListener("selectionchange", this.onSelectionChange);
    }
    removeWindowListeners(win) {
        win.removeEventListener("scroll", this.onScroll);
        win.removeEventListener("resize", this.onResize);
        win.removeEventListener("beforeprint", this.onPrint);
        win.document.removeEventListener("selectionchange", this.onSelectionChange);
    }
    destroy() {
        var _a, _b, _c;
        this.stop();
        (_a = this.intersection) === null || _a === void 0 ? void 0 : _a.disconnect();
        (_b = this.gapIntersection) === null || _b === void 0 ? void 0 : _b.disconnect();
        (_c = this.resizeScroll) === null || _c === void 0 ? void 0 : _c.disconnect();
        for (let dom of this.scrollTargets)
            dom.removeEventListener("scroll", this.onScroll);
        this.removeWindowListeners(this.win);
        clearTimeout(this.parentCheck);
        clearTimeout(this.resizeTimeout);
        this.win.cancelAnimationFrame(this.delayedFlush);
        this.win.cancelAnimationFrame(this.flushingAndroidKey);
    }
}
function findChild(cView, dom, dir) {
    while (dom) {
        let curView = ContentView.get(dom);
        if (curView && curView.parent == cView)
            return curView;
        let parent = dom.parentNode;
        dom = parent != cView.dom ? parent : dir > 0 ? dom.nextSibling : dom.previousSibling;
    }
    return null;
}
// Used to work around a Safari Selection/shadow DOM bug (#414)
function safariSelectionRangeHack(view) {
    let found = null;
    // Because Safari (at least in 2018-2021) doesn't provide regular
    // access to the selection inside a shadowroot, we have to perform a
    // ridiculous hack to get at it—using `execCommand` to trigger a
    // `beforeInput` event so that we can read the target range from the
    // event.
    function read(event) {
        event.preventDefault();
        event.stopImmediatePropagation();
        found = event.getTargetRanges()[0];
    }
    view.contentDOM.addEventListener("beforeinput", read, true);
    view.dom.ownerDocument.execCommand("indent");
    view.contentDOM.removeEventListener("beforeinput", read, true);
    if (!found)
        return null;
    let anchorNode = found.startContainer, anchorOffset = found.startOffset;
    let focusNode = found.endContainer, focusOffset = found.endOffset;
    let curAnchor = view.docView.domAtPos(view.state.selection.main.anchor);
    // Since such a range doesn't distinguish between anchor and head,
    // use a heuristic that flips it around if its end matches the
    // current anchor.
    if (isEquivalentPosition(curAnchor.node, curAnchor.offset, focusNode, focusOffset))
        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
    return { anchorNode, anchorOffset, focusNode, focusOffset };
}

// The editor's update state machine looks something like this:
//
//     Idle → Updating ⇆ Idle (unchecked) → Measuring → Idle
//                                         ↑      ↓
//                                         Updating (measure)
//
// The difference between 'Idle' and 'Idle (unchecked)' lies in
// whether a layout check has been scheduled. A regular update through
// the `update` method updates the DOM in a write-only fashion, and
// relies on a check (scheduled with `requestAnimationFrame`) to make
// sure everything is where it should be and the viewport covers the
// visible code. That check continues to measure and then optionally
// update until it reaches a coherent state.
/**
An editor view represents the editor's user interface. It holds
the editable DOM surface, and possibly other elements such as the
line number gutter. It handles events and dispatches state
transactions for editing actions.
*/
class EditorView {
    /**
    The current editor state.
    */
    get state() { return this.viewState.state; }
    /**
    To be able to display large documents without consuming too much
    memory or overloading the browser, CodeMirror only draws the
    code that is visible (plus a margin around it) to the DOM. This
    property tells you the extent of the current drawn viewport, in
    document positions.
    */
    get viewport() { return this.viewState.viewport; }
    /**
    When there are, for example, large collapsed ranges in the
    viewport, its size can be a lot bigger than the actual visible
    content. Thus, if you are doing something like styling the
    content in the viewport, it is preferable to only do so for
    these ranges, which are the subset of the viewport that is
    actually drawn.
    */
    get visibleRanges() { return this.viewState.visibleRanges; }
    /**
    Returns false when the editor is entirely scrolled out of view
    or otherwise hidden.
    */
    get inView() { return this.viewState.inView; }
    /**
    Indicates whether the user is currently composing text via
    [IME](https://en.wikipedia.org/wiki/Input_method), and at least
    one change has been made in the current composition.
    */
    get composing() { return this.inputState.composing > 0; }
    /**
    Indicates whether the user is currently in composing state. Note
    that on some platforms, like Android, this will be the case a
    lot, since just putting the cursor on a word starts a
    composition there.
    */
    get compositionStarted() { return this.inputState.composing >= 0; }
    /**
    The document or shadow root that the view lives in.
    */
    get root() { return this._root; }
    /**
    @internal
    */
    get win() { return this.dom.ownerDocument.defaultView || window; }
    /**
    Construct a new view. You'll want to either provide a `parent`
    option, or put `view.dom` into your document after creating a
    view, so that the user can see the editor.
    */
    constructor(config = {}) {
        this.plugins = [];
        this.pluginMap = new Map;
        this.editorAttrs = {};
        this.contentAttrs = {};
        this.bidiCache = [];
        this.destroyed = false;
        /**
        @internal
        */
        this.updateState = 2 /* UpdateState.Updating */;
        /**
        @internal
        */
        this.measureScheduled = -1;
        /**
        @internal
        */
        this.measureRequests = [];
        this.contentDOM = document.createElement("div");
        this.scrollDOM = document.createElement("div");
        this.scrollDOM.tabIndex = -1;
        this.scrollDOM.className = "cm-scroller";
        this.scrollDOM.appendChild(this.contentDOM);
        this.announceDOM = document.createElement("div");
        this.announceDOM.className = "cm-announced";
        this.announceDOM.setAttribute("aria-live", "polite");
        this.dom = document.createElement("div");
        this.dom.appendChild(this.announceDOM);
        this.dom.appendChild(this.scrollDOM);
        if (config.parent)
            config.parent.appendChild(this.dom);
        let { dispatch } = config;
        this.dispatchTransactions = config.dispatchTransactions ||
            (dispatch && ((trs) => trs.forEach(tr => dispatch(tr, this)))) ||
            ((trs) => this.update(trs));
        this.dispatch = this.dispatch.bind(this);
        this._root = (config.root || getRoot(config.parent) || document);
        this.viewState = new ViewState(config.state || EditorState.create(config));
        if (config.scrollTo && config.scrollTo.is(scrollIntoView))
            this.viewState.scrollTarget = config.scrollTo.value.clip(this.viewState.state);
        this.plugins = this.state.facet(viewPlugin).map(spec => new PluginInstance(spec));
        for (let plugin of this.plugins)
            plugin.update(this);
        this.observer = new DOMObserver(this);
        this.inputState = new InputState(this);
        this.inputState.ensureHandlers(this.plugins);
        this.docView = new DocView(this);
        this.mountStyles();
        this.updateAttrs();
        this.updateState = 0 /* UpdateState.Idle */;
        this.requestMeasure();
    }
    dispatch(...input) {
        let trs = input.length == 1 && input[0] instanceof Transaction ? input
            : input.length == 1 && Array.isArray(input[0]) ? input[0]
                : [this.state.update(...input)];
        this.dispatchTransactions(trs, this);
    }
    /**
    Update the view for the given array of transactions. This will
    update the visible document and selection to match the state
    produced by the transactions, and notify view plugins of the
    change. You should usually call
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
    as a primitive.
    */
    update(transactions) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
        let redrawn = false, attrsChanged = false, update;
        let state = this.state;
        for (let tr of transactions) {
            if (tr.startState != state)
                throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
            state = tr.state;
        }
        if (this.destroyed) {
            this.viewState.state = state;
            return;
        }
        let focus = this.hasFocus, focusFlag = 0, dispatchFocus = null;
        if (transactions.some(tr => tr.annotation(isFocusChange))) {
            this.inputState.notifiedFocused = focus;
            // If a focus-change transaction is being dispatched, set this update flag.
            focusFlag = 1 /* UpdateFlag.Focus */;
        }
        else if (focus != this.inputState.notifiedFocused) {
            this.inputState.notifiedFocused = focus;
            // Schedule a separate focus transaction if necessary, otherwise
            // add a flag to this update
            dispatchFocus = focusChangeTransaction(state, focus);
            if (!dispatchFocus)
                focusFlag = 1 /* UpdateFlag.Focus */;
        }
        // If there was a pending DOM change, eagerly read it and try to
        // apply it after the given transactions.
        let pendingKey = this.observer.delayedAndroidKey, domChange = null;
        if (pendingKey) {
            this.observer.clearDelayedAndroidKey();
            domChange = this.observer.readChange();
            // Only try to apply DOM changes if the transactions didn't
            // change the doc or selection.
            if (domChange && !this.state.doc.eq(state.doc) || !this.state.selection.eq(state.selection))
                domChange = null;
        }
        else {
            this.observer.clear();
        }
        // When the phrases change, redraw the editor
        if (state.facet(EditorState.phrases) != this.state.facet(EditorState.phrases))
            return this.setState(state);
        update = ViewUpdate.create(this, state, transactions);
        update.flags |= focusFlag;
        let scrollTarget = this.viewState.scrollTarget;
        try {
            this.updateState = 2 /* UpdateState.Updating */;
            for (let tr of transactions) {
                if (scrollTarget)
                    scrollTarget = scrollTarget.map(tr.changes);
                if (tr.scrollIntoView) {
                    let { main } = tr.state.selection;
                    scrollTarget = new ScrollTarget(main.empty ? main : dist_EditorSelection.cursor(main.head, main.head > main.anchor ? -1 : 1));
                }
                for (let e of tr.effects)
                    if (e.is(scrollIntoView))
                        scrollTarget = e.value.clip(this.state);
            }
            this.viewState.update(update, scrollTarget);
            this.bidiCache = CachedOrder.update(this.bidiCache, update.changes);
            if (!update.empty) {
                this.updatePlugins(update);
                this.inputState.update(update);
            }
            redrawn = this.docView.update(update);
            if (this.state.facet(styleModule) != this.styleModules)
                this.mountStyles();
            attrsChanged = this.updateAttrs();
            this.showAnnouncements(transactions);
            this.docView.updateSelection(redrawn, transactions.some(tr => tr.isUserEvent("select.pointer")));
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (update.startState.facet(theme) != update.state.facet(theme))
            this.viewState.mustMeasureContent = true;
        if (redrawn || attrsChanged || scrollTarget || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent)
            this.requestMeasure();
        if (!update.empty)
            for (let listener of this.state.facet(updateListener)) {
                try {
                    listener(update);
                }
                catch (e) {
                    dist_logException(this.state, e, "update listener");
                }
            }
        if (dispatchFocus || domChange)
            Promise.resolve().then(() => {
                if (dispatchFocus && this.state == dispatchFocus.startState)
                    this.dispatch(dispatchFocus);
                if (domChange) {
                    if (!applyDOMChange(this, domChange) && pendingKey.force)
                        dispatchKey(this.contentDOM, pendingKey.key, pendingKey.keyCode);
                }
            });
    }
    /**
    Reset the view to the given state. (This will cause the entire
    document to be redrawn and all view plugins to be reinitialized,
    so you should probably only use it when the new state isn't
    derived from the old state. Otherwise, use
    [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
    */
    setState(newState) {
        if (this.updateState != 0 /* UpdateState.Idle */)
            throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
        if (this.destroyed) {
            this.viewState.state = newState;
            return;
        }
        this.updateState = 2 /* UpdateState.Updating */;
        let hadFocus = this.hasFocus;
        try {
            for (let plugin of this.plugins)
                plugin.destroy(this);
            this.viewState = new ViewState(newState);
            this.plugins = newState.facet(viewPlugin).map(spec => new PluginInstance(spec));
            this.pluginMap.clear();
            for (let plugin of this.plugins)
                plugin.update(this);
            this.docView.destroy();
            this.docView = new DocView(this);
            this.inputState.ensureHandlers(this.plugins);
            this.mountStyles();
            this.updateAttrs();
            this.bidiCache = [];
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
        }
        if (hadFocus)
            this.focus();
        this.requestMeasure();
    }
    updatePlugins(update) {
        let prevSpecs = update.startState.facet(viewPlugin), specs = update.state.facet(viewPlugin);
        if (prevSpecs != specs) {
            let newPlugins = [];
            for (let spec of specs) {
                let found = prevSpecs.indexOf(spec);
                if (found < 0) {
                    newPlugins.push(new PluginInstance(spec));
                }
                else {
                    let plugin = this.plugins[found];
                    plugin.mustUpdate = update;
                    newPlugins.push(plugin);
                }
            }
            for (let plugin of this.plugins)
                if (plugin.mustUpdate != update)
                    plugin.destroy(this);
            this.plugins = newPlugins;
            this.pluginMap.clear();
        }
        else {
            for (let p of this.plugins)
                p.mustUpdate = update;
        }
        for (let i = 0; i < this.plugins.length; i++)
            this.plugins[i].update(this);
        if (prevSpecs != specs)
            this.inputState.ensureHandlers(this.plugins);
    }
    /**
    @internal
    */
    measure(flush = true) {
        if (this.destroyed)
            return;
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        if (this.observer.delayedAndroidKey) {
            this.measureScheduled = -1;
            this.requestMeasure();
            return;
        }
        this.measureScheduled = 0; // Prevent requestMeasure calls from scheduling another animation frame
        if (flush)
            this.observer.forceFlush();
        let updated = null;
        let sDOM = this.scrollDOM, scrollTop = sDOM.scrollTop * this.scaleY;
        let { scrollAnchorPos, scrollAnchorHeight } = this.viewState;
        if (Math.abs(scrollTop - this.viewState.scrollTop) > 1)
            scrollAnchorHeight = -1;
        this.viewState.scrollAnchorHeight = -1;
        try {
            for (let i = 0;; i++) {
                if (scrollAnchorHeight < 0) {
                    if (isScrolledToBottom(sDOM)) {
                        scrollAnchorPos = -1;
                        scrollAnchorHeight = this.viewState.heightMap.height;
                    }
                    else {
                        let block = this.viewState.scrollAnchorAt(scrollTop);
                        scrollAnchorPos = block.from;
                        scrollAnchorHeight = block.top;
                    }
                }
                this.updateState = 1 /* UpdateState.Measuring */;
                let changed = this.viewState.measure(this);
                if (!changed && !this.measureRequests.length && this.viewState.scrollTarget == null)
                    break;
                if (i > 5) {
                    console.warn(this.measureRequests.length
                        ? "Measure loop restarted more than 5 times"
                        : "Viewport failed to stabilize");
                    break;
                }
                let measuring = [];
                // Only run measure requests in this cycle when the viewport didn't change
                if (!(changed & 4 /* UpdateFlag.Viewport */))
                    [this.measureRequests, measuring] = [measuring, this.measureRequests];
                let measured = measuring.map(m => {
                    try {
                        return m.read(this);
                    }
                    catch (e) {
                        dist_logException(this.state, e);
                        return BadMeasure;
                    }
                });
                let update = ViewUpdate.create(this, this.state, []), redrawn = false;
                update.flags |= changed;
                if (!updated)
                    updated = update;
                else
                    updated.flags |= changed;
                this.updateState = 2 /* UpdateState.Updating */;
                if (!update.empty) {
                    this.updatePlugins(update);
                    this.inputState.update(update);
                    this.updateAttrs();
                    redrawn = this.docView.update(update);
                }
                for (let i = 0; i < measuring.length; i++)
                    if (measured[i] != BadMeasure) {
                        try {
                            let m = measuring[i];
                            if (m.write)
                                m.write(measured[i], this);
                        }
                        catch (e) {
                            dist_logException(this.state, e);
                        }
                    }
                if (redrawn)
                    this.docView.updateSelection(true);
                if (!update.viewportChanged && this.measureRequests.length == 0) {
                    if (this.viewState.editorHeight) {
                        if (this.viewState.scrollTarget) {
                            this.docView.scrollIntoView(this.viewState.scrollTarget);
                            this.viewState.scrollTarget = null;
                            scrollAnchorHeight = -1;
                            continue;
                        }
                        else {
                            let newAnchorHeight = scrollAnchorPos < 0 ? this.viewState.heightMap.height :
                                this.viewState.lineBlockAt(scrollAnchorPos).top;
                            let diff = newAnchorHeight - scrollAnchorHeight;
                            if (diff > 1 || diff < -1) {
                                scrollTop = scrollTop + diff;
                                sDOM.scrollTop = scrollTop / this.scaleY;
                                scrollAnchorHeight = -1;
                                continue;
                            }
                        }
                    }
                    break;
                }
            }
        }
        finally {
            this.updateState = 0 /* UpdateState.Idle */;
            this.measureScheduled = -1;
        }
        if (updated && !updated.empty)
            for (let listener of this.state.facet(updateListener))
                listener(updated);
    }
    /**
    Get the CSS classes for the currently active editor themes.
    */
    get themeClasses() {
        return baseThemeID + " " +
            (this.state.facet(darkTheme) ? baseDarkID : baseLightID) + " " +
            this.state.facet(theme);
    }
    updateAttrs() {
        let editorAttrs = attrsFromFacet(this, editorAttributes, {
            class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
        });
        let contentAttrs = {
            spellcheck: "false",
            autocorrect: "off",
            autocapitalize: "off",
            translate: "no",
            contenteditable: !this.state.facet(editable) ? "false" : "true",
            class: "cm-content",
            style: `${browser.tabSize}: ${this.state.tabSize}`,
            role: "textbox",
            "aria-multiline": "true"
        };
        if (this.state.readOnly)
            contentAttrs["aria-readonly"] = "true";
        attrsFromFacet(this, contentAttributes, contentAttrs);
        let changed = this.observer.ignore(() => {
            let changedContent = updateAttrs(this.contentDOM, this.contentAttrs, contentAttrs);
            let changedEditor = updateAttrs(this.dom, this.editorAttrs, editorAttrs);
            return changedContent || changedEditor;
        });
        this.editorAttrs = editorAttrs;
        this.contentAttrs = contentAttrs;
        return changed;
    }
    showAnnouncements(trs) {
        let first = true;
        for (let tr of trs)
            for (let effect of tr.effects)
                if (effect.is(EditorView.announce)) {
                    if (first)
                        this.announceDOM.textContent = "";
                    first = false;
                    let div = this.announceDOM.appendChild(document.createElement("div"));
                    div.textContent = effect.value;
                }
    }
    mountStyles() {
        this.styleModules = this.state.facet(styleModule);
        let nonce = this.state.facet(EditorView.cspNonce);
        StyleModule.mount(this.root, this.styleModules.concat(baseTheme$1).reverse(), nonce ? { nonce } : undefined);
    }
    readMeasured() {
        if (this.updateState == 2 /* UpdateState.Updating */)
            throw new Error("Reading the editor layout isn't allowed during an update");
        if (this.updateState == 0 /* UpdateState.Idle */ && this.measureScheduled > -1)
            this.measure(false);
    }
    /**
    Schedule a layout measurement, optionally providing callbacks to
    do custom DOM measuring followed by a DOM write phase. Using
    this is preferable reading DOM layout directly from, for
    example, an event handler, because it'll make sure measuring and
    drawing done by other components is synchronized, avoiding
    unnecessary DOM layout computations.
    */
    requestMeasure(request) {
        if (this.measureScheduled < 0)
            this.measureScheduled = this.win.requestAnimationFrame(() => this.measure());
        if (request) {
            if (this.measureRequests.indexOf(request) > -1)
                return;
            if (request.key != null)
                for (let i = 0; i < this.measureRequests.length; i++) {
                    if (this.measureRequests[i].key === request.key) {
                        this.measureRequests[i] = request;
                        return;
                    }
                }
            this.measureRequests.push(request);
        }
    }
    /**
    Get the value of a specific plugin, if present. Note that
    plugins that crash can be dropped from a view, so even when you
    know you registered a given plugin, it is recommended to check
    the return value of this method.
    */
    plugin(plugin) {
        let known = this.pluginMap.get(plugin);
        if (known === undefined || known && known.spec != plugin)
            this.pluginMap.set(plugin, known = this.plugins.find(p => p.spec == plugin) || null);
        return known && known.update(this).value;
    }
    /**
    The top position of the document, in screen coordinates. This
    may be negative when the editor is scrolled down. Points
    directly to the top of the first line, not above the padding.
    */
    get documentTop() {
        return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
    }
    /**
    Reports the padding above and below the document.
    */
    get documentPadding() {
        return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
    }
    /**
    If the editor is transformed with CSS, this provides the scale
    along the X axis. Otherwise, it will just be 1. Note that
    transforms other than translation and scaling are not supported.
    */
    get scaleX() { return this.viewState.scaleX; }
    /**
    Provide the CSS transformed scale along the Y axis.
    */
    get scaleY() { return this.viewState.scaleY; }
    /**
    Find the text line or block widget at the given vertical
    position (which is interpreted as relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
    */
    elementAtHeight(height) {
        this.readMeasured();
        return this.viewState.elementAtHeight(height);
    }
    /**
    Find the line block (see
    [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
    height, again interpreted relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
    */
    lineBlockAtHeight(height) {
        this.readMeasured();
        return this.viewState.lineBlockAtHeight(height);
    }
    /**
    Get the extent and vertical position of all [line
    blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
    are relative to the [top of the
    document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
    */
    get viewportLineBlocks() {
        return this.viewState.viewportLines;
    }
    /**
    Find the line block around the given document position. A line
    block is a range delimited on both sides by either a
    non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
    start/end of the document. It will usually just hold a line of
    text, but may be broken into multiple textblocks by block
    widgets.
    */
    lineBlockAt(pos) {
        return this.viewState.lineBlockAt(pos);
    }
    /**
    The editor's total content height.
    */
    get contentHeight() {
        return this.viewState.contentHeight;
    }
    /**
    Move a cursor position by [grapheme
    cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
    the motion is away from the line start, or towards it. In
    bidirectional text, the line is traversed in visual order, using
    the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
    When the start position was the last one on the line, the
    returned position will be across the line break. If there is no
    further line, the original position is returned.
    
    By default, this method moves over a single cluster. The
    optional `by` argument can be used to move across more. It will
    be called with the first cluster as argument, and should return
    a predicate that determines, for each subsequent cluster,
    whether it should also be moved over.
    */
    moveByChar(start, forward, by) {
        return skipAtoms(this, start, moveByChar(this, start, forward, by));
    }
    /**
    Move a cursor position across the next group of either
    [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
    non-whitespace characters.
    */
    moveByGroup(start, forward) {
        return skipAtoms(this, start, moveByChar(this, start, forward, initial => byGroup(this, start.head, initial)));
    }
    /**
    Move to the next line boundary in the given direction. If
    `includeWrap` is true, line wrapping is on, and there is a
    further wrap point on the current line, the wrap point will be
    returned. Otherwise this function will return the start or end
    of the line.
    */
    moveToLineBoundary(start, forward, includeWrap = true) {
        return moveToLineBoundary(this, start, forward, includeWrap);
    }
    /**
    Move a cursor position vertically. When `distance` isn't given,
    it defaults to moving to the next line (including wrapped
    lines). Otherwise, `distance` should provide a positive distance
    in pixels.
    
    When `start` has a
    [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
    motion will use that as a target horizontal position. Otherwise,
    the cursor's own horizontal position is used. The returned
    cursor will have its goal column set to whichever column was
    used.
    */
    moveVertically(start, forward, distance) {
        return skipAtoms(this, start, moveVertically(this, start, forward, distance));
    }
    /**
    Find the DOM parent node and offset (child offset if `node` is
    an element, character offset when it is a text node) at the
    given document position.
    
    Note that for positions that aren't currently in
    `visibleRanges`, the resulting DOM position isn't necessarily
    meaningful (it may just point before or after a placeholder
    element).
    */
    domAtPos(pos) {
        return this.docView.domAtPos(pos);
    }
    /**
    Find the document position at the given DOM node. Can be useful
    for associating positions with DOM events. Will raise an error
    when `node` isn't part of the editor content.
    */
    posAtDOM(node, offset = 0) {
        return this.docView.posFromDOM(node, offset);
    }
    posAtCoords(coords, precise = true) {
        this.readMeasured();
        return posAtCoords(this, coords, precise);
    }
    /**
    Get the screen coordinates at the given document position.
    `side` determines whether the coordinates are based on the
    element before (-1) or after (1) the position (if no element is
    available on the given side, the method will transparently use
    another strategy to get reasonable coordinates).
    */
    coordsAtPos(pos, side = 1) {
        this.readMeasured();
        let rect = this.docView.coordsAt(pos, side);
        if (!rect || rect.left == rect.right)
            return rect;
        let line = this.state.doc.lineAt(pos), order = this.bidiSpans(line);
        let span = order[BidiSpan.find(order, pos - line.from, -1, side)];
        return flattenRect(rect, (span.dir == Direction.LTR) == (side > 0));
    }
    /**
    Return the rectangle around a given character. If `pos` does not
    point in front of a character that is in the viewport and
    rendered (i.e. not replaced, not a line break), this will return
    null. For space characters that are a line wrap point, this will
    return the position before the line break.
    */
    coordsForChar(pos) {
        this.readMeasured();
        return this.docView.coordsForChar(pos);
    }
    /**
    The default width of a character in the editor. May not
    accurately reflect the width of all characters (given variable
    width fonts or styling of invididual ranges).
    */
    get defaultCharacterWidth() { return this.viewState.heightOracle.charWidth; }
    /**
    The default height of a line in the editor. May not be accurate
    for all lines.
    */
    get defaultLineHeight() { return this.viewState.heightOracle.lineHeight; }
    /**
    The text direction
    ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
    CSS property) of the editor's content element.
    */
    get textDirection() { return this.viewState.defaultTextDirection; }
    /**
    Find the text direction of the block at the given position, as
    assigned by CSS. If
    [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
    isn't enabled, or the given position is outside of the viewport,
    this will always return the same as
    [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
    this may trigger a DOM layout.
    */
    textDirectionAt(pos) {
        let perLine = this.state.facet(perLineTextDirection);
        if (!perLine || pos < this.viewport.from || pos > this.viewport.to)
            return this.textDirection;
        this.readMeasured();
        return this.docView.textDirectionAt(pos);
    }
    /**
    Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
    (as determined by the
    [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
    CSS property of its content element).
    */
    get lineWrapping() { return this.viewState.heightOracle.lineWrapping; }
    /**
    Returns the bidirectional text structure of the given line
    (which should be in the current document) as an array of span
    objects. The order of these spans matches the [text
    direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
    left-to-right, the leftmost spans come first, otherwise the
    rightmost spans come first.
    */
    bidiSpans(line) {
        if (line.length > MaxBidiLine)
            return trivialOrder(line.length);
        let dir = this.textDirectionAt(line.from), isolates;
        for (let entry of this.bidiCache) {
            if (entry.from == line.from && entry.dir == dir &&
                (entry.fresh || isolatesEq(entry.isolates, isolates = getIsolatedRanges(this, line.from, line.to))))
                return entry.order;
        }
        if (!isolates)
            isolates = getIsolatedRanges(this, line.from, line.to);
        let order = computeOrder(line.text, dir, isolates);
        this.bidiCache.push(new CachedOrder(line.from, line.to, dir, isolates, true, order));
        return order;
    }
    /**
    Check whether the editor has focus.
    */
    get hasFocus() {
        var _a;
        // Safari return false for hasFocus when the context menu is open
        // or closing, which leads us to ignore selection changes from the
        // context menu because it looks like the editor isn't focused.
        // This kludges around that.
        return (this.dom.ownerDocument.hasFocus() || browser.safari && ((_a = this.inputState) === null || _a === void 0 ? void 0 : _a.lastContextMenu) > Date.now() - 3e4) &&
            this.root.activeElement == this.contentDOM;
    }
    /**
    Put focus on the editor.
    */
    focus() {
        this.observer.ignore(() => {
            focusPreventScroll(this.contentDOM);
            this.docView.updateSelection();
        });
    }
    /**
    Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
    necessary when moving the editor's existing DOM to a new window or shadow root.
    */
    setRoot(root) {
        if (this._root != root) {
            this._root = root;
            this.observer.setWindow((root.nodeType == 9 ? root : root.ownerDocument).defaultView || window);
            this.mountStyles();
        }
    }
    /**
    Clean up this editor view, removing its element from the
    document, unregistering event handlers, and notifying
    plugins. The view instance can no longer be used after
    calling this.
    */
    destroy() {
        for (let plugin of this.plugins)
            plugin.destroy(this);
        this.plugins = [];
        this.inputState.destroy();
        this.docView.destroy();
        this.dom.remove();
        this.observer.destroy();
        if (this.measureScheduled > -1)
            this.win.cancelAnimationFrame(this.measureScheduled);
        this.destroyed = true;
    }
    /**
    Returns an effect that can be
    [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
    cause it to scroll the given position or range into view.
    */
    static scrollIntoView(pos, options = {}) {
        return scrollIntoView.of(new ScrollTarget(typeof pos == "number" ? dist_EditorSelection.cursor(pos) : pos, options.y, options.x, options.yMargin, options.xMargin));
    }
    /**
    Return an effect that resets the editor to its current (at the
    time this method was called) scroll position. Note that this
    only affects the editor's own scrollable element, not parents.
    See also
    [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
    
    The effect should be used with a document identical to the one
    it was created for. Failing to do so is not an error, but may
    not scroll to the expected position. You can
    [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
    */
    scrollSnapshot() {
        let { scrollTop, scrollLeft } = this.scrollDOM;
        let ref = this.viewState.scrollAnchorAt(scrollTop);
        return scrollIntoView.of(new ScrollTarget(dist_EditorSelection.cursor(ref.from), "start", "start", ref.top - scrollTop, scrollLeft, true));
    }
    /**
    Returns an extension that can be used to add DOM event handlers.
    The value should be an object mapping event names to handler
    functions. For any given event, such functions are ordered by
    extension precedence, and the first handler to return true will
    be assumed to have handled that event, and no other handlers or
    built-in behavior will be activated for it. These are registered
    on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
    for `scroll` handlers, which will be called any time the
    editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
    its parent nodes is scrolled.
    */
    static domEventHandlers(handlers) {
        return dist_ViewPlugin.define(() => ({}), { eventHandlers: handlers });
    }
    /**
    Create an extension that registers DOM event observers. Contrary
    to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
    observers can't be prevented from running by a higher-precedence
    handler returning true. They also don't prevent other handlers
    and observers from running when they return true, and should not
    call `preventDefault`.
    */
    static domEventObservers(observers) {
        return dist_ViewPlugin.define(() => ({}), { eventObservers: observers });
    }
    /**
    Create a theme extension. The first argument can be a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)
    style spec providing the styles for the theme. These will be
    prefixed with a generated class for the style.
    
    Because the selectors will be prefixed with a scope class, rule
    that directly match the editor's [wrapper
    element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
    added—need to be explicitly differentiated by adding an `&` to
    the selector for that element—for example
    `&.cm-focused`.
    
    When `dark` is set to true, the theme will be marked as dark,
    which will cause the `&dark` rules from [base
    themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
    `&light` when a light theme is active).
    */
    static theme(spec, options) {
        let prefix = StyleModule.newName();
        let result = [theme.of(prefix), styleModule.of(buildTheme(`.${prefix}`, spec))];
        if (options && options.dark)
            result.push(darkTheme.of(true));
        return result;
    }
    /**
    Create an extension that adds styles to the base theme. Like
    with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
    place of the editor wrapper element when directly targeting
    that. You can also use `&dark` or `&light` instead to only
    target editors with a dark or light theme.
    */
    static baseTheme(spec) {
        return Prec.lowest(styleModule.of(buildTheme("." + baseThemeID, spec, lightDarkIDs)));
    }
    /**
    Retrieve an editor view instance from the view's DOM
    representation.
    */
    static findFromDOM(dom) {
        var _a;
        let content = dom.querySelector(".cm-content");
        let cView = content && ContentView.get(content) || ContentView.get(dom);
        return ((_a = cView === null || cView === void 0 ? void 0 : cView.rootView) === null || _a === void 0 ? void 0 : _a.view) || null;
    }
}
/**
Facet to add a [style
module](https://github.com/marijnh/style-mod#documentation) to
an editor view. The view will ensure that the module is
mounted in its [document
root](https://codemirror.net/6/docs/ref/#view.EditorView.constructor^config.root).
*/
EditorView.styleModule = styleModule;
/**
An input handler can override the way changes to the editable
DOM content are handled. Handlers are passed the document
positions between which the change was found, and the new
content. When one returns true, no further input handlers are
called and the default behavior is prevented.

The `insert` argument can be used to get the default transaction
that would be applied for this input. This can be useful when
dispatching the custom behavior as a separate transaction.
*/
EditorView.inputHandler = inputHandler;
/**
This facet can be used to provide functions that create effects
to be dispatched when the editor's focus state changes.
*/
EditorView.focusChangeEffect = focusChangeEffect;
/**
By default, the editor assumes all its content has the same
[text direction](https://codemirror.net/6/docs/ref/#view.Direction). Configure this with a `true`
value to make it read the text direction of every (rendered)
line separately.
*/
EditorView.perLineTextDirection = perLineTextDirection;
/**
Allows you to provide a function that should be called when the
library catches an exception from an extension (mostly from view
plugins, but may be used by other extensions to route exceptions
from user-code-provided callbacks). This is mostly useful for
debugging and logging. See [`logException`](https://codemirror.net/6/docs/ref/#view.logException).
*/
EditorView.exceptionSink = exceptionSink;
/**
A facet that can be used to register a function to be called
every time the view updates.
*/
EditorView.updateListener = updateListener;
/**
Facet that controls whether the editor content DOM is editable.
When its highest-precedence value is `false`, the element will
not have its `contenteditable` attribute set. (Note that this
doesn't affect API calls that change the editor content, even
when those are bound to keys or buttons. See the
[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) facet for that.)
*/
EditorView.editable = editable;
/**
Allows you to influence the way mouse selection happens. The
functions in this facet will be called for a `mousedown` event
on the editor, and can return an object that overrides the way a
selection is computed from that mouse click or drag.
*/
EditorView.mouseSelectionStyle = mouseSelectionStyle;
/**
Facet used to configure whether a given selection drag event
should move or copy the selection. The given predicate will be
called with the `mousedown` event, and can return `true` when
the drag should move the content.
*/
EditorView.dragMovesSelection = dragMovesSelection$1;
/**
Facet used to configure whether a given selecting click adds a
new range to the existing selection or replaces it entirely. The
default behavior is to check `event.metaKey` on macOS, and
`event.ctrlKey` elsewhere.
*/
EditorView.clickAddsSelectionRange = clickAddsSelectionRange;
/**
A facet that determines which [decorations](https://codemirror.net/6/docs/ref/#view.Decoration)
are shown in the view. Decorations can be provided in two
ways—directly, or via a function that takes an editor view.

Only decoration sets provided directly are allowed to influence
the editor's vertical layout structure. The ones provided as
functions are called _after_ the new viewport has been computed,
and thus **must not** introduce block widgets or replacing
decorations that cover line breaks.

If you want decorated ranges to behave like atomic units for
cursor motion and deletion purposes, also provide the range set
containing the decorations to
[`EditorView.atomicRanges`](https://codemirror.net/6/docs/ref/#view.EditorView^atomicRanges).
*/
EditorView.decorations = decorations;
/**
Used to provide ranges that should be treated as atoms as far as
cursor motion is concerned. This causes methods like
[`moveByChar`](https://codemirror.net/6/docs/ref/#view.EditorView.moveByChar) and
[`moveVertically`](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) (and the
commands built on top of them) to skip across such regions when
a selection endpoint would enter them. This does _not_ prevent
direct programmatic [selection
updates](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) from moving into such
regions.
*/
EditorView.atomicRanges = atomicRanges;
/**
When range decorations add a `unicode-bidi: isolate` style, they
should also include a
[`bidiIsolate`](https://codemirror.net/6/docs/ref/#view.MarkDecorationSpec.bidiIsolate) property
in their decoration spec, and be exposed through this facet, so
that the editor can compute the proper text order. (Other values
for `unicode-bidi`, except of course `normal`, are not
supported.)
*/
EditorView.bidiIsolatedRanges = bidiIsolatedRanges;
/**
Facet that allows extensions to provide additional scroll
margins (space around the sides of the scrolling element that
should be considered invisible). This can be useful when the
plugin introduces elements that cover part of that element (for
example a horizontally fixed gutter).
*/
EditorView.scrollMargins = scrollMargins;
/**
This facet records whether a dark theme is active. The extension
returned by [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme) automatically
includes an instance of this when the `dark` option is set to
true.
*/
EditorView.darkTheme = darkTheme;
/**
Provides a Content Security Policy nonce to use when creating
the style sheets for the editor. Holds the empty string when no
nonce has been provided.
*/
EditorView.cspNonce = /*@__PURE__*/Facet.define({ combine: values => values.length ? values[0] : "" });
/**
Facet that provides additional DOM attributes for the editor's
editable DOM element.
*/
EditorView.contentAttributes = contentAttributes;
/**
Facet that provides DOM attributes for the editor's outer
element.
*/
EditorView.editorAttributes = editorAttributes;
/**
An extension that enables line wrapping in the editor (by
setting CSS `white-space` to `pre-wrap` in the content).
*/
EditorView.lineWrapping = /*@__PURE__*/EditorView.contentAttributes.of({ "class": "cm-lineWrapping" });
/**
State effect used to include screen reader announcements in a
transaction. These will be added to the DOM in a visually hidden
element with `aria-live="polite"` set, and should be used to
describe effects that are visually obvious but may not be
noticed by screen reader users (such as moving to the next
search match).
*/
EditorView.announce = /*@__PURE__*/StateEffect.define();
// Maximum line length for which we compute accurate bidi info
const MaxBidiLine = 4096;
const BadMeasure = {};
class CachedOrder {
    constructor(from, to, dir, isolates, fresh, order) {
        this.from = from;
        this.to = to;
        this.dir = dir;
        this.isolates = isolates;
        this.fresh = fresh;
        this.order = order;
    }
    static update(cache, changes) {
        if (changes.empty && !cache.some(c => c.fresh))
            return cache;
        let result = [], lastDir = cache.length ? cache[cache.length - 1].dir : Direction.LTR;
        for (let i = Math.max(0, cache.length - 10); i < cache.length; i++) {
            let entry = cache[i];
            if (entry.dir == lastDir && !changes.touchesRange(entry.from, entry.to))
                result.push(new CachedOrder(changes.mapPos(entry.from, 1), changes.mapPos(entry.to, -1), entry.dir, entry.isolates, false, entry.order));
        }
        return result;
    }
}
function attrsFromFacet(view, facet, base) {
    for (let sources = view.state.facet(facet), i = sources.length - 1; i >= 0; i--) {
        let source = sources[i], value = typeof source == "function" ? source(view) : source;
        if (value)
            combineAttrs(value, base);
    }
    return base;
}

const currentPlatform = browser.mac ? "mac" : browser.windows ? "win" : browser.linux ? "linux" : "key";
function normalizeKeyName(name, platform) {
    const parts = name.split(/-(?!$)/);
    let result = parts[parts.length - 1];
    if (result == "Space")
        result = " ";
    let alt, ctrl, shift, meta;
    for (let i = 0; i < parts.length - 1; ++i) {
        const mod = parts[i];
        if (/^(cmd|meta|m)$/i.test(mod))
            meta = true;
        else if (/^a(lt)?$/i.test(mod))
            alt = true;
        else if (/^(c|ctrl|control)$/i.test(mod))
            ctrl = true;
        else if (/^s(hift)?$/i.test(mod))
            shift = true;
        else if (/^mod$/i.test(mod)) {
            if (platform == "mac")
                meta = true;
            else
                ctrl = true;
        }
        else
            throw new Error("Unrecognized modifier name: " + mod);
    }
    if (alt)
        result = "Alt-" + result;
    if (ctrl)
        result = "Ctrl-" + result;
    if (meta)
        result = "Meta-" + result;
    if (shift)
        result = "Shift-" + result;
    return result;
}
function modifiers(name, event, shift) {
    if (event.altKey)
        name = "Alt-" + name;
    if (event.ctrlKey)
        name = "Ctrl-" + name;
    if (event.metaKey)
        name = "Meta-" + name;
    if (shift !== false && event.shiftKey)
        name = "Shift-" + name;
    return name;
}
const handleKeyEvents = /*@__PURE__*/Prec.default(/*@__PURE__*/EditorView.domEventHandlers({
    keydown(event, view) {
        return runHandlers(getKeymap(view.state), event, view, "editor");
    }
}));
/**
Facet used for registering keymaps.

You can add multiple keymaps to an editor. Their priorities
determine their precedence (the ones specified early or with high
priority get checked first). When a handler has returned `true`
for a given key, no further handlers are called.
*/
const dist_keymap = /*@__PURE__*/Facet.define({ enables: handleKeyEvents });
const Keymaps = /*@__PURE__*/new WeakMap();
// This is hidden behind an indirection, rather than directly computed
// by the facet, to keep internal types out of the facet's type.
function getKeymap(state) {
    let bindings = state.facet(dist_keymap);
    let map = Keymaps.get(bindings);
    if (!map)
        Keymaps.set(bindings, map = buildKeymap(bindings.reduce((a, b) => a.concat(b), [])));
    return map;
}
/**
Run the key handlers registered for a given scope. The event
object should be a `"keydown"` event. Returns true if any of the
handlers handled it.
*/
function runScopeHandlers(view, event, scope) {
    return runHandlers(getKeymap(view.state), event, view, scope);
}
let storedPrefix = null;
const PrefixTimeout = 4000;
function buildKeymap(bindings, platform = currentPlatform) {
    let bound = Object.create(null);
    let isPrefix = Object.create(null);
    let checkPrefix = (name, is) => {
        let current = isPrefix[name];
        if (current == null)
            isPrefix[name] = is;
        else if (current != is)
            throw new Error("Key binding " + name + " is used both as a regular binding and as a multi-stroke prefix");
    };
    let add = (scope, key, command, preventDefault, stopPropagation) => {
        var _a, _b;
        let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
        let parts = key.split(/ (?!$)/).map(k => normalizeKeyName(k, platform));
        for (let i = 1; i < parts.length; i++) {
            let prefix = parts.slice(0, i).join(" ");
            checkPrefix(prefix, true);
            if (!scopeObj[prefix])
                scopeObj[prefix] = {
                    preventDefault: true,
                    stopPropagation: false,
                    run: [(view) => {
                            let ourObj = storedPrefix = { view, prefix, scope };
                            setTimeout(() => { if (storedPrefix == ourObj)
                                storedPrefix = null; }, PrefixTimeout);
                            return true;
                        }]
                };
        }
        let full = parts.join(" ");
        checkPrefix(full, false);
        let binding = scopeObj[full] || (scopeObj[full] = {
            preventDefault: false,
            stopPropagation: false,
            run: ((_b = (_a = scopeObj._any) === null || _a === void 0 ? void 0 : _a.run) === null || _b === void 0 ? void 0 : _b.slice()) || []
        });
        if (command)
            binding.run.push(command);
        if (preventDefault)
            binding.preventDefault = true;
        if (stopPropagation)
            binding.stopPropagation = true;
    };
    for (let b of bindings) {
        let scopes = b.scope ? b.scope.split(" ") : ["editor"];
        if (b.any)
            for (let scope of scopes) {
                let scopeObj = bound[scope] || (bound[scope] = Object.create(null));
                if (!scopeObj._any)
                    scopeObj._any = { preventDefault: false, stopPropagation: false, run: [] };
                for (let key in scopeObj)
                    scopeObj[key].run.push(b.any);
            }
        let name = b[platform] || b.key;
        if (!name)
            continue;
        for (let scope of scopes) {
            add(scope, name, b.run, b.preventDefault, b.stopPropagation);
            if (b.shift)
                add(scope, "Shift-" + name, b.shift, b.preventDefault, b.stopPropagation);
        }
    }
    return bound;
}
function runHandlers(map, event, view, scope) {
    let name = keyName(event);
    let charCode = codePointAt(name, 0), isChar = codePointSize(charCode) == name.length && name != " ";
    let prefix = "", handled = false, prevented = false, stopPropagation = false;
    if (storedPrefix && storedPrefix.view == view && storedPrefix.scope == scope) {
        prefix = storedPrefix.prefix + " ";
        if (modifierCodes.indexOf(event.keyCode) < 0) {
            prevented = true;
            storedPrefix = null;
        }
    }
    let ran = new Set;
    let runFor = (binding) => {
        if (binding) {
            for (let cmd of binding.run)
                if (!ran.has(cmd)) {
                    ran.add(cmd);
                    if (cmd(view, event)) {
                        if (binding.stopPropagation)
                            stopPropagation = true;
                        return true;
                    }
                }
            if (binding.preventDefault) {
                if (binding.stopPropagation)
                    stopPropagation = true;
                prevented = true;
            }
        }
        return false;
    };
    let scopeObj = map[scope], baseName, shiftName;
    if (scopeObj) {
        if (runFor(scopeObj[prefix + modifiers(name, event, !isChar)])) {
            handled = true;
        }
        else if (isChar && (event.altKey || event.metaKey || event.ctrlKey) &&
            // Ctrl-Alt may be used for AltGr on Windows
            !(browser.windows && event.ctrlKey && event.altKey) &&
            (baseName = base[event.keyCode]) && baseName != name) {
            if (runFor(scopeObj[prefix + modifiers(baseName, event, true)])) {
                handled = true;
            }
            else if (event.shiftKey && (shiftName = shift[event.keyCode]) != name && shiftName != baseName &&
                runFor(scopeObj[prefix + modifiers(shiftName, event, false)])) {
                handled = true;
            }
        }
        else if (isChar && event.shiftKey &&
            runFor(scopeObj[prefix + modifiers(name, event, true)])) {
            handled = true;
        }
        if (!handled && runFor(scopeObj._any))
            handled = true;
    }
    if (prevented)
        handled = true;
    if (handled && stopPropagation)
        event.stopPropagation();
    return handled;
}

/**
Implementation of [`LayerMarker`](https://codemirror.net/6/docs/ref/#view.LayerMarker) that creates
a rectangle at a given set of coordinates.
*/
class RectangleMarker {
    /**
    Create a marker with the given class and dimensions. If `width`
    is null, the DOM element will get no width style.
    */
    constructor(className, 
    /**
    The left position of the marker (in pixels, document-relative).
    */
    left, 
    /**
    The top position of the marker.
    */
    top, 
    /**
    The width of the marker, or null if it shouldn't get a width assigned.
    */
    width, 
    /**
    The height of the marker.
    */
    height) {
        this.className = className;
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
    }
    draw() {
        let elt = document.createElement("div");
        elt.className = this.className;
        this.adjust(elt);
        return elt;
    }
    update(elt, prev) {
        if (prev.className != this.className)
            return false;
        this.adjust(elt);
        return true;
    }
    adjust(elt) {
        elt.style.left = this.left + "px";
        elt.style.top = this.top + "px";
        if (this.width != null)
            elt.style.width = this.width + "px";
        elt.style.height = this.height + "px";
    }
    eq(p) {
        return this.left == p.left && this.top == p.top && this.width == p.width && this.height == p.height &&
            this.className == p.className;
    }
    /**
    Create a set of rectangles for the given selection range,
    assigning them theclass`className`. Will create a single
    rectangle for empty ranges, and a set of selection-style
    rectangles covering the range's content (in a bidi-aware
    way) for non-empty ones.
    */
    static forRange(view, className, range) {
        if (range.empty) {
            let pos = view.coordsAtPos(range.head, range.assoc || 1);
            if (!pos)
                return [];
            let base = getBase(view);
            return [new RectangleMarker(className, pos.left - base.left, pos.top - base.top, null, pos.bottom - pos.top)];
        }
        else {
            return rectanglesForRange(view, className, range);
        }
    }
}
function getBase(view) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let left = view.textDirection == Direction.LTR ? rect.left : rect.right - view.scrollDOM.clientWidth * view.scaleX;
    return { left: left - view.scrollDOM.scrollLeft * view.scaleX, top: rect.top - view.scrollDOM.scrollTop * view.scaleY };
}
function wrappedLine(view, pos, inside) {
    let range = dist_EditorSelection.cursor(pos);
    return { from: Math.max(inside.from, view.moveToLineBoundary(range, false, true).from),
        to: Math.min(inside.to, view.moveToLineBoundary(range, true, true).from),
        type: BlockType.Text };
}
function rectanglesForRange(view, className, range) {
    if (range.to <= view.viewport.from || range.from >= view.viewport.to)
        return [];
    let from = Math.max(range.from, view.viewport.from), to = Math.min(range.to, view.viewport.to);
    let ltr = view.textDirection == Direction.LTR;
    let content = view.contentDOM, contentRect = content.getBoundingClientRect(), base = getBase(view);
    let lineElt = content.querySelector(".cm-line"), lineStyle = lineElt && window.getComputedStyle(lineElt);
    let leftSide = contentRect.left +
        (lineStyle ? parseInt(lineStyle.paddingLeft) + Math.min(0, parseInt(lineStyle.textIndent)) : 0);
    let rightSide = contentRect.right - (lineStyle ? parseInt(lineStyle.paddingRight) : 0);
    let startBlock = blockAt(view, from), endBlock = blockAt(view, to);
    let visualStart = startBlock.type == BlockType.Text ? startBlock : null;
    let visualEnd = endBlock.type == BlockType.Text ? endBlock : null;
    if (visualStart && (view.lineWrapping || startBlock.widgetLineBreaks))
        visualStart = wrappedLine(view, from, visualStart);
    if (visualEnd && (view.lineWrapping || endBlock.widgetLineBreaks))
        visualEnd = wrappedLine(view, to, visualEnd);
    if (visualStart && visualEnd && visualStart.from == visualEnd.from) {
        return pieces(drawForLine(range.from, range.to, visualStart));
    }
    else {
        let top = visualStart ? drawForLine(range.from, null, visualStart) : drawForWidget(startBlock, false);
        let bottom = visualEnd ? drawForLine(null, range.to, visualEnd) : drawForWidget(endBlock, true);
        let between = [];
        if ((visualStart || startBlock).to < (visualEnd || endBlock).from - (visualStart && visualEnd ? 1 : 0) ||
            startBlock.widgetLineBreaks > 1 && top.bottom + view.defaultLineHeight / 2 < bottom.top)
            between.push(piece(leftSide, top.bottom, rightSide, bottom.top));
        else if (top.bottom < bottom.top && view.elementAtHeight((top.bottom + bottom.top) / 2).type == BlockType.Text)
            top.bottom = bottom.top = (top.bottom + bottom.top) / 2;
        return pieces(top).concat(between).concat(pieces(bottom));
    }
    function piece(left, top, right, bottom) {
        return new RectangleMarker(className, left - base.left, top - base.top - 0.01 /* C.Epsilon */, right - left, bottom - top + 0.01 /* C.Epsilon */);
    }
    function pieces({ top, bottom, horizontal }) {
        let pieces = [];
        for (let i = 0; i < horizontal.length; i += 2)
            pieces.push(piece(horizontal[i], top, horizontal[i + 1], bottom));
        return pieces;
    }
    // Gets passed from/to in line-local positions
    function drawForLine(from, to, line) {
        let top = 1e9, bottom = -1e9, horizontal = [];
        function addSpan(from, fromOpen, to, toOpen, dir) {
            // Passing 2/-2 is a kludge to force the view to return
            // coordinates on the proper side of block widgets, since
            // normalizing the side there, though appropriate for most
            // coordsAtPos queries, would break selection drawing.
            let fromCoords = view.coordsAtPos(from, (from == line.to ? -2 : 2));
            let toCoords = view.coordsAtPos(to, (to == line.from ? 2 : -2));
            if (!fromCoords || !toCoords)
                return;
            top = Math.min(fromCoords.top, toCoords.top, top);
            bottom = Math.max(fromCoords.bottom, toCoords.bottom, bottom);
            if (dir == Direction.LTR)
                horizontal.push(ltr && fromOpen ? leftSide : fromCoords.left, ltr && toOpen ? rightSide : toCoords.right);
            else
                horizontal.push(!ltr && toOpen ? leftSide : toCoords.left, !ltr && fromOpen ? rightSide : fromCoords.right);
        }
        let start = from !== null && from !== void 0 ? from : line.from, end = to !== null && to !== void 0 ? to : line.to;
        // Split the range by visible range and document line
        for (let r of view.visibleRanges)
            if (r.to > start && r.from < end) {
                for (let pos = Math.max(r.from, start), endPos = Math.min(r.to, end);;) {
                    let docLine = view.state.doc.lineAt(pos);
                    for (let span of view.bidiSpans(docLine)) {
                        let spanFrom = span.from + docLine.from, spanTo = span.to + docLine.from;
                        if (spanFrom >= endPos)
                            break;
                        if (spanTo > pos)
                            addSpan(Math.max(spanFrom, pos), from == null && spanFrom <= start, Math.min(spanTo, endPos), to == null && spanTo >= end, span.dir);
                    }
                    pos = docLine.to + 1;
                    if (pos >= endPos)
                        break;
                }
            }
        if (horizontal.length == 0)
            addSpan(start, from == null, end, to == null, view.textDirection);
        return { top, bottom, horizontal };
    }
    function drawForWidget(block, top) {
        let y = contentRect.top + (top ? block.top : block.bottom);
        return { top: y, bottom: y, horizontal: [] };
    }
}
function sameMarker(a, b) {
    return a.constructor == b.constructor && a.eq(b);
}
class LayerView {
    constructor(view, layer) {
        this.view = view;
        this.layer = layer;
        this.drawn = [];
        this.scaleX = 1;
        this.scaleY = 1;
        this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) };
        this.dom = view.scrollDOM.appendChild(document.createElement("div"));
        this.dom.classList.add("cm-layer");
        if (layer.above)
            this.dom.classList.add("cm-layer-above");
        if (layer.class)
            this.dom.classList.add(layer.class);
        this.scale();
        this.dom.setAttribute("aria-hidden", "true");
        this.setOrder(view.state);
        view.requestMeasure(this.measureReq);
        if (layer.mount)
            layer.mount(this.dom, view);
    }
    update(update) {
        if (update.startState.facet(layerOrder) != update.state.facet(layerOrder))
            this.setOrder(update.state);
        if (this.layer.update(update, this.dom) || update.geometryChanged) {
            this.scale();
            update.view.requestMeasure(this.measureReq);
        }
    }
    setOrder(state) {
        let pos = 0, order = state.facet(layerOrder);
        while (pos < order.length && order[pos] != this.layer)
            pos++;
        this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - pos);
    }
    measure() {
        return this.layer.markers(this.view);
    }
    scale() {
        let { scaleX, scaleY } = this.view;
        if (scaleX != this.scaleX || scaleY != this.scaleY) {
            this.scaleX = scaleX;
            this.scaleY = scaleY;
            this.dom.style.transform = `scale(${1 / scaleX}, ${1 / scaleY})`;
        }
    }
    draw(markers) {
        if (markers.length != this.drawn.length || markers.some((p, i) => !sameMarker(p, this.drawn[i]))) {
            let old = this.dom.firstChild, oldI = 0;
            for (let marker of markers) {
                if (marker.update && old && marker.constructor && this.drawn[oldI].constructor &&
                    marker.update(old, this.drawn[oldI])) {
                    old = old.nextSibling;
                    oldI++;
                }
                else {
                    this.dom.insertBefore(marker.draw(), old);
                }
            }
            while (old) {
                let next = old.nextSibling;
                old.remove();
                old = next;
            }
            this.drawn = markers;
        }
    }
    destroy() {
        if (this.layer.destroy)
            this.layer.destroy(this.dom, this.view);
        this.dom.remove();
    }
}
const layerOrder = /*@__PURE__*/Facet.define();
/**
Define a layer.
*/
function dist_layer(config) {
    return [
        dist_ViewPlugin.define(v => new LayerView(v, config)),
        layerOrder.of(config)
    ];
}

const CanHidePrimary = !browser.ios; // FIXME test IE
const selectionConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            cursorBlinkRate: 1200,
            drawRangeCursor: true
        }, {
            cursorBlinkRate: (a, b) => Math.min(a, b),
            drawRangeCursor: (a, b) => a || b
        });
    }
});
/**
Returns an extension that hides the browser's native selection and
cursor, replacing the selection with a background behind the text
(with the `cm-selectionBackground` class), and the
cursors with elements overlaid over the code (using
`cm-cursor-primary` and `cm-cursor-secondary`).

This allows the editor to display secondary selection ranges, and
tends to produce a type of selection more in line with that users
expect in a text editor (the native selection styling will often
leave gaps between lines and won't fill the horizontal space after
a line when the selection continues past it).

It does have a performance cost, in that it requires an extra DOM
layout cycle for many updates (the selection is drawn based on DOM
layout information that's only available after laying out the
content).
*/
function dist_drawSelection(config = {}) {
    return [
        selectionConfig.of(config),
        cursorLayer,
        selectionLayer,
        hideNativeSelection,
        nativeSelectionHidden.of(true)
    ];
}
/**
Retrieve the [`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) configuration
for this state. (Note that this will return a set of defaults even
if `drawSelection` isn't enabled.)
*/
function getDrawSelectionConfig(state) {
    return state.facet(selectionConfig);
}
function configChanged(update) {
    return update.startState.facet(selectionConfig) != update.state.facet(selectionConfig);
}
const cursorLayer = /*@__PURE__*/dist_layer({
    above: true,
    markers(view) {
        let { state } = view, conf = state.facet(selectionConfig);
        let cursors = [];
        for (let r of state.selection.ranges) {
            let prim = r == state.selection.main;
            if (r.empty ? !prim || CanHidePrimary : conf.drawRangeCursor) {
                let className = prim ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary";
                let cursor = r.empty ? r : dist_EditorSelection.cursor(r.head, r.head > r.anchor ? -1 : 1);
                for (let piece of RectangleMarker.forRange(view, className, cursor))
                    cursors.push(piece);
            }
        }
        return cursors;
    },
    update(update, dom) {
        if (update.transactions.some(tr => tr.selection))
            dom.style.animationName = dom.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink";
        let confChange = configChanged(update);
        if (confChange)
            setBlinkRate(update.state, dom);
        return update.docChanged || update.selectionSet || confChange;
    },
    mount(dom, view) {
        setBlinkRate(view.state, dom);
    },
    class: "cm-cursorLayer"
});
function setBlinkRate(state, dom) {
    dom.style.animationDuration = state.facet(selectionConfig).cursorBlinkRate + "ms";
}
const selectionLayer = /*@__PURE__*/dist_layer({
    above: false,
    markers(view) {
        return view.state.selection.ranges.map(r => r.empty ? [] : RectangleMarker.forRange(view, "cm-selectionBackground", r))
            .reduce((a, b) => a.concat(b));
    },
    update(update, dom) {
        return update.docChanged || update.selectionSet || update.viewportChanged || configChanged(update);
    },
    class: "cm-selectionLayer"
});
const themeSpec = {
    ".cm-line": {
        "& ::selection": { backgroundColor: "transparent !important" },
        "&::selection": { backgroundColor: "transparent !important" }
    }
};
if (CanHidePrimary) {
    themeSpec[".cm-line"].caretColor = "transparent !important";
    themeSpec[".cm-content"] = { caretColor: "transparent !important" };
}
const hideNativeSelection = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.theme(themeSpec));

const setDropCursorPos = /*@__PURE__*/StateEffect.define({
    map(pos, mapping) { return pos == null ? null : mapping.mapPos(pos); }
});
const dropCursorPos = /*@__PURE__*/StateField.define({
    create() { return null; },
    update(pos, tr) {
        if (pos != null)
            pos = tr.changes.mapPos(pos);
        return tr.effects.reduce((pos, e) => e.is(setDropCursorPos) ? e.value : pos, pos);
    }
});
const drawDropCursor = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.cursor = null;
        this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
    }
    update(update) {
        var _a;
        let cursorPos = update.state.field(dropCursorPos);
        if (cursorPos == null) {
            if (this.cursor != null) {
                (_a = this.cursor) === null || _a === void 0 ? void 0 : _a.remove();
                this.cursor = null;
            }
        }
        else {
            if (!this.cursor) {
                this.cursor = this.view.scrollDOM.appendChild(document.createElement("div"));
                this.cursor.className = "cm-dropCursor";
            }
            if (update.startState.field(dropCursorPos) != cursorPos || update.docChanged || update.geometryChanged)
                this.view.requestMeasure(this.measureReq);
        }
    }
    readPos() {
        let { view } = this;
        let pos = view.state.field(dropCursorPos);
        let rect = pos != null && view.coordsAtPos(pos);
        if (!rect)
            return null;
        let outer = view.scrollDOM.getBoundingClientRect();
        return {
            left: rect.left - outer.left + view.scrollDOM.scrollLeft * view.scaleX,
            top: rect.top - outer.top + view.scrollDOM.scrollTop * view.scaleY,
            height: rect.bottom - rect.top
        };
    }
    drawCursor(pos) {
        if (this.cursor) {
            let { scaleX, scaleY } = this.view;
            if (pos) {
                this.cursor.style.left = pos.left / scaleX + "px";
                this.cursor.style.top = pos.top / scaleY + "px";
                this.cursor.style.height = pos.height / scaleY + "px";
            }
            else {
                this.cursor.style.left = "-100000px";
            }
        }
    }
    destroy() {
        if (this.cursor)
            this.cursor.remove();
    }
    setDropPos(pos) {
        if (this.view.state.field(dropCursorPos) != pos)
            this.view.dispatch({ effects: setDropCursorPos.of(pos) });
    }
}, {
    eventObservers: {
        dragover(event) {
            this.setDropPos(this.view.posAtCoords({ x: event.clientX, y: event.clientY }));
        },
        dragleave(event) {
            if (event.target == this.view.contentDOM || !this.view.contentDOM.contains(event.relatedTarget))
                this.setDropPos(null);
        },
        dragend() {
            this.setDropPos(null);
        },
        drop() {
            this.setDropPos(null);
        }
    }
});
/**
Draws a cursor at the current drop position when something is
dragged over the editor.
*/
function dropCursor() {
    return [dropCursorPos, drawDropCursor];
}

function iterMatches(doc, re, from, to, f) {
    re.lastIndex = 0;
    for (let cursor = doc.iterRange(from, to), pos = from, m; !cursor.next().done; pos += cursor.value.length) {
        if (!cursor.lineBreak)
            while (m = re.exec(cursor.value))
                f(pos + m.index, m);
    }
}
function matchRanges(view, maxLength) {
    let visible = view.visibleRanges;
    if (visible.length == 1 && visible[0].from == view.viewport.from &&
        visible[0].to == view.viewport.to)
        return visible;
    let result = [];
    for (let { from, to } of visible) {
        from = Math.max(view.state.doc.lineAt(from).from, from - maxLength);
        to = Math.min(view.state.doc.lineAt(to).to, to + maxLength);
        if (result.length && result[result.length - 1].to >= from)
            result[result.length - 1].to = to;
        else
            result.push({ from, to });
    }
    return result;
}
/**
Helper class used to make it easier to maintain decorations on
visible code that matches a given regular expression. To be used
in a [view plugin](https://codemirror.net/6/docs/ref/#view.ViewPlugin). Instances of this object
represent a matching configuration.
*/
class MatchDecorator {
    /**
    Create a decorator.
    */
    constructor(config) {
        const { regexp, decoration, decorate, boundary, maxLength = 1000 } = config;
        if (!regexp.global)
            throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
        this.regexp = regexp;
        if (decorate) {
            this.addMatch = (match, view, from, add) => decorate(add, from, from + match[0].length, match, view);
        }
        else if (typeof decoration == "function") {
            this.addMatch = (match, view, from, add) => {
                let deco = decoration(match, view, from);
                if (deco)
                    add(from, from + match[0].length, deco);
            };
        }
        else if (decoration) {
            this.addMatch = (match, _view, from, add) => add(from, from + match[0].length, decoration);
        }
        else {
            throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
        }
        this.boundary = boundary;
        this.maxLength = maxLength;
    }
    /**
    Compute the full set of decorations for matches in the given
    view's viewport. You'll want to call this when initializing your
    plugin.
    */
    createDeco(view) {
        let build = new RangeSetBuilder(), add = build.add.bind(build);
        for (let { from, to } of matchRanges(view, this.maxLength))
            iterMatches(view.state.doc, this.regexp, from, to, (from, m) => this.addMatch(m, view, from, add));
        return build.finish();
    }
    /**
    Update a set of decorations for a view update. `deco` _must_ be
    the set of decorations produced by _this_ `MatchDecorator` for
    the view state before the update.
    */
    updateDeco(update, deco) {
        let changeFrom = 1e9, changeTo = -1;
        if (update.docChanged)
            update.changes.iterChanges((_f, _t, from, to) => {
                if (to > update.view.viewport.from && from < update.view.viewport.to) {
                    changeFrom = Math.min(from, changeFrom);
                    changeTo = Math.max(to, changeTo);
                }
            });
        if (update.viewportChanged || changeTo - changeFrom > 1000)
            return this.createDeco(update.view);
        if (changeTo > -1)
            return this.updateRange(update.view, deco.map(update.changes), changeFrom, changeTo);
        return deco;
    }
    updateRange(view, deco, updateFrom, updateTo) {
        for (let r of view.visibleRanges) {
            let from = Math.max(r.from, updateFrom), to = Math.min(r.to, updateTo);
            if (to > from) {
                let fromLine = view.state.doc.lineAt(from), toLine = fromLine.to < to ? view.state.doc.lineAt(to) : fromLine;
                let start = Math.max(r.from, fromLine.from), end = Math.min(r.to, toLine.to);
                if (this.boundary) {
                    for (; from > fromLine.from; from--)
                        if (this.boundary.test(fromLine.text[from - 1 - fromLine.from])) {
                            start = from;
                            break;
                        }
                    for (; to < toLine.to; to++)
                        if (this.boundary.test(toLine.text[to - toLine.from])) {
                            end = to;
                            break;
                        }
                }
                let ranges = [], m;
                let add = (from, to, deco) => ranges.push(deco.range(from, to));
                if (fromLine == toLine) {
                    this.regexp.lastIndex = start - fromLine.from;
                    while ((m = this.regexp.exec(fromLine.text)) && m.index < end - fromLine.from)
                        this.addMatch(m, view, m.index + fromLine.from, add);
                }
                else {
                    iterMatches(view.state.doc, this.regexp, start, end, (from, m) => this.addMatch(m, view, from, add));
                }
                deco = deco.update({ filterFrom: start, filterTo: end, filter: (from, to) => from < start || to > end, add: ranges });
            }
        }
        return deco;
    }
}

const UnicodeRegexpSupport = /x/.unicode != null ? "gu" : "g";
const Specials = /*@__PURE__*/new RegExp("[\u0000-\u0008\u000a-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]", UnicodeRegexpSupport);
const Names = {
    0: "null",
    7: "bell",
    8: "backspace",
    10: "newline",
    11: "vertical tab",
    13: "carriage return",
    27: "escape",
    8203: "zero width space",
    8204: "zero width non-joiner",
    8205: "zero width joiner",
    8206: "left-to-right mark",
    8207: "right-to-left mark",
    8232: "line separator",
    8237: "left-to-right override",
    8238: "right-to-left override",
    8294: "left-to-right isolate",
    8295: "right-to-left isolate",
    8297: "pop directional isolate",
    8233: "paragraph separator",
    65279: "zero width no-break space",
    65532: "object replacement"
};
let _supportsTabSize = null;
function supportsTabSize() {
    var _a;
    if (_supportsTabSize == null && typeof document != "undefined" && document.body) {
        let styles = document.body.style;
        _supportsTabSize = ((_a = styles.tabSize) !== null && _a !== void 0 ? _a : styles.MozTabSize) != null;
    }
    return _supportsTabSize || false;
}
const specialCharConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        let config = combineConfig(configs, {
            render: null,
            specialChars: Specials,
            addSpecialChars: null
        });
        if (config.replaceTabs = !supportsTabSize())
            config.specialChars = new RegExp("\t|" + config.specialChars.source, UnicodeRegexpSupport);
        if (config.addSpecialChars)
            config.specialChars = new RegExp(config.specialChars.source + "|" + config.addSpecialChars.source, UnicodeRegexpSupport);
        return config;
    }
});
/**
Returns an extension that installs highlighting of special
characters.
*/
function dist_highlightSpecialChars(
/**
Configuration options.
*/
config = {}) {
    return [specialCharConfig.of(config), specialCharPlugin()];
}
let _plugin = null;
function specialCharPlugin() {
    return _plugin || (_plugin = dist_ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.decorations = Decoration.none;
            this.decorationCache = Object.create(null);
            this.decorator = this.makeDecorator(view.state.facet(specialCharConfig));
            this.decorations = this.decorator.createDeco(view);
        }
        makeDecorator(conf) {
            return new MatchDecorator({
                regexp: conf.specialChars,
                decoration: (m, view, pos) => {
                    let { doc } = view.state;
                    let code = codePointAt(m[0], 0);
                    if (code == 9) {
                        let line = doc.lineAt(pos);
                        let size = view.state.tabSize, col = countColumn(line.text, size, pos - line.from);
                        return Decoration.replace({
                            widget: new TabWidget((size - (col % size)) * this.view.defaultCharacterWidth / this.view.scaleX)
                        });
                    }
                    return this.decorationCache[code] ||
                        (this.decorationCache[code] = Decoration.replace({ widget: new SpecialCharWidget(conf, code) }));
                },
                boundary: conf.replaceTabs ? undefined : /[^]/
            });
        }
        update(update) {
            let conf = update.state.facet(specialCharConfig);
            if (update.startState.facet(specialCharConfig) != conf) {
                this.decorator = this.makeDecorator(conf);
                this.decorations = this.decorator.createDeco(update.view);
            }
            else {
                this.decorations = this.decorator.updateDeco(update, this.decorations);
            }
        }
    }, {
        decorations: v => v.decorations
    }));
}
const DefaultPlaceholder = "\u2022";
// Assigns placeholder characters from the Control Pictures block to
// ASCII control characters
function placeholder$1(code) {
    if (code >= 32)
        return DefaultPlaceholder;
    if (code == 10)
        return "\u2424";
    return String.fromCharCode(9216 + code);
}
class SpecialCharWidget extends WidgetType {
    constructor(options, code) {
        super();
        this.options = options;
        this.code = code;
    }
    eq(other) { return other.code == this.code; }
    toDOM(view) {
        let ph = placeholder$1(this.code);
        let desc = view.state.phrase("Control character") + " " + (Names[this.code] || "0x" + this.code.toString(16));
        let custom = this.options.render && this.options.render(this.code, desc, ph);
        if (custom)
            return custom;
        let span = document.createElement("span");
        span.textContent = ph;
        span.title = desc;
        span.setAttribute("aria-label", desc);
        span.className = "cm-specialChar";
        return span;
    }
    ignoreEvent() { return false; }
}
class TabWidget extends WidgetType {
    constructor(width) {
        super();
        this.width = width;
    }
    eq(other) { return other.width == this.width; }
    toDOM() {
        let span = document.createElement("span");
        span.textContent = "\t";
        span.className = "cm-tab";
        span.style.width = this.width + "px";
        return span;
    }
    ignoreEvent() { return false; }
}

const dist_plugin = /*@__PURE__*/(/* unused pure expression or super */ null && (dist_ViewPlugin.fromClass(class {
    constructor() {
        this.height = 1000;
        this.attrs = { style: "padding-bottom: 1000px" };
    }
    update(update) {
        let { view } = update;
        let height = view.viewState.editorHeight * view.scaleY -
            view.defaultLineHeight - view.documentPadding.top - 0.5;
        if (height >= 0 && height != this.height) {
            this.height = height;
            this.attrs = { style: `padding-bottom: ${height}px` };
        }
    }
})));
/**
Returns an extension that makes sure the content has a bottom
margin equivalent to the height of the editor, minus one line
height, so that every line in the document can be scrolled to the
top of the editor.

This is only meaningful when the editor is scrollable, and should
not be enabled in editors that take the size of their content.
*/
function scrollPastEnd() {
    return [dist_plugin, contentAttributes.of(view => { var _a; return ((_a = view.plugin(dist_plugin)) === null || _a === void 0 ? void 0 : _a.attrs) || null; })];
}

/**
Mark lines that have a cursor on them with the `"cm-activeLine"`
DOM class.
*/
function highlightActiveLine() {
    return activeLineHighlighter;
}
const lineDeco = /*@__PURE__*/Decoration.line({ class: "cm-activeLine" });
const activeLineHighlighter = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.docChanged || update.selectionSet)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let lastLineStart = -1, deco = [];
        for (let r of view.state.selection.ranges) {
            let line = view.lineBlockAt(r.head);
            if (line.from > lastLineStart) {
                deco.push(lineDeco.range(line.from));
                lastLineStart = line.from;
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});

class Placeholder extends (/* unused pure expression or super */ null && (WidgetType)) {
    constructor(content) {
        super();
        this.content = content;
    }
    toDOM() {
        let wrap = document.createElement("span");
        wrap.className = "cm-placeholder";
        wrap.style.pointerEvents = "none";
        wrap.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content);
        if (typeof this.content == "string")
            wrap.setAttribute("aria-label", "placeholder " + this.content);
        else
            wrap.setAttribute("aria-hidden", "true");
        return wrap;
    }
    coordsAt(dom) {
        let rects = dom.firstChild ? clientRectsFor(dom.firstChild) : [];
        if (!rects.length)
            return null;
        let style = window.getComputedStyle(dom.parentNode);
        let rect = flattenRect(rects[0], style.direction != "rtl");
        let lineHeight = parseInt(style.lineHeight);
        if (rect.bottom - rect.top > lineHeight * 1.5)
            return { left: rect.left, right: rect.right, top: rect.top, bottom: rect.top + lineHeight };
        return rect;
    }
    ignoreEvent() { return false; }
}
/**
Extension that enables a placeholder—a piece of example content
to show when the editor is empty.
*/
function placeholder(content) {
    return dist_ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.placeholder = content
                ? Decoration.set([Decoration.widget({ widget: new Placeholder(content), side: 1 }).range(0)])
                : Decoration.none;
        }
        get decorations() { return this.view.state.doc.length ? Decoration.none : this.placeholder; }
    }, { decorations: v => v.decorations });
}

// Don't compute precise column positions for line offsets above this
// (since it could get expensive). Assume offset==column for them.
const MaxOff = 2000;
function rectangleFor(state, a, b) {
    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);
    let ranges = [];
    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {
        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            if (line.length <= endOff)
                ranges.push(dist_EditorSelection.range(line.from + startOff, line.to + endOff));
        }
    }
    else {
        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);
        for (let i = startLine; i <= endLine; i++) {
            let line = state.doc.line(i);
            let start = findColumn(line.text, startCol, state.tabSize, true);
            if (start < 0) {
                ranges.push(dist_EditorSelection.cursor(line.to));
            }
            else {
                let end = findColumn(line.text, endCol, state.tabSize);
                ranges.push(dist_EditorSelection.range(line.from + start, line.from + end));
            }
        }
    }
    return ranges;
}
function absoluteColumn(view, x) {
    let ref = view.coordsAtPos(view.viewport.from);
    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;
}
function getPos(view, event) {
    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);
    let line = view.state.doc.lineAt(offset), off = offset - line.from;
    let col = off > MaxOff ? -1
        : off == line.length ? absoluteColumn(view, event.clientX)
            : countColumn(line.text, view.state.tabSize, offset - line.from);
    return { line: line.number, col, off };
}
function rectangleSelectionStyle(view, event) {
    let start = getPos(view, event), startSel = view.state.selection;
    if (!start)
        return null;
    return {
        update(update) {
            if (update.docChanged) {
                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);
                let newLine = update.state.doc.lineAt(newStart);
                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };
                startSel = startSel.map(update.changes);
            }
        },
        get(event, _extend, multiple) {
            let cur = getPos(view, event);
            if (!cur)
                return startSel;
            let ranges = rectangleFor(view.state, start, cur);
            if (!ranges.length)
                return startSel;
            if (multiple)
                return dist_EditorSelection.create(ranges.concat(startSel.ranges));
            else
                return dist_EditorSelection.create(ranges);
        }
    };
}
/**
Create an extension that enables rectangular selections. By
default, it will react to left mouse drag with the Alt key held
down. When such a selection occurs, the text within the rectangle
that was dragged over will be selected, as one selection
[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.
*/
function rectangularSelection(options) {
    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);
    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);
}
const keys = {
    Alt: [18, e => !!e.altKey],
    Control: [17, e => !!e.ctrlKey],
    Shift: [16, e => !!e.shiftKey],
    Meta: [91, e => !!e.metaKey]
};
const showCrosshair = { style: "cursor: crosshair" };
/**
Returns an extension that turns the pointer cursor into a
crosshair when a given modifier key, defaulting to Alt, is held
down. Can serve as a visual hint that rectangular selection is
going to happen when paired with
[`rectangularSelection`](https://codemirror.net/6/docs/ref/#view.rectangularSelection).
*/
function crosshairCursor(options = {}) {
    let [code, getter] = keys[options.key || "Alt"];
    let plugin = dist_ViewPlugin.fromClass(class {
        constructor(view) {
            this.view = view;
            this.isDown = false;
        }
        set(isDown) {
            if (this.isDown != isDown) {
                this.isDown = isDown;
                this.view.update([]);
            }
        }
    }, {
        eventObservers: {
            keydown(e) {
                this.set(e.keyCode == code || getter(e));
            },
            keyup(e) {
                if (e.keyCode == code || !getter(e))
                    this.set(false);
            },
            mousemove(e) {
                this.set(getter(e));
            }
        }
    });
    return [
        plugin,
        EditorView.contentAttributes.of(view => { var _a; return ((_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.isDown) ? showCrosshair : null; })
    ];
}

const Outside = "-10000px";
class TooltipViewManager {
    constructor(view, facet, createTooltipView) {
        this.facet = facet;
        this.createTooltipView = createTooltipView;
        this.input = view.state.facet(facet);
        this.tooltips = this.input.filter(t => t);
        this.tooltipViews = this.tooltips.map(createTooltipView);
    }
    update(update, above) {
        var _a;
        let input = update.state.facet(this.facet);
        let tooltips = input.filter(x => x);
        if (input === this.input) {
            for (let t of this.tooltipViews)
                if (t.update)
                    t.update(update);
            return false;
        }
        let tooltipViews = [], newAbove = above ? [] : null;
        for (let i = 0; i < tooltips.length; i++) {
            let tip = tooltips[i], known = -1;
            if (!tip)
                continue;
            for (let i = 0; i < this.tooltips.length; i++) {
                let other = this.tooltips[i];
                if (other && other.create == tip.create)
                    known = i;
            }
            if (known < 0) {
                tooltipViews[i] = this.createTooltipView(tip);
                if (newAbove)
                    newAbove[i] = !!tip.above;
            }
            else {
                let tooltipView = tooltipViews[i] = this.tooltipViews[known];
                if (newAbove)
                    newAbove[i] = above[known];
                if (tooltipView.update)
                    tooltipView.update(update);
            }
        }
        for (let t of this.tooltipViews)
            if (tooltipViews.indexOf(t) < 0) {
                t.dom.remove();
                (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
            }
        if (above) {
            newAbove.forEach((val, i) => above[i] = val);
            above.length = newAbove.length;
        }
        this.input = input;
        this.tooltips = tooltips;
        this.tooltipViews = tooltipViews;
        return true;
    }
}
/**
Creates an extension that configures tooltip behavior.
*/
function tooltips(config = {}) {
    return tooltipConfig.of(config);
}
function windowSpace(view) {
    let { win } = view;
    return { top: 0, left: 0, bottom: win.innerHeight, right: win.innerWidth };
}
const tooltipConfig = /*@__PURE__*/Facet.define({
    combine: values => {
        var _a, _b, _c;
        return ({
            position: browser.ios ? "absolute" : ((_a = values.find(conf => conf.position)) === null || _a === void 0 ? void 0 : _a.position) || "fixed",
            parent: ((_b = values.find(conf => conf.parent)) === null || _b === void 0 ? void 0 : _b.parent) || null,
            tooltipSpace: ((_c = values.find(conf => conf.tooltipSpace)) === null || _c === void 0 ? void 0 : _c.tooltipSpace) || windowSpace,
        });
    }
});
const knownHeight = /*@__PURE__*/new WeakMap();
const tooltipPlugin = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.above = [];
        this.inView = true;
        this.madeAbsolute = false;
        this.lastTransaction = 0;
        this.measureTimeout = -1;
        let config = view.state.facet(tooltipConfig);
        this.position = config.position;
        this.parent = config.parent;
        this.classes = view.themeClasses;
        this.createContainer();
        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };
        this.manager = new TooltipViewManager(view, showTooltip, t => this.createTooltip(t));
        this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver(entries => {
            if (Date.now() > this.lastTransaction - 50 &&
                entries.length > 0 && entries[entries.length - 1].intersectionRatio < 1)
                this.measureSoon();
        }, { threshold: [1] }) : null;
        this.observeIntersection();
        view.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this));
        this.maybeMeasure();
    }
    createContainer() {
        if (this.parent) {
            this.container = document.createElement("div");
            this.container.style.position = "relative";
            this.container.className = this.view.themeClasses;
            this.parent.appendChild(this.container);
        }
        else {
            this.container = this.view.dom;
        }
    }
    observeIntersection() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            for (let tooltip of this.manager.tooltipViews)
                this.intersectionObserver.observe(tooltip.dom);
        }
    }
    measureSoon() {
        if (this.measureTimeout < 0)
            this.measureTimeout = setTimeout(() => {
                this.measureTimeout = -1;
                this.maybeMeasure();
            }, 50);
    }
    update(update) {
        if (update.transactions.length)
            this.lastTransaction = Date.now();
        let updated = this.manager.update(update, this.above);
        if (updated)
            this.observeIntersection();
        let shouldMeasure = updated || update.geometryChanged;
        let newConfig = update.state.facet(tooltipConfig);
        if (newConfig.position != this.position && !this.madeAbsolute) {
            this.position = newConfig.position;
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = this.position;
            shouldMeasure = true;
        }
        if (newConfig.parent != this.parent) {
            if (this.parent)
                this.container.remove();
            this.parent = newConfig.parent;
            this.createContainer();
            for (let t of this.manager.tooltipViews)
                this.container.appendChild(t.dom);
            shouldMeasure = true;
        }
        else if (this.parent && this.view.themeClasses != this.classes) {
            this.classes = this.container.className = this.view.themeClasses;
        }
        if (shouldMeasure)
            this.maybeMeasure();
    }
    createTooltip(tooltip) {
        let tooltipView = tooltip.create(this.view);
        tooltipView.dom.classList.add("cm-tooltip");
        if (tooltip.arrow && !tooltipView.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
            let arrow = document.createElement("div");
            arrow.className = "cm-tooltip-arrow";
            tooltipView.dom.appendChild(arrow);
        }
        tooltipView.dom.style.position = this.position;
        tooltipView.dom.style.top = Outside;
        tooltipView.dom.style.left = "0px";
        this.container.appendChild(tooltipView.dom);
        if (tooltipView.mount)
            tooltipView.mount(this.view);
        return tooltipView;
    }
    destroy() {
        var _a, _b;
        this.view.win.removeEventListener("resize", this.measureSoon);
        for (let tooltipView of this.manager.tooltipViews) {
            tooltipView.dom.remove();
            (_a = tooltipView.destroy) === null || _a === void 0 ? void 0 : _a.call(tooltipView);
        }
        if (this.parent)
            this.container.remove();
        (_b = this.intersectionObserver) === null || _b === void 0 ? void 0 : _b.disconnect();
        clearTimeout(this.measureTimeout);
    }
    readMeasure() {
        let editor = this.view.dom.getBoundingClientRect();
        let scaleX = 1, scaleY = 1, makeAbsolute = false;
        if (this.position == "fixed" && this.manager.tooltipViews.length) {
            let { dom } = this.manager.tooltipViews[0];
            if (browser.gecko) {
                // Firefox sets the element's `offsetParent` to the
                // transformed element when a transform interferes with fixed
                // positioning.
                makeAbsolute = dom.offsetParent != this.container.ownerDocument.body;
            }
            else if (dom.style.top == Outside && dom.style.left == "0px") {
                // On other browsers, we have to awkwardly try and use other
                // information to detect a transform.
                let rect = dom.getBoundingClientRect();
                makeAbsolute = Math.abs(rect.top + 10000) > 1 || Math.abs(rect.left) > 1;
            }
        }
        if (makeAbsolute || this.position == "absolute") {
            if (this.parent) {
                let rect = this.parent.getBoundingClientRect();
                if (rect.width && rect.height) {
                    scaleX = rect.width / this.parent.offsetWidth;
                    scaleY = rect.height / this.parent.offsetHeight;
                }
            }
            else {
                ({ scaleX, scaleY } = this.view.viewState);
            }
        }
        return {
            editor,
            parent: this.parent ? this.container.getBoundingClientRect() : editor,
            pos: this.manager.tooltips.map((t, i) => {
                let tv = this.manager.tooltipViews[i];
                return tv.getCoords ? tv.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
            }),
            size: this.manager.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),
            space: this.view.state.facet(tooltipConfig).tooltipSpace(this.view),
            scaleX, scaleY, makeAbsolute
        };
    }
    writeMeasure(measured) {
        var _a;
        if (measured.makeAbsolute) {
            this.madeAbsolute = true;
            this.position = "absolute";
            for (let t of this.manager.tooltipViews)
                t.dom.style.position = "absolute";
        }
        let { editor, space, scaleX, scaleY } = measured;
        let others = [];
        for (let i = 0; i < this.manager.tooltips.length; i++) {
            let tooltip = this.manager.tooltips[i], tView = this.manager.tooltipViews[i], { dom } = tView;
            let pos = measured.pos[i], size = measured.size[i];
            // Hide tooltips that are outside of the editor.
            if (!pos || pos.bottom <= Math.max(editor.top, space.top) ||
                pos.top >= Math.min(editor.bottom, space.bottom) ||
                pos.right < Math.max(editor.left, space.left) - .1 ||
                pos.left > Math.min(editor.right, space.right) + .1) {
                dom.style.top = Outside;
                continue;
            }
            let arrow = tooltip.arrow ? tView.dom.querySelector(".cm-tooltip-arrow") : null;
            let arrowHeight = arrow ? 7 /* Arrow.Size */ : 0;
            let width = size.right - size.left, height = (_a = knownHeight.get(tView)) !== null && _a !== void 0 ? _a : size.bottom - size.top;
            let offset = tView.offset || noOffset, ltr = this.view.textDirection == Direction.LTR;
            let left = size.width > space.right - space.left ? (ltr ? space.left : space.right - size.width)
                : ltr ? Math.min(pos.left - (arrow ? 14 /* Arrow.Offset */ : 0) + offset.x, space.right - width)
                    : Math.max(space.left, pos.left - width + (arrow ? 14 /* Arrow.Offset */ : 0) - offset.x);
            let above = this.above[i];
            if (!tooltip.strictSide && (above
                ? pos.top - (size.bottom - size.top) - offset.y < space.top
                : pos.bottom + (size.bottom - size.top) + offset.y > space.bottom) &&
                above == (space.bottom - pos.bottom > pos.top - space.top))
                above = this.above[i] = !above;
            let spaceVert = (above ? pos.top - space.top : space.bottom - pos.bottom) - arrowHeight;
            if (spaceVert < height && tView.resize !== false) {
                if (spaceVert < this.view.defaultLineHeight) {
                    dom.style.top = Outside;
                    continue;
                }
                knownHeight.set(tView, height);
                dom.style.height = (height = spaceVert) / scaleY + "px";
            }
            else if (dom.style.height) {
                dom.style.height = "";
            }
            let top = above ? pos.top - height - arrowHeight - offset.y : pos.bottom + arrowHeight + offset.y;
            let right = left + width;
            if (tView.overlap !== true)
                for (let r of others)
                    if (r.left < right && r.right > left && r.top < top + height && r.bottom > top)
                        top = above ? r.top - height - 2 - arrowHeight : r.bottom + arrowHeight + 2;
            if (this.position == "absolute") {
                dom.style.top = (top - measured.parent.top) / scaleY + "px";
                dom.style.left = (left - measured.parent.left) / scaleX + "px";
            }
            else {
                dom.style.top = top / scaleY + "px";
                dom.style.left = left / scaleX + "px";
            }
            if (arrow) {
                let arrowLeft = pos.left + (ltr ? offset.x : -offset.x) - (left + 14 /* Arrow.Offset */ - 7 /* Arrow.Size */);
                arrow.style.left = arrowLeft / scaleX + "px";
            }
            if (tView.overlap !== true)
                others.push({ left, top, right, bottom: top + height });
            dom.classList.toggle("cm-tooltip-above", above);
            dom.classList.toggle("cm-tooltip-below", !above);
            if (tView.positioned)
                tView.positioned(measured.space);
        }
    }
    maybeMeasure() {
        if (this.manager.tooltips.length) {
            if (this.view.inView)
                this.view.requestMeasure(this.measureReq);
            if (this.inView != this.view.inView) {
                this.inView = this.view.inView;
                if (!this.inView)
                    for (let tv of this.manager.tooltipViews)
                        tv.dom.style.top = Outside;
            }
        }
    }
}, {
    eventObservers: {
        scroll() { this.maybeMeasure(); }
    }
});
const baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip": {
        zIndex: 100,
        boxSizing: "border-box"
    },
    "&light .cm-tooltip": {
        border: "1px solid #bbb",
        backgroundColor: "#f5f5f5"
    },
    "&light .cm-tooltip-section:not(:first-child)": {
        borderTop: "1px solid #bbb",
    },
    "&dark .cm-tooltip": {
        backgroundColor: "#333338",
        color: "white"
    },
    ".cm-tooltip-arrow": {
        height: `${7 /* Arrow.Size */}px`,
        width: `${7 /* Arrow.Size */ * 2}px`,
        position: "absolute",
        zIndex: -1,
        overflow: "hidden",
        "&:before, &:after": {
            content: "''",
            position: "absolute",
            width: 0,
            height: 0,
            borderLeft: `${7 /* Arrow.Size */}px solid transparent`,
            borderRight: `${7 /* Arrow.Size */}px solid transparent`,
        },
        ".cm-tooltip-above &": {
            bottom: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderTop: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderTop: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                bottom: "1px"
            }
        },
        ".cm-tooltip-below &": {
            top: `-${7 /* Arrow.Size */}px`,
            "&:before": {
                borderBottom: `${7 /* Arrow.Size */}px solid #bbb`,
            },
            "&:after": {
                borderBottom: `${7 /* Arrow.Size */}px solid #f5f5f5`,
                top: "1px"
            }
        },
    },
    "&dark .cm-tooltip .cm-tooltip-arrow": {
        "&:before": {
            borderTopColor: "#333338",
            borderBottomColor: "#333338"
        },
        "&:after": {
            borderTopColor: "transparent",
            borderBottomColor: "transparent"
        }
    }
});
const noOffset = { x: 0, y: 0 };
/**
Facet to which an extension can add a value to show a tooltip.
*/
const showTooltip = /*@__PURE__*/Facet.define({
    enables: [tooltipPlugin, baseTheme]
});
const showHoverTooltip = /*@__PURE__*/Facet.define();
class HoverTooltipHost {
    // Needs to be static so that host tooltip instances always match
    static create(view) {
        return new HoverTooltipHost(view);
    }
    constructor(view) {
        this.view = view;
        this.mounted = false;
        this.dom = document.createElement("div");
        this.dom.classList.add("cm-tooltip-hover");
        this.manager = new TooltipViewManager(view, showHoverTooltip, t => this.createHostedView(t));
    }
    createHostedView(tooltip) {
        let hostedView = tooltip.create(this.view);
        hostedView.dom.classList.add("cm-tooltip-section");
        this.dom.appendChild(hostedView.dom);
        if (this.mounted && hostedView.mount)
            hostedView.mount(this.view);
        return hostedView;
    }
    mount(view) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.mount)
                hostedView.mount(view);
        }
        this.mounted = true;
    }
    positioned(space) {
        for (let hostedView of this.manager.tooltipViews) {
            if (hostedView.positioned)
                hostedView.positioned(space);
        }
    }
    update(update) {
        this.manager.update(update);
    }
    destroy() {
        var _a;
        for (let t of this.manager.tooltipViews)
            (_a = t.destroy) === null || _a === void 0 ? void 0 : _a.call(t);
    }
    passProp(name) {
        let value = undefined;
        for (let view of this.manager.tooltipViews) {
            let given = view[name];
            if (given !== undefined) {
                if (value === undefined)
                    value = given;
                else if (value !== given)
                    return undefined;
            }
        }
        return value;
    }
    get offset() { return this.passProp("offset"); }
    get getCoords() { return this.passProp("getCoords"); }
    get overlap() { return this.passProp("overlap"); }
    get resize() { return this.passProp("resize"); }
}
const showHoverTooltipHost = /*@__PURE__*/showTooltip.compute([showHoverTooltip], state => {
    let tooltips = state.facet(showHoverTooltip).filter(t => t);
    if (tooltips.length === 0)
        return null;
    return {
        pos: Math.min(...tooltips.map(t => t.pos)),
        end: Math.max(...tooltips.map(t => { var _a; return (_a = t.end) !== null && _a !== void 0 ? _a : t.pos; })),
        create: HoverTooltipHost.create,
        above: tooltips[0].above,
        arrow: tooltips.some(t => t.arrow),
    };
});
class HoverPlugin {
    constructor(view, source, field, setHover, hoverTime) {
        this.view = view;
        this.source = source;
        this.field = field;
        this.setHover = setHover;
        this.hoverTime = hoverTime;
        this.hoverTimeout = -1;
        this.restartTimeout = -1;
        this.pending = null;
        this.lastMove = { x: 0, y: 0, target: view.dom, time: 0 };
        this.checkHover = this.checkHover.bind(this);
        view.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this));
        view.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
    }
    update() {
        if (this.pending) {
            this.pending = null;
            clearTimeout(this.restartTimeout);
            this.restartTimeout = setTimeout(() => this.startHover(), 20);
        }
    }
    get active() {
        return this.view.state.field(this.field);
    }
    checkHover() {
        this.hoverTimeout = -1;
        if (this.active)
            return;
        let hovered = Date.now() - this.lastMove.time;
        if (hovered < this.hoverTime)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - hovered);
        else
            this.startHover();
    }
    startHover() {
        clearTimeout(this.restartTimeout);
        let { view, lastMove } = this;
        let desc = view.docView.nearest(lastMove.target);
        if (!desc)
            return;
        let pos, side = 1;
        if (desc instanceof WidgetView) {
            pos = desc.posAtStart;
        }
        else {
            pos = view.posAtCoords(lastMove);
            if (pos == null)
                return;
            let posCoords = view.coordsAtPos(pos);
            if (!posCoords ||
                lastMove.y < posCoords.top || lastMove.y > posCoords.bottom ||
                lastMove.x < posCoords.left - view.defaultCharacterWidth ||
                lastMove.x > posCoords.right + view.defaultCharacterWidth)
                return;
            let bidi = view.bidiSpans(view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);
            let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;
            side = (lastMove.x < posCoords.left ? -rtl : rtl);
        }
        let open = this.source(view, pos, side);
        if (open === null || open === void 0 ? void 0 : open.then) {
            let pending = this.pending = { pos };
            open.then(result => {
                if (this.pending == pending) {
                    this.pending = null;
                    if (result)
                        view.dispatch({ effects: this.setHover.of(result) });
                }
            }, e => dist_logException(view.state, e, "hover tooltip"));
        }
        else if (open) {
            view.dispatch({ effects: this.setHover.of(open) });
        }
    }
    get tooltip() {
        let plugin = this.view.plugin(tooltipPlugin);
        let index = plugin ? plugin.manager.tooltips.findIndex(t => t.create == HoverTooltipHost.create) : -1;
        return index > -1 ? plugin.manager.tooltipViews[index] : null;
    }
    mousemove(event) {
        var _a;
        this.lastMove = { x: event.clientX, y: event.clientY, target: event.target, time: Date.now() };
        if (this.hoverTimeout < 0)
            this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime);
        let { active, tooltip } = this;
        if (active && tooltip && !isInTooltip(tooltip.dom, event) || this.pending) {
            let { pos } = active || this.pending, end = (_a = active === null || active === void 0 ? void 0 : active.end) !== null && _a !== void 0 ? _a : pos;
            if ((pos == end ? this.view.posAtCoords(this.lastMove) != pos
                : !isOverRange(this.view, pos, end, event.clientX, event.clientY))) {
                this.view.dispatch({ effects: this.setHover.of(null) });
                this.pending = null;
            }
        }
    }
    mouseleave(event) {
        clearTimeout(this.hoverTimeout);
        this.hoverTimeout = -1;
        let { active } = this;
        if (active) {
            let { tooltip } = this;
            let inTooltip = tooltip && tooltip.dom.contains(event.relatedTarget);
            if (!inTooltip)
                this.view.dispatch({ effects: this.setHover.of(null) });
            else
                this.watchTooltipLeave(tooltip.dom);
        }
    }
    watchTooltipLeave(tooltip) {
        let watch = (event) => {
            tooltip.removeEventListener("mouseleave", watch);
            if (this.active && !this.view.dom.contains(event.relatedTarget))
                this.view.dispatch({ effects: this.setHover.of(null) });
        };
        tooltip.addEventListener("mouseleave", watch);
    }
    destroy() {
        clearTimeout(this.hoverTimeout);
        this.view.dom.removeEventListener("mouseleave", this.mouseleave);
        this.view.dom.removeEventListener("mousemove", this.mousemove);
    }
}
const tooltipMargin = 4;
function isInTooltip(tooltip, event) {
    let rect = tooltip.getBoundingClientRect();
    return event.clientX >= rect.left - tooltipMargin && event.clientX <= rect.right + tooltipMargin &&
        event.clientY >= rect.top - tooltipMargin && event.clientY <= rect.bottom + tooltipMargin;
}
function isOverRange(view, from, to, x, y, margin) {
    let rect = view.scrollDOM.getBoundingClientRect();
    let docBottom = view.documentTop + view.documentPadding.top + view.contentHeight;
    if (rect.left > x || rect.right < x || rect.top > y || Math.min(rect.bottom, docBottom) < y)
        return false;
    let pos = view.posAtCoords({ x, y }, false);
    return pos >= from && pos <= to;
}
/**
Set up a hover tooltip, which shows up when the pointer hovers
over ranges of text. The callback is called when the mouse hovers
over the document text. It should, if there is a tooltip
associated with position `pos`, return the tooltip description
(either directly or in a promise). The `side` argument indicates
on which side of the position the pointer is—it will be -1 if the
pointer is before the position, 1 if after the position.

Note that all hover tooltips are hosted within a single tooltip
container element. This allows multiple tooltips over the same
range to be "merged" together without overlapping.
*/
function hoverTooltip(source, options = {}) {
    let setHover = StateEffect.define();
    let hoverState = StateField.define({
        create() { return null; },
        update(value, tr) {
            if (value && (options.hideOnChange && (tr.docChanged || tr.selection) ||
                options.hideOn && options.hideOn(tr, value)))
                return null;
            if (value && tr.docChanged) {
                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);
                if (newPos == null)
                    return null;
                let copy = Object.assign(Object.create(null), value);
                copy.pos = newPos;
                if (value.end != null)
                    copy.end = tr.changes.mapPos(value.end);
                value = copy;
            }
            for (let effect of tr.effects) {
                if (effect.is(setHover))
                    value = effect.value;
                if (effect.is(closeHoverTooltipEffect))
                    value = null;
            }
            return value;
        },
        provide: f => showHoverTooltip.from(f)
    });
    return [
        hoverState,
        dist_ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover, options.hoverTime || 300 /* Hover.Time */)),
        showHoverTooltipHost
    ];
}
/**
Get the active tooltip view for a given tooltip, if available.
*/
function getTooltip(view, tooltip) {
    let plugin = view.plugin(tooltipPlugin);
    if (!plugin)
        return null;
    let found = plugin.manager.tooltips.indexOf(tooltip);
    return found < 0 ? null : plugin.manager.tooltipViews[found];
}
/**
Returns true if any hover tooltips are currently active.
*/
function hasHoverTooltips(state) {
    return state.facet(showHoverTooltip).some(x => x);
}
const closeHoverTooltipEffect = /*@__PURE__*/StateEffect.define();
/**
Transaction effect that closes all hover tooltips.
*/
const closeHoverTooltips = /*@__PURE__*/(/* unused pure expression or super */ null && (closeHoverTooltipEffect.of(null)));
/**
Tell the tooltip extension to recompute the position of the active
tooltips. This can be useful when something happens (such as a
re-positioning or CSS change affecting the editor) that could
invalidate the existing tooltip positions.
*/
function repositionTooltips(view) {
    let plugin = view.plugin(tooltipPlugin);
    if (plugin)
        plugin.maybeMeasure();
}

const panelConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        let topContainer, bottomContainer;
        for (let c of configs) {
            topContainer = topContainer || c.topContainer;
            bottomContainer = bottomContainer || c.bottomContainer;
        }
        return { topContainer, bottomContainer };
    }
});
/**
Configures the panel-managing extension.
*/
function panels(config) {
    return config ? [panelConfig.of(config)] : [];
}
/**
Get the active panel created by the given constructor, if any.
This can be useful when you need access to your panels' DOM
structure.
*/
function getPanel(view, panel) {
    let plugin = view.plugin(panelPlugin);
    let index = plugin ? plugin.specs.indexOf(panel) : -1;
    return index > -1 ? plugin.panels[index] : null;
}
const panelPlugin = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.input = view.state.facet(showPanel);
        this.specs = this.input.filter(s => s);
        this.panels = this.specs.map(spec => spec(view));
        let conf = view.state.facet(panelConfig);
        this.top = new PanelGroup(view, true, conf.topContainer);
        this.bottom = new PanelGroup(view, false, conf.bottomContainer);
        this.top.sync(this.panels.filter(p => p.top));
        this.bottom.sync(this.panels.filter(p => !p.top));
        for (let p of this.panels) {
            p.dom.classList.add("cm-panel");
            if (p.mount)
                p.mount();
        }
    }
    update(update) {
        let conf = update.state.facet(panelConfig);
        if (this.top.container != conf.topContainer) {
            this.top.sync([]);
            this.top = new PanelGroup(update.view, true, conf.topContainer);
        }
        if (this.bottom.container != conf.bottomContainer) {
            this.bottom.sync([]);
            this.bottom = new PanelGroup(update.view, false, conf.bottomContainer);
        }
        this.top.syncClasses();
        this.bottom.syncClasses();
        let input = update.state.facet(showPanel);
        if (input != this.input) {
            let specs = input.filter(x => x);
            let panels = [], top = [], bottom = [], mount = [];
            for (let spec of specs) {
                let known = this.specs.indexOf(spec), panel;
                if (known < 0) {
                    panel = spec(update.view);
                    mount.push(panel);
                }
                else {
                    panel = this.panels[known];
                    if (panel.update)
                        panel.update(update);
                }
                panels.push(panel);
                (panel.top ? top : bottom).push(panel);
            }
            this.specs = specs;
            this.panels = panels;
            this.top.sync(top);
            this.bottom.sync(bottom);
            for (let p of mount) {
                p.dom.classList.add("cm-panel");
                if (p.mount)
                    p.mount();
            }
        }
        else {
            for (let p of this.panels)
                if (p.update)
                    p.update(update);
        }
    }
    destroy() {
        this.top.sync([]);
        this.bottom.sync([]);
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        return value && { top: value.top.scrollMargin(), bottom: value.bottom.scrollMargin() };
    })
});
class PanelGroup {
    constructor(view, top, container) {
        this.view = view;
        this.top = top;
        this.container = container;
        this.dom = undefined;
        this.classes = "";
        this.panels = [];
        this.syncClasses();
    }
    sync(panels) {
        for (let p of this.panels)
            if (p.destroy && panels.indexOf(p) < 0)
                p.destroy();
        this.panels = panels;
        this.syncDOM();
    }
    syncDOM() {
        if (this.panels.length == 0) {
            if (this.dom) {
                this.dom.remove();
                this.dom = undefined;
            }
            return;
        }
        if (!this.dom) {
            this.dom = document.createElement("div");
            this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom";
            this.dom.style[this.top ? "top" : "bottom"] = "0";
            let parent = this.container || this.view.dom;
            parent.insertBefore(this.dom, this.top ? parent.firstChild : null);
        }
        let curDOM = this.dom.firstChild;
        for (let panel of this.panels) {
            if (panel.dom.parentNode == this.dom) {
                while (curDOM != panel.dom)
                    curDOM = rm(curDOM);
                curDOM = curDOM.nextSibling;
            }
            else {
                this.dom.insertBefore(panel.dom, curDOM);
            }
        }
        while (curDOM)
            curDOM = rm(curDOM);
    }
    scrollMargin() {
        return !this.dom || this.container ? 0
            : Math.max(0, this.top ?
                this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) :
                Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
    }
    syncClasses() {
        if (!this.container || this.classes == this.view.themeClasses)
            return;
        for (let cls of this.classes.split(" "))
            if (cls)
                this.container.classList.remove(cls);
        for (let cls of (this.classes = this.view.themeClasses).split(" "))
            if (cls)
                this.container.classList.add(cls);
    }
}
function rm(node) {
    let next = node.nextSibling;
    node.remove();
    return next;
}
/**
Opening a panel is done by providing a constructor function for
the panel through this facet. (The panel is closed again when its
constructor is no longer provided.) Values of `null` are ignored.
*/
const showPanel = /*@__PURE__*/Facet.define({
    enables: panelPlugin
});

/**
A gutter marker represents a bit of information attached to a line
in a specific gutter. Your own custom markers have to extend this
class.
*/
class GutterMarker extends RangeValue {
    /**
    @internal
    */
    compare(other) {
        return this == other || this.constructor == other.constructor && this.eq(other);
    }
    /**
    Compare this marker to another marker of the same type.
    */
    eq(other) { return false; }
    /**
    Called if the marker has a `toDOM` method and its representation
    was removed from a gutter.
    */
    destroy(dom) { }
}
GutterMarker.prototype.elementClass = "";
GutterMarker.prototype.toDOM = undefined;
GutterMarker.prototype.mapMode = MapMode.TrackBefore;
GutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;
GutterMarker.prototype.point = true;
/**
Facet used to add a class to all gutter elements for a given line.
Markers given to this facet should _only_ define an
[`elementclass`](https://codemirror.net/6/docs/ref/#view.GutterMarker.elementClass), not a
[`toDOM`](https://codemirror.net/6/docs/ref/#view.GutterMarker.toDOM) (or the marker will appear
in all gutters for the line).
*/
const gutterLineClass = /*@__PURE__*/Facet.define();
const defaults = {
    class: "",
    renderEmptyElements: false,
    elementStyle: "",
    markers: () => dist_RangeSet.empty,
    lineMarker: () => null,
    widgetMarker: () => null,
    lineMarkerChange: null,
    initialSpacer: null,
    updateSpacer: null,
    domEventHandlers: {}
};
const activeGutters = /*@__PURE__*/Facet.define();
/**
Define an editor gutter. The order in which the gutters appear is
determined by their extension priority.
*/
function gutter(config) {
    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];
}
const unfixGutters = /*@__PURE__*/Facet.define({
    combine: values => values.some(x => x)
});
/**
The gutter-drawing plugin is automatically enabled when you add a
gutter, but you can use this function to explicitly configure it.

Unless `fixed` is explicitly set to `false`, the gutters are
fixed, meaning they don't scroll along with the content
horizontally (except on Internet Explorer, which doesn't support
CSS [`position:
sticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).
*/
function gutters(config) {
    let result = [
        gutterView,
    ];
    if (config && config.fixed === false)
        result.push(unfixGutters.of(true));
    return result;
}
const gutterView = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.prevViewport = view.viewport;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutters";
        this.dom.setAttribute("aria-hidden", "true");
        this.dom.style.minHeight = (this.view.contentHeight / this.view.scaleY) + "px";
        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));
        for (let gutter of this.gutters)
            this.dom.appendChild(gutter.dom);
        this.fixed = !view.state.facet(unfixGutters);
        if (this.fixed) {
            // FIXME IE11 fallback, which doesn't support position: sticky,
            // by using position: relative + event handlers that realign the
            // gutter (or just force fixed=false on IE11?)
            this.dom.style.position = "sticky";
        }
        this.syncGutters(false);
        view.scrollDOM.insertBefore(this.dom, view.contentDOM);
    }
    update(update) {
        if (this.updateGutters(update)) {
            // Detach during sync when the viewport changed significantly
            // (such as during scrolling), since for large updates that is
            // faster.
            let vpA = this.prevViewport, vpB = update.view.viewport;
            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);
            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);
        }
        if (update.geometryChanged)
            this.dom.style.minHeight = this.view.contentHeight + "px";
        if (this.view.state.facet(unfixGutters) != !this.fixed) {
            this.fixed = !this.fixed;
            this.dom.style.position = this.fixed ? "sticky" : "";
        }
        this.prevViewport = update.view.viewport;
    }
    syncGutters(detach) {
        let after = this.dom.nextSibling;
        if (detach)
            this.dom.remove();
        let lineClasses = dist_RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);
        let classSet = [];
        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));
        for (let line of this.view.viewportLineBlocks) {
            if (classSet.length)
                classSet = [];
            if (Array.isArray(line.type)) {
                let first = true;
                for (let b of line.type) {
                    if (b.type == BlockType.Text && first) {
                        advanceCursor(lineClasses, classSet, b.from);
                        for (let cx of contexts)
                            cx.line(this.view, b, classSet);
                        first = false;
                    }
                    else if (b.widget) {
                        for (let cx of contexts)
                            cx.widget(this.view, b);
                    }
                }
            }
            else if (line.type == BlockType.Text) {
                advanceCursor(lineClasses, classSet, line.from);
                for (let cx of contexts)
                    cx.line(this.view, line, classSet);
            }
            else if (line.widget) {
                for (let cx of contexts)
                    cx.widget(this.view, line);
            }
        }
        for (let cx of contexts)
            cx.finish();
        if (detach)
            this.view.scrollDOM.insertBefore(this.dom, after);
    }
    updateGutters(update) {
        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);
        let change = update.docChanged || update.heightChanged || update.viewportChanged ||
            !dist_RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);
        if (prev == cur) {
            for (let gutter of this.gutters)
                if (gutter.update(update))
                    change = true;
        }
        else {
            change = true;
            let gutters = [];
            for (let conf of cur) {
                let known = prev.indexOf(conf);
                if (known < 0) {
                    gutters.push(new SingleGutterView(this.view, conf));
                }
                else {
                    this.gutters[known].update(update);
                    gutters.push(this.gutters[known]);
                }
            }
            for (let g of this.gutters) {
                g.dom.remove();
                if (gutters.indexOf(g) < 0)
                    g.destroy();
            }
            for (let g of gutters)
                this.dom.appendChild(g.dom);
            this.gutters = gutters;
        }
        return change;
    }
    destroy() {
        for (let view of this.gutters)
            view.destroy();
        this.dom.remove();
    }
}, {
    provide: plugin => EditorView.scrollMargins.of(view => {
        let value = view.plugin(plugin);
        if (!value || value.gutters.length == 0 || !value.fixed)
            return null;
        return view.textDirection == Direction.LTR
            ? { left: value.dom.offsetWidth * view.scaleX }
            : { right: value.dom.offsetWidth * view.scaleX };
    })
});
function dist_asArray(val) { return (Array.isArray(val) ? val : [val]); }
function advanceCursor(cursor, collect, pos) {
    while (cursor.value && cursor.from <= pos) {
        if (cursor.from == pos)
            collect.push(cursor.value);
        cursor.next();
    }
}
class UpdateContext {
    constructor(gutter, viewport, height) {
        this.gutter = gutter;
        this.height = height;
        this.i = 0;
        this.cursor = dist_RangeSet.iter(gutter.markers, viewport.from);
    }
    addElement(view, block, markers) {
        let { gutter } = this, above = (block.top - this.height) / view.scaleY, height = block.height / view.scaleY;
        if (this.i == gutter.elements.length) {
            let newElt = new GutterElement(view, height, above, markers);
            gutter.elements.push(newElt);
            gutter.dom.appendChild(newElt.dom);
        }
        else {
            gutter.elements[this.i].update(view, height, above, markers);
        }
        this.height = block.bottom;
        this.i++;
    }
    line(view, line, extraMarkers) {
        let localMarkers = [];
        advanceCursor(this.cursor, localMarkers, line.from);
        if (extraMarkers.length)
            localMarkers = localMarkers.concat(extraMarkers);
        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);
        if (forLine)
            localMarkers.unshift(forLine);
        let gutter = this.gutter;
        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)
            return;
        this.addElement(view, line, localMarkers);
    }
    widget(view, block) {
        let marker = this.gutter.config.widgetMarker(view, block.widget, block);
        if (marker)
            this.addElement(view, block, [marker]);
    }
    finish() {
        let gutter = this.gutter;
        while (gutter.elements.length > this.i) {
            let last = gutter.elements.pop();
            gutter.dom.removeChild(last.dom);
            last.destroy();
        }
    }
}
class SingleGutterView {
    constructor(view, config) {
        this.view = view;
        this.config = config;
        this.elements = [];
        this.spacer = null;
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
        for (let prop in config.domEventHandlers) {
            this.dom.addEventListener(prop, (event) => {
                let target = event.target, y;
                if (target != this.dom && this.dom.contains(target)) {
                    while (target.parentNode != this.dom)
                        target = target.parentNode;
                    let rect = target.getBoundingClientRect();
                    y = (rect.top + rect.bottom) / 2;
                }
                else {
                    y = event.clientY;
                }
                let line = view.lineBlockAtHeight(y - view.documentTop);
                if (config.domEventHandlers[prop](view, line, event))
                    event.preventDefault();
            });
        }
        this.markers = dist_asArray(config.markers(view));
        if (config.initialSpacer) {
            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);
            this.dom.appendChild(this.spacer.dom);
            this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none";
        }
    }
    update(update) {
        let prevMarkers = this.markers;
        this.markers = dist_asArray(this.config.markers(update.view));
        if (this.spacer && this.config.updateSpacer) {
            let updated = this.config.updateSpacer(this.spacer.markers[0], update);
            if (updated != this.spacer.markers[0])
                this.spacer.update(update.view, 0, 0, [updated]);
        }
        let vp = update.view.viewport;
        return !dist_RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||
            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);
    }
    destroy() {
        for (let elt of this.elements)
            elt.destroy();
    }
}
class GutterElement {
    constructor(view, height, above, markers) {
        this.height = -1;
        this.above = 0;
        this.markers = [];
        this.dom = document.createElement("div");
        this.dom.className = "cm-gutterElement";
        this.update(view, height, above, markers);
    }
    update(view, height, above, markers) {
        if (this.height != height) {
            this.height = height;
            this.dom.style.height = height + "px";
        }
        if (this.above != above)
            this.dom.style.marginTop = (this.above = above) ? above + "px" : "";
        if (!sameMarkers(this.markers, markers))
            this.setMarkers(view, markers);
    }
    setMarkers(view, markers) {
        let cls = "cm-gutterElement", domPos = this.dom.firstChild;
        for (let iNew = 0, iOld = 0;;) {
            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;
            if (marker) {
                let c = marker.elementClass;
                if (c)
                    cls += " " + c;
                for (let i = iOld; i < this.markers.length; i++)
                    if (this.markers[i].compare(marker)) {
                        skipTo = i;
                        matched = true;
                        break;
                    }
            }
            else {
                skipTo = this.markers.length;
            }
            while (iOld < skipTo) {
                let next = this.markers[iOld++];
                if (next.toDOM) {
                    next.destroy(domPos);
                    let after = domPos.nextSibling;
                    domPos.remove();
                    domPos = after;
                }
            }
            if (!marker)
                break;
            if (marker.toDOM) {
                if (matched)
                    domPos = domPos.nextSibling;
                else
                    this.dom.insertBefore(marker.toDOM(view), domPos);
            }
            if (matched)
                iOld++;
        }
        this.dom.className = cls;
        this.markers = markers;
    }
    destroy() {
        this.setMarkers(null, []); // First argument not used unless creating markers
    }
}
function sameMarkers(a, b) {
    if (a.length != b.length)
        return false;
    for (let i = 0; i < a.length; i++)
        if (!a[i].compare(b[i]))
            return false;
    return true;
}
/**
Facet used to provide markers to the line number gutter.
*/
const lineNumberMarkers = /*@__PURE__*/Facet.define();
const lineNumberConfig = /*@__PURE__*/Facet.define({
    combine(values) {
        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {
            domEventHandlers(a, b) {
                let result = Object.assign({}, a);
                for (let event in b) {
                    let exists = result[event], add = b[event];
                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;
                }
                return result;
            }
        });
    }
});
class NumberMarker extends GutterMarker {
    constructor(number) {
        super();
        this.number = number;
    }
    eq(other) { return this.number == other.number; }
    toDOM() { return document.createTextNode(this.number); }
}
function formatNumber(view, number) {
    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);
}
const lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({
    class: "cm-lineNumbers",
    renderEmptyElements: false,
    markers(view) { return view.state.facet(lineNumberMarkers); },
    lineMarker(view, line, others) {
        if (others.some(m => m.toDOM))
            return null;
        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));
    },
    widgetMarker: () => null,
    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),
    initialSpacer(view) {
        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));
    },
    updateSpacer(spacer, update) {
        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));
        return max == spacer.number ? spacer : new NumberMarker(max);
    },
    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers
}));
/**
Create a line number gutter extension.
*/
function lineNumbers(config = {}) {
    return [
        lineNumberConfig.of(config),
        gutters(),
        lineNumberGutter
    ];
}
function maxLineNumber(lines) {
    let last = 9;
    while (last < lines)
        last = last * 10 + 9;
    return last;
}
const activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {
    constructor() {
        super(...arguments);
        this.elementClass = "cm-activeLineGutter";
    }
};
const activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute(["selection"], state => {
    let marks = [], last = -1;
    for (let range of state.selection.ranges) {
        let linePos = state.doc.lineAt(range.head).from;
        if (linePos > last) {
            last = linePos;
            marks.push(activeLineGutterMarker.range(linePos));
        }
    }
    return dist_RangeSet.of(marks);
});
/**
Returns an extension that adds a `cm-activeLineGutter` class to
all gutter elements on the [active
line](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).
*/
function highlightActiveLineGutter() {
    return activeLineGutterHighlighter;
}

const WhitespaceDeco = /*@__PURE__*/new Map();
function getWhitespaceDeco(space) {
    let deco = WhitespaceDeco.get(space);
    if (!deco)
        WhitespaceDeco.set(space, deco = Decoration.mark({
            attributes: space === "\t" ? {
                class: "cm-highlightTab",
            } : {
                class: "cm-highlightSpace",
                "data-display": space.replace(/ /g, "·")
            }
        }));
    return deco;
}
function matcher(decorator) {
    return dist_ViewPlugin.define(view => ({
        decorations: decorator.createDeco(view),
        update(u) {
            this.decorations = decorator.updateDeco(u, this.decorations);
        },
    }), {
        decorations: v => v.decorations
    });
}
const whitespaceHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\t| +/g,
    decoration: match => getWhitespaceDeco(match[0]),
    boundary: /\S/,
}));
/**
Returns an extension that highlights whitespace, adding a
`cm-highlightSpace` class to stretches of spaces, and a
`cm-highlightTab` class to individual tab characters. By default,
the former are shown as faint dots, and the latter as arrows.
*/
function highlightWhitespace() {
    return whitespaceHighlighter;
}
const trailingHighlighter = /*@__PURE__*/matcher(/*@__PURE__*/new MatchDecorator({
    regexp: /\s+$/g,
    decoration: /*@__PURE__*/Decoration.mark({ class: "cm-trailingSpace" }),
    boundary: /\S/,
}));
/**
Returns an extension that adds a `cm-trailingSpace` class to all
trailing whitespace.
*/
function highlightTrailingWhitespace() {
    return trailingHighlighter;
}

/**
@internal
*/
const __test = { HeightMap, HeightOracle, MeasuredHeights, QueryType, ChangedRange, computeOrder, moveVisually };



;// CONCATENATED MODULE: ./node_modules/codemirror-readonly-ranges/dist/index.es.js

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var n=function(){return n=Object.assign||function(t){for(var o,r=1,n=arguments.length;r<n;r++)for(var f in o=arguments[r])Object.prototype.hasOwnProperty.call(o,f)&&(t[f]=o[f]);return t},n.apply(this,arguments)};function f(t,o,r){if(r||2===arguments.length)for(var n,f=0,e=o.length;f<e;f++)!n&&f in o||(n||(n=Array.prototype.slice.call(o,0,f)),n[f]=o[f]);return t.concat(n||Array.prototype.slice.call(o))}var e=function(t){return/^-?\d+$/.test(t)},a=function(t,o,r){void 0===r&&(r={from:void 0,to:void 0});var a=t.map((function(t){if(t.from=e(t.from)?t.from:void 0,t.to=e(t.to)?t.to:void 0,e(t.from)&&e(t.to)){var o=n({},t);t.from=Math.min(o.from,o.to),t.to=Math.max(o.from,o.to)}return t})),m={from:e(null==o?void 0:o.from)?null==o?void 0:o.from:void 0,to:e(null==o?void 0:o.to)?null==o?void 0:o.to:void 0};if(e(m.from)&&e(m.to)){var u=n({},m);m.from=Math.min(u.from,u.to),m.to=Math.max(u.from,u.to)}var l={from:e(null==r?void 0:r.from)?null==r?void 0:r.from:void 0,to:e(null==r?void 0:r.to)?null==r?void 0:r.to:void 0};if(e(l.from)&&e(l.to)){var c=n({},l);l.from=Math.min(c.from,c.to),l.to=Math.max(c.from,c.to)}var s=f(f([],a.map((function(t){return t.from})),!0),[null==m?void 0:m.from,null==l?void 0:l.from],!1).filter((function(t){return void 0!==t})),v=f(f([],a.map((function(t){return t.to})),!0),[null==m?void 0:m.to,null==l?void 0:l.to],!1).filter((function(t){return void 0!==t})),d=f(f([],s,!0),v,!0),p=0,h=0;d.length>0&&(p=Math.max.apply(Math,d),h=Math.min.apply(Math,d));var g=Math.abs(p),M=Math.abs(h),y=Math.max(g,M)+1,S=-y;return a=a.map((function(t){return t.from=e(t.from)?t.from:S,t.to=e(t.to)?t.to:y,t})),m={from:e(m.from)?m.from:S,to:e(m.to)?m.to:y},l={from:e(l.from)?l.from:S,to:e(l.to)?l.to:y},a=a.slice().sort((function(t,o){var r=t.to-t.from,n=o.to-o.from;if(t.from>o.from)return 1;if(t.from===o.from){if(t.from+r>o.from+n)return-1;if(t.from+r===o.from+n)return 0;if(t.from+r<o.from+n)return 1}return-1})),index_es_i(a,m,[],l).map((function(t){return{from:t.from===S?void 0:t.from,to:t.to===y?void 0:t.to}}))},index_es_i=function(t,o,r,n){var f=r;if(null===o||0===t.length)return null===o||r.some((function(t){return t.from===(null==o?void 0:o.from)&&t.to===(null==o?void 0:o.to)}))||f.push(o),(f=f.filter((function(t){return t.from<=n.to&&t.to>=n.from}))).map((function(t){return function(t,o){return{from:t.from<o.from?o.from:t.from,to:t.to>o.to?o.to:t.to}}(t,n)}));var e=o.to-o.from;if(o.from>=t[0].from&&o.from<=t[0].to)o.from+e<=t[0].to?o=null:o.from=t[0].to+1;else if(o.from<t[0].from&&o.from+e>=t[0].from){var a=o.to,m={from:o.from,to:t[0].from-1};r.push(m),a>t[0].to?o.from=t[0].to+1:o=null}return t.shift(),index_es_i(t,o,r,n)},m=function(r){return EditorState.transactionFilter.of((function(t){if(t.isUserEvent("delete.selection")&&!t.isUserEvent("delete.selection.smart")){var n=t.startState.selection.ranges.map((function(t){return{from:t.from,to:t.to}}));if(n.length>0){var f=r(t.startState);return a(f,n[0],{from:0,to:t.startState.doc.line(t.startState.doc.lines).to}).map((function(r){return t.startState.update({changes:{from:r.from,to:r.to},annotations:Transaction.userEvent.of("".concat(t.annotation(Transaction.userEvent),".smart"))})}))}}return t}))},u=function(o){return EditorState.changeFilter.of((function(t){var r,n,f,e;try{for(var a=o(t.startState),i=o(t.state),m=0;m<a.length;m++){var u=null!==(r=a[m].from)&&void 0!==r?r:0,l=null!==(n=a[m].to)&&void 0!==n?n:t.startState.doc.line(t.startState.doc.lines).to,c=null!==(f=i[m].from)&&void 0!==f?f:0,s=null!==(e=i[m].to)&&void 0!==e?e:t.state.doc.line(t.state.doc.lines).to;if(t.startState.sliceDoc(u,l)!==t.state.sliceDoc(c,s))return!1}}catch(t){return!1}return!0}))},l=function(t){return EditorView.domEventHandlers({paste:function(r,n){var f=(r.clipboardData||window.clipboardData).getData("Text"),e=n.state.selection.ranges.map((function(t){return{from:t.from,to:t.to}}));if(e.length>0){var i=t(n.state),m=a(i,e[0],{from:0,to:n.state.doc.line(n.state.doc.lines).to});m.length>0&&n.dispatch({changes:{from:m[0].from,to:m[0].to,insert:f},annotations:Transaction.userEvent.of("input.paste.smart")})}return!0}})},c=function(t){return[l(t),m(t),u(t)]};
//# sourceMappingURL=index.es.js.map

;// CONCATENATED MODULE: ./node_modules/@lezer/common/dist/index.js
/**
The default maximum length of a `TreeBuffer` node.
*/
const DefaultBufferLength = 1024;
let nextPropID = 0;
class dist_Range {
    constructor(from, to) {
        this.from = from;
        this.to = to;
    }
}
/**
Each [node type](#common.NodeType) or [individual tree](#common.Tree)
can have metadata associated with it in props. Instances of this
class represent prop names.
*/
class dist_NodeProp {
    /**
    Create a new node prop type.
    */
    constructor(config = {}) {
        this.id = nextPropID++;
        this.perNode = !!config.perNode;
        this.deserialize = config.deserialize || (() => {
            throw new Error("This node type doesn't define a deserialize function");
        });
    }
    /**
    This is meant to be used with
    [`NodeSet.extend`](#common.NodeSet.extend) or
    [`LRParser.configure`](#lr.ParserConfig.props) to compute
    prop values for each node type in the set. Takes a [match
    object](#common.NodeType^match) or function that returns undefined
    if the node type doesn't get this prop, and the prop's value if
    it does.
    */
    add(match) {
        if (this.perNode)
            throw new RangeError("Can't add per-node props to node types");
        if (typeof match != "function")
            match = dist_NodeType.match(match);
        return (type) => {
            let result = match(type);
            return result === undefined ? null : [this, result];
        };
    }
}
/**
Prop that is used to describe matching delimiters. For opening
delimiters, this holds an array of node names (written as a
space-separated string when declaring this prop in a grammar)
for the node types of closing delimiters that match it.
*/
dist_NodeProp.closedBy = new dist_NodeProp({ deserialize: str => str.split(" ") });
/**
The inverse of [`closedBy`](#common.NodeProp^closedBy). This is
attached to closing delimiters, holding an array of node names
of types of matching opening delimiters.
*/
dist_NodeProp.openedBy = new dist_NodeProp({ deserialize: str => str.split(" ") });
/**
Used to assign node types to groups (for example, all node
types that represent an expression could be tagged with an
`"Expression"` group).
*/
dist_NodeProp.group = new dist_NodeProp({ deserialize: str => str.split(" ") });
/**
The hash of the [context](#lr.ContextTracker.constructor)
that the node was parsed in, if any. Used to limit reuse of
contextual nodes.
*/
dist_NodeProp.contextHash = new dist_NodeProp({ perNode: true });
/**
The distance beyond the end of the node that the tokenizer
looked ahead for any of the tokens inside the node. (The LR
parser only stores this when it is larger than 25, for
efficiency reasons.)
*/
dist_NodeProp.lookAhead = new dist_NodeProp({ perNode: true });
/**
This per-node prop is used to replace a given node, or part of a
node, with another tree. This is useful to include trees from
different languages in mixed-language parsers.
*/
dist_NodeProp.mounted = new dist_NodeProp({ perNode: true });
/**
A mounted tree, which can be [stored](#common.NodeProp^mounted) on
a tree node to indicate that parts of its content are
represented by another tree.
*/
class MountedTree {
    constructor(
    /**
    The inner tree.
    */
    tree, 
    /**
    If this is null, this tree replaces the entire node (it will
    be included in the regular iteration instead of its host
    node). If not, only the given ranges are considered to be
    covered by this tree. This is used for trees that are mixed in
    a way that isn't strictly hierarchical. Such mounted trees are
    only entered by [`resolveInner`](#common.Tree.resolveInner)
    and [`enter`](#common.SyntaxNode.enter).
    */
    overlay, 
    /**
    The parser used to create this subtree.
    */
    parser) {
        this.tree = tree;
        this.overlay = overlay;
        this.parser = parser;
    }
    /**
    @internal
    */
    static get(tree) {
        return tree && tree.props && tree.props[dist_NodeProp.mounted.id];
    }
}
const noProps = Object.create(null);
/**
Each node in a syntax tree has a node type associated with it.
*/
class dist_NodeType {
    /**
    @internal
    */
    constructor(
    /**
    The name of the node type. Not necessarily unique, but if the
    grammar was written properly, different node types with the
    same name within a node set should play the same semantic
    role.
    */
    name, 
    /**
    @internal
    */
    props, 
    /**
    The id of this node in its set. Corresponds to the term ids
    used in the parser.
    */
    id, 
    /**
    @internal
    */
    flags = 0) {
        this.name = name;
        this.props = props;
        this.id = id;
        this.flags = flags;
    }
    /**
    Define a node type.
    */
    static define(spec) {
        let props = spec.props && spec.props.length ? Object.create(null) : noProps;
        let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) |
            (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);
        let type = new dist_NodeType(spec.name || "", props, spec.id, flags);
        if (spec.props)
            for (let src of spec.props) {
                if (!Array.isArray(src))
                    src = src(type);
                if (src) {
                    if (src[0].perNode)
                        throw new RangeError("Can't store a per-node prop on a node type");
                    props[src[0].id] = src[1];
                }
            }
        return type;
    }
    /**
    Retrieves a node prop for this type. Will return `undefined` if
    the prop isn't present on this node.
    */
    prop(prop) { return this.props[prop.id]; }
    /**
    True when this is the top node of a grammar.
    */
    get isTop() { return (this.flags & 1 /* NodeFlag.Top */) > 0; }
    /**
    True when this node is produced by a skip rule.
    */
    get isSkipped() { return (this.flags & 2 /* NodeFlag.Skipped */) > 0; }
    /**
    Indicates whether this is an error node.
    */
    get isError() { return (this.flags & 4 /* NodeFlag.Error */) > 0; }
    /**
    When true, this node type doesn't correspond to a user-declared
    named node, for example because it is used to cache repetition.
    */
    get isAnonymous() { return (this.flags & 8 /* NodeFlag.Anonymous */) > 0; }
    /**
    Returns true when this node's name or one of its
    [groups](#common.NodeProp^group) matches the given string.
    */
    is(name) {
        if (typeof name == 'string') {
            if (this.name == name)
                return true;
            let group = this.prop(dist_NodeProp.group);
            return group ? group.indexOf(name) > -1 : false;
        }
        return this.id == name;
    }
    /**
    Create a function from node types to arbitrary values by
    specifying an object whose property names are node or
    [group](#common.NodeProp^group) names. Often useful with
    [`NodeProp.add`](#common.NodeProp.add). You can put multiple
    names, separated by spaces, in a single property name to map
    multiple node names to a single value.
    */
    static match(map) {
        let direct = Object.create(null);
        for (let prop in map)
            for (let name of prop.split(" "))
                direct[name] = map[prop];
        return (node) => {
            for (let groups = node.prop(dist_NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {
                let found = direct[i < 0 ? node.name : groups[i]];
                if (found)
                    return found;
            }
        };
    }
}
/**
An empty dummy node type to use when no actual type is available.
*/
dist_NodeType.none = new dist_NodeType("", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);
/**
A node set holds a collection of node types. It is used to
compactly represent trees by storing their type ids, rather than a
full pointer to the type object, in a numeric array. Each parser
[has](#lr.LRParser.nodeSet) a node set, and [tree
buffers](#common.TreeBuffer) can only store collections of nodes
from the same set. A set can have a maximum of 2**16 (65536) node
types in it, so that the ids fit into 16-bit typed array slots.
*/
class NodeSet {
    /**
    Create a set with the given types. The `id` property of each
    type should correspond to its position within the array.
    */
    constructor(
    /**
    The node types in this set, by id.
    */
    types) {
        this.types = types;
        for (let i = 0; i < types.length; i++)
            if (types[i].id != i)
                throw new RangeError("Node type ids should correspond to array positions when creating a node set");
    }
    /**
    Create a copy of this set with some node properties added. The
    arguments to this method can be created with
    [`NodeProp.add`](#common.NodeProp.add).
    */
    extend(...props) {
        let newTypes = [];
        for (let type of this.types) {
            let newProps = null;
            for (let source of props) {
                let add = source(type);
                if (add) {
                    if (!newProps)
                        newProps = Object.assign({}, type.props);
                    newProps[add[0].id] = add[1];
                }
            }
            newTypes.push(newProps ? new dist_NodeType(type.name, newProps, type.id, type.flags) : type);
        }
        return new NodeSet(newTypes);
    }
}
const CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();
/**
Options that control iteration. Can be combined with the `|`
operator to enable multiple ones.
*/
var IterMode;
(function (IterMode) {
    /**
    When enabled, iteration will only visit [`Tree`](#common.Tree)
    objects, not nodes packed into
    [`TreeBuffer`](#common.TreeBuffer)s.
    */
    IterMode[IterMode["ExcludeBuffers"] = 1] = "ExcludeBuffers";
    /**
    Enable this to make iteration include anonymous nodes (such as
    the nodes that wrap repeated grammar constructs into a balanced
    tree).
    */
    IterMode[IterMode["IncludeAnonymous"] = 2] = "IncludeAnonymous";
    /**
    By default, regular [mounted](#common.NodeProp^mounted) nodes
    replace their base node in iteration. Enable this to ignore them
    instead.
    */
    IterMode[IterMode["IgnoreMounts"] = 4] = "IgnoreMounts";
    /**
    This option only applies in
    [`enter`](#common.SyntaxNode.enter)-style methods. It tells the
    library to not enter mounted overlays if one covers the given
    position.
    */
    IterMode[IterMode["IgnoreOverlays"] = 8] = "IgnoreOverlays";
})(IterMode || (IterMode = {}));
/**
A piece of syntax tree. There are two ways to approach these
trees: the way they are actually stored in memory, and the
convenient way.

Syntax trees are stored as a tree of `Tree` and `TreeBuffer`
objects. By packing detail information into `TreeBuffer` leaf
nodes, the representation is made a lot more memory-efficient.

However, when you want to actually work with tree nodes, this
representation is very awkward, so most client code will want to
use the [`TreeCursor`](#common.TreeCursor) or
[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides
a view on some part of this data structure, and can be used to
move around to adjacent nodes.
*/
class dist_Tree {
    /**
    Construct a new tree. See also [`Tree.build`](#common.Tree^build).
    */
    constructor(
    /**
    The type of the top node.
    */
    type, 
    /**
    This node's child nodes.
    */
    children, 
    /**
    The positions (offsets relative to the start of this tree) of
    the children.
    */
    positions, 
    /**
    The total length of this tree
    */
    length, 
    /**
    Per-node [node props](#common.NodeProp) to associate with this node.
    */
    props) {
        this.type = type;
        this.children = children;
        this.positions = positions;
        this.length = length;
        /**
        @internal
        */
        this.props = null;
        if (props && props.length) {
            this.props = Object.create(null);
            for (let [prop, value] of props)
                this.props[typeof prop == "number" ? prop : prop.id] = value;
        }
    }
    /**
    @internal
    */
    toString() {
        let mounted = MountedTree.get(this);
        if (mounted && !mounted.overlay)
            return mounted.tree.toString();
        let children = "";
        for (let ch of this.children) {
            let str = ch.toString();
            if (str) {
                if (children)
                    children += ",";
                children += str;
            }
        }
        return !this.type.name ? children :
            (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +
                (children.length ? "(" + children + ")" : "");
    }
    /**
    Get a [tree cursor](#common.TreeCursor) positioned at the top of
    the tree. Mode can be used to [control](#common.IterMode) which
    nodes the cursor visits.
    */
    cursor(mode = 0) {
        return new TreeCursor(this.topNode, mode);
    }
    /**
    Get a [tree cursor](#common.TreeCursor) pointing into this tree
    at the given position and side (see
    [`moveTo`](#common.TreeCursor.moveTo).
    */
    cursorAt(pos, side = 0, mode = 0) {
        let scope = CachedNode.get(this) || this.topNode;
        let cursor = new TreeCursor(scope);
        cursor.moveTo(pos, side);
        CachedNode.set(this, cursor._tree);
        return cursor;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) object for the top of the
    tree.
    */
    get topNode() {
        return new TreeNode(this, 0, 0, null);
    }
    /**
    Get the [syntax node](#common.SyntaxNode) at the given position.
    If `side` is -1, this will move into nodes that end at the
    position. If 1, it'll move into nodes that start at the
    position. With 0, it'll only enter nodes that cover the position
    from both sides.
    
    Note that this will not enter
    [overlays](#common.MountedTree.overlay), and you often want
    [`resolveInner`](#common.Tree.resolveInner) instead.
    */
    resolve(pos, side = 0) {
        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);
        CachedNode.set(this, node);
        return node;
    }
    /**
    Like [`resolve`](#common.Tree.resolve), but will enter
    [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
    pointing into the innermost overlaid tree at the given position
    (with parent links going through all parent structure, including
    the host trees).
    */
    resolveInner(pos, side = 0) {
        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);
        CachedInnerNode.set(this, node);
        return node;
    }
    /**
    In some situations, it can be useful to iterate through all
    nodes around a position, including those in overlays that don't
    directly cover the position. This method gives you an iterator
    that will produce all nodes, from small to big, around the given
    position.
    */
    resolveStack(pos, side = 0) {
        return stackIterator(this, pos, side);
    }
    /**
    Iterate over the tree and its children, calling `enter` for any
    node that touches the `from`/`to` region (if given) before
    running over such a node's children, and `leave` (if given) when
    leaving the node. When `enter` returns `false`, that node will
    not have its children iterated over (or `leave` called).
    */
    iterate(spec) {
        let { enter, leave, from = 0, to = this.length } = spec;
        let mode = spec.mode || 0, anon = (mode & IterMode.IncludeAnonymous) > 0;
        for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {
            let entered = false;
            if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {
                if (c.firstChild())
                    continue;
                entered = true;
            }
            for (;;) {
                if (entered && leave && (anon || !c.type.isAnonymous))
                    leave(c);
                if (c.nextSibling())
                    break;
                if (!c.parent())
                    return;
                entered = true;
            }
        }
    }
    /**
    Get the value of the given [node prop](#common.NodeProp) for this
    node. Works with both per-node and per-type props.
    */
    prop(prop) {
        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;
    }
    /**
    Returns the node's [per-node props](#common.NodeProp.perNode) in a
    format that can be passed to the [`Tree`](#common.Tree)
    constructor.
    */
    get propValues() {
        let result = [];
        if (this.props)
            for (let id in this.props)
                result.push([+id, this.props[id]]);
        return result;
    }
    /**
    Balance the direct children of this tree, producing a copy of
    which may have children grouped into subtrees with type
    [`NodeType.none`](#common.NodeType^none).
    */
    balance(config = {}) {
        return this.children.length <= 8 /* Balance.BranchFactor */ ? this :
            balanceRange(dist_NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new dist_Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new dist_Tree(dist_NodeType.none, children, positions, length)));
    }
    /**
    Build a tree from a postfix-ordered buffer of node information,
    or a cursor over such a buffer.
    */
    static build(data) { return buildTree(data); }
}
/**
The empty tree
*/
dist_Tree.empty = new dist_Tree(dist_NodeType.none, [], [], 0);
class FlatBufferCursor {
    constructor(buffer, index) {
        this.buffer = buffer;
        this.index = index;
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    get pos() { return this.index; }
    next() { this.index -= 4; }
    fork() { return new FlatBufferCursor(this.buffer, this.index); }
}
/**
Tree buffers contain (type, start, end, endIndex) quads for each
node. In such a buffer, nodes are stored in prefix order (parents
before children, with the endIndex of the parent indicating which
children belong to it).
*/
class TreeBuffer {
    /**
    Create a tree buffer.
    */
    constructor(
    /**
    The buffer's content.
    */
    buffer, 
    /**
    The total length of the group of nodes in the buffer.
    */
    length, 
    /**
    The node set used in this buffer.
    */
    set) {
        this.buffer = buffer;
        this.length = length;
        this.set = set;
    }
    /**
    @internal
    */
    get type() { return dist_NodeType.none; }
    /**
    @internal
    */
    toString() {
        let result = [];
        for (let index = 0; index < this.buffer.length;) {
            result.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result.join(",");
    }
    /**
    @internal
    */
    childString(index) {
        let id = this.buffer[index], endIndex = this.buffer[index + 3];
        let type = this.set.types[id], result = type.name;
        if (/\W/.test(result) && !type.isError)
            result = JSON.stringify(result);
        index += 4;
        if (endIndex == index)
            return result;
        let children = [];
        while (index < endIndex) {
            children.push(this.childString(index));
            index = this.buffer[index + 3];
        }
        return result + "(" + children.join(",") + ")";
    }
    /**
    @internal
    */
    findChild(startIndex, endIndex, dir, pos, side) {
        let { buffer } = this, pick = -1;
        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {
            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {
                pick = i;
                if (dir > 0)
                    break;
            }
        }
        return pick;
    }
    /**
    @internal
    */
    slice(startI, endI, from) {
        let b = this.buffer;
        let copy = new Uint16Array(endI - startI), len = 0;
        for (let i = startI, j = 0; i < endI;) {
            copy[j++] = b[i++];
            copy[j++] = b[i++] - from;
            let to = copy[j++] = b[i++] - from;
            copy[j++] = b[i++] - startI;
            len = Math.max(len, to);
        }
        return new TreeBuffer(copy, len, this.set);
    }
}
function checkSide(side, pos, from, to) {
    switch (side) {
        case -2 /* Side.Before */: return from < pos;
        case -1 /* Side.AtOrBefore */: return to >= pos && from < pos;
        case 0 /* Side.Around */: return from < pos && to > pos;
        case 1 /* Side.AtOrAfter */: return from <= pos && to > pos;
        case 2 /* Side.After */: return to > pos;
        case 4 /* Side.DontCare */: return true;
    }
}
function resolveNode(node, pos, side, overlays) {
    var _a;
    // Move up to a node that actually holds the position, if possible
    while (node.from == node.to ||
        (side < 1 ? node.from >= pos : node.from > pos) ||
        (side > -1 ? node.to <= pos : node.to < pos)) {
        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;
        if (!parent)
            return node;
        node = parent;
    }
    let mode = overlays ? 0 : IterMode.IgnoreOverlays;
    // Must go up out of overlays when those do not overlap with pos
    if (overlays)
        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {
            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)
                node = parent;
        }
    for (;;) {
        let inner = node.enter(pos, side, mode);
        if (!inner)
            return node;
        node = inner;
    }
}
class BaseNode {
    cursor(mode = 0) { return new TreeCursor(this, mode); }
    getChild(type, before = null, after = null) {
        let r = getChildren(this, type, before, after);
        return r.length ? r[0] : null;
    }
    getChildren(type, before = null, after = null) {
        return getChildren(this, type, before, after);
    }
    resolve(pos, side = 0) {
        return resolveNode(this, pos, side, false);
    }
    resolveInner(pos, side = 0) {
        return resolveNode(this, pos, side, true);
    }
    matchContext(context) {
        return matchNodeContext(this, context);
    }
    enterUnfinishedNodesBefore(pos) {
        let scan = this.childBefore(pos), node = this;
        while (scan) {
            let last = scan.lastChild;
            if (!last || last.to != scan.to)
                break;
            if (last.type.isError && last.from == last.to) {
                node = scan;
                scan = last.prevSibling;
            }
            else {
                scan = last;
            }
        }
        return node;
    }
    get node() { return this; }
    get next() { return this.parent; }
}
class TreeNode extends BaseNode {
    constructor(_tree, from, 
    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)
    index, _parent) {
        super();
        this._tree = _tree;
        this.from = from;
        this.index = index;
        this._parent = _parent;
    }
    get type() { return this._tree.type; }
    get name() { return this._tree.type.name; }
    get to() { return this.from + this._tree.length; }
    nextChild(i, dir, pos, side, mode = 0) {
        for (let parent = this;;) {
            for (let { children, positions } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {
                let next = children[i], start = positions[i] + parent.from;
                if (!checkSide(side, pos, start, start + next.length))
                    continue;
                if (next instanceof TreeBuffer) {
                    if (mode & IterMode.ExcludeBuffers)
                        continue;
                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);
                    if (index > -1)
                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);
                }
                else if ((mode & IterMode.IncludeAnonymous) || (!next.type.isAnonymous || hasChild(next))) {
                    let mounted;
                    if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay)
                        return new TreeNode(mounted.tree, start, i, parent);
                    let inner = new TreeNode(next, start, i, parent);
                    return (mode & IterMode.IncludeAnonymous) || !inner.type.isAnonymous ? inner
                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);
                }
            }
            if ((mode & IterMode.IncludeAnonymous) || !parent.type.isAnonymous)
                return null;
            if (parent.index >= 0)
                i = parent.index + dir;
            else
                i = dir < 0 ? -1 : parent._parent._tree.children.length;
            parent = parent._parent;
            if (!parent)
                return null;
        }
    }
    get firstChild() { return this.nextChild(0, 1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        let mounted;
        if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {
            let rPos = pos - this.from;
            for (let { from, to } of mounted.overlay) {
                if ((side > 0 ? from <= rPos : from < rPos) &&
                    (side < 0 ? to >= rPos : to > rPos))
                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);
            }
        }
        return this.nextChild(0, 1, pos, side, mode);
    }
    nextSignificantParent() {
        let val = this;
        while (val.type.isAnonymous && val._parent)
            val = val._parent;
        return val;
    }
    get parent() {
        return this._parent ? this._parent.nextSignificantParent() : null;
    }
    get nextSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;
    }
    get prevSibling() {
        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;
    }
    get tree() { return this._tree; }
    toTree() { return this._tree; }
    /**
    @internal
    */
    toString() { return this._tree.toString(); }
}
function getChildren(node, type, before, after) {
    let cur = node.cursor(), result = [];
    if (!cur.firstChild())
        return result;
    if (before != null)
        while (!cur.type.is(before))
            if (!cur.nextSibling())
                return result;
    for (;;) {
        if (after != null && cur.type.is(after))
            return result;
        if (cur.type.is(type))
            result.push(cur.node);
        if (!cur.nextSibling())
            return after == null ? result : [];
    }
}
function matchNodeContext(node, context, i = context.length - 1) {
    for (let p = node.parent; i >= 0; p = p.parent) {
        if (!p)
            return false;
        if (!p.type.isAnonymous) {
            if (context[i] && context[i] != p.name)
                return false;
            i--;
        }
    }
    return true;
}
class BufferContext {
    constructor(parent, buffer, index, start) {
        this.parent = parent;
        this.buffer = buffer;
        this.index = index;
        this.start = start;
    }
}
class BufferNode extends BaseNode {
    get name() { return this.type.name; }
    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }
    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }
    constructor(context, _parent, index) {
        super();
        this.context = context;
        this._parent = _parent;
        this.index = index;
        this.type = context.buffer.set.types[context.buffer.buffer[index]];
    }
    child(dir, pos, side) {
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get firstChild() { return this.child(1, 0, 4 /* Side.DontCare */); }
    get lastChild() { return this.child(-1, 0, 4 /* Side.DontCare */); }
    childAfter(pos) { return this.child(1, pos, 2 /* Side.After */); }
    childBefore(pos) { return this.child(-1, pos, -2 /* Side.Before */); }
    enter(pos, side, mode = 0) {
        if (mode & IterMode.ExcludeBuffers)
            return null;
        let { buffer } = this.context;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);
        return index < 0 ? null : new BufferNode(this.context, this, index);
    }
    get parent() {
        return this._parent || this.context.parent.nextSignificantParent();
    }
    externalSibling(dir) {
        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);
    }
    get nextSibling() {
        let { buffer } = this.context;
        let after = buffer.buffer[this.index + 3];
        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))
            return new BufferNode(this.context, this._parent, after);
        return this.externalSibling(1);
    }
    get prevSibling() {
        let { buffer } = this.context;
        let parentStart = this._parent ? this._parent.index + 4 : 0;
        if (this.index == parentStart)
            return this.externalSibling(-1);
        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
    }
    get tree() { return null; }
    toTree() {
        let children = [], positions = [];
        let { buffer } = this.context;
        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];
        if (endI > startI) {
            let from = buffer.buffer[this.index + 1];
            children.push(buffer.slice(startI, endI, from));
            positions.push(0);
        }
        return new dist_Tree(this.type, children, positions, this.to - this.from);
    }
    /**
    @internal
    */
    toString() { return this.context.buffer.childString(this.index); }
}
function iterStack(heads) {
    if (!heads.length)
        return null;
    let pick = 0, picked = heads[0];
    for (let i = 1; i < heads.length; i++) {
        let node = heads[i];
        if (node.from > picked.from || node.to < picked.to) {
            picked = node;
            pick = i;
        }
    }
    let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;
    let newHeads = heads.slice();
    if (next)
        newHeads[pick] = next;
    else
        newHeads.splice(pick, 1);
    return new StackIterator(newHeads, picked);
}
class StackIterator {
    constructor(heads, node) {
        this.heads = heads;
        this.node = node;
    }
    get next() { return iterStack(this.heads); }
}
function stackIterator(tree, pos, side) {
    let inner = tree.resolveInner(pos, side), layers = null;
    for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {
        if (scan.index < 0) { // This is an overlay root
            let parent = scan.parent;
            (layers || (layers = [inner])).push(parent.resolve(pos, side));
            scan = parent;
        }
        else {
            let mount = MountedTree.get(scan.tree);
            // Relevant overlay branching off
            if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {
                let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);
                (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));
            }
        }
    }
    return layers ? iterStack(layers) : inner;
}
/**
A tree cursor object focuses on a given node in a syntax tree, and
allows you to move to adjacent nodes.
*/
class TreeCursor {
    /**
    Shorthand for `.type.name`.
    */
    get name() { return this.type.name; }
    /**
    @internal
    */
    constructor(node, 
    /**
    @internal
    */
    mode = 0) {
        this.mode = mode;
        /**
        @internal
        */
        this.buffer = null;
        this.stack = [];
        /**
        @internal
        */
        this.index = 0;
        this.bufferNode = null;
        if (node instanceof TreeNode) {
            this.yieldNode(node);
        }
        else {
            this._tree = node.context.parent;
            this.buffer = node.context;
            for (let n = node._parent; n; n = n._parent)
                this.stack.unshift(n.index);
            this.bufferNode = node;
            this.yieldBuf(node.index);
        }
    }
    yieldNode(node) {
        if (!node)
            return false;
        this._tree = node;
        this.type = node.type;
        this.from = node.from;
        this.to = node.to;
        return true;
    }
    yieldBuf(index, type) {
        this.index = index;
        let { start, buffer } = this.buffer;
        this.type = type || buffer.set.types[buffer.buffer[index]];
        this.from = start + buffer.buffer[index + 1];
        this.to = start + buffer.buffer[index + 2];
        return true;
    }
    /**
    @internal
    */
    yield(node) {
        if (!node)
            return false;
        if (node instanceof TreeNode) {
            this.buffer = null;
            return this.yieldNode(node);
        }
        this.buffer = node.context;
        return this.yieldBuf(node.index, node.type);
    }
    /**
    @internal
    */
    toString() {
        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
    }
    /**
    @internal
    */
    enterChild(dir, pos, side) {
        if (!this.buffer)
            return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));
        let { buffer } = this.buffer;
        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);
        if (index < 0)
            return false;
        this.stack.push(this.index);
        return this.yieldBuf(index);
    }
    /**
    Move the cursor to this node's first child. When this returns
    false, the node has no child, and the cursor has not been moved.
    */
    firstChild() { return this.enterChild(1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to this node's last child.
    */
    lastChild() { return this.enterChild(-1, 0, 4 /* Side.DontCare */); }
    /**
    Move the cursor to the first child that ends after `pos`.
    */
    childAfter(pos) { return this.enterChild(1, pos, 2 /* Side.After */); }
    /**
    Move to the last child that starts before `pos`.
    */
    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Side.Before */); }
    /**
    Move the cursor to the child around `pos`. If side is -1 the
    child may end at that position, when 1 it may start there. This
    will also enter [overlaid](#common.MountedTree.overlay)
    [mounted](#common.NodeProp^mounted) trees unless `overlays` is
    set to false.
    */
    enter(pos, side, mode = this.mode) {
        if (!this.buffer)
            return this.yield(this._tree.enter(pos, side, mode));
        return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);
    }
    /**
    Move to the node's parent node, if this isn't the top node.
    */
    parent() {
        if (!this.buffer)
            return this.yieldNode((this.mode & IterMode.IncludeAnonymous) ? this._tree._parent : this._tree.parent);
        if (this.stack.length)
            return this.yieldBuf(this.stack.pop());
        let parent = (this.mode & IterMode.IncludeAnonymous) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
        this.buffer = null;
        return this.yieldNode(parent);
    }
    /**
    @internal
    */
    sibling(dir) {
        if (!this.buffer)
            return !this._tree._parent ? false
                : this.yield(this._tree.index < 0 ? null
                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));
        let { buffer } = this.buffer, d = this.stack.length - 1;
        if (dir < 0) {
            let parentStart = d < 0 ? 0 : this.stack[d] + 4;
            if (this.index != parentStart)
                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));
        }
        else {
            let after = buffer.buffer[this.index + 3];
            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))
                return this.yieldBuf(after);
        }
        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;
    }
    /**
    Move to this node's next sibling, if any.
    */
    nextSibling() { return this.sibling(1); }
    /**
    Move to this node's previous sibling, if any.
    */
    prevSibling() { return this.sibling(-1); }
    atLastNode(dir) {
        let index, parent, { buffer } = this;
        if (buffer) {
            if (dir > 0) {
                if (this.index < buffer.buffer.buffer.length)
                    return false;
            }
            else {
                for (let i = 0; i < this.index; i++)
                    if (buffer.buffer.buffer[i + 3] < this.index)
                        return false;
            }
            ({ index, parent } = buffer);
        }
        else {
            ({ index, _parent: parent } = this._tree);
        }
        for (; parent; { index, _parent: parent } = parent) {
            if (index > -1)
                for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {
                    let child = parent._tree.children[i];
                    if ((this.mode & IterMode.IncludeAnonymous) ||
                        child instanceof TreeBuffer ||
                        !child.type.isAnonymous ||
                        hasChild(child))
                        return false;
                }
        }
        return true;
    }
    move(dir, enter) {
        if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */))
            return true;
        for (;;) {
            if (this.sibling(dir))
                return true;
            if (this.atLastNode(dir) || !this.parent())
                return false;
        }
    }
    /**
    Move to the next node in a
    [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
    traversal, going from a node to its first child or, if the
    current node is empty or `enter` is false, its next sibling or
    the next sibling of the first parent node that has one.
    */
    next(enter = true) { return this.move(1, enter); }
    /**
    Move to the next node in a last-to-first pre-order traveral. A
    node is followed by its last child or, if it has none, its
    previous sibling or the previous sibling of the first parent
    node that has one.
    */
    prev(enter = true) { return this.move(-1, enter); }
    /**
    Move the cursor to the innermost node that covers `pos`. If
    `side` is -1, it will enter nodes that end at `pos`. If it is 1,
    it will enter nodes that start at `pos`.
    */
    moveTo(pos, side = 0) {
        // Move up to a node that actually holds the position, if possible
        while (this.from == this.to ||
            (side < 1 ? this.from >= pos : this.from > pos) ||
            (side > -1 ? this.to <= pos : this.to < pos))
            if (!this.parent())
                break;
        // Then scan down into child nodes as far as possible
        while (this.enterChild(1, pos, side)) { }
        return this;
    }
    /**
    Get a [syntax node](#common.SyntaxNode) at the cursor's current
    position.
    */
    get node() {
        if (!this.buffer)
            return this._tree;
        let cache = this.bufferNode, result = null, depth = 0;
        if (cache && cache.context == this.buffer) {
            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {
                for (let c = cache; c; c = c._parent)
                    if (c.index == index) {
                        if (index == this.index)
                            return c;
                        result = c;
                        depth = d + 1;
                        break scan;
                    }
                index = this.stack[--d];
            }
        }
        for (let i = depth; i < this.stack.length; i++)
            result = new BufferNode(this.buffer, result, this.stack[i]);
        return this.bufferNode = new BufferNode(this.buffer, result, this.index);
    }
    /**
    Get the [tree](#common.Tree) that represents the current node, if
    any. Will return null when the node is in a [tree
    buffer](#common.TreeBuffer).
    */
    get tree() {
        return this.buffer ? null : this._tree._tree;
    }
    /**
    Iterate over the current node and all its descendants, calling
    `enter` when entering a node and `leave`, if given, when leaving
    one. When `enter` returns `false`, any children of that node are
    skipped, and `leave` isn't called for it.
    */
    iterate(enter, leave) {
        for (let depth = 0;;) {
            let mustLeave = false;
            if (this.type.isAnonymous || enter(this) !== false) {
                if (this.firstChild()) {
                    depth++;
                    continue;
                }
                if (!this.type.isAnonymous)
                    mustLeave = true;
            }
            for (;;) {
                if (mustLeave && leave)
                    leave(this);
                mustLeave = this.type.isAnonymous;
                if (this.nextSibling())
                    break;
                if (!depth)
                    return;
                this.parent();
                depth--;
                mustLeave = true;
            }
        }
    }
    /**
    Test whether the current node matches a given context—a sequence
    of direct parent node names. Empty strings in the context array
    are treated as wildcards.
    */
    matchContext(context) {
        if (!this.buffer)
            return matchNodeContext(this.node, context);
        let { buffer } = this.buffer, { types } = buffer.set;
        for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {
            if (d < 0)
                return matchNodeContext(this.node, context, i);
            let type = types[buffer.buffer[this.stack[d]]];
            if (!type.isAnonymous) {
                if (context[i] && context[i] != type.name)
                    return false;
                i--;
            }
        }
        return true;
    }
}
function hasChild(tree) {
    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));
}
function buildTree(data) {
    var _a;
    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;
    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;
    let types = nodeSet.types;
    let contextHash = 0, lookAhead = 0;
    function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {
        let { id, start, end, size } = cursor;
        let lookAheadAtStart = lookAhead;
        while (size < 0) {
            cursor.next();
            if (size == -1 /* SpecialRecord.Reuse */) {
                let node = reused[id];
                children.push(node);
                positions.push(start - parentStart);
                return;
            }
            else if (size == -3 /* SpecialRecord.ContextChange */) { // Context change
                contextHash = id;
                return;
            }
            else if (size == -4 /* SpecialRecord.LookAhead */) {
                lookAhead = id;
                return;
            }
            else {
                throw new RangeError(`Unrecognized record size: ${size}`);
            }
        }
        let type = types[id], node, buffer;
        let startPos = start - parentStart;
        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {
            // Small enough for a buffer, and no reused nodes inside
            let data = new Uint16Array(buffer.size - buffer.skip);
            let endPos = cursor.pos - buffer.size, index = data.length;
            while (cursor.pos > endPos)
                index = copyToBuffer(buffer.start, data, index);
            node = new TreeBuffer(data, end - buffer.start, nodeSet);
            startPos = buffer.start - parentStart;
        }
        else { // Make it a node
            let endPos = cursor.pos - size;
            cursor.next();
            let localChildren = [], localPositions = [];
            let localInRepeat = id >= minRepeatType ? id : -1;
            let lastGroup = 0, lastEnd = end;
            while (cursor.pos > endPos) {
                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {
                    if (cursor.end <= lastEnd - maxBufferLength) {
                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);
                        lastGroup = localChildren.length;
                        lastEnd = cursor.end;
                    }
                    cursor.next();
                }
                else if (depth > 2500 /* CutOff.Depth */) {
                    takeFlatNode(start, endPos, localChildren, localPositions);
                }
                else {
                    takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);
                }
            }
            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)
                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);
            localChildren.reverse();
            localPositions.reverse();
            if (localInRepeat > -1 && lastGroup > 0) {
                let make = makeBalanced(type);
                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);
            }
            else {
                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);
            }
        }
        children.push(node);
        positions.push(startPos);
    }
    function takeFlatNode(parentStart, minPos, children, positions) {
        let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions
        let nodeCount = 0, stopAt = -1;
        while (cursor.pos > minPos) {
            let { id, start, end, size } = cursor;
            if (size > 4) { // Not a leaf
                cursor.next();
            }
            else if (stopAt > -1 && start < stopAt) {
                break;
            }
            else {
                if (stopAt < 0)
                    stopAt = end - maxBufferLength;
                nodes.push(id, start, end);
                nodeCount++;
                cursor.next();
            }
        }
        if (nodeCount) {
            let buffer = new Uint16Array(nodeCount * 4);
            let start = nodes[nodes.length - 2];
            for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {
                buffer[j++] = nodes[i];
                buffer[j++] = nodes[i + 1] - start;
                buffer[j++] = nodes[i + 2] - start;
                buffer[j++] = j;
            }
            children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));
            positions.push(start - parentStart);
        }
    }
    function makeBalanced(type) {
        return (children, positions, length) => {
            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;
            if (lastI >= 0 && (last = children[lastI]) instanceof dist_Tree) {
                if (!lastI && last.type == type && last.length == length)
                    return last;
                if (lookAheadProp = last.prop(dist_NodeProp.lookAhead))
                    lookAhead = positions[lastI] + last.length + lookAheadProp;
            }
            return makeTree(type, children, positions, length, lookAhead);
        };
    }
    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {
        let localChildren = [], localPositions = [];
        while (children.length > i) {
            localChildren.push(children.pop());
            localPositions.push(positions.pop() + base - from);
        }
        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));
        positions.push(from - base);
    }
    function makeTree(type, children, positions, length, lookAhead = 0, props) {
        if (contextHash) {
            let pair = [dist_NodeProp.contextHash, contextHash];
            props = props ? [pair].concat(props) : [pair];
        }
        if (lookAhead > 25) {
            let pair = [dist_NodeProp.lookAhead, lookAhead];
            props = props ? [pair].concat(props) : [pair];
        }
        return new dist_Tree(type, children, positions, length, props);
    }
    function findBufferSize(maxSize, inRepeat) {
        // Scan through the buffer to find previous siblings that fit
        // together in a TreeBuffer, and don't contain any reused nodes
        // (which can't be stored in a buffer).
        // If `inRepeat` is > -1, ignore node boundaries of that type for
        // nesting, but make sure the end falls either at the start
        // (`maxSize`) or before such a node.
        let fork = cursor.fork();
        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;
        let result = { size: 0, start: 0, skip: 0 };
        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {
            let nodeSize = fork.size;
            // Pretend nested repeat nodes of the same type don't exist
            if (fork.id == inRepeat && nodeSize >= 0) {
                // Except that we store the current state as a valid return
                // value.
                result.size = size;
                result.start = start;
                result.skip = skip;
                skip += 4;
                size += 4;
                fork.next();
                continue;
            }
            let startPos = fork.pos - nodeSize;
            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)
                break;
            let localSkipped = fork.id >= minRepeatType ? 4 : 0;
            let nodeStart = fork.start;
            fork.next();
            while (fork.pos > startPos) {
                if (fork.size < 0) {
                    if (fork.size == -3 /* SpecialRecord.ContextChange */)
                        localSkipped += 4;
                    else
                        break scan;
                }
                else if (fork.id >= minRepeatType) {
                    localSkipped += 4;
                }
                fork.next();
            }
            start = nodeStart;
            size += nodeSize;
            skip += localSkipped;
        }
        if (inRepeat < 0 || size == maxSize) {
            result.size = size;
            result.start = start;
            result.skip = skip;
        }
        return result.size > 4 ? result : undefined;
    }
    function copyToBuffer(bufferStart, buffer, index) {
        let { id, start, end, size } = cursor;
        cursor.next();
        if (size >= 0 && id < minRepeatType) {
            let startIndex = index;
            if (size > 4) {
                let endPos = cursor.pos - (size - 4);
                while (cursor.pos > endPos)
                    index = copyToBuffer(bufferStart, buffer, index);
            }
            buffer[--index] = startIndex;
            buffer[--index] = end - bufferStart;
            buffer[--index] = start - bufferStart;
            buffer[--index] = id;
        }
        else if (size == -3 /* SpecialRecord.ContextChange */) {
            contextHash = id;
        }
        else if (size == -4 /* SpecialRecord.LookAhead */) {
            lookAhead = id;
        }
        return index;
    }
    let children = [], positions = [];
    while (cursor.pos > 0)
        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);
    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);
    return new dist_Tree(types[data.topID], children.reverse(), positions.reverse(), length);
}
const nodeSizeCache = new WeakMap;
function nodeSize(balanceType, node) {
    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)
        return 1;
    let size = nodeSizeCache.get(node);
    if (size == null) {
        size = 1;
        for (let child of node.children) {
            if (child.type != balanceType || !(child instanceof dist_Tree)) {
                size = 1;
                break;
            }
            size += nodeSize(balanceType, child);
        }
        nodeSizeCache.set(node, size);
    }
    return size;
}
function balanceRange(
// The type the balanced tree's inner nodes.
balanceType, 
// The direct children and their positions
children, positions, 
// The index range in children/positions to use
from, to, 
// The start position of the nodes, relative to their parent.
start, 
// Length of the outer node
length, 
// Function to build the top node of the balanced tree
mkTop, 
// Function to build internal nodes for the balanced tree
mkTree) {
    let total = 0;
    for (let i = from; i < to; i++)
        total += nodeSize(balanceType, children[i]);
    let maxChild = Math.ceil((total * 1.5) / 8 /* Balance.BranchFactor */);
    let localChildren = [], localPositions = [];
    function divide(children, positions, from, to, offset) {
        for (let i = from; i < to;) {
            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);
            i++;
            for (; i < to; i++) {
                let nextSize = nodeSize(balanceType, children[i]);
                if (groupSize + nextSize >= maxChild)
                    break;
                groupSize += nextSize;
            }
            if (i == groupFrom + 1) {
                if (groupSize > maxChild) {
                    let only = children[groupFrom]; // Only trees can have a size > 1
                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);
                    continue;
                }
                localChildren.push(children[groupFrom]);
            }
            else {
                let length = positions[i - 1] + children[i - 1].length - groupStart;
                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));
            }
            localPositions.push(groupStart + offset - start);
        }
    }
    divide(children, positions, from, to, 0);
    return (mkTop || mkTree)(localChildren, localPositions, length);
}
/**
Provides a way to associate values with pieces of trees. As long
as that part of the tree is reused, the associated values can be
retrieved from an updated tree.
*/
class NodeWeakMap {
    constructor() {
        this.map = new WeakMap();
    }
    setBuffer(buffer, index, value) {
        let inner = this.map.get(buffer);
        if (!inner)
            this.map.set(buffer, inner = new Map);
        inner.set(index, value);
    }
    getBuffer(buffer, index) {
        let inner = this.map.get(buffer);
        return inner && inner.get(index);
    }
    /**
    Set the value for this syntax node.
    */
    set(node, value) {
        if (node instanceof BufferNode)
            this.setBuffer(node.context.buffer, node.index, value);
        else if (node instanceof TreeNode)
            this.map.set(node.tree, value);
    }
    /**
    Retrieve value for this syntax node, if it exists in the map.
    */
    get(node) {
        return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index)
            : node instanceof TreeNode ? this.map.get(node.tree) : undefined;
    }
    /**
    Set the value for the node that a cursor currently points to.
    */
    cursorSet(cursor, value) {
        if (cursor.buffer)
            this.setBuffer(cursor.buffer.buffer, cursor.index, value);
        else
            this.map.set(cursor.tree, value);
    }
    /**
    Retrieve the value for the node that a cursor currently points
    to.
    */
    cursorGet(cursor) {
        return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);
    }
}

/**
Tree fragments are used during [incremental
parsing](#common.Parser.startParse) to track parts of old trees
that can be reused in a new parse. An array of fragments is used
to track regions of an old tree whose nodes might be reused in new
parses. Use the static
[`applyChanges`](#common.TreeFragment^applyChanges) method to
update fragments for document changes.
*/
class TreeFragment {
    /**
    Construct a tree fragment. You'll usually want to use
    [`addTree`](#common.TreeFragment^addTree) and
    [`applyChanges`](#common.TreeFragment^applyChanges) instead of
    calling this directly.
    */
    constructor(
    /**
    The start of the unchanged range pointed to by this fragment.
    This refers to an offset in the _updated_ document (as opposed
    to the original tree).
    */
    from, 
    /**
    The end of the unchanged range.
    */
    to, 
    /**
    The tree that this fragment is based on.
    */
    tree, 
    /**
    The offset between the fragment's tree and the document that
    this fragment can be used against. Add this when going from
    document to tree positions, subtract it to go from tree to
    document positions.
    */
    offset, openStart = false, openEnd = false) {
        this.from = from;
        this.to = to;
        this.tree = tree;
        this.offset = offset;
        this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);
    }
    /**
    Whether the start of the fragment represents the start of a
    parse, or the end of a change. (In the second case, it may not
    be safe to reuse some nodes at the start, depending on the
    parsing algorithm.)
    */
    get openStart() { return (this.open & 1 /* Open.Start */) > 0; }
    /**
    Whether the end of the fragment represents the end of a
    full-document parse, or the start of a change.
    */
    get openEnd() { return (this.open & 2 /* Open.End */) > 0; }
    /**
    Create a set of fragments from a freshly parsed tree, or update
    an existing set of fragments by replacing the ones that overlap
    with a tree with content from the new tree. When `partial` is
    true, the parse is treated as incomplete, and the resulting
    fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
    true.
    */
    static addTree(tree, fragments = [], partial = false) {
        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];
        for (let f of fragments)
            if (f.to > tree.length)
                result.push(f);
        return result;
    }
    /**
    Apply a set of edits to an array of fragments, removing or
    splitting fragments as necessary to remove edited ranges, and
    adjusting offsets for fragments that moved.
    */
    static applyChanges(fragments, changes, minGap = 128) {
        if (!changes.length)
            return fragments;
        let result = [];
        let fI = 1, nextF = fragments.length ? fragments[0] : null;
        for (let cI = 0, pos = 0, off = 0;; cI++) {
            let nextC = cI < changes.length ? changes[cI] : null;
            let nextPos = nextC ? nextC.fromA : 1e9;
            if (nextPos - pos >= minGap)
                while (nextF && nextF.from < nextPos) {
                    let cut = nextF;
                    if (pos >= cut.from || nextPos <= cut.to || off) {
                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;
                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);
                    }
                    if (cut)
                        result.push(cut);
                    if (nextF.to > nextPos)
                        break;
                    nextF = fI < fragments.length ? fragments[fI++] : null;
                }
            if (!nextC)
                break;
            pos = nextC.toA;
            off = nextC.toA - nextC.toB;
        }
        return result;
    }
}
/**
A superclass that parsers should extend.
*/
class dist_Parser {
    /**
    Start a parse, returning a [partial parse](#common.PartialParse)
    object. [`fragments`](#common.TreeFragment) can be passed in to
    make the parse incremental.
    
    By default, the entire input is parsed. You can pass `ranges`,
    which should be a sorted array of non-empty, non-overlapping
    ranges, to parse only those ranges. The tree returned in that
    case will start at `ranges[0].from`.
    */
    startParse(input, fragments, ranges) {
        if (typeof input == "string")
            input = new StringInput(input);
        ranges = !ranges ? [new dist_Range(0, input.length)] : ranges.length ? ranges.map(r => new dist_Range(r.from, r.to)) : [new dist_Range(0, 0)];
        return this.createParse(input, fragments || [], ranges);
    }
    /**
    Run a full parse, returning the resulting tree.
    */
    parse(input, fragments, ranges) {
        let parse = this.startParse(input, fragments, ranges);
        for (;;) {
            let done = parse.advance();
            if (done)
                return done;
        }
    }
}
class StringInput {
    constructor(string) {
        this.string = string;
    }
    get length() { return this.string.length; }
    chunk(from) { return this.string.slice(from); }
    get lineChunks() { return false; }
    read(from, to) { return this.string.slice(from, to); }
}

/**
Create a parse wrapper that, after the inner parse completes,
scans its tree for mixed language regions with the `nest`
function, runs the resulting [inner parses](#common.NestedParse),
and then [mounts](#common.NodeProp^mounted) their results onto the
tree.
*/
function parseMixed(nest) {
    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);
}
class InnerParse {
    constructor(parser, parse, overlay, target, from) {
        this.parser = parser;
        this.parse = parse;
        this.overlay = overlay;
        this.target = target;
        this.from = from;
    }
}
function checkRanges(ranges) {
    if (!ranges.length || ranges.some(r => r.from >= r.to))
        throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(ranges));
}
class ActiveOverlay {
    constructor(parser, predicate, mounts, index, start, target, prev) {
        this.parser = parser;
        this.predicate = predicate;
        this.mounts = mounts;
        this.index = index;
        this.start = start;
        this.target = target;
        this.prev = prev;
        this.depth = 0;
        this.ranges = [];
    }
}
const stoppedInner = new dist_NodeProp({ perNode: true });
class MixedParse {
    constructor(base, nest, input, fragments, ranges) {
        this.nest = nest;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.inner = [];
        this.innerDone = 0;
        this.baseTree = null;
        this.stoppedAt = null;
        this.baseParse = base;
    }
    advance() {
        if (this.baseParse) {
            let done = this.baseParse.advance();
            if (!done)
                return null;
            this.baseParse = null;
            this.baseTree = done;
            this.startInner();
            if (this.stoppedAt != null)
                for (let inner of this.inner)
                    inner.parse.stopAt(this.stoppedAt);
        }
        if (this.innerDone == this.inner.length) {
            let result = this.baseTree;
            if (this.stoppedAt != null)
                result = new dist_Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));
            return result;
        }
        let inner = this.inner[this.innerDone], done = inner.parse.advance();
        if (done) {
            this.innerDone++;
            // This is a somewhat dodgy but super helpful hack where we
            // patch up nodes created by the inner parse (and thus
            // presumably not aliased anywhere else) to hold the information
            // about the inner parse.
            let props = Object.assign(Object.create(null), inner.target.props);
            props[dist_NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);
            inner.target.props = props;
        }
        return null;
    }
    get parsedPos() {
        if (this.baseParse)
            return 0;
        let pos = this.input.length;
        for (let i = this.innerDone; i < this.inner.length; i++) {
            if (this.inner[i].from < pos)
                pos = Math.min(pos, this.inner[i].parse.parsedPos);
        }
        return pos;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
        if (this.baseParse)
            this.baseParse.stopAt(pos);
        else
            for (let i = this.innerDone; i < this.inner.length; i++)
                this.inner[i].parse.stopAt(pos);
    }
    startInner() {
        let fragmentCursor = new FragmentCursor(this.fragments);
        let overlay = null;
        let covered = null;
        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
        scan: for (let nest, isCovered;;) {
            let enter = true, range;
            if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {
                enter = false;
            }
            else if (fragmentCursor.hasNode(cursor)) {
                if (overlay) {
                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);
                    if (match)
                        for (let r of match.mount.overlay) {
                            let from = r.from + match.pos, to = r.to + match.pos;
                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))
                                overlay.ranges.push({ from, to });
                        }
                }
                enter = false;
            }
            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {
                enter = isCovered != 2 /* Cover.Full */;
            }
            else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) &&
                (cursor.from < cursor.to || !nest.overlay)) {
                if (!cursor.tree)
                    materialize(cursor);
                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);
                if (typeof nest.overlay == "function") {
                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);
                }
                else {
                    let ranges = punchRanges(this.ranges, nest.overlay ||
                        (cursor.from < cursor.to ? [new dist_Range(cursor.from, cursor.to)] : []));
                    if (ranges.length)
                        checkRanges(ranges);
                    if (ranges.length || !nest.overlay)
                        this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges)
                            : nest.parser.startParse(""), nest.overlay ? nest.overlay.map(r => new dist_Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));
                    if (!nest.overlay)
                        enter = false;
                    else if (ranges.length)
                        covered = { ranges, depth: 0, prev: covered };
                }
            }
            else if (overlay && (range = overlay.predicate(cursor))) {
                if (range === true)
                    range = new dist_Range(cursor.from, cursor.to);
                if (range.from < range.to)
                    overlay.ranges.push(range);
            }
            if (enter && cursor.firstChild()) {
                if (overlay)
                    overlay.depth++;
                if (covered)
                    covered.depth++;
            }
            else {
                for (;;) {
                    if (cursor.nextSibling())
                        break;
                    if (!cursor.parent())
                        break scan;
                    if (overlay && !--overlay.depth) {
                        let ranges = punchRanges(this.ranges, overlay.ranges);
                        if (ranges.length) {
                            checkRanges(ranges);
                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new dist_Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));
                        }
                        overlay = overlay.prev;
                    }
                    if (covered && !--covered.depth)
                        covered = covered.prev;
                }
            }
        }
    }
}
function checkCover(covered, from, to) {
    for (let range of covered) {
        if (range.from >= to)
            break;
        if (range.to > from)
            return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;
    }
    return 0 /* Cover.None */;
}
// Take a piece of buffer and convert it into a stand-alone
// TreeBuffer.
function sliceBuf(buf, startI, endI, nodes, positions, off) {
    if (startI < endI) {
        let from = buf.buffer[startI + 1];
        nodes.push(buf.slice(startI, endI, from));
        positions.push(from - off);
    }
}
// This function takes a node that's in a buffer, and converts it, and
// its parent buffer nodes, into a Tree. This is again acting on the
// assumption that the trees and buffers have been constructed by the
// parse that was ran via the mix parser, and thus aren't shared with
// any other code, making violations of the immutability safe.
function materialize(cursor) {
    let { node } = cursor, stack = [];
    let buffer = node.context.buffer;
    // Scan up to the nearest tree
    do {
        stack.push(cursor.index);
        cursor.parent();
    } while (!cursor.tree);
    // Find the index of the buffer in that tree
    let base = cursor.tree, i = base.children.indexOf(buffer);
    let buf = base.children[i], b = buf.buffer, newStack = [i];
    // Split a level in the buffer, putting the nodes before and after
    // the child that contains `node` into new buffers.
    function split(startI, endI, type, innerOffset, length, stackPos) {
        let targetI = stack[stackPos];
        let children = [], positions = [];
        sliceBuf(buf, startI, targetI, children, positions, innerOffset);
        let from = b[targetI + 1], to = b[targetI + 2];
        newStack.push(children.length);
        let child = stackPos
            ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1)
            : node.toTree();
        children.push(child);
        positions.push(from - innerOffset);
        sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);
        return new dist_Tree(type, children, positions, length);
    }
    base.children[i] = split(0, b.length, dist_NodeType.none, 0, buf.length, stack.length - 1);
    // Move the cursor back to the target node
    for (let index of newStack) {
        let tree = cursor.tree.children[index], pos = cursor.tree.positions[index];
        cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));
    }
}
class StructureCursor {
    constructor(root, offset) {
        this.offset = offset;
        this.done = false;
        this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);
    }
    // Move to the first node (in pre-order) that starts at or after `pos`.
    moveTo(pos) {
        let { cursor } = this, p = pos - this.offset;
        while (!this.done && cursor.from < p) {
            if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;
            else if (!cursor.next(false))
                this.done = true;
        }
    }
    hasNode(cursor) {
        this.moveTo(cursor.from);
        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {
            for (let tree = this.cursor.tree;;) {
                if (tree == cursor.tree)
                    return true;
                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof dist_Tree)
                    tree = tree.children[0];
                else
                    break;
            }
        }
        return false;
    }
}
class FragmentCursor {
    constructor(fragments) {
        var _a;
        this.fragments = fragments;
        this.curTo = 0;
        this.fragI = 0;
        if (fragments.length) {
            let first = this.curFrag = fragments[0];
            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;
            this.inner = new StructureCursor(first.tree, -first.offset);
        }
        else {
            this.curFrag = this.inner = null;
        }
    }
    hasNode(node) {
        while (this.curFrag && node.from >= this.curTo)
            this.nextFrag();
        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);
    }
    nextFrag() {
        var _a;
        this.fragI++;
        if (this.fragI == this.fragments.length) {
            this.curFrag = this.inner = null;
        }
        else {
            let frag = this.curFrag = this.fragments[this.fragI];
            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;
            this.inner = new StructureCursor(frag.tree, -frag.offset);
        }
    }
    findMounts(pos, parser) {
        var _a;
        let result = [];
        if (this.inner) {
            this.inner.cursor.moveTo(pos, 1);
            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {
                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(dist_NodeProp.mounted);
                if (mount && mount.parser == parser) {
                    for (let i = this.fragI; i < this.fragments.length; i++) {
                        let frag = this.fragments[i];
                        if (frag.from >= pos.to)
                            break;
                        if (frag.tree == this.curFrag.tree)
                            result.push({
                                frag,
                                pos: pos.from - frag.offset,
                                mount
                            });
                    }
                }
            }
        }
        return result;
    }
}
function punchRanges(outer, ranges) {
    let copy = null, current = ranges;
    for (let i = 1, j = 0; i < outer.length; i++) {
        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;
        for (; j < current.length; j++) {
            let r = current[j];
            if (r.from >= gapTo)
                break;
            if (r.to <= gapFrom)
                continue;
            if (!copy)
                current = copy = ranges.slice();
            if (r.from < gapFrom) {
                copy[j] = new dist_Range(r.from, gapFrom);
                if (r.to > gapTo)
                    copy.splice(j + 1, 0, new dist_Range(gapTo, r.to));
            }
            else if (r.to > gapTo) {
                copy[j--] = new dist_Range(gapTo, r.to);
            }
            else {
                copy.splice(j--, 1);
            }
        }
    }
    return current;
}
function findCoverChanges(a, b, from, to) {
    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;
    let result = [];
    for (;;) {
        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;
        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;
        if (inA != inB) {
            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);
            if (start < end)
                result.push(new dist_Range(start, end));
        }
        pos = Math.min(nextA, nextB);
        if (pos == 1e9)
            break;
        if (nextA == pos) {
            if (!inA)
                inA = true;
            else {
                inA = false;
                iA++;
            }
        }
        if (nextB == pos) {
            if (!inB)
                inB = true;
            else {
                inB = false;
                iB++;
            }
        }
    }
    return result;
}
// Given a number of fragments for the outer tree, and a set of ranges
// to parse, find fragments for inner trees mounted around those
// ranges, if any.
function enterFragments(mounts, ranges) {
    let result = [];
    for (let { pos, mount, frag } of mounts) {
        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;
        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);
        if (mount.overlay) {
            let overlay = mount.overlay.map(r => new dist_Range(r.from + pos, r.to + pos));
            let changes = findCoverChanges(ranges, overlay, from, to);
            for (let i = 0, pos = from;; i++) {
                let last = i == changes.length, end = last ? to : changes[i].from;
                if (end > pos)
                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));
                if (last)
                    break;
                pos = changes[i].to;
            }
        }
        else {
            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));
        }
    }
    return result;
}



;// CONCATENATED MODULE: ./node_modules/@lezer/highlight/dist/index.js


let nextTagID = 0;
/**
Highlighting tags are markers that denote a highlighting category.
They are [associated](#highlight.styleTags) with parts of a syntax
tree by a language mode, and then mapped to an actual CSS style by
a [highlighter](#highlight.Highlighter).

Because syntax tree node types and highlight styles have to be
able to talk the same language, CodeMirror uses a mostly _closed_
[vocabulary](#highlight.tags) of syntax tags (as opposed to
traditional open string-based systems, which make it hard for
highlighting themes to cover all the tokens produced by the
various languages).

It _is_ possible to [define](#highlight.Tag^define) your own
highlighting tags for system-internal use (where you control both
the language package and the highlighter), but such tags will not
be picked up by regular highlighters (though you can derive them
from standard tags to allow highlighters to fall back to those).
*/
class Tag {
    /**
    @internal
    */
    constructor(
    /**
    The set of this tag and all its parent tags, starting with
    this one itself and sorted in order of decreasing specificity.
    */
    set, 
    /**
    The base unmodified tag that this one is based on, if it's
    modified @internal
    */
    base, 
    /**
    The modifiers applied to this.base @internal
    */
    modified) {
        this.set = set;
        this.base = base;
        this.modified = modified;
        /**
        @internal
        */
        this.id = nextTagID++;
    }
    /**
    Define a new tag. If `parent` is given, the tag is treated as a
    sub-tag of that parent, and
    [highlighters](#highlight.tagHighlighter) that don't mention
    this tag will try to fall back to the parent tag (or grandparent
    tag, etc).
    */
    static define(parent) {
        if (parent === null || parent === void 0 ? void 0 : parent.base)
            throw new Error("Can not derive from a modified tag");
        let tag = new Tag([], null, []);
        tag.set.push(tag);
        if (parent)
            for (let t of parent.set)
                tag.set.push(t);
        return tag;
    }
    /**
    Define a tag _modifier_, which is a function that, given a tag,
    will return a tag that is a subtag of the original. Applying the
    same modifier to a twice tag will return the same value (`m1(t1)
    == m1(t1)`) and applying multiple modifiers will, regardless or
    order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
    
    When multiple modifiers are applied to a given base tag, each
    smaller set of modifiers is registered as a parent, so that for
    example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
    `m1(m3(t1)`, and so on.
    */
    static defineModifier() {
        let mod = new Modifier;
        return (tag) => {
            if (tag.modified.indexOf(mod) > -1)
                return tag;
            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));
        };
    }
}
let nextModifierID = 0;
class Modifier {
    constructor() {
        this.instances = [];
        this.id = nextModifierID++;
    }
    static get(base, mods) {
        if (!mods.length)
            return base;
        let exists = mods[0].instances.find(t => t.base == base && dist_sameArray(mods, t.modified));
        if (exists)
            return exists;
        let set = [], tag = new Tag(set, base, mods);
        for (let m of mods)
            m.instances.push(tag);
        let configs = powerSet(mods);
        for (let parent of base.set)
            if (!parent.modified.length)
                for (let config of configs)
                    set.push(Modifier.get(parent, config));
        return tag;
    }
}
function dist_sameArray(a, b) {
    return a.length == b.length && a.every((x, i) => x == b[i]);
}
function powerSet(array) {
    let sets = [[]];
    for (let i = 0; i < array.length; i++) {
        for (let j = 0, e = sets.length; j < e; j++) {
            sets.push(sets[j].concat(array[i]));
        }
    }
    return sets.sort((a, b) => b.length - a.length);
}
/**
This function is used to add a set of tags to a language syntax
via [`NodeSet.extend`](#common.NodeSet.extend) or
[`LRParser.configure`](#lr.LRParser.configure).

The argument object maps node selectors to [highlighting
tags](#highlight.Tag) or arrays of tags.

Node selectors may hold one or more (space-separated) node paths.
Such a path can be a [node name](#common.NodeType.name), or
multiple node names (or `*` wildcards) separated by slash
characters, as in `"Block/Declaration/VariableName"`. Such a path
matches the final node but only if its direct parent nodes are the
other nodes mentioned. A `*` in such a path matches any parent,
but only a single level—wildcards that match multiple parents
aren't supported, both for efficiency reasons and because Lezer
trees make it rather hard to reason about what they would match.)

A path can be ended with `/...` to indicate that the tag assigned
to the node should also apply to all child nodes, even if they
match their own style (by default, only the innermost style is
used).

When a path ends in `!`, as in `Attribute!`, no further matching
happens for the node's child nodes, and the entire node gets the
given style.

In this notation, node names that contain `/`, `!`, `*`, or `...`
must be quoted as JSON strings.

For example:

```javascript
parser.withProps(
  styleTags({
    // Style Number and BigNumber nodes
    "Number BigNumber": tags.number,
    // Style Escape nodes whose parent is String
    "String/Escape": tags.escape,
    // Style anything inside Attributes nodes
    "Attributes!": tags.meta,
    // Add a style to all content inside Italic nodes
    "Italic/...": tags.emphasis,
    // Style InvalidString nodes as both `string` and `invalid`
    "InvalidString": [tags.string, tags.invalid],
    // Style the node named "/" as punctuation
    '"/"': tags.punctuation
  })
)
```
*/
function styleTags(spec) {
    let byName = Object.create(null);
    for (let prop in spec) {
        let tags = spec[prop];
        if (!Array.isArray(tags))
            tags = [tags];
        for (let part of prop.split(" "))
            if (part) {
                let pieces = [], mode = 2 /* Mode.Normal */, rest = part;
                for (let pos = 0;;) {
                    if (rest == "..." && pos > 0 && pos + 3 == part.length) {
                        mode = 1 /* Mode.Inherit */;
                        break;
                    }
                    let m = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(rest);
                    if (!m)
                        throw new RangeError("Invalid path: " + part);
                    pieces.push(m[0] == "*" ? "" : m[0][0] == '"' ? JSON.parse(m[0]) : m[0]);
                    pos += m[0].length;
                    if (pos == part.length)
                        break;
                    let next = part[pos++];
                    if (pos == part.length && next == "!") {
                        mode = 0 /* Mode.Opaque */;
                        break;
                    }
                    if (next != "/")
                        throw new RangeError("Invalid path: " + part);
                    rest = part.slice(pos);
                }
                let last = pieces.length - 1, inner = pieces[last];
                if (!inner)
                    throw new RangeError("Invalid path: " + part);
                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);
                byName[inner] = rule.sort(byName[inner]);
            }
    }
    return ruleNodeProp.add(byName);
}
const ruleNodeProp = new dist_NodeProp();
class Rule {
    constructor(tags, mode, context, next) {
        this.tags = tags;
        this.mode = mode;
        this.context = context;
        this.next = next;
    }
    get opaque() { return this.mode == 0 /* Mode.Opaque */; }
    get inherit() { return this.mode == 1 /* Mode.Inherit */; }
    sort(other) {
        if (!other || other.depth < this.depth) {
            this.next = other;
            return this;
        }
        other.next = this.sort(other.next);
        return other;
    }
    get depth() { return this.context ? this.context.length : 0; }
}
Rule.empty = new Rule([], 2 /* Mode.Normal */, null);
/**
Define a [highlighter](#highlight.Highlighter) from an array of
tag/class pairs. Classes associated with more specific tags will
take precedence.
*/
function tagHighlighter(tags, options) {
    let map = Object.create(null);
    for (let style of tags) {
        if (!Array.isArray(style.tag))
            map[style.tag.id] = style.class;
        else
            for (let tag of style.tag)
                map[tag.id] = style.class;
    }
    let { scope, all = null } = options || {};
    return {
        style: (tags) => {
            let cls = all;
            for (let tag of tags) {
                for (let sub of tag.set) {
                    let tagClass = map[sub.id];
                    if (tagClass) {
                        cls = cls ? cls + " " + tagClass : tagClass;
                        break;
                    }
                }
            }
            return cls;
        },
        scope
    };
}
function highlightTags(highlighters, tags) {
    let result = null;
    for (let highlighter of highlighters) {
        let value = highlighter.style(tags);
        if (value)
            result = result ? result + " " + value : value;
    }
    return result;
}
/**
Highlight the given [tree](#common.Tree) with the given
[highlighter](#highlight.Highlighter). Often, the higher-level
[`highlightCode`](#highlight.highlightCode) function is easier to
use.
*/
function highlightTree(tree, highlighter, 
/**
Assign styling to a region of the text. Will be called, in order
of position, for any ranges where more than zero classes apply.
`classes` is a space separated string of CSS classes.
*/
putStyle, 
/**
The start of the range to highlight.
*/
from = 0, 
/**
The end of the range.
*/
to = tree.length) {
    let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);
    builder.highlightRange(tree.cursor(), from, to, "", builder.highlighters);
    builder.flush(to);
}
/**
Highlight the given tree with the given highlighter, calling
`putText` for every piece of text, either with a set of classes or
with the empty string when unstyled, and `putBreak` for every line
break.
*/
function highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {
    let pos = from;
    function writeTo(p, classes) {
        if (p <= pos)
            return;
        for (let text = code.slice(pos, p), i = 0;;) {
            let nextBreak = text.indexOf("\n", i);
            let upto = nextBreak < 0 ? text.length : nextBreak;
            if (upto > i)
                putText(text.slice(i, upto), classes);
            if (nextBreak < 0)
                break;
            putBreak();
            i = nextBreak + 1;
        }
        pos = p;
    }
    highlightTree(tree, highlighter, (from, to, classes) => {
        writeTo(from, "");
        writeTo(to, classes);
    }, from, to);
    writeTo(to, "");
}
class HighlightBuilder {
    constructor(at, highlighters, span) {
        this.at = at;
        this.highlighters = highlighters;
        this.span = span;
        this.class = "";
    }
    startSpan(at, cls) {
        if (cls != this.class) {
            this.flush(at);
            if (at > this.at)
                this.at = at;
            this.class = cls;
        }
    }
    flush(to) {
        if (to > this.at && this.class)
            this.span(this.at, to, this.class);
    }
    highlightRange(cursor, from, to, inheritedClass, highlighters) {
        let { type, from: start, to: end } = cursor;
        if (start >= to || end <= from)
            return;
        if (type.isTop)
            highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));
        let cls = inheritedClass;
        let rule = getStyleTags(cursor) || Rule.empty;
        let tagCls = highlightTags(highlighters, rule.tags);
        if (tagCls) {
            if (cls)
                cls += " ";
            cls += tagCls;
            if (rule.mode == 1 /* Mode.Inherit */)
                inheritedClass += (inheritedClass ? " " : "") + tagCls;
        }
        this.startSpan(Math.max(from, start), cls);
        if (rule.opaque)
            return;
        let mounted = cursor.tree && cursor.tree.prop(dist_NodeProp.mounted);
        if (mounted && mounted.overlay) {
            let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);
            let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));
            let hasChild = cursor.firstChild();
            for (let i = 0, pos = start;; i++) {
                let next = i < mounted.overlay.length ? mounted.overlay[i] : null;
                let nextPos = next ? next.from + start : end;
                let rangeFrom = Math.max(from, pos), rangeTo = Math.min(to, nextPos);
                if (rangeFrom < rangeTo && hasChild) {
                    while (cursor.from < rangeTo) {
                        this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);
                        this.startSpan(Math.min(rangeTo, cursor.to), cls);
                        if (cursor.to >= nextPos || !cursor.nextSibling())
                            break;
                    }
                }
                if (!next || nextPos > to)
                    break;
                pos = next.to + start;
                if (pos > from) {
                    this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), "", innerHighlighters);
                    this.startSpan(Math.min(to, pos), cls);
                }
            }
            if (hasChild)
                cursor.parent();
        }
        else if (cursor.firstChild()) {
            if (mounted)
                inheritedClass = "";
            do {
                if (cursor.to <= from)
                    continue;
                if (cursor.from >= to)
                    break;
                this.highlightRange(cursor, from, to, inheritedClass, highlighters);
                this.startSpan(Math.min(to, cursor.to), cls);
            } while (cursor.nextSibling());
            cursor.parent();
        }
    }
}
/**
Match a syntax node's [highlight rules](#highlight.styleTags). If
there's a match, return its set of tags, and whether it is
opaque (uses a `!`) or applies to all child nodes (`/...`).
*/
function getStyleTags(node) {
    let rule = node.type.prop(ruleNodeProp);
    while (rule && rule.context && !node.matchContext(rule.context))
        rule = rule.next;
    return rule || null;
}
const t = Tag.define;
const comment = t(), dist_name = t(), typeName = t(dist_name), propertyName = t(dist_name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();
/**
The default set of highlighting [tags](#highlight.Tag).

This collection is heavily biased towards programming languages,
and necessarily incomplete. A full ontology of syntactic
constructs would fill a stack of books, and be impractical to
write themes for. So try to make do with this set. If all else
fails, [open an
issue](https://github.com/codemirror/codemirror.next) to propose a
new tag, or [define](#highlight.Tag^define) a local custom tag for
your use case.

Note that it is not obligatory to always attach the most specific
tag possible to an element—if your grammar can't easily
distinguish a certain type of element (such as a local variable),
it is okay to style it as its more general variant (a variable).

For tags that extend some parent tag, the documentation links to
the parent.
*/
const tags = {
    /**
    A comment.
    */
    comment,
    /**
    A line [comment](#highlight.tags.comment).
    */
    lineComment: t(comment),
    /**
    A block [comment](#highlight.tags.comment).
    */
    blockComment: t(comment),
    /**
    A documentation [comment](#highlight.tags.comment).
    */
    docComment: t(comment),
    /**
    Any kind of identifier.
    */
    name: dist_name,
    /**
    The [name](#highlight.tags.name) of a variable.
    */
    variableName: t(dist_name),
    /**
    A type [name](#highlight.tags.name).
    */
    typeName: typeName,
    /**
    A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
    */
    tagName: t(typeName),
    /**
    A property or field [name](#highlight.tags.name).
    */
    propertyName: propertyName,
    /**
    An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
    */
    attributeName: t(propertyName),
    /**
    The [name](#highlight.tags.name) of a class.
    */
    className: t(dist_name),
    /**
    A label [name](#highlight.tags.name).
    */
    labelName: t(dist_name),
    /**
    A namespace [name](#highlight.tags.name).
    */
    namespace: t(dist_name),
    /**
    The [name](#highlight.tags.name) of a macro.
    */
    macroName: t(dist_name),
    /**
    A literal value.
    */
    literal,
    /**
    A string [literal](#highlight.tags.literal).
    */
    string,
    /**
    A documentation [string](#highlight.tags.string).
    */
    docString: t(string),
    /**
    A character literal (subtag of [string](#highlight.tags.string)).
    */
    character: t(string),
    /**
    An attribute value (subtag of [string](#highlight.tags.string)).
    */
    attributeValue: t(string),
    /**
    A number [literal](#highlight.tags.literal).
    */
    number,
    /**
    An integer [number](#highlight.tags.number) literal.
    */
    integer: t(number),
    /**
    A floating-point [number](#highlight.tags.number) literal.
    */
    float: t(number),
    /**
    A boolean [literal](#highlight.tags.literal).
    */
    bool: t(literal),
    /**
    Regular expression [literal](#highlight.tags.literal).
    */
    regexp: t(literal),
    /**
    An escape [literal](#highlight.tags.literal), for example a
    backslash escape in a string.
    */
    escape: t(literal),
    /**
    A color [literal](#highlight.tags.literal).
    */
    color: t(literal),
    /**
    A URL [literal](#highlight.tags.literal).
    */
    url: t(literal),
    /**
    A language keyword.
    */
    keyword,
    /**
    The [keyword](#highlight.tags.keyword) for the self or this
    object.
    */
    self: t(keyword),
    /**
    The [keyword](#highlight.tags.keyword) for null.
    */
    null: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) denoting some atomic value.
    */
    atom: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that represents a unit.
    */
    unit: t(keyword),
    /**
    A modifier [keyword](#highlight.tags.keyword).
    */
    modifier: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that acts as an operator.
    */
    operatorKeyword: t(keyword),
    /**
    A control-flow related [keyword](#highlight.tags.keyword).
    */
    controlKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) that defines something.
    */
    definitionKeyword: t(keyword),
    /**
    A [keyword](#highlight.tags.keyword) related to defining or
    interfacing with modules.
    */
    moduleKeyword: t(keyword),
    /**
    An operator.
    */
    operator,
    /**
    An [operator](#highlight.tags.operator) that dereferences something.
    */
    derefOperator: t(operator),
    /**
    Arithmetic-related [operator](#highlight.tags.operator).
    */
    arithmeticOperator: t(operator),
    /**
    Logical [operator](#highlight.tags.operator).
    */
    logicOperator: t(operator),
    /**
    Bit [operator](#highlight.tags.operator).
    */
    bitwiseOperator: t(operator),
    /**
    Comparison [operator](#highlight.tags.operator).
    */
    compareOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that updates its operand.
    */
    updateOperator: t(operator),
    /**
    [Operator](#highlight.tags.operator) that defines something.
    */
    definitionOperator: t(operator),
    /**
    Type-related [operator](#highlight.tags.operator).
    */
    typeOperator: t(operator),
    /**
    Control-flow [operator](#highlight.tags.operator).
    */
    controlOperator: t(operator),
    /**
    Program or markup punctuation.
    */
    punctuation,
    /**
    [Punctuation](#highlight.tags.punctuation) that separates
    things.
    */
    separator: t(punctuation),
    /**
    Bracket-style [punctuation](#highlight.tags.punctuation).
    */
    bracket,
    /**
    Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
    tokens).
    */
    angleBracket: t(bracket),
    /**
    Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
    tokens).
    */
    squareBracket: t(bracket),
    /**
    Parentheses (usually `(` and `)` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    paren: t(bracket),
    /**
    Braces (usually `{` and `}` tokens). Subtag of
    [bracket](#highlight.tags.bracket).
    */
    brace: t(bracket),
    /**
    Content, for example plain text in XML or markup documents.
    */
    content,
    /**
    [Content](#highlight.tags.content) that represents a heading.
    */
    heading,
    /**
    A level 1 [heading](#highlight.tags.heading).
    */
    heading1: t(heading),
    /**
    A level 2 [heading](#highlight.tags.heading).
    */
    heading2: t(heading),
    /**
    A level 3 [heading](#highlight.tags.heading).
    */
    heading3: t(heading),
    /**
    A level 4 [heading](#highlight.tags.heading).
    */
    heading4: t(heading),
    /**
    A level 5 [heading](#highlight.tags.heading).
    */
    heading5: t(heading),
    /**
    A level 6 [heading](#highlight.tags.heading).
    */
    heading6: t(heading),
    /**
    A prose separator (such as a horizontal rule).
    */
    contentSeparator: t(content),
    /**
    [Content](#highlight.tags.content) that represents a list.
    */
    list: t(content),
    /**
    [Content](#highlight.tags.content) that represents a quote.
    */
    quote: t(content),
    /**
    [Content](#highlight.tags.content) that is emphasized.
    */
    emphasis: t(content),
    /**
    [Content](#highlight.tags.content) that is styled strong.
    */
    strong: t(content),
    /**
    [Content](#highlight.tags.content) that is part of a link.
    */
    link: t(content),
    /**
    [Content](#highlight.tags.content) that is styled as code or
    monospace.
    */
    monospace: t(content),
    /**
    [Content](#highlight.tags.content) that has a strike-through
    style.
    */
    strikethrough: t(content),
    /**
    Inserted text in a change-tracking format.
    */
    inserted: t(),
    /**
    Deleted text.
    */
    deleted: t(),
    /**
    Changed text.
    */
    changed: t(),
    /**
    An invalid or unsyntactic element.
    */
    invalid: t(),
    /**
    Metadata or meta-instruction.
    */
    meta,
    /**
    [Metadata](#highlight.tags.meta) that applies to the entire
    document.
    */
    documentMeta: t(meta),
    /**
    [Metadata](#highlight.tags.meta) that annotates or adds
    attributes to a given syntactic element.
    */
    annotation: t(meta),
    /**
    Processing instruction or preprocessor directive. Subtag of
    [meta](#highlight.tags.meta).
    */
    processingInstruction: t(meta),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that a
    given element is being defined. Expected to be used with the
    various [name](#highlight.tags.name) tags.
    */
    definition: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates that
    something is constant. Mostly expected to be used with
    [variable names](#highlight.tags.variableName).
    */
    constant: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) used to indicate that
    a [variable](#highlight.tags.variableName) or [property
    name](#highlight.tags.propertyName) is being called or defined
    as a function.
    */
    function: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that can be applied to
    [names](#highlight.tags.name) to indicate that they belong to
    the language's standard environment.
    */
    standard: Tag.defineModifier(),
    /**
    [Modifier](#highlight.Tag^defineModifier) that indicates a given
    [names](#highlight.tags.name) is local to some scope.
    */
    local: Tag.defineModifier(),
    /**
    A generic variant [modifier](#highlight.Tag^defineModifier) that
    can be used to tag language-specific alternative variants of
    some common tag. It is recommended for themes to define special
    forms of at least the [string](#highlight.tags.string) and
    [variable name](#highlight.tags.variableName) tags, since those
    come up a lot.
    */
    special: Tag.defineModifier()
};
/**
This is a highlighter that adds stable, predictable classes to
tokens, for styling with external CSS.

The following tags are mapped to their name prefixed with `"tok-"`
(for example `"tok-comment"`):

* [`link`](#highlight.tags.link)
* [`heading`](#highlight.tags.heading)
* [`emphasis`](#highlight.tags.emphasis)
* [`strong`](#highlight.tags.strong)
* [`keyword`](#highlight.tags.keyword)
* [`atom`](#highlight.tags.atom)
* [`bool`](#highlight.tags.bool)
* [`url`](#highlight.tags.url)
* [`labelName`](#highlight.tags.labelName)
* [`inserted`](#highlight.tags.inserted)
* [`deleted`](#highlight.tags.deleted)
* [`literal`](#highlight.tags.literal)
* [`string`](#highlight.tags.string)
* [`number`](#highlight.tags.number)
* [`variableName`](#highlight.tags.variableName)
* [`typeName`](#highlight.tags.typeName)
* [`namespace`](#highlight.tags.namespace)
* [`className`](#highlight.tags.className)
* [`macroName`](#highlight.tags.macroName)
* [`propertyName`](#highlight.tags.propertyName)
* [`operator`](#highlight.tags.operator)
* [`comment`](#highlight.tags.comment)
* [`meta`](#highlight.tags.meta)
* [`punctuation`](#highlight.tags.punctuation)
* [`invalid`](#highlight.tags.invalid)

In addition, these mappings are provided:

* [`regexp`](#highlight.tags.regexp),
  [`escape`](#highlight.tags.escape), and
  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)
  are mapped to `"tok-string2"`
* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName2"`
* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-local"`
* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)
  to `"tok-variableName tok-definition"`
* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)
  to `"tok-propertyName tok-definition"`
*/
const classHighlighter = tagHighlighter([
    { tag: tags.link, class: "tok-link" },
    { tag: tags.heading, class: "tok-heading" },
    { tag: tags.emphasis, class: "tok-emphasis" },
    { tag: tags.strong, class: "tok-strong" },
    { tag: tags.keyword, class: "tok-keyword" },
    { tag: tags.atom, class: "tok-atom" },
    { tag: tags.bool, class: "tok-bool" },
    { tag: tags.url, class: "tok-url" },
    { tag: tags.labelName, class: "tok-labelName" },
    { tag: tags.inserted, class: "tok-inserted" },
    { tag: tags.deleted, class: "tok-deleted" },
    { tag: tags.literal, class: "tok-literal" },
    { tag: tags.string, class: "tok-string" },
    { tag: tags.number, class: "tok-number" },
    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: "tok-string2" },
    { tag: tags.variableName, class: "tok-variableName" },
    { tag: tags.local(tags.variableName), class: "tok-variableName tok-local" },
    { tag: tags.definition(tags.variableName), class: "tok-variableName tok-definition" },
    { tag: tags.special(tags.variableName), class: "tok-variableName2" },
    { tag: tags.definition(tags.propertyName), class: "tok-propertyName tok-definition" },
    { tag: tags.typeName, class: "tok-typeName" },
    { tag: tags.namespace, class: "tok-namespace" },
    { tag: tags.className, class: "tok-className" },
    { tag: tags.macroName, class: "tok-macroName" },
    { tag: tags.propertyName, class: "tok-propertyName" },
    { tag: tags.operator, class: "tok-operator" },
    { tag: tags.comment, class: "tok-comment" },
    { tag: tags.meta, class: "tok-meta" },
    { tag: tags.invalid, class: "tok-invalid" },
    { tag: tags.punctuation, class: "tok-punctuation" }
]);



;// CONCATENATED MODULE: ./node_modules/@codemirror/language/dist/index.js






var _a;
/**
Node prop stored in a parser's top syntax node to provide the
facet that stores language-specific data for that language.
*/
const languageDataProp = /*@__PURE__*/new dist_NodeProp();
/**
Helper function to define a facet (to be added to the top syntax
node(s) for a language via
[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be
used to associate language data with the language. You
probably only need this when subclassing
[`Language`](https://codemirror.net/6/docs/ref/#language.Language).
*/
function defineLanguageFacet(baseData) {
    return Facet.define({
        combine: baseData ? values => values.concat(baseData) : undefined
    });
}
/**
Syntax node prop used to register sublanguages. Should be added to
the top level node type for the language.
*/
const sublanguageProp = /*@__PURE__*/new dist_NodeProp();
/**
A language object manages parsing and per-language
[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is
managed as a [Lezer](https://lezer.codemirror.net) tree. The class
can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)
subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or
via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass
for stream parsers.
*/
class Language {
    /**
    Construct a language object. If you need to invoke this
    directly, first define a data facet with
    [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
    configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
    to the language's outer syntax node.
    */
    constructor(
    /**
    The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet
    used for this language.
    */
    data, parser, extraExtensions = [], 
    /**
    A language name.
    */
    name = "") {
        this.data = data;
        this.name = name;
        // Kludge to define EditorState.tree as a debugging helper,
        // without the EditorState package actually knowing about
        // languages and lezer trees.
        if (!EditorState.prototype.hasOwnProperty("tree"))
            Object.defineProperty(EditorState.prototype, "tree", { get() { return dist_syntaxTree(this); } });
        this.parser = parser;
        this.extension = [
            language.of(this),
            EditorState.languageData.of((state, pos, side) => {
                let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);
                if (!data)
                    return [];
                let base = state.facet(data), sub = top.type.prop(sublanguageProp);
                if (sub) {
                    let innerNode = top.resolve(pos - top.from, side);
                    for (let sublang of sub)
                        if (sublang.test(innerNode, state)) {
                            let data = state.facet(sublang.facet);
                            return sublang.type == "replace" ? data : data.concat(base);
                        }
                }
                return base;
            })
        ].concat(extraExtensions);
    }
    /**
    Query whether this language is active at the given position.
    */
    isActiveAt(state, pos, side = -1) {
        return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;
    }
    /**
    Find the document regions that were parsed using this language.
    The returned regions will _include_ any nested languages rooted
    in this language, when those exist.
    */
    findRegions(state) {
        let lang = state.facet(language);
        if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)
            return [{ from: 0, to: state.doc.length }];
        if (!lang || !lang.allowsNesting)
            return [];
        let result = [];
        let explore = (tree, from) => {
            if (tree.prop(languageDataProp) == this.data) {
                result.push({ from, to: from + tree.length });
                return;
            }
            let mount = tree.prop(dist_NodeProp.mounted);
            if (mount) {
                if (mount.tree.prop(languageDataProp) == this.data) {
                    if (mount.overlay)
                        for (let r of mount.overlay)
                            result.push({ from: r.from + from, to: r.to + from });
                    else
                        result.push({ from: from, to: from + tree.length });
                    return;
                }
                else if (mount.overlay) {
                    let size = result.length;
                    explore(mount.tree, mount.overlay[0].from + from);
                    if (result.length > size)
                        return;
                }
            }
            for (let i = 0; i < tree.children.length; i++) {
                let ch = tree.children[i];
                if (ch instanceof dist_Tree)
                    explore(ch, tree.positions[i] + from);
            }
        };
        explore(dist_syntaxTree(state), 0);
        return result;
    }
    /**
    Indicates whether this language allows nested languages. The
    default implementation returns true.
    */
    get allowsNesting() { return true; }
}
/**
@internal
*/
Language.setState = /*@__PURE__*/StateEffect.define();
function topNodeAt(state, pos, side) {
    let topLang = state.facet(language), tree = dist_syntaxTree(state).topNode;
    if (!topLang || topLang.allowsNesting) {
        for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))
            if (node.type.isTop)
                tree = node;
    }
    return tree;
}
/**
A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer
[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)
parsers.
*/
class LRLanguage extends Language {
    constructor(data, parser, name) {
        super(data, parser, [], name);
        this.parser = parser;
    }
    /**
    Define a language from a parser.
    */
    static define(spec) {
        let data = defineLanguageFacet(spec.languageData);
        return new LRLanguage(data, spec.parser.configure({
            props: [languageDataProp.add(type => type.isTop ? data : undefined)]
        }), spec.name);
    }
    /**
    Create a new instance of this language with a reconfigured
    version of its parser and optionally a new name.
    */
    configure(options, name) {
        return new LRLanguage(this.data, this.parser.configure(options), name || this.name);
    }
    get allowsNesting() { return this.parser.hasWrappers(); }
}
/**
Get the syntax tree for a state, which is the current (possibly
incomplete) parse tree of the active
[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no
language available.
*/
function dist_syntaxTree(state) {
    let field = state.field(Language.state, false);
    return field ? field.tree : dist_Tree.empty;
}
/**
Try to get a parse tree that spans at least up to `upto`. The
method will do at most `timeout` milliseconds of work to parse
up to that point if the tree isn't already available.
*/
function ensureSyntaxTree(state, upto, timeout = 50) {
    var _a;
    let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;
    if (!parse)
        return null;
    let oldVieport = parse.viewport;
    parse.updateViewport({ from: 0, to: upto });
    let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;
    parse.updateViewport(oldVieport);
    return result;
}
/**
Queries whether there is a full syntax tree available up to the
given document position. If there isn't, the background parse
process _might_ still be working and update the tree further, but
there is no guarantee of that—the parser will [stop
working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a
certain amount of time or has moved beyond the visible viewport.
Always returns false if no language has been enabled.
*/
function syntaxTreeAvailable(state, upto = state.doc.length) {
    var _a;
    return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;
}
/**
Move parsing forward, and update the editor state afterwards to
reflect the new tree. Will work for at most `timeout`
milliseconds. Returns true if the parser managed get to the given
position in that time.
*/
function forceParsing(view, upto = view.viewport.to, timeout = 100) {
    let success = ensureSyntaxTree(view.state, upto, timeout);
    if (success != dist_syntaxTree(view.state))
        view.dispatch({});
    return !!success;
}
/**
Tells you whether the language parser is planning to do more
parsing work (in a `requestIdleCallback` pseudo-thread) or has
stopped running, either because it parsed the entire document,
because it spent too much time and was cut off, or because there
is no language parser enabled.
*/
function syntaxParserRunning(view) {
    var _a;
    return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;
}
/**
Lezer-style
[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)
object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.
*/
class DocInput {
    /**
    Create an input object for the given document.
    */
    constructor(doc) {
        this.doc = doc;
        this.cursorPos = 0;
        this.string = "";
        this.cursor = doc.iter();
    }
    get length() { return this.doc.length; }
    syncTo(pos) {
        this.string = this.cursor.next(pos - this.cursorPos).value;
        this.cursorPos = pos + this.string.length;
        return this.cursorPos - this.string.length;
    }
    chunk(pos) {
        this.syncTo(pos);
        return this.string;
    }
    get lineChunks() { return true; }
    read(from, to) {
        let stringStart = this.cursorPos - this.string.length;
        if (from < stringStart || to >= this.cursorPos)
            return this.doc.sliceString(from, to);
        else
            return this.string.slice(from - stringStart, to - stringStart);
    }
}
let currentContext = null;
/**
A parse context provided to parsers working on the editor content.
*/
class ParseContext {
    constructor(parser, 
    /**
    The current editor state.
    */
    state, 
    /**
    Tree fragments that can be reused by incremental re-parses.
    */
    fragments = [], 
    /**
    @internal
    */
    tree, 
    /**
    @internal
    */
    treeLen, 
    /**
    The current editor viewport (or some overapproximation
    thereof). Intended to be used for opportunistically avoiding
    work (in which case
    [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)
    should be called to make sure the parser is restarted when the
    skipped region becomes visible).
    */
    viewport, 
    /**
    @internal
    */
    skipped, 
    /**
    This is where skipping parsers can register a promise that,
    when resolved, will schedule a new parse. It is cleared when
    the parse worker picks up the promise. @internal
    */
    scheduleOn) {
        this.parser = parser;
        this.state = state;
        this.fragments = fragments;
        this.tree = tree;
        this.treeLen = treeLen;
        this.viewport = viewport;
        this.skipped = skipped;
        this.scheduleOn = scheduleOn;
        this.parse = null;
        /**
        @internal
        */
        this.tempSkipped = [];
    }
    /**
    @internal
    */
    static create(parser, state, viewport) {
        return new ParseContext(parser, state, [], dist_Tree.empty, 0, viewport, [], null);
    }
    startParse() {
        return this.parser.startParse(new DocInput(this.state.doc), this.fragments);
    }
    /**
    @internal
    */
    work(until, upto) {
        if (upto != null && upto >= this.state.doc.length)
            upto = undefined;
        if (this.tree != dist_Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {
            this.takeTree();
            return true;
        }
        return this.withContext(() => {
            var _a;
            if (typeof until == "number") {
                let endTime = Date.now() + until;
                until = () => Date.now() > endTime;
            }
            if (!this.parse)
                this.parse = this.startParse();
            if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) &&
                upto < this.state.doc.length)
                this.parse.stopAt(upto);
            for (;;) {
                let done = this.parse.advance();
                if (done) {
                    this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));
                    this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;
                    this.tree = done;
                    this.parse = null;
                    if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length))
                        this.parse = this.startParse();
                    else
                        return true;
                }
                if (until())
                    return false;
            }
        });
    }
    /**
    @internal
    */
    takeTree() {
        let pos, tree;
        if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {
            if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos)
                this.parse.stopAt(pos);
            this.withContext(() => { while (!(tree = this.parse.advance())) { } });
            this.treeLen = pos;
            this.tree = tree;
            this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));
            this.parse = null;
        }
    }
    withContext(f) {
        let prev = currentContext;
        currentContext = this;
        try {
            return f();
        }
        finally {
            currentContext = prev;
        }
    }
    withoutTempSkipped(fragments) {
        for (let r; r = this.tempSkipped.pop();)
            fragments = cutFragments(fragments, r.from, r.to);
        return fragments;
    }
    /**
    @internal
    */
    changes(changes, newState) {
        let { fragments, tree, treeLen, viewport, skipped } = this;
        this.takeTree();
        if (!changes.empty) {
            let ranges = [];
            changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({ fromA, toA, fromB, toB }));
            fragments = TreeFragment.applyChanges(fragments, ranges);
            tree = dist_Tree.empty;
            treeLen = 0;
            viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };
            if (this.skipped.length) {
                skipped = [];
                for (let r of this.skipped) {
                    let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);
                    if (from < to)
                        skipped.push({ from, to });
                }
            }
        }
        return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);
    }
    /**
    @internal
    */
    updateViewport(viewport) {
        if (this.viewport.from == viewport.from && this.viewport.to == viewport.to)
            return false;
        this.viewport = viewport;
        let startLen = this.skipped.length;
        for (let i = 0; i < this.skipped.length; i++) {
            let { from, to } = this.skipped[i];
            if (from < viewport.to && to > viewport.from) {
                this.fragments = cutFragments(this.fragments, from, to);
                this.skipped.splice(i--, 1);
            }
        }
        if (this.skipped.length >= startLen)
            return false;
        this.reset();
        return true;
    }
    /**
    @internal
    */
    reset() {
        if (this.parse) {
            this.takeTree();
            this.parse = null;
        }
    }
    /**
    Notify the parse scheduler that the given region was skipped
    because it wasn't in view, and the parse should be restarted
    when it comes into view.
    */
    skipUntilInView(from, to) {
        this.skipped.push({ from, to });
    }
    /**
    Returns a parser intended to be used as placeholder when
    asynchronously loading a nested parser. It'll skip its input and
    mark it as not-really-parsed, so that the next update will parse
    it again.
    
    When `until` is given, a reparse will be scheduled when that
    promise resolves.
    */
    static getSkippingParser(until) {
        return new class extends dist_Parser {
            createParse(input, fragments, ranges) {
                let from = ranges[0].from, to = ranges[ranges.length - 1].to;
                let parser = {
                    parsedPos: from,
                    advance() {
                        let cx = currentContext;
                        if (cx) {
                            for (let r of ranges)
                                cx.tempSkipped.push(r);
                            if (until)
                                cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;
                        }
                        this.parsedPos = to;
                        return new dist_Tree(dist_NodeType.none, [], [], to - from);
                    },
                    stoppedAt: null,
                    stopAt() { }
                };
                return parser;
            }
        };
    }
    /**
    @internal
    */
    isDone(upto) {
        upto = Math.min(upto, this.state.doc.length);
        let frags = this.fragments;
        return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;
    }
    /**
    Get the context for the current parse, or `null` if no editor
    parse is in progress.
    */
    static get() { return currentContext; }
}
function cutFragments(fragments, from, to) {
    return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);
}
class LanguageState {
    constructor(
    // A mutable parse state that is used to preserve work done during
    // the lifetime of a state when moving to the next state.
    context) {
        this.context = context;
        this.tree = context.tree;
    }
    apply(tr) {
        if (!tr.docChanged && this.tree == this.context.tree)
            return this;
        let newCx = this.context.changes(tr.changes, tr.state);
        // If the previous parse wasn't done, go forward only up to its
        // end position or the end of the viewport, to avoid slowing down
        // state updates with parse work beyond the viewport.
        let upto = this.context.treeLen == tr.startState.doc.length ? undefined
            : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);
        if (!newCx.work(20 /* Work.Apply */, upto))
            newCx.takeTree();
        return new LanguageState(newCx);
    }
    static init(state) {
        let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);
        let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });
        if (!parseState.work(20 /* Work.Apply */, vpTo))
            parseState.takeTree();
        return new LanguageState(parseState);
    }
}
Language.state = /*@__PURE__*/StateField.define({
    create: LanguageState.init,
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(Language.setState))
                return e.value;
        if (tr.startState.facet(language) != tr.state.facet(language))
            return LanguageState.init(tr.state);
        return value.apply(tr);
    }
});
let requestIdle = (callback) => {
    let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);
    return () => clearTimeout(timeout);
};
if (typeof requestIdleCallback != "undefined")
    requestIdle = (callback) => {
        let idle = -1, timeout = setTimeout(() => {
            idle = requestIdleCallback(callback, { timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */ });
        }, 100 /* Work.MinPause */);
        return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);
    };
const isInputPending = typeof navigator != "undefined" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)
    ? () => navigator.scheduling.isInputPending() : null;
const parseWorker = /*@__PURE__*/dist_ViewPlugin.fromClass(class ParseWorker {
    constructor(view) {
        this.view = view;
        this.working = null;
        this.workScheduled = 0;
        // End of the current time chunk
        this.chunkEnd = -1;
        // Milliseconds of budget left for this chunk
        this.chunkBudget = -1;
        this.work = this.work.bind(this);
        this.scheduleWork();
    }
    update(update) {
        let cx = this.view.state.field(Language.state).context;
        if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen)
            this.scheduleWork();
        if (update.docChanged || update.selectionSet) {
            if (this.view.hasFocus)
                this.chunkBudget += 50 /* Work.ChangeBonus */;
            this.scheduleWork();
        }
        this.checkAsyncSchedule(cx);
    }
    scheduleWork() {
        if (this.working)
            return;
        let { state } = this.view, field = state.field(Language.state);
        if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))
            this.working = requestIdle(this.work);
    }
    work(deadline) {
        this.working = null;
        let now = Date.now();
        if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) { // Start a new chunk
            this.chunkEnd = now + 30000 /* Work.ChunkTime */;
            this.chunkBudget = 3000 /* Work.ChunkBudget */;
        }
        if (this.chunkBudget <= 0)
            return; // No more budget
        let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);
        if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */))
            return;
        let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);
        let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;
        let done = field.context.work(() => {
            return isInputPending && isInputPending() || Date.now() > endTime;
        }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));
        this.chunkBudget -= Date.now() - now;
        if (done || this.chunkBudget <= 0) {
            field.context.takeTree();
            this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });
        }
        if (this.chunkBudget > 0 && !(done && !viewportFirst))
            this.scheduleWork();
        this.checkAsyncSchedule(field.context);
    }
    checkAsyncSchedule(cx) {
        if (cx.scheduleOn) {
            this.workScheduled++;
            cx.scheduleOn
                .then(() => this.scheduleWork())
                .catch(err => dist_logException(this.view.state, err))
                .then(() => this.workScheduled--);
            cx.scheduleOn = null;
        }
    }
    destroy() {
        if (this.working)
            this.working();
    }
    isWorking() {
        return !!(this.working || this.workScheduled > 0);
    }
}, {
    eventHandlers: { focus() { this.scheduleWork(); } }
});
/**
The facet used to associate a language with an editor state. Used
by `Language` object's `extension` property (so you don't need to
manually wrap your languages in this). Can be used to access the
current language on a state.
*/
const language = /*@__PURE__*/Facet.define({
    combine(languages) { return languages.length ? languages[0] : null; },
    enables: language => [
        Language.state,
        parseWorker,
        EditorView.contentAttributes.compute([language], state => {
            let lang = state.facet(language);
            return lang && lang.name ? { "data-language": lang.name } : {};
        })
    ]
});
/**
This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an
optional set of supporting extensions. Language packages are
encouraged to export a function that optionally takes a
configuration object and returns a `LanguageSupport` instance, as
the main way for client code to use the package.
*/
class LanguageSupport {
    /**
    Create a language support object.
    */
    constructor(
    /**
    The language object.
    */
    language, 
    /**
    An optional set of supporting extensions. When nesting a
    language in another language, the outer language is encouraged
    to include the supporting extensions for its inner languages
    in its own set of support extensions.
    */
    support = []) {
        this.language = language;
        this.support = support;
        this.extension = [language, support];
    }
}
/**
Language descriptions are used to store metadata about languages
and to dynamically load them. Their main role is finding the
appropriate language for a filename or dynamically loading nested
parsers.
*/
class LanguageDescription {
    constructor(
    /**
    The name of this language.
    */
    name, 
    /**
    Alternative names for the mode (lowercased, includes `this.name`).
    */
    alias, 
    /**
    File extensions associated with this language.
    */
    extensions, 
    /**
    Optional filename pattern that should be associated with this
    language.
    */
    filename, loadFunc, 
    /**
    If the language has been loaded, this will hold its value.
    */
    support = undefined) {
        this.name = name;
        this.alias = alias;
        this.extensions = extensions;
        this.filename = filename;
        this.loadFunc = loadFunc;
        this.support = support;
        this.loading = null;
    }
    /**
    Start loading the the language. Will return a promise that
    resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)
    object when the language successfully loads.
    */
    load() {
        return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => { this.loading = null; throw err; }));
    }
    /**
    Create a language description.
    */
    static of(spec) {
        let { load, support } = spec;
        if (!load) {
            if (!support)
                throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");
            load = () => Promise.resolve(support);
        }
        return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);
    }
    /**
    Look for a language in the given array of descriptions that
    matches the filename. Will first match
    [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,
    and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),
    and return the first language that matches.
    */
    static matchFilename(descs, filename) {
        for (let d of descs)
            if (d.filename && d.filename.test(filename))
                return d;
        let ext = /\.([^.]+)$/.exec(filename);
        if (ext)
            for (let d of descs)
                if (d.extensions.indexOf(ext[1]) > -1)
                    return d;
        return null;
    }
    /**
    Look for a language whose name or alias matches the the given
    name (case-insensitively). If `fuzzy` is true, and no direct
    matchs is found, this'll also search for a language whose name
    or alias occurs in the string (for names shorter than three
    characters, only when surrounded by non-word characters).
    */
    static matchLanguageName(descs, name, fuzzy = true) {
        name = name.toLowerCase();
        for (let d of descs)
            if (d.alias.some(a => a == name))
                return d;
        if (fuzzy)
            for (let d of descs)
                for (let a of d.alias) {
                    let found = name.indexOf(a);
                    if (found > -1 && (a.length > 2 || !/\w/.test(name[found - 1]) && !/\w/.test(name[found + a.length])))
                        return d;
                }
        return null;
    }
}

/**
Facet that defines a way to provide a function that computes the
appropriate indentation depth, as a column number (see
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given
line. A return value of `null` indicates no indentation can be
determined, and the line should inherit the indentation of the one
above it. A return value of `undefined` defers to the next indent
service.
*/
const indentService = /*@__PURE__*/Facet.define();
/**
Facet for overriding the unit by which indentation happens. Should
be a string consisting either entirely of the same whitespace
character. When not set, this defaults to 2 spaces.
*/
const indentUnit = /*@__PURE__*/Facet.define({
    combine: values => {
        if (!values.length)
            return "  ";
        let unit = values[0];
        if (!unit || /\S/.test(unit) || Array.from(unit).some(e => e != unit[0]))
            throw new Error("Invalid indent unit: " + JSON.stringify(values[0]));
        return unit;
    }
});
/**
Return the _column width_ of an indent unit in the state.
Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)
facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that
contains tabs.
*/
function getIndentUnit(state) {
    let unit = state.facet(indentUnit);
    return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;
}
/**
Create an indentation string that covers columns 0 to `cols`.
Will use tabs for as much of the columns as possible when the
[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains
tabs.
*/
function indentString(state, cols) {
    let result = "", ts = state.tabSize, ch = state.facet(indentUnit)[0];
    if (ch == "\t") {
        while (cols >= ts) {
            result += "\t";
            cols -= ts;
        }
        ch = " ";
    }
    for (let i = 0; i < cols; i++)
        result += ch;
    return result;
}
/**
Get the indentation, as a column number, at the given position.
Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)
that are registered, and if none of those return an indentation,
this will check the syntax tree for the [indent node
prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a
number when an indentation could be determined, and null
otherwise.
*/
function getIndentation(context, pos) {
    if (context instanceof EditorState)
        context = new IndentContext(context);
    for (let service of context.state.facet(indentService)) {
        let result = service(context, pos);
        if (result !== undefined)
            return result;
    }
    let tree = dist_syntaxTree(context.state);
    return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;
}
/**
Create a change set that auto-indents all lines touched by the
given document range.
*/
function indentRange(state, from, to) {
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => { var _a; return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1; } });
    let changes = [];
    for (let pos = from; pos <= to;) {
        let line = state.doc.lineAt(pos);
        pos = line.to + 1;
        let indent = getIndentation(context, line.from);
        if (indent == null)
            continue;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    }
    return state.changes(changes);
}
/**
Indentation contexts are used when calling [indentation
services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities
useful in indentation logic, and can selectively override the
indentation reported for some lines.
*/
class IndentContext {
    /**
    Create an indent context.
    */
    constructor(
    /**
    The editor state.
    */
    state, 
    /**
    @internal
    */
    options = {}) {
        this.state = state;
        this.options = options;
        this.unit = getIndentUnit(state);
    }
    /**
    Get a description of the line at the given position, taking
    [simulated line
    breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    into account. If there is such a break at `pos`, the `bias`
    argument determines whether the part of the line line before or
    after the break is used.
    */
    lineAt(pos, bias = 1) {
        let line = this.state.doc.lineAt(pos);
        let { simulateBreak, simulateDoubleBreak } = this.options;
        if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {
            if (simulateDoubleBreak && simulateBreak == pos)
                return { text: "", from: pos };
            else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos)
                return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };
            else
                return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };
        }
        return line;
    }
    /**
    Get the text directly after `pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    textAfterPos(pos, bias = 1) {
        if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak)
            return "";
        let { text, from } = this.lineAt(pos, bias);
        return text.slice(pos - from, Math.min(text.length, pos + 100 - from));
    }
    /**
    Find the column for the given position.
    */
    column(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let result = this.countColumn(text, pos - from);
        let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;
        if (override > -1)
            result += override - this.countColumn(text, text.search(/\S|$/));
        return result;
    }
    /**
    Find the column position (taking tabs into account) of the given
    position in the given string.
    */
    countColumn(line, pos = line.length) {
        return countColumn(line, this.state.tabSize, pos);
    }
    /**
    Find the indentation column of the line at the given point.
    */
    lineIndent(pos, bias = 1) {
        let { text, from } = this.lineAt(pos, bias);
        let override = this.options.overrideIndentation;
        if (override) {
            let overriden = override(from);
            if (overriden > -1)
                return overriden;
        }
        return this.countColumn(text, text.search(/\S|$/));
    }
    /**
    Returns the [simulated line
    break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
    for this context, if any.
    */
    get simulatedBreak() {
        return this.options.simulateBreak || null;
    }
}
/**
A syntax tree node prop used to associate indentation strategies
with node types. Such a strategy is a function from an indentation
context to a column number (see also
[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null
indicates that no definitive indentation can be determined.
*/
const indentNodeProp = /*@__PURE__*/new dist_NodeProp();
// Compute the indentation for a given position from the syntax tree.
function syntaxIndentation(cx, ast, pos) {
    let stack = ast.resolveStack(pos);
    let inner = stack.node.enterUnfinishedNodesBefore(pos);
    if (inner != stack.node) {
        let add = [];
        for (let cur = inner; cur != stack.node; cur = cur.parent)
            add.push(cur);
        for (let i = add.length - 1; i >= 0; i--)
            stack = { node: add[i], next: stack };
    }
    return indentFor(stack, cx, pos);
}
function indentFor(stack, cx, pos) {
    for (let cur = stack; cur; cur = cur.next) {
        let strategy = indentStrategy(cur.node);
        if (strategy)
            return strategy(TreeIndentContext.create(cx, pos, cur));
    }
    return 0;
}
function ignoreClosed(cx) {
    return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;
}
function indentStrategy(tree) {
    let strategy = tree.type.prop(indentNodeProp);
    if (strategy)
        return strategy;
    let first = tree.firstChild, close;
    if (first && (close = first.type.prop(dist_NodeProp.closedBy))) {
        let last = tree.lastChild, closed = last && close.indexOf(last.name) > -1;
        return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);
    }
    return tree.parent == null ? topIndent : null;
}
function topIndent() { return 0; }
/**
Objects of this type provide context information and helper
methods to indentation functions registered on syntax nodes.
*/
class TreeIndentContext extends IndentContext {
    constructor(base, 
    /**
    The position at which indentation is being computed.
    */
    pos, 
    /**
    @internal
    */
    context) {
        super(base.state, base.options);
        this.base = base;
        this.pos = pos;
        this.context = context;
    }
    /**
    The syntax tree node to which the indentation strategy
    applies.
    */
    get node() { return this.context.node; }
    /**
    @internal
    */
    static create(base, pos, context) {
        return new TreeIndentContext(base, pos, context);
    }
    /**
    Get the text directly after `this.pos`, either the entire line
    or the next 100 characters, whichever is shorter.
    */
    get textAfter() {
        return this.textAfterPos(this.pos);
    }
    /**
    Get the indentation at the reference line for `this.node`, which
    is the line on which it starts, unless there is a node that is
    _not_ a parent of this node covering the start of that line. If
    so, the line at the start of that node is tried, again skipping
    on if it is covered by another such node.
    */
    get baseIndent() {
        return this.baseIndentFor(this.node);
    }
    /**
    Get the indentation for the reference line of the given node
    (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
    */
    baseIndentFor(node) {
        let line = this.state.doc.lineAt(node.from);
        // Skip line starts that are covered by a sibling (or cousin, etc)
        for (;;) {
            let atBreak = node.resolve(line.from);
            while (atBreak.parent && atBreak.parent.from == atBreak.from)
                atBreak = atBreak.parent;
            if (isParent(atBreak, node))
                break;
            line = this.state.doc.lineAt(atBreak.from);
        }
        return this.lineIndent(line.from);
    }
    /**
    Continue looking for indentations in the node's parent nodes,
    and return the result of that.
    */
    continue() {
        return indentFor(this.context.next, this.base, this.pos);
    }
}
function isParent(parent, of) {
    for (let cur = of; cur; cur = cur.parent)
        if (parent == cur)
            return true;
    return false;
}
// Check whether a delimited node is aligned (meaning there are
// non-skipped nodes on the same line as the opening delimiter). And
// if so, return the opening token.
function bracketedAligned(context) {
    let tree = context.node;
    let openToken = tree.childAfter(tree.from), last = tree.lastChild;
    if (!openToken)
        return null;
    let sim = context.options.simulateBreak;
    let openLine = context.state.doc.lineAt(openToken.from);
    let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);
    for (let pos = openToken.to;;) {
        let next = tree.childAfter(pos);
        if (!next || next == last)
            return null;
        if (!next.type.isSkipped)
            return next.from < lineEnd ? openToken : null;
        pos = next.to;
    }
}
/**
An indentation strategy for delimited (usually bracketed) nodes.
Will, by default, indent one unit more than the parent's base
indent unless the line starts with a closing token. When `align`
is true and there are non-skipped nodes on the node's opening
line, the content of the node will be aligned with the end of the
opening node, like this:

    foo(bar,
        baz)
*/
function delimitedIndent({ closing, align = true, units = 1 }) {
    return (context) => delimitedStrategy(context, align, units, closing);
}
function delimitedStrategy(context, align, units, closing, closedAt) {
    let after = context.textAfter, space = after.match(/^\s*/)[0].length;
    let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;
    let aligned = align ? bracketedAligned(context) : null;
    if (aligned)
        return closed ? context.column(aligned.from) : context.column(aligned.to);
    return context.baseIndent + (closed ? 0 : context.unit * units);
}
/**
An indentation strategy that aligns a node's content to its base
indentation.
*/
const flatIndent = (context) => context.baseIndent;
/**
Creates an indentation strategy that, by default, indents
continued lines one unit more than the node's base indentation.
You can provide `except` to prevent indentation of lines that
match a pattern (for example `/^else\b/` in `if`/`else`
constructs), and you can change the amount of units used with the
`units` option.
*/
function continuedIndent({ except, units = 1 } = {}) {
    return (context) => {
        let matchExcept = except && except.test(context.textAfter);
        return context.baseIndent + (matchExcept ? 0 : units * context.unit);
    };
}
const DontIndentBeyond = 200;
/**
Enables reindentation on input. When a language defines an
`indentOnInput` field in its [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular
expression, the line at the cursor will be reindented whenever new
text is typed and the input from the start of the line up to the
cursor matches that regexp.

To avoid unneccesary reindents, it is recommended to start the
regexp with `^` (usually followed by `\s*`), and end it with `$`.
For example, `/^\s*\}$/` will reindent when a closing brace is
added at the start of a line.
*/
function indentOnInput() {
    return EditorState.transactionFilter.of(tr => {
        if (!tr.docChanged || !tr.isUserEvent("input.type") && !tr.isUserEvent("input.complete"))
            return tr;
        let rules = tr.startState.languageDataAt("indentOnInput", tr.startState.selection.main.head);
        if (!rules.length)
            return tr;
        let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);
        if (head > line.from + DontIndentBeyond)
            return tr;
        let lineStart = doc.sliceString(line.from, head);
        if (!rules.some(r => r.test(lineStart)))
            return tr;
        let { state } = tr, last = -1, changes = [];
        for (let { head } of state.selection.ranges) {
            let line = state.doc.lineAt(head);
            if (line.from == last)
                continue;
            last = line.from;
            let indent = getIndentation(state, line.from);
            if (indent == null)
                continue;
            let cur = /^\s*/.exec(line.text)[0];
            let norm = indentString(state, indent);
            if (cur != norm)
                changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
        return changes.length ? [tr, { changes, sequential: true }] : tr;
    });
}

/**
A facet that registers a code folding service. When called with
the extent of a line, such a function should return a foldable
range that starts on that line (but continues beyond it), if one
can be found.
*/
const foldService = /*@__PURE__*/Facet.define();
/**
This node prop is used to associate folding information with
syntax node types. Given a syntax node, it should check whether
that tree is foldable and return the range that can be collapsed
when it is.
*/
const foldNodeProp = /*@__PURE__*/new dist_NodeProp();
/**
[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but
the first and the last child of a syntax node. Useful for nodes
that start and end with delimiters.
*/
function foldInside(node) {
    let first = node.firstChild, last = node.lastChild;
    return first && first.to < last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;
}
function syntaxFolding(state, start, end) {
    let tree = dist_syntaxTree(state);
    if (tree.length < end)
        return null;
    let stack = tree.resolveStack(end, 1);
    let found = null;
    for (let iter = stack; iter; iter = iter.next) {
        let cur = iter.node;
        if (cur.to <= end || cur.from > end)
            continue;
        if (found && cur.from < start)
            break;
        let prop = cur.type.prop(foldNodeProp);
        if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {
            let value = prop(cur, state);
            if (value && value.from <= end && value.from >= start && value.to > end)
                found = value;
        }
    }
    return found;
}
function isUnfinished(node) {
    let ch = node.lastChild;
    return ch && ch.to == node.to && ch.type.isError;
}
/**
Check whether the given line is foldable. First asks any fold
services registered through
[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return
a result, tries to query the [fold node
prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end
of the line.
*/
function foldable(state, lineStart, lineEnd) {
    for (let service of state.facet(foldService)) {
        let result = service(state, lineStart, lineEnd);
        if (result)
            return result;
    }
    return syntaxFolding(state, lineStart, lineEnd);
}
function mapRange(range, mapping) {
    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);
    return from >= to ? undefined : { from, to };
}
/**
State effect that can be attached to a transaction to fold the
given range. (You probably only need this in exceptional
circumstances—usually you'll just want to let
[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold
gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)
*/
const foldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });
/**
State effect that unfolds the given range (if it was folded).
*/
const unfoldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });
function selectedLines(view) {
    let lines = [];
    for (let { head } of view.state.selection.ranges) {
        if (lines.some(l => l.from <= head && l.to >= head))
            continue;
        lines.push(view.lineBlockAt(head));
    }
    return lines;
}
/**
The state field that stores the folded ranges (as a [decoration
set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to
[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and
[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold
state.
*/
const foldState = /*@__PURE__*/StateField.define({
    create() {
        return Decoration.none;
    },
    update(folded, tr) {
        folded = folded.map(tr.changes);
        for (let e of tr.effects) {
            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {
                let { preparePlaceholder } = tr.state.facet(foldConfig);
                let widget = !preparePlaceholder ? foldWidget :
                    Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });
                folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });
            }
            else if (e.is(unfoldEffect)) {
                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,
                    filterFrom: e.value.from, filterTo: e.value.to });
            }
        }
        // Clear folded ranges that cover the selection head
        if (tr.selection) {
            let onSelection = false, { head } = tr.selection.main;
            folded.between(head, head, (a, b) => { if (a < head && b > head)
                onSelection = true; });
            if (onSelection)
                folded = folded.update({
                    filterFrom: head,
                    filterTo: head,
                    filter: (a, b) => b <= head || a >= head
                });
        }
        return folded;
    },
    provide: f => EditorView.decorations.from(f),
    toJSON(folded, state) {
        let ranges = [];
        folded.between(0, state.doc.length, (from, to) => { ranges.push(from, to); });
        return ranges;
    },
    fromJSON(value) {
        if (!Array.isArray(value) || value.length % 2)
            throw new RangeError("Invalid JSON for fold state");
        let ranges = [];
        for (let i = 0; i < value.length;) {
            let from = value[i++], to = value[i++];
            if (typeof from != "number" || typeof to != "number")
                throw new RangeError("Invalid JSON for fold state");
            ranges.push(foldWidget.range(from, to));
        }
        return Decoration.set(ranges, true);
    }
});
/**
Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges
in the given state.
*/
function foldedRanges(state) {
    return state.field(foldState, false) || RangeSet.empty;
}
function findFold(state, from, to) {
    var _a;
    let found = null;
    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {
        if (!found || found.from > from)
            found = { from, to };
    });
    return found;
}
function foldExists(folded, from, to) {
    let found = false;
    folded.between(from, from, (a, b) => { if (a == from && b == to)
        found = true; });
    return found;
}
function maybeEnable(state, other) {
    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));
}
/**
Fold the lines that are selected, if possible.
*/
const foldCode = view => {
    for (let line of selectedLines(view)) {
        let range = foldable(view.state, line.from, line.to);
        if (range) {
            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });
            return true;
        }
    }
    return false;
};
/**
Unfold folded ranges on selected lines.
*/
const unfoldCode = view => {
    if (!view.state.field(foldState, false))
        return false;
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
    }
    if (effects.length)
        view.dispatch({ effects });
    return effects.length > 0;
};
function announceFold(view, range, fold = true) {
    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;
    return EditorView.announce.of(`${view.state.phrase(fold ? "Folded lines" : "Unfolded lines")} ${lineFrom} ${view.state.phrase("to")} ${lineTo}.`);
}
/**
Fold all top-level foldable ranges. Note that, in most cases,
folding information will depend on the [syntax
tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work
reliably when the document hasn't been fully parsed (either
because the editor state was only just initialized, or because the
document is so big that the parser decided not to parse it
entirely).
*/
const foldAll = view => {
    let { state } = view, effects = [];
    for (let pos = 0; pos < state.doc.length;) {
        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);
        if (range)
            effects.push(foldEffect.of(range));
        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;
    }
    if (effects.length)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Unfold all folded code.
*/
const unfoldAll = view => {
    let field = view.state.field(foldState, false);
    if (!field || !field.size)
        return false;
    let effects = [];
    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });
    view.dispatch({ effects });
    return true;
};
// Find the foldable region containing the given line, if one exists
function foldableContainer(view, lineBlock) {
    // Look backwards through line blocks until we find a foldable region that
    // intersects with the line
    for (let line = lineBlock;;) {
        let foldableRegion = foldable(view.state, line.from, line.to);
        if (foldableRegion && foldableRegion.to > lineBlock.from)
            return foldableRegion;
        if (!line.from)
            return null;
        line = view.lineBlockAt(line.from - 1);
    }
}
/**
Toggle folding at cursors. Unfolds if there is an existing fold
starting in that line, tries to find a foldable range around it
otherwise.
*/
const toggleFold = (view) => {
    let effects = [];
    for (let line of selectedLines(view)) {
        let folded = findFold(view.state, line.from, line.to);
        if (folded) {
            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));
        }
        else {
            let foldRange = foldableContainer(view, line);
            if (foldRange)
                effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));
        }
    }
    if (effects.length > 0)
        view.dispatch({ effects: maybeEnable(view.state, effects) });
    return !!effects.length;
};
/**
Default fold-related key bindings.

 - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).
 - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).
 - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).
 - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).
*/
const foldKeymap = [
    { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: foldCode },
    { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: unfoldCode },
    { key: "Ctrl-Alt-[", run: foldAll },
    { key: "Ctrl-Alt-]", run: unfoldAll }
];
const defaultConfig = {
    placeholderDOM: null,
    preparePlaceholder: null,
    placeholderText: "…"
};
const foldConfig = /*@__PURE__*/Facet.define({
    combine(values) { return combineConfig(values, defaultConfig); }
});
/**
Create an extension that configures code folding.
*/
function codeFolding(config) {
    let result = [foldState, dist_baseTheme$1];
    if (config)
        result.push(foldConfig.of(config));
    return result;
}
function widgetToDOM(view, prepared) {
    let { state } = view, conf = state.facet(foldConfig);
    let onclick = (event) => {
        let line = view.lineBlockAt(view.posAtDOM(event.target));
        let folded = findFold(view.state, line.from, line.to);
        if (folded)
            view.dispatch({ effects: unfoldEffect.of(folded) });
        event.preventDefault();
    };
    if (conf.placeholderDOM)
        return conf.placeholderDOM(view, onclick, prepared);
    let element = document.createElement("span");
    element.textContent = conf.placeholderText;
    element.setAttribute("aria-label", state.phrase("folded code"));
    element.title = state.phrase("unfold");
    element.className = "cm-foldPlaceholder";
    element.onclick = onclick;
    return element;
}
const foldWidget = /*@__PURE__*/Decoration.replace({ widget: /*@__PURE__*/new class extends WidgetType {
        toDOM(view) { return widgetToDOM(view, null); }
    } });
class PreparedFoldWidget extends WidgetType {
    constructor(value) {
        super();
        this.value = value;
    }
    eq(other) { return this.value == other.value; }
    toDOM(view) { return widgetToDOM(view, this.value); }
}
const foldGutterDefaults = {
    openText: "⌄",
    closedText: "›",
    markerDOM: null,
    domEventHandlers: {},
    foldingChanged: () => false
};
class FoldMarker extends GutterMarker {
    constructor(config, open) {
        super();
        this.config = config;
        this.open = open;
    }
    eq(other) { return this.config == other.config && this.open == other.open; }
    toDOM(view) {
        if (this.config.markerDOM)
            return this.config.markerDOM(this.open);
        let span = document.createElement("span");
        span.textContent = this.open ? this.config.openText : this.config.closedText;
        span.title = view.state.phrase(this.open ? "Fold line" : "Unfold line");
        return span;
    }
}
/**
Create an extension that registers a fold gutter, which shows a
fold status indicator before foldable lines (which can be clicked
to fold or unfold the line).
*/
function foldGutter(config = {}) {
    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);
    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);
    let markers = dist_ViewPlugin.fromClass(class {
        constructor(view) {
            this.from = view.viewport.from;
            this.markers = this.buildMarkers(view);
        }
        update(update) {
            if (update.docChanged || update.viewportChanged ||
                update.startState.facet(language) != update.state.facet(language) ||
                update.startState.field(foldState, false) != update.state.field(foldState, false) ||
                dist_syntaxTree(update.startState) != dist_syntaxTree(update.state) ||
                fullConfig.foldingChanged(update))
                this.markers = this.buildMarkers(update.view);
        }
        buildMarkers(view) {
            let builder = new RangeSetBuilder();
            for (let line of view.viewportLineBlocks) {
                let mark = findFold(view.state, line.from, line.to) ? canUnfold
                    : foldable(view.state, line.from, line.to) ? canFold : null;
                if (mark)
                    builder.add(line.from, line.from, mark);
            }
            return builder.finish();
        }
    });
    let { domEventHandlers } = fullConfig;
    return [
        markers,
        gutter({
            class: "cm-foldGutter",
            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || dist_RangeSet.empty; },
            initialSpacer() {
                return new FoldMarker(fullConfig, false);
            },
            domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) => {
                    if (domEventHandlers.click && domEventHandlers.click(view, line, event))
                        return true;
                    let folded = findFold(view.state, line.from, line.to);
                    if (folded) {
                        view.dispatch({ effects: unfoldEffect.of(folded) });
                        return true;
                    }
                    let range = foldable(view.state, line.from, line.to);
                    if (range) {
                        view.dispatch({ effects: foldEffect.of(range) });
                        return true;
                    }
                    return false;
                } })
        }),
        codeFolding()
    ];
}
const dist_baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({
    ".cm-foldPlaceholder": {
        backgroundColor: "#eee",
        border: "1px solid #ddd",
        color: "#888",
        borderRadius: ".2em",
        margin: "0 1px",
        padding: "0 1px",
        cursor: "pointer"
    },
    ".cm-foldGutter span": {
        padding: "0 1px",
        cursor: "pointer"
    }
});

/**
A highlight style associates CSS styles with higlighting
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).
*/
class HighlightStyle {
    constructor(
    /**
    The tag styles used to create this highlight style.
    */
    specs, options) {
        this.specs = specs;
        let modSpec;
        function def(spec) {
            let cls = StyleModule.newName();
            (modSpec || (modSpec = Object.create(null)))["." + cls] = spec;
            return cls;
        }
        const all = typeof options.all == "string" ? options.all : options.all ? def(options.all) : undefined;
        const scopeOpt = options.scope;
        this.scope = scopeOpt instanceof Language ? (type) => type.prop(languageDataProp) == scopeOpt.data
            : scopeOpt ? (type) => type == scopeOpt : undefined;
        this.style = tagHighlighter(specs.map(style => ({
            tag: style.tag,
            class: style.class || def(Object.assign({}, style, { tag: null }))
        })), {
            all,
        }).style;
        this.module = modSpec ? new StyleModule(modSpec) : null;
        this.themeType = options.themeType;
    }
    /**
    Create a highlighter style that associates the given styles to
    the given tags. The specs must be objects that hold a style tag
    or array of tags in their `tag` property, and either a single
    `class` property providing a static CSS class (for highlighter
    that rely on external styling), or a
    [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
    set of CSS properties (which define the styling for those tags).
    
    The CSS rules created for a highlighter will be emitted in the
    order of the spec's properties. That means that for elements that
    have multiple tags associated with them, styles defined further
    down in the list will have a higher CSS precedence than styles
    defined earlier.
    */
    static define(specs, options) {
        return new HighlightStyle(specs, options || {});
    }
}
const highlighterFacet = /*@__PURE__*/Facet.define();
const fallbackHighlighter = /*@__PURE__*/Facet.define({
    combine(values) { return values.length ? [values[0]] : null; }
});
function getHighlighters(state) {
    let main = state.facet(highlighterFacet);
    return main.length ? main : state.facet(fallbackHighlighter);
}
/**
Wrap a highlighter in an editor extension that uses it to apply
syntax highlighting to the editor content.

When multiple (non-fallback) styles are provided, the styling
applied is the union of the classes they emit.
*/
function dist_syntaxHighlighting(highlighter, options) {
    let ext = [treeHighlighter], themeType;
    if (highlighter instanceof HighlightStyle) {
        if (highlighter.module)
            ext.push(EditorView.styleModule.of(highlighter.module));
        themeType = highlighter.themeType;
    }
    if (options === null || options === void 0 ? void 0 : options.fallback)
        ext.push(fallbackHighlighter.of(highlighter));
    else if (themeType)
        ext.push(highlighterFacet.computeN([EditorView.darkTheme], state => {
            return state.facet(EditorView.darkTheme) == (themeType == "dark") ? [highlighter] : [];
        }));
    else
        ext.push(highlighterFacet.of(highlighter));
    return ext;
}
/**
Returns the CSS classes (if any) that the highlighters active in
the state would assign to the given style
[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and
(optional) language
[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).
*/
function highlightingFor(state, tags, scope) {
    let highlighters = getHighlighters(state);
    let result = null;
    if (highlighters)
        for (let highlighter of highlighters) {
            if (!highlighter.scope || scope && highlighter.scope(scope)) {
                let cls = highlighter.style(tags);
                if (cls)
                    result = result ? result + " " + cls : cls;
            }
        }
    return result;
}
class TreeHighlighter {
    constructor(view) {
        this.markCache = Object.create(null);
        this.tree = dist_syntaxTree(view.state);
        this.decorations = this.buildDeco(view, getHighlighters(view.state));
    }
    update(update) {
        let tree = dist_syntaxTree(update.state), highlighters = getHighlighters(update.state);
        let styleChange = highlighters != getHighlighters(update.startState);
        if (tree.length < update.view.viewport.to && !styleChange && tree.type == this.tree.type) {
            this.decorations = this.decorations.map(update.changes);
        }
        else if (tree != this.tree || update.viewportChanged || styleChange) {
            this.tree = tree;
            this.decorations = this.buildDeco(update.view, highlighters);
        }
    }
    buildDeco(view, highlighters) {
        if (!highlighters || !this.tree.length)
            return Decoration.none;
        let builder = new RangeSetBuilder();
        for (let { from, to } of view.visibleRanges) {
            highlightTree(this.tree, highlighters, (from, to, style) => {
                builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));
            }, from, to);
        }
        return builder.finish();
    }
}
const treeHighlighter = /*@__PURE__*/Prec.high(/*@__PURE__*/dist_ViewPlugin.fromClass(TreeHighlighter, {
    decorations: v => v.decorations
}));
/**
A default highlight style (works well with light themes).
*/
const dist_defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([
    { tag: tags.meta,
        color: "#404740" },
    { tag: tags.link,
        textDecoration: "underline" },
    { tag: tags.heading,
        textDecoration: "underline",
        fontWeight: "bold" },
    { tag: tags.emphasis,
        fontStyle: "italic" },
    { tag: tags.strong,
        fontWeight: "bold" },
    { tag: tags.strikethrough,
        textDecoration: "line-through" },
    { tag: tags.keyword,
        color: "#708" },
    { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],
        color: "#219" },
    { tag: [tags.literal, tags.inserted],
        color: "#164" },
    { tag: [tags.string, tags.deleted],
        color: "#a11" },
    { tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],
        color: "#e40" },
    { tag: /*@__PURE__*/tags.definition(tags.variableName),
        color: "#00f" },
    { tag: /*@__PURE__*/tags.local(tags.variableName),
        color: "#30a" },
    { tag: [tags.typeName, tags.namespace],
        color: "#085" },
    { tag: tags.className,
        color: "#167" },
    { tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],
        color: "#256" },
    { tag: /*@__PURE__*/tags.definition(tags.propertyName),
        color: "#00c" },
    { tag: tags.comment,
        color: "#940" },
    { tag: tags.invalid,
        color: "#f00" }
]);

const dist_baseTheme = /*@__PURE__*/EditorView.baseTheme({
    "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
    "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
});
const DefaultScanDist = 10000, DefaultBrackets = "()[]{}";
const bracketMatchingConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            afterCursor: true,
            brackets: DefaultBrackets,
            maxScanDistance: DefaultScanDist,
            renderMatch: defaultRenderMatch
        });
    }
});
const matchingMark = /*@__PURE__*/Decoration.mark({ class: "cm-matchingBracket" }), nonmatchingMark = /*@__PURE__*/Decoration.mark({ class: "cm-nonmatchingBracket" });
function defaultRenderMatch(match) {
    let decorations = [];
    let mark = match.matched ? matchingMark : nonmatchingMark;
    decorations.push(mark.range(match.start.from, match.start.to));
    if (match.end)
        decorations.push(mark.range(match.end.from, match.end.to));
    return decorations;
}
const bracketMatchingState = /*@__PURE__*/StateField.define({
    create() { return Decoration.none; },
    update(deco, tr) {
        if (!tr.docChanged && !tr.selection)
            return deco;
        let decorations = [];
        let config = tr.state.facet(bracketMatchingConfig);
        for (let range of tr.state.selection.ranges) {
            if (!range.empty)
                continue;
            let match = matchBrackets(tr.state, range.head, -1, config)
                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))
                || (config.afterCursor &&
                    (matchBrackets(tr.state, range.head, 1, config) ||
                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));
            if (match)
                decorations = decorations.concat(config.renderMatch(match, tr.state));
        }
        return Decoration.set(decorations, true);
    },
    provide: f => EditorView.decorations.from(f)
});
const bracketMatchingUnique = [
    bracketMatchingState,
    dist_baseTheme
];
/**
Create an extension that enables bracket matching. Whenever the
cursor is next to a bracket, that bracket and the one it matches
are highlighted. Or, when no matching bracket is found, another
highlighting style is used to indicate this.
*/
function bracketMatching(config = {}) {
    return [bracketMatchingConfig.of(config), bracketMatchingUnique];
}
/**
When larger syntax nodes, such as HTML tags, are marked as
opening/closing, it can be a bit messy to treat the whole node as
a matchable bracket. This node prop allows you to define, for such
a node, a ‘handle’—the part of the node that is highlighted, and
that the cursor must be on to activate highlighting in the first
place.
*/
const bracketMatchingHandle = /*@__PURE__*/new dist_NodeProp();
function matchingNodes(node, dir, brackets) {
    let byProp = node.prop(dir < 0 ? dist_NodeProp.openedBy : dist_NodeProp.closedBy);
    if (byProp)
        return byProp;
    if (node.name.length == 1) {
        let index = brackets.indexOf(node.name);
        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))
            return [brackets[index + dir]];
    }
    return null;
}
function findHandle(node) {
    let hasHandle = node.type.prop(bracketMatchingHandle);
    return hasHandle ? hasHandle(node.node) : node;
}
/**
Find the matching bracket for the token at `pos`, scanning
direction `dir`. Only the `brackets` and `maxScanDistance`
properties are used from `config`, if given. Returns null if no
bracket was found at `pos`, or a match result otherwise.
*/
function matchBrackets(state, pos, dir, config = {}) {
    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;
    let tree = dist_syntaxTree(state), node = tree.resolveInner(pos, dir);
    for (let cur = node; cur; cur = cur.parent) {
        let matches = matchingNodes(cur.type, dir, brackets);
        if (matches && cur.from < cur.to) {
            let handle = findHandle(cur);
            if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to))
                return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);
        }
    }
    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);
}
function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {
    let parent = token.parent, firstToken = { from: handle.from, to: handle.to };
    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();
    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))
        do {
            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {
                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {
                    let endHandle = findHandle(cursor);
                    return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };
                }
                else if (matchingNodes(cursor.type, dir, brackets)) {
                    depth++;
                }
                else if (matchingNodes(cursor.type, -dir, brackets)) {
                    if (depth == 0) {
                        let endHandle = findHandle(cursor);
                        return {
                            start: firstToken,
                            end: endHandle && endHandle.from < endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,
                            matched: false
                        };
                    }
                    depth--;
                }
            }
        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());
    return { start: firstToken, matched: false };
}
function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {
    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);
    let bracket = brackets.indexOf(startCh);
    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))
        return null;
    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };
    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;
    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {
        let text = iter.value;
        if (dir < 0)
            distance += text.length;
        let basePos = pos + distance * dir;
        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {
            let found = brackets.indexOf(text[pos]);
            if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)
                continue;
            if ((found % 2 == 0) == (dir > 0)) {
                depth++;
            }
            else if (depth == 1) { // Closing
                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };
            }
            else {
                depth--;
            }
        }
        if (dir > 0)
            distance += text.length;
    }
    return iter.done ? { start: startToken, matched: false } : null;
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {
    if (end == null) {
        end = string.search(/[^\s\u00a0]/);
        if (end == -1)
            end = string.length;
    }
    let n = startValue;
    for (let i = startIndex; i < end; i++) {
        if (string.charCodeAt(i) == 9)
            n += tabSize - (n % tabSize);
        else
            n++;
    }
    return n;
}
/**
Encapsulates a single line of input. Given to stream syntax code,
which uses it to tokenize the content.
*/
class StringStream {
    /**
    Create a stream.
    */
    constructor(
    /**
    The line.
    */
    string, tabSize, 
    /**
    The current indent unit size.
    */
    indentUnit, overrideIndent) {
        this.string = string;
        this.tabSize = tabSize;
        this.indentUnit = indentUnit;
        this.overrideIndent = overrideIndent;
        /**
        The current position on the line.
        */
        this.pos = 0;
        /**
        The start position of the current token.
        */
        this.start = 0;
        this.lastColumnPos = 0;
        this.lastColumnValue = 0;
    }
    /**
    True if we are at the end of the line.
    */
    eol() { return this.pos >= this.string.length; }
    /**
    True if we are at the start of the line.
    */
    sol() { return this.pos == 0; }
    /**
    Get the next code unit after the current position, or undefined
    if we're at the end of the line.
    */
    peek() { return this.string.charAt(this.pos) || undefined; }
    /**
    Read the next code unit and advance `this.pos`.
    */
    next() {
        if (this.pos < this.string.length)
            return this.string.charAt(this.pos++);
    }
    /**
    Match the next character against the given string, regular
    expression, or predicate. Consume and return it if it matches.
    */
    eat(match) {
        let ch = this.string.charAt(this.pos);
        let ok;
        if (typeof match == "string")
            ok = ch == match;
        else
            ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));
        if (ok) {
            ++this.pos;
            return ch;
        }
    }
    /**
    Continue matching characters that match the given string,
    regular expression, or predicate function. Return true if any
    characters were consumed.
    */
    eatWhile(match) {
        let start = this.pos;
        while (this.eat(match)) { }
        return this.pos > start;
    }
    /**
    Consume whitespace ahead of `this.pos`. Return true if any was
    found.
    */
    eatSpace() {
        let start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos)))
            ++this.pos;
        return this.pos > start;
    }
    /**
    Move to the end of the line.
    */
    skipToEnd() { this.pos = this.string.length; }
    /**
    Move to directly before the given character, if found on the
    current line.
    */
    skipTo(ch) {
        let found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
            this.pos = found;
            return true;
        }
    }
    /**
    Move back `n` characters.
    */
    backUp(n) { this.pos -= n; }
    /**
    Get the column position at `this.pos`.
    */
    column() {
        if (this.lastColumnPos < this.start) {
            this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
            this.lastColumnPos = this.start;
        }
        return this.lastColumnValue;
    }
    /**
    Get the indentation column of the current line.
    */
    indentation() {
        var _a;
        return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);
    }
    /**
    Match the input against the given string or regular expression
    (which should start with a `^`). Return true or the regexp match
    if it matches.
    
    Unless `consume` is set to `false`, this will move `this.pos`
    past the matched text.
    
    When matching a string `caseInsensitive` can be set to true to
    make the match case-insensitive.
    */
    match(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
            let cased = (str) => caseInsensitive ? str.toLowerCase() : str;
            let substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) {
                if (consume !== false)
                    this.pos += pattern.length;
                return true;
            }
            else
                return null;
        }
        else {
            let match = this.string.slice(this.pos).match(pattern);
            if (match && match.index > 0)
                return null;
            if (match && consume !== false)
                this.pos += match[0].length;
            return match;
        }
    }
    /**
    Get the current token.
    */
    current() { return this.string.slice(this.start, this.pos); }
}

function fullParser(spec) {
    return {
        name: spec.name || "",
        token: spec.token,
        blankLine: spec.blankLine || (() => { }),
        startState: spec.startState || (() => true),
        copyState: spec.copyState || defaultCopyState,
        indent: spec.indent || (() => null),
        languageData: spec.languageData || {},
        tokenTable: spec.tokenTable || noTokens
    };
}
function defaultCopyState(state) {
    if (typeof state != "object")
        return state;
    let newState = {};
    for (let prop in state) {
        let val = state[prop];
        newState[prop] = (val instanceof Array ? val.slice() : val);
    }
    return newState;
}
const IndentedFrom = /*@__PURE__*/new WeakMap();
/**
A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror
5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).
*/
class StreamLanguage extends (/* unused pure expression or super */ null && (Language)) {
    constructor(parser) {
        let data = defineLanguageFacet(parser.languageData);
        let p = fullParser(parser), self;
        let impl = new class extends Parser {
            createParse(input, fragments, ranges) {
                return new Parse(self, input, fragments, ranges);
            }
        };
        super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);
        this.topNode = docID(data);
        self = this;
        this.streamParser = p;
        this.stateAfter = new NodeProp({ perNode: true });
        this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;
    }
    /**
    Define a stream language.
    */
    static define(spec) { return new StreamLanguage(spec); }
    getIndent(cx, pos) {
        let tree = dist_syntaxTree(cx.state), at = tree.resolve(pos);
        while (at && at.type != this.topNode)
            at = at.parent;
        if (!at)
            return null;
        let from = undefined;
        let { overrideIndentation } = cx.options;
        if (overrideIndentation) {
            from = IndentedFrom.get(cx.state);
            if (from != null && from < pos - 1e4)
                from = undefined;
        }
        let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos), statePos, state;
        if (start) {
            state = start.state;
            statePos = start.pos + 1;
        }
        else {
            state = this.streamParser.startState(cx.unit);
            statePos = 0;
        }
        if (pos - statePos > 10000 /* C.MaxIndentScanDist */)
            return null;
        while (statePos < pos) {
            let line = cx.state.doc.lineAt(statePos), end = Math.min(pos, line.to);
            if (line.length) {
                let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;
                let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);
                while (stream.pos < end - line.from)
                    readToken(this.streamParser.token, stream, state);
            }
            else {
                this.streamParser.blankLine(state, cx.unit);
            }
            if (end == pos)
                break;
            statePos = line.to + 1;
        }
        let line = cx.lineAt(pos);
        if (overrideIndentation && from == null)
            IndentedFrom.set(cx.state, line.from);
        return this.streamParser.indent(state, /^\s*(.*)/.exec(line.text)[1], cx);
    }
    get allowsNesting() { return false; }
}
function findState(lang, tree, off, startPos, before) {
    let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);
    if (state)
        return { state: lang.streamParser.copyState(state), pos: off + tree.length };
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let child = tree.children[i], pos = off + tree.positions[i];
        let found = child instanceof Tree && pos < before && findState(lang, child, pos, startPos, before);
        if (found)
            return found;
    }
    return null;
}
function cutTree(lang, tree, from, to, inside) {
    if (inside && from <= 0 && to >= tree.length)
        return tree;
    if (!inside && tree.type == lang.topNode)
        inside = true;
    for (let i = tree.children.length - 1; i >= 0; i--) {
        let pos = tree.positions[i], child = tree.children[i], inner;
        if (pos < to && child instanceof Tree) {
            if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))
                break;
            return !inside ? inner
                : new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);
        }
    }
    return null;
}
function findStartInFragments(lang, fragments, startPos, editorState) {
    for (let f of fragments) {
        let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);
        let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to), tree;
        if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))
            return { state: found.state, tree };
    }
    return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };
}
class Parse {
    constructor(lang, input, fragments, ranges) {
        this.lang = lang;
        this.input = input;
        this.fragments = fragments;
        this.ranges = ranges;
        this.stoppedAt = null;
        this.chunks = [];
        this.chunkPos = [];
        this.chunk = [];
        this.chunkReused = undefined;
        this.rangeIndex = 0;
        this.to = ranges[ranges.length - 1].to;
        let context = ParseContext.get(), from = ranges[0].from;
        let { state, tree } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);
        this.state = state;
        this.parsedPos = this.chunkStart = from + tree.length;
        for (let i = 0; i < tree.children.length; i++) {
            this.chunks.push(tree.children[i]);
            this.chunkPos.push(tree.positions[i]);
        }
        if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */) {
            this.state = this.lang.streamParser.startState(getIndentUnit(context.state));
            context.skipUntilInView(this.parsedPos, context.viewport.from);
            this.parsedPos = context.viewport.from;
        }
        this.moveRangeIndex();
    }
    advance() {
        let context = ParseContext.get();
        let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);
        let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);
        if (context)
            end = Math.min(end, context.viewport.to);
        while (this.parsedPos < end)
            this.parseLine(context);
        if (this.chunkStart < this.parsedPos)
            this.finishChunk();
        if (this.parsedPos >= parseEnd)
            return this.finish();
        if (context && this.parsedPos >= context.viewport.to) {
            context.skipUntilInView(this.parsedPos, parseEnd);
            return this.finish();
        }
        return null;
    }
    stopAt(pos) {
        this.stoppedAt = pos;
    }
    lineAfter(pos) {
        let chunk = this.input.chunk(pos);
        if (!this.input.lineChunks) {
            let eol = chunk.indexOf("\n");
            if (eol > -1)
                chunk = chunk.slice(0, eol);
        }
        else if (chunk == "\n") {
            chunk = "";
        }
        return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);
    }
    nextLine() {
        let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;
        for (let index = this.rangeIndex;;) {
            let rangeEnd = this.ranges[index].to;
            if (rangeEnd >= end)
                break;
            line = line.slice(0, rangeEnd - (end - line.length));
            index++;
            if (index == this.ranges.length)
                break;
            let rangeStart = this.ranges[index].from;
            let after = this.lineAfter(rangeStart);
            line += after;
            end = rangeStart + after.length;
        }
        return { line, end };
    }
    skipGapsTo(pos, offset, side) {
        for (;;) {
            let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;
            if (side > 0 ? end > offPos : end >= offPos)
                break;
            let start = this.ranges[++this.rangeIndex].from;
            offset += start - end;
        }
        return offset;
    }
    moveRangeIndex() {
        while (this.ranges[this.rangeIndex].to < this.parsedPos)
            this.rangeIndex++;
    }
    emitToken(id, from, to, size, offset) {
        if (this.ranges.length > 1) {
            offset = this.skipGapsTo(from, offset, 1);
            from += offset;
            let len0 = this.chunk.length;
            offset = this.skipGapsTo(to, offset, -1);
            to += offset;
            size += this.chunk.length - len0;
        }
        this.chunk.push(id, from, to, size);
        return offset;
    }
    parseLine(context) {
        let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;
        let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);
        if (stream.eol()) {
            streamParser.blankLine(this.state, stream.indentUnit);
        }
        else {
            while (!stream.eol()) {
                let token = readToken(streamParser.token, stream, this.state);
                if (token)
                    offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);
                if (stream.start > 10000 /* C.MaxLineLength */)
                    break;
            }
        }
        this.parsedPos = end;
        this.moveRangeIndex();
        if (this.parsedPos < this.to)
            this.parsedPos++;
    }
    finishChunk() {
        let tree = Tree.build({
            buffer: this.chunk,
            start: this.chunkStart,
            length: this.parsedPos - this.chunkStart,
            nodeSet,
            topID: 0,
            maxBufferLength: 2048 /* C.ChunkSize */,
            reused: this.chunkReused
        });
        tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);
        this.chunks.push(tree);
        this.chunkPos.push(this.chunkStart - this.ranges[0].from);
        this.chunk = [];
        this.chunkReused = undefined;
        this.chunkStart = this.parsedPos;
    }
    finish() {
        return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();
    }
}
function readToken(token, stream, state) {
    stream.start = stream.pos;
    for (let i = 0; i < 10; i++) {
        let result = token(stream, state);
        if (stream.pos > stream.start)
            return result;
    }
    throw new Error("Stream parser failed to advance stream.");
}
const noTokens = /*@__PURE__*/Object.create(null);
const typeArray = [dist_NodeType.none];
const nodeSet = /*@__PURE__*/new NodeSet(typeArray);
const warned = [];
// Cache of node types by name and tags
const byTag = /*@__PURE__*/Object.create(null);
const defaultTable = /*@__PURE__*/Object.create(null);
for (let [legacyName, name] of [
    ["variable", "variableName"],
    ["variable-2", "variableName.special"],
    ["string-2", "string.special"],
    ["def", "variableName.definition"],
    ["tag", "tagName"],
    ["attribute", "attributeName"],
    ["type", "typeName"],
    ["builtin", "variableName.standard"],
    ["qualifier", "modifier"],
    ["error", "invalid"],
    ["header", "heading"],
    ["property", "propertyName"]
])
    defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);
class TokenTable {
    constructor(extra) {
        this.extra = extra;
        this.table = Object.assign(Object.create(null), defaultTable);
    }
    resolve(tag) {
        return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));
    }
}
const defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);
function warnForPart(part, msg) {
    if (warned.indexOf(part) > -1)
        return;
    warned.push(part);
    console.warn(msg);
}
function createTokenType(extra, tagStr) {
    let tags$1 = [];
    for (let name of tagStr.split(" ")) {
        let found = [];
        for (let part of name.split(".")) {
            let value = (extra[part] || tags[part]);
            if (!value) {
                warnForPart(part, `Unknown highlighting tag ${part}`);
            }
            else if (typeof value == "function") {
                if (!found.length)
                    warnForPart(part, `Modifier ${part} used at start of tag`);
                else
                    found = found.map(value);
            }
            else {
                if (found.length)
                    warnForPart(part, `Tag ${part} used as modifier`);
                else
                    found = Array.isArray(value) ? value : [value];
            }
        }
        for (let tag of found)
            tags$1.push(tag);
    }
    if (!tags$1.length)
        return 0;
    let name = tagStr.replace(/ /g, "_"), key = name + " " + tags$1.map(t => t.id);
    let known = byTag[key];
    if (known)
        return known.id;
    let type = byTag[key] = dist_NodeType.define({
        id: typeArray.length,
        name,
        props: [styleTags({ [name]: tags$1 })]
    });
    typeArray.push(type);
    return type.id;
}
function docID(data) {
    let type = NodeType.define({ id: typeArray.length, name: "Document", props: [languageDataProp.add(() => data)], top: true });
    typeArray.push(type);
    return type;
}



;// CONCATENATED MODULE: ./node_modules/@codemirror/commands/dist/index.js





/**
Comment or uncomment the current selection. Will use line comments
if available, otherwise falling back to block comments.
*/
const toggleComment = target => {
    let { state } = target, line = state.doc.lineAt(state.selection.main.from), config = getConfig(target.state, line.from);
    return config.line ? toggleLineComment(target) : config.block ? toggleBlockCommentByLine(target) : false;
};
function command(f, option) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let tr = f(option, state);
        if (!tr)
            return false;
        dispatch(state.update(tr));
        return true;
    };
}
/**
Comment or uncomment the current selection using line comments.
The line comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* CommentOption.Toggle */);
/**
Comment the current selection using line comments.
*/
const lineComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeLineComment, 1 /* CommentOption.Comment */)));
/**
Uncomment the current selection using line comments.
*/
const lineUncomment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeLineComment, 2 /* CommentOption.Uncomment */)));
/**
Comment or uncomment the current selection using block comments.
The block comment syntax is taken from the
[`commentTokens`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) [language
data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).
*/
const toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* CommentOption.Toggle */);
/**
Comment the current selection using block comments.
*/
const blockComment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeBlockComment, 1 /* CommentOption.Comment */)));
/**
Uncomment the current selection using block comments.
*/
const blockUncomment = /*@__PURE__*/(/* unused pure expression or super */ null && (command(changeBlockComment, 2 /* CommentOption.Uncomment */)));
/**
Comment or uncomment the lines around the current selection using
block comments.
*/
const toggleBlockCommentByLine = /*@__PURE__*/command((o, s) => changeBlockComment(o, s, selectedLineRanges(s)), 0 /* CommentOption.Toggle */);
function getConfig(state, pos) {
    let data = state.languageDataAt("commentTokens", pos);
    return data.length ? data[0] : {};
}
const SearchMargin = 50;
/**
Determines if the given range is block-commented in the given
state.
*/
function findBlockComment(state, { open, close }, from, to) {
    let textBefore = state.sliceDoc(from - SearchMargin, from);
    let textAfter = state.sliceDoc(to, to + SearchMargin);
    let spaceBefore = /\s*$/.exec(textBefore)[0].length, spaceAfter = /^\s*/.exec(textAfter)[0].length;
    let beforeOff = textBefore.length - spaceBefore;
    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&
        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {
        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },
            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };
    }
    let startText, endText;
    if (to - from <= 2 * SearchMargin) {
        startText = endText = state.sliceDoc(from, to);
    }
    else {
        startText = state.sliceDoc(from, from + SearchMargin);
        endText = state.sliceDoc(to - SearchMargin, to);
    }
    let startSpace = /^\s*/.exec(startText)[0].length, endSpace = /\s*$/.exec(endText)[0].length;
    let endOff = endText.length - endSpace - close.length;
    if (startText.slice(startSpace, startSpace + open.length) == open &&
        endText.slice(endOff, endOff + close.length) == close) {
        return { open: { pos: from + startSpace + open.length,
                margin: /\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },
            close: { pos: to - endSpace - close.length,
                margin: /\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };
    }
    return null;
}
function selectedLineRanges(state) {
    let ranges = [];
    for (let r of state.selection.ranges) {
        let fromLine = state.doc.lineAt(r.from);
        let toLine = r.to <= fromLine.to ? fromLine : state.doc.lineAt(r.to);
        let last = ranges.length - 1;
        if (last >= 0 && ranges[last].to > fromLine.from)
            ranges[last].to = toLine.to;
        else
            ranges.push({ from: fromLine.from + /^\s*/.exec(fromLine.text)[0].length, to: toLine.to });
    }
    return ranges;
}
// Performs toggle, comment and uncomment of block comments in
// languages that support them.
function changeBlockComment(option, state, ranges = state.selection.ranges) {
    let tokens = ranges.map(r => getConfig(state, r.from).block);
    if (!tokens.every(c => c))
        return null;
    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));
    if (option != 2 /* CommentOption.Uncomment */ && !comments.every(c => c)) {
        return { changes: state.changes(ranges.map((range, i) => {
                if (comments[i])
                    return [];
                return [{ from: range.from, insert: tokens[i].open + " " }, { from: range.to, insert: " " + tokens[i].close }];
            })) };
    }
    else if (option != 1 /* CommentOption.Comment */ && comments.some(c => c)) {
        let changes = [];
        for (let i = 0, comment; i < comments.length; i++)
            if (comment = comments[i]) {
                let token = tokens[i], { open, close } = comment;
                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });
            }
        return { changes };
    }
    return null;
}
// Performs toggle, comment and uncomment of line comments.
function changeLineComment(option, state, ranges = state.selection.ranges) {
    let lines = [];
    let prevLine = -1;
    for (let { from, to } of ranges) {
        let startI = lines.length, minIndent = 1e9;
        let token = getConfig(state, from).line;
        if (!token)
            continue;
        for (let pos = from; pos <= to;) {
            let line = state.doc.lineAt(pos);
            if (line.from > prevLine && (from == to || to > line.from)) {
                prevLine = line.from;
                let indent = /^\s*/.exec(line.text)[0].length;
                let empty = indent == line.length;
                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;
                if (indent < line.text.length && indent < minIndent)
                    minIndent = indent;
                lines.push({ line, comment, token, indent, empty, single: false });
            }
            pos = line.to + 1;
        }
        if (minIndent < 1e9)
            for (let i = startI; i < lines.length; i++)
                if (lines[i].indent < lines[i].line.text.length)
                    lines[i].indent = minIndent;
        if (lines.length == startI + 1)
            lines[startI].single = true;
    }
    if (option != 2 /* CommentOption.Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {
        let changes = [];
        for (let { line, token, indent, empty, single } of lines)
            if (single || !empty)
                changes.push({ from: line.from + indent, insert: token + " " });
        let changeSet = state.changes(changes);
        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };
    }
    else if (option != 1 /* CommentOption.Comment */ && lines.some(l => l.comment >= 0)) {
        let changes = [];
        for (let { line, comment, token } of lines)
            if (comment >= 0) {
                let from = line.from + comment, to = from + token.length;
                if (line.text[to - line.from] == " ")
                    to++;
                changes.push({ from, to });
            }
        return { changes };
    }
    return null;
}

const fromHistory = /*@__PURE__*/Annotation.define();
/**
Transaction annotation that will prevent that transaction from
being combined with other transactions in the undo history. Given
`"before"`, it'll prevent merging with previous transactions. With
`"after"`, subsequent transactions won't be combined with this
one. With `"full"`, the transaction is isolated on both sides.
*/
const isolateHistory = /*@__PURE__*/Annotation.define();
/**
This facet provides a way to register functions that, given a
transaction, provide a set of effects that the history should
store when inverting the transaction. This can be used to
integrate some kinds of effects in the history, so that they can
be undone (and redone again).
*/
const invertedEffects = /*@__PURE__*/Facet.define();
const historyConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            minDepth: 100,
            newGroupDelay: 500,
            joinToEvent: (_t, isAdjacent) => isAdjacent,
        }, {
            minDepth: Math.max,
            newGroupDelay: Math.min,
            joinToEvent: (a, b) => (tr, adj) => a(tr, adj) || b(tr, adj)
        });
    }
});
const historyField_ = /*@__PURE__*/StateField.define({
    create() {
        return HistoryState.empty;
    },
    update(state, tr) {
        let config = tr.state.facet(historyConfig);
        let fromHist = tr.annotation(fromHistory);
        if (fromHist) {
            let item = HistEvent.fromTransaction(tr, fromHist.selection), from = fromHist.side;
            let other = from == 0 /* BranchName.Done */ ? state.undone : state.done;
            if (item)
                other = updateBranch(other, other.length, config.minDepth, item);
            else
                other = addSelection(other, tr.startState.selection);
            return new HistoryState(from == 0 /* BranchName.Done */ ? fromHist.rest : other, from == 0 /* BranchName.Done */ ? other : fromHist.rest);
        }
        let isolate = tr.annotation(isolateHistory);
        if (isolate == "full" || isolate == "before")
            state = state.isolate();
        if (tr.annotation(Transaction.addToHistory) === false)
            return !tr.changes.empty ? state.addMapping(tr.changes.desc) : state;
        let event = HistEvent.fromTransaction(tr);
        let time = tr.annotation(Transaction.time), userEvent = tr.annotation(Transaction.userEvent);
        if (event)
            state = state.addChanges(event, time, userEvent, config, tr);
        else if (tr.selection)
            state = state.addSelection(tr.startState.selection, time, userEvent, config.newGroupDelay);
        if (isolate == "full" || isolate == "after")
            state = state.isolate();
        return state;
    },
    toJSON(value) {
        return { done: value.done.map(e => e.toJSON()), undone: value.undone.map(e => e.toJSON()) };
    },
    fromJSON(json) {
        return new HistoryState(json.done.map(HistEvent.fromJSON), json.undone.map(HistEvent.fromJSON));
    }
});
/**
Create a history extension with the given configuration.
*/
function dist_history(config = {}) {
    return [
        historyField_,
        historyConfig.of(config),
        EditorView.domEventHandlers({
            beforeinput(e, view) {
                let command = e.inputType == "historyUndo" ? undo : e.inputType == "historyRedo" ? redo : null;
                if (!command)
                    return false;
                e.preventDefault();
                return command(view);
            }
        })
    ];
}
/**
The state field used to store the history data. Should probably
only be used when you want to
[serialize](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) or
[deserialize](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) state objects in a way
that preserves history.
*/
const historyField = (/* unused pure expression or super */ null && (historyField_));
function cmd(side, selection) {
    return function ({ state, dispatch }) {
        if (!selection && state.readOnly)
            return false;
        let historyState = state.field(historyField_, false);
        if (!historyState)
            return false;
        let tr = historyState.pop(side, state, selection);
        if (!tr)
            return false;
        dispatch(tr);
        return true;
    };
}
/**
Undo a single group of history events. Returns false if no group
was available.
*/
const undo = /*@__PURE__*/cmd(0 /* BranchName.Done */, false);
/**
Redo a group of history events. Returns false if no group was
available.
*/
const redo = /*@__PURE__*/cmd(1 /* BranchName.Undone */, false);
/**
Undo a change or selection change.
*/
const undoSelection = /*@__PURE__*/cmd(0 /* BranchName.Done */, true);
/**
Redo a change or selection change.
*/
const redoSelection = /*@__PURE__*/cmd(1 /* BranchName.Undone */, true);
function depth(side) {
    return function (state) {
        let histState = state.field(historyField_, false);
        if (!histState)
            return 0;
        let branch = side == 0 /* BranchName.Done */ ? histState.done : histState.undone;
        return branch.length - (branch.length && !branch[0].changes ? 1 : 0);
    };
}
/**
The amount of undoable change events available in a given state.
*/
const undoDepth = /*@__PURE__*/(/* unused pure expression or super */ null && (depth(0 /* BranchName.Done */)));
/**
The amount of redoable change events available in a given state.
*/
const redoDepth = /*@__PURE__*/(/* unused pure expression or super */ null && (depth(1 /* BranchName.Undone */)));
// History events store groups of changes or effects that need to be
// undone/redone together.
class HistEvent {
    constructor(
    // The changes in this event. Normal events hold at least one
    // change or effect. But it may be necessary to store selection
    // events before the first change, in which case a special type of
    // instance is created which doesn't hold any changes, with
    // changes == startSelection == undefined
    changes, 
    // The effects associated with this event
    effects, 
    // Accumulated mapping (from addToHistory==false) that should be
    // applied to events below this one.
    mapped, 
    // The selection before this event
    startSelection, 
    // Stores selection changes after this event, to be used for
    // selection undo/redo.
    selectionsAfter) {
        this.changes = changes;
        this.effects = effects;
        this.mapped = mapped;
        this.startSelection = startSelection;
        this.selectionsAfter = selectionsAfter;
    }
    setSelAfter(after) {
        return new HistEvent(this.changes, this.effects, this.mapped, this.startSelection, after);
    }
    toJSON() {
        var _a, _b, _c;
        return {
            changes: (_a = this.changes) === null || _a === void 0 ? void 0 : _a.toJSON(),
            mapped: (_b = this.mapped) === null || _b === void 0 ? void 0 : _b.toJSON(),
            startSelection: (_c = this.startSelection) === null || _c === void 0 ? void 0 : _c.toJSON(),
            selectionsAfter: this.selectionsAfter.map(s => s.toJSON())
        };
    }
    static fromJSON(json) {
        return new HistEvent(json.changes && ChangeSet.fromJSON(json.changes), [], json.mapped && ChangeDesc.fromJSON(json.mapped), json.startSelection && dist_EditorSelection.fromJSON(json.startSelection), json.selectionsAfter.map(dist_EditorSelection.fromJSON));
    }
    // This does not check `addToHistory` and such, it assumes the
    // transaction needs to be converted to an item. Returns null when
    // there are no changes or effects in the transaction.
    static fromTransaction(tr, selection) {
        let effects = dist_none;
        for (let invert of tr.startState.facet(invertedEffects)) {
            let result = invert(tr);
            if (result.length)
                effects = effects.concat(result);
        }
        if (!effects.length && tr.changes.empty)
            return null;
        return new HistEvent(tr.changes.invert(tr.startState.doc), effects, undefined, selection || tr.startState.selection, dist_none);
    }
    static selection(selections) {
        return new HistEvent(undefined, dist_none, undefined, undefined, selections);
    }
}
function updateBranch(branch, to, maxLen, newEvent) {
    let start = to + 1 > maxLen + 20 ? to - maxLen - 1 : 0;
    let newBranch = branch.slice(start, to);
    newBranch.push(newEvent);
    return newBranch;
}
function isAdjacent(a, b) {
    let ranges = [], isAdjacent = false;
    a.iterChangedRanges((f, t) => ranges.push(f, t));
    b.iterChangedRanges((_f, _t, f, t) => {
        for (let i = 0; i < ranges.length;) {
            let from = ranges[i++], to = ranges[i++];
            if (t >= from && f <= to)
                isAdjacent = true;
        }
    });
    return isAdjacent;
}
function eqSelectionShape(a, b) {
    return a.ranges.length == b.ranges.length &&
        a.ranges.filter((r, i) => r.empty != b.ranges[i].empty).length === 0;
}
function conc(a, b) {
    return !a.length ? b : !b.length ? a : a.concat(b);
}
const dist_none = [];
const MaxSelectionsPerEvent = 200;
function addSelection(branch, selection) {
    if (!branch.length) {
        return [HistEvent.selection([selection])];
    }
    else {
        let lastEvent = branch[branch.length - 1];
        let sels = lastEvent.selectionsAfter.slice(Math.max(0, lastEvent.selectionsAfter.length - MaxSelectionsPerEvent));
        if (sels.length && sels[sels.length - 1].eq(selection))
            return branch;
        sels.push(selection);
        return updateBranch(branch, branch.length - 1, 1e9, lastEvent.setSelAfter(sels));
    }
}
// Assumes the top item has one or more selectionAfter values
function popSelection(branch) {
    let last = branch[branch.length - 1];
    let newBranch = branch.slice();
    newBranch[branch.length - 1] = last.setSelAfter(last.selectionsAfter.slice(0, last.selectionsAfter.length - 1));
    return newBranch;
}
// Add a mapping to the top event in the given branch. If this maps
// away all the changes and effects in that item, drop it and
// propagate the mapping to the next item.
function addMappingToBranch(branch, mapping) {
    if (!branch.length)
        return branch;
    let length = branch.length, selections = dist_none;
    while (length) {
        let event = mapEvent(branch[length - 1], mapping, selections);
        if (event.changes && !event.changes.empty || event.effects.length) { // Event survived mapping
            let result = branch.slice(0, length);
            result[length - 1] = event;
            return result;
        }
        else { // Drop this event, since there's no changes or effects left
            mapping = event.mapped;
            length--;
            selections = event.selectionsAfter;
        }
    }
    return selections.length ? [HistEvent.selection(selections)] : dist_none;
}
function mapEvent(event, mapping, extraSelections) {
    let selections = conc(event.selectionsAfter.length ? event.selectionsAfter.map(s => s.map(mapping)) : dist_none, extraSelections);
    // Change-less events don't store mappings (they are always the last event in a branch)
    if (!event.changes)
        return HistEvent.selection(selections);
    let mappedChanges = event.changes.map(mapping), before = mapping.mapDesc(event.changes, true);
    let fullMapping = event.mapped ? event.mapped.composeDesc(before) : before;
    return new HistEvent(mappedChanges, StateEffect.mapEffects(event.effects, mapping), fullMapping, event.startSelection.map(before), selections);
}
const joinableUserEvent = /^(input\.type|delete)($|\.)/;
class HistoryState {
    constructor(done, undone, prevTime = 0, prevUserEvent = undefined) {
        this.done = done;
        this.undone = undone;
        this.prevTime = prevTime;
        this.prevUserEvent = prevUserEvent;
    }
    isolate() {
        return this.prevTime ? new HistoryState(this.done, this.undone) : this;
    }
    addChanges(event, time, userEvent, config, tr) {
        let done = this.done, lastEvent = done[done.length - 1];
        if (lastEvent && lastEvent.changes && !lastEvent.changes.empty && event.changes &&
            (!userEvent || joinableUserEvent.test(userEvent)) &&
            ((!lastEvent.selectionsAfter.length &&
                time - this.prevTime < config.newGroupDelay &&
                config.joinToEvent(tr, isAdjacent(lastEvent.changes, event.changes))) ||
                // For compose (but not compose.start) events, always join with previous event
                userEvent == "input.type.compose")) {
            done = updateBranch(done, done.length - 1, config.minDepth, new HistEvent(event.changes.compose(lastEvent.changes), conc(event.effects, lastEvent.effects), lastEvent.mapped, lastEvent.startSelection, dist_none));
        }
        else {
            done = updateBranch(done, done.length, config.minDepth, event);
        }
        return new HistoryState(done, dist_none, time, userEvent);
    }
    addSelection(selection, time, userEvent, newGroupDelay) {
        let last = this.done.length ? this.done[this.done.length - 1].selectionsAfter : dist_none;
        if (last.length > 0 &&
            time - this.prevTime < newGroupDelay &&
            userEvent == this.prevUserEvent && userEvent && /^select($|\.)/.test(userEvent) &&
            eqSelectionShape(last[last.length - 1], selection))
            return this;
        return new HistoryState(addSelection(this.done, selection), this.undone, time, userEvent);
    }
    addMapping(mapping) {
        return new HistoryState(addMappingToBranch(this.done, mapping), addMappingToBranch(this.undone, mapping), this.prevTime, this.prevUserEvent);
    }
    pop(side, state, onlySelection) {
        let branch = side == 0 /* BranchName.Done */ ? this.done : this.undone;
        if (branch.length == 0)
            return null;
        let event = branch[branch.length - 1], selection = event.selectionsAfter[0] || state.selection;
        if (onlySelection && event.selectionsAfter.length) {
            return state.update({
                selection: event.selectionsAfter[event.selectionsAfter.length - 1],
                annotations: fromHistory.of({ side, rest: popSelection(branch), selection }),
                userEvent: side == 0 /* BranchName.Done */ ? "select.undo" : "select.redo",
                scrollIntoView: true
            });
        }
        else if (!event.changes) {
            return null;
        }
        else {
            let rest = branch.length == 1 ? dist_none : branch.slice(0, branch.length - 1);
            if (event.mapped)
                rest = addMappingToBranch(rest, event.mapped);
            return state.update({
                changes: event.changes,
                selection: event.startSelection,
                effects: event.effects,
                annotations: fromHistory.of({ side, rest, selection }),
                filter: false,
                userEvent: side == 0 /* BranchName.Done */ ? "undo" : "redo",
                scrollIntoView: true
            });
        }
    }
}
HistoryState.empty = /*@__PURE__*/new HistoryState(dist_none, dist_none);
/**
Default key bindings for the undo history.

- Mod-z: [`undo`](https://codemirror.net/6/docs/ref/#commands.undo).
- Mod-y (Mod-Shift-z on macOS) + Ctrl-Shift-z on Linux: [`redo`](https://codemirror.net/6/docs/ref/#commands.redo).
- Mod-u: [`undoSelection`](https://codemirror.net/6/docs/ref/#commands.undoSelection).
- Alt-u (Mod-Shift-u on macOS): [`redoSelection`](https://codemirror.net/6/docs/ref/#commands.redoSelection).
*/
const dist_historyKeymap = [
    { key: "Mod-z", run: undo, preventDefault: true },
    { key: "Mod-y", mac: "Mod-Shift-z", run: redo, preventDefault: true },
    { linux: "Ctrl-Shift-z", run: redo, preventDefault: true },
    { key: "Mod-u", run: undoSelection, preventDefault: true },
    { key: "Alt-u", mac: "Mod-Shift-u", run: redoSelection, preventDefault: true }
];

function updateSel(sel, by) {
    return dist_EditorSelection.create(sel.ranges.map(by), sel.mainIndex);
}
function setSel(state, selection) {
    return state.update({ selection, scrollIntoView: true, userEvent: "select" });
}
function moveSel({ state, dispatch }, how) {
    let selection = updateSel(state.selection, how);
    if (selection.eq(state.selection))
        return false;
    dispatch(setSel(state, selection));
    return true;
}
function rangeEnd(range, forward) {
    return dist_EditorSelection.cursor(forward ? range.to : range.from);
}
function cursorByChar(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByChar(range, forward) : rangeEnd(range, forward));
}
function ltrAtCursor(view) {
    return view.textDirectionAt(view.state.selection.main.head) == Direction.LTR;
}
/**
Move the selection one character to the left (which is backward in
left-to-right text, forward in right-to-left text).
*/
const cursorCharLeft = view => cursorByChar(view, !ltrAtCursor(view));
/**
Move the selection one character to the right.
*/
const cursorCharRight = view => cursorByChar(view, ltrAtCursor(view));
/**
Move the selection one character forward.
*/
const cursorCharForward = view => cursorByChar(view, true);
/**
Move the selection one character backward.
*/
const cursorCharBackward = view => cursorByChar(view, false);
function cursorByGroup(view, forward) {
    return moveSel(view, range => range.empty ? view.moveByGroup(range, forward) : rangeEnd(range, forward));
}
/**
Move the selection to the left across one group of word or
non-word (but also non-space) characters.
*/
const cursorGroupLeft = view => cursorByGroup(view, !ltrAtCursor(view));
/**
Move the selection one group to the right.
*/
const cursorGroupRight = view => cursorByGroup(view, ltrAtCursor(view));
/**
Move the selection one group forward.
*/
const cursorGroupForward = view => cursorByGroup(view, true);
/**
Move the selection one group backward.
*/
const cursorGroupBackward = view => cursorByGroup(view, false);
const segmenter = typeof Intl != "undefined" && Intl.Segmenter ?
    /*@__PURE__*/new (Intl.Segmenter)(undefined, { granularity: "word" }) : null;
function moveBySubword(view, range, forward) {
    let categorize = view.state.charCategorizer(range.from);
    let cat = CharCategory.Space, pos = range.from, steps = 0;
    let done = false, sawUpper = false, sawLower = false;
    let step = (next) => {
        if (done)
            return false;
        pos += forward ? next.length : -next.length;
        let nextCat = categorize(next), ahead;
        if (nextCat == CharCategory.Word && next.charCodeAt(0) < 128 && /[\W_]/.test(next))
            nextCat = -1; // Treat word punctuation specially
        if (cat == CharCategory.Space)
            cat = nextCat;
        if (cat != nextCat)
            return false;
        if (cat == CharCategory.Word) {
            if (next.toLowerCase() == next) {
                if (!forward && sawUpper)
                    return false;
                sawLower = true;
            }
            else if (sawLower) {
                if (forward)
                    return false;
                done = true;
            }
            else {
                if (sawUpper && forward && categorize(ahead = view.state.sliceDoc(pos, pos + 1)) == CharCategory.Word &&
                    ahead.toLowerCase() == ahead)
                    return false;
                sawUpper = true;
            }
        }
        steps++;
        return true;
    };
    let end = view.moveByChar(range, forward, start => {
        step(start);
        return step;
    });
    if (segmenter && cat == CharCategory.Word && end.from == range.from + steps * (forward ? 1 : -1)) {
        let from = Math.min(range.head, end.head), to = Math.max(range.head, end.head);
        let skipped = view.state.sliceDoc(from, to);
        if (skipped.length > 1 && /[\u4E00-\uffff]/.test(skipped)) {
            let segments = Array.from(segmenter.segment(skipped));
            if (segments.length > 1) {
                if (forward)
                    return EditorSelection.cursor(range.head + segments[1].index, -1);
                return EditorSelection.cursor(end.head + segments[segments.length - 1].index, 1);
            }
        }
    }
    return end;
}
function cursorBySubword(view, forward) {
    return moveSel(view, range => range.empty ? moveBySubword(view, range, forward) : rangeEnd(range, forward));
}
/**
Move the selection one group or camel-case subword forward.
*/
const cursorSubwordForward = view => cursorBySubword(view, true);
/**
Move the selection one group or camel-case subword backward.
*/
const cursorSubwordBackward = view => cursorBySubword(view, false);
function interestingNode(state, node, bracketProp) {
    if (node.type.prop(bracketProp))
        return true;
    let len = node.to - node.from;
    return len && (len > 2 || /[^\s,.;:]/.test(state.sliceDoc(node.from, node.to))) || node.firstChild;
}
function moveBySyntax(state, start, forward) {
    let pos = dist_syntaxTree(state).resolveInner(start.head);
    let bracketProp = forward ? dist_NodeProp.closedBy : dist_NodeProp.openedBy;
    // Scan forward through child nodes to see if there's an interesting
    // node ahead.
    for (let at = start.head;;) {
        let next = forward ? pos.childAfter(at) : pos.childBefore(at);
        if (!next)
            break;
        if (interestingNode(state, next, bracketProp))
            pos = next;
        else
            at = forward ? next.to : next.from;
    }
    let bracket = pos.type.prop(bracketProp), match, newPos;
    if (bracket && (match = forward ? matchBrackets(state, pos.from, 1) : matchBrackets(state, pos.to, -1)) && match.matched)
        newPos = forward ? match.end.to : match.end.from;
    else
        newPos = forward ? pos.to : pos.from;
    return dist_EditorSelection.cursor(newPos, forward ? -1 : 1);
}
/**
Move the cursor over the next syntactic element to the left.
*/
const cursorSyntaxLeft = view => moveSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the cursor over the next syntactic element to the right.
*/
const cursorSyntaxRight = view => moveSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function cursorByLine(view, forward) {
    return moveSel(view, range => {
        if (!range.empty)
            return rangeEnd(range, forward);
        let moved = view.moveVertically(range, forward);
        return moved.head != range.head ? moved : view.moveToLineBoundary(range, forward);
    });
}
/**
Move the selection one line up.
*/
const cursorLineUp = view => cursorByLine(view, false);
/**
Move the selection one line down.
*/
const cursorLineDown = view => cursorByLine(view, true);
function pageInfo(view) {
    let selfScroll = view.scrollDOM.clientHeight < view.scrollDOM.scrollHeight - 2;
    let marginTop = 0, marginBottom = 0, height;
    if (selfScroll) {
        for (let source of view.state.facet(EditorView.scrollMargins)) {
            let margins = source(view);
            if (margins === null || margins === void 0 ? void 0 : margins.top)
                marginTop = Math.max(margins === null || margins === void 0 ? void 0 : margins.top, marginTop);
            if (margins === null || margins === void 0 ? void 0 : margins.bottom)
                marginBottom = Math.max(margins === null || margins === void 0 ? void 0 : margins.bottom, marginBottom);
        }
        height = view.scrollDOM.clientHeight - marginTop - marginBottom;
    }
    else {
        height = (view.dom.ownerDocument.defaultView || window).innerHeight;
    }
    return { marginTop, marginBottom, selfScroll,
        height: Math.max(view.defaultLineHeight, height - 5) };
}
function cursorByPage(view, forward) {
    let page = pageInfo(view);
    let { state } = view, selection = updateSel(state.selection, range => {
        return range.empty ? view.moveVertically(range, forward, page.height)
            : rangeEnd(range, forward);
    });
    if (selection.eq(state.selection))
        return false;
    let effect;
    if (page.selfScroll) {
        let startPos = view.coordsAtPos(state.selection.main.head);
        let scrollRect = view.scrollDOM.getBoundingClientRect();
        let scrollTop = scrollRect.top + page.marginTop, scrollBottom = scrollRect.bottom - page.marginBottom;
        if (startPos && startPos.top > scrollTop && startPos.bottom < scrollBottom)
            effect = EditorView.scrollIntoView(selection.main.head, { y: "start", yMargin: startPos.top - scrollTop });
    }
    view.dispatch(setSel(state, selection), { effects: effect });
    return true;
}
/**
Move the selection one page up.
*/
const cursorPageUp = view => cursorByPage(view, false);
/**
Move the selection one page down.
*/
const cursorPageDown = view => cursorByPage(view, true);
function moveByLineBoundary(view, start, forward) {
    let line = view.lineBlockAt(start.head), moved = view.moveToLineBoundary(start, forward);
    if (moved.head == start.head && moved.head != (forward ? line.to : line.from))
        moved = view.moveToLineBoundary(start, forward, false);
    if (!forward && moved.head == line.from && line.length) {
        let space = /^\s*/.exec(view.state.sliceDoc(line.from, Math.min(line.from + 100, line.to)))[0].length;
        if (space && start.head != line.from + space)
            moved = dist_EditorSelection.cursor(line.from + space);
    }
    return moved;
}
/**
Move the selection to the next line wrap point, or to the end of
the line if there isn't one left on this line.
*/
const cursorLineBoundaryForward = view => moveSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection to previous line wrap point, or failing that to
the start of the line. If the line is indented, and the cursor
isn't already at the end of the indentation, this will move to the
end of the indentation instead of the start of the line.
*/
const cursorLineBoundaryBackward = view => moveSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection one line wrap point to the left.
*/
const cursorLineBoundaryLeft = view => moveSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection one line wrap point to the right.
*/
const cursorLineBoundaryRight = view => moveSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection to the start of the line.
*/
const cursorLineStart = view => moveSel(view, range => dist_EditorSelection.cursor(view.lineBlockAt(range.head).from, 1));
/**
Move the selection to the end of the line.
*/
const cursorLineEnd = view => moveSel(view, range => dist_EditorSelection.cursor(view.lineBlockAt(range.head).to, -1));
function toMatchingBracket(state, dispatch, extend) {
    let found = false, selection = updateSel(state.selection, range => {
        let matching = matchBrackets(state, range.head, -1)
            || matchBrackets(state, range.head, 1)
            || (range.head > 0 && matchBrackets(state, range.head - 1, 1))
            || (range.head < state.doc.length && matchBrackets(state, range.head + 1, -1));
        if (!matching || !matching.end)
            return range;
        found = true;
        let head = matching.start.from == range.head ? matching.end.to : matching.end.from;
        return extend ? dist_EditorSelection.range(range.anchor, head) : dist_EditorSelection.cursor(head);
    });
    if (!found)
        return false;
    dispatch(setSel(state, selection));
    return true;
}
/**
Move the selection to the bracket matching the one it is currently
on, if any.
*/
const cursorMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, false);
/**
Extend the selection to the bracket matching the one the selection
head is currently on, if any.
*/
const selectMatchingBracket = ({ state, dispatch }) => toMatchingBracket(state, dispatch, true);
function extendSel(view, how) {
    let selection = updateSel(view.state.selection, range => {
        let head = how(range);
        return dist_EditorSelection.range(range.anchor, head.head, head.goalColumn, head.bidiLevel || undefined);
    });
    if (selection.eq(view.state.selection))
        return false;
    view.dispatch(setSel(view.state, selection));
    return true;
}
function selectByChar(view, forward) {
    return extendSel(view, range => view.moveByChar(range, forward));
}
/**
Move the selection head one character to the left, while leaving
the anchor in place.
*/
const selectCharLeft = view => selectByChar(view, !ltrAtCursor(view));
/**
Move the selection head one character to the right.
*/
const selectCharRight = view => selectByChar(view, ltrAtCursor(view));
/**
Move the selection head one character forward.
*/
const selectCharForward = view => selectByChar(view, true);
/**
Move the selection head one character backward.
*/
const selectCharBackward = view => selectByChar(view, false);
function selectByGroup(view, forward) {
    return extendSel(view, range => view.moveByGroup(range, forward));
}
/**
Move the selection head one [group](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) to
the left.
*/
const selectGroupLeft = view => selectByGroup(view, !ltrAtCursor(view));
/**
Move the selection head one group to the right.
*/
const selectGroupRight = view => selectByGroup(view, ltrAtCursor(view));
/**
Move the selection head one group forward.
*/
const selectGroupForward = view => selectByGroup(view, true);
/**
Move the selection head one group backward.
*/
const selectGroupBackward = view => selectByGroup(view, false);
function selectBySubword(view, forward) {
    return extendSel(view, range => moveBySubword(view, range, forward));
}
/**
Move the selection head one group or camel-case subword forward.
*/
const selectSubwordForward = view => selectBySubword(view, true);
/**
Move the selection head one group or subword backward.
*/
const selectSubwordBackward = view => selectBySubword(view, false);
/**
Move the selection head over the next syntactic element to the left.
*/
const selectSyntaxLeft = view => extendSel(view, range => moveBySyntax(view.state, range, !ltrAtCursor(view)));
/**
Move the selection head over the next syntactic element to the right.
*/
const selectSyntaxRight = view => extendSel(view, range => moveBySyntax(view.state, range, ltrAtCursor(view)));
function selectByLine(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward));
}
/**
Move the selection head one line up.
*/
const selectLineUp = view => selectByLine(view, false);
/**
Move the selection head one line down.
*/
const selectLineDown = view => selectByLine(view, true);
function selectByPage(view, forward) {
    return extendSel(view, range => view.moveVertically(range, forward, pageInfo(view).height));
}
/**
Move the selection head one page up.
*/
const selectPageUp = view => selectByPage(view, false);
/**
Move the selection head one page down.
*/
const selectPageDown = view => selectByPage(view, true);
/**
Move the selection head to the next line boundary.
*/
const selectLineBoundaryForward = view => extendSel(view, range => moveByLineBoundary(view, range, true));
/**
Move the selection head to the previous line boundary.
*/
const selectLineBoundaryBackward = view => extendSel(view, range => moveByLineBoundary(view, range, false));
/**
Move the selection head one line boundary to the left.
*/
const selectLineBoundaryLeft = view => extendSel(view, range => moveByLineBoundary(view, range, !ltrAtCursor(view)));
/**
Move the selection head one line boundary to the right.
*/
const selectLineBoundaryRight = view => extendSel(view, range => moveByLineBoundary(view, range, ltrAtCursor(view)));
/**
Move the selection head to the start of the line.
*/
const selectLineStart = view => extendSel(view, range => dist_EditorSelection.cursor(view.lineBlockAt(range.head).from));
/**
Move the selection head to the end of the line.
*/
const selectLineEnd = view => extendSel(view, range => dist_EditorSelection.cursor(view.lineBlockAt(range.head).to));
/**
Move the selection to the start of the document.
*/
const cursorDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: 0 }));
    return true;
};
/**
Move the selection to the end of the document.
*/
const cursorDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.doc.length }));
    return true;
};
/**
Move the selection head to the start of the document.
*/
const selectDocStart = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: 0 }));
    return true;
};
/**
Move the selection head to the end of the document.
*/
const selectDocEnd = ({ state, dispatch }) => {
    dispatch(setSel(state, { anchor: state.selection.main.anchor, head: state.doc.length }));
    return true;
};
/**
Select the entire document.
*/
const selectAll = ({ state, dispatch }) => {
    dispatch(state.update({ selection: { anchor: 0, head: state.doc.length }, userEvent: "select" }));
    return true;
};
/**
Expand the selection to cover entire lines.
*/
const selectLine = ({ state, dispatch }) => {
    let ranges = selectedLineBlocks(state).map(({ from, to }) => dist_EditorSelection.range(from, Math.min(to + 1, state.doc.length)));
    dispatch(state.update({ selection: dist_EditorSelection.create(ranges), userEvent: "select" }));
    return true;
};
/**
Select the next syntactic construct that is larger than the
selection. Note that this will only work insofar as the language
[provider](https://codemirror.net/6/docs/ref/#language.language) you use builds up a full
syntax tree.
*/
const selectParentSyntax = ({ state, dispatch }) => {
    let selection = updateSel(state.selection, range => {
        var _a;
        let stack = dist_syntaxTree(state).resolveStack(range.from, 1);
        for (let cur = stack; cur; cur = cur.next) {
            let { node } = cur;
            if (((node.from < range.from && node.to >= range.to) ||
                (node.to > range.to && node.from <= range.from)) &&
                ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent))
                return dist_EditorSelection.range(node.to, node.from);
        }
        return range;
    });
    dispatch(setSel(state, selection));
    return true;
};
/**
Simplify the current selection. When multiple ranges are selected,
reduce it to its main range. Otherwise, if the selection is
non-empty, convert it to a cursor selection.
*/
const simplifySelection = ({ state, dispatch }) => {
    let cur = state.selection, selection = null;
    if (cur.ranges.length > 1)
        selection = dist_EditorSelection.create([cur.main]);
    else if (!cur.main.empty)
        selection = dist_EditorSelection.create([dist_EditorSelection.cursor(cur.main.head)]);
    if (!selection)
        return false;
    dispatch(setSel(state, selection));
    return true;
};
function deleteBy(target, by) {
    if (target.state.readOnly)
        return false;
    let event = "delete.selection", { state } = target;
    let changes = state.changeByRange(range => {
        let { from, to } = range;
        if (from == to) {
            let towards = by(range);
            if (towards < from) {
                event = "delete.backward";
                towards = skipAtomic(target, towards, false);
            }
            else if (towards > from) {
                event = "delete.forward";
                towards = skipAtomic(target, towards, true);
            }
            from = Math.min(from, towards);
            to = Math.max(to, towards);
        }
        else {
            from = skipAtomic(target, from, false);
            to = skipAtomic(target, to, true);
        }
        return from == to ? { range } : { changes: { from, to }, range: dist_EditorSelection.cursor(from, from < range.head ? -1 : 1) };
    });
    if (changes.changes.empty)
        return false;
    target.dispatch(state.update(changes, {
        scrollIntoView: true,
        userEvent: event,
        effects: event == "delete.selection" ? EditorView.announce.of(state.phrase("Selection deleted")) : undefined
    }));
    return true;
}
function skipAtomic(target, pos, forward) {
    if (target instanceof EditorView)
        for (let ranges of target.state.facet(EditorView.atomicRanges).map(f => f(target)))
            ranges.between(pos, pos, (from, to) => {
                if (from < pos && to > pos)
                    pos = forward ? to : from;
            });
    return pos;
}
const deleteByChar = (target, forward) => deleteBy(target, range => {
    let pos = range.from, { state } = target, line = state.doc.lineAt(pos), before, targetPos;
    if (!forward && pos > line.from && pos < line.from + 200 &&
        !/[^ \t]/.test(before = line.text.slice(0, pos - line.from))) {
        if (before[before.length - 1] == "\t")
            return pos - 1;
        let col = countColumn(before, state.tabSize), drop = col % getIndentUnit(state) || getIndentUnit(state);
        for (let i = 0; i < drop && before[before.length - 1 - i] == " "; i++)
            pos--;
        targetPos = pos;
    }
    else {
        targetPos = findClusterBreak(line.text, pos - line.from, forward, forward) + line.from;
        if (targetPos == pos && line.number != (forward ? state.doc.lines : 1))
            targetPos += forward ? 1 : -1;
        else if (!forward && /[\ufe00-\ufe0f]/.test(line.text.slice(targetPos - line.from, pos - line.from)))
            targetPos = findClusterBreak(line.text, targetPos - line.from, false, false) + line.from;
    }
    return targetPos;
});
/**
Delete the selection, or, for cursor selections, the character
before the cursor.
*/
const deleteCharBackward = view => deleteByChar(view, false);
/**
Delete the selection or the character after the cursor.
*/
const deleteCharForward = view => deleteByChar(view, true);
const deleteByGroup = (target, forward) => deleteBy(target, range => {
    let pos = range.head, { state } = target, line = state.doc.lineAt(pos);
    let categorize = state.charCategorizer(pos);
    for (let cat = null;;) {
        if (pos == (forward ? line.to : line.from)) {
            if (pos == range.head && line.number != (forward ? state.doc.lines : 1))
                pos += forward ? 1 : -1;
            break;
        }
        let next = findClusterBreak(line.text, pos - line.from, forward) + line.from;
        let nextChar = line.text.slice(Math.min(pos, next) - line.from, Math.max(pos, next) - line.from);
        let nextCat = categorize(nextChar);
        if (cat != null && nextCat != cat)
            break;
        if (nextChar != " " || pos != range.head)
            cat = nextCat;
        pos = next;
    }
    return pos;
});
/**
Delete the selection or backward until the end of the next
[group](https://codemirror.net/6/docs/ref/#view.EditorView.moveByGroup), only skipping groups of
whitespace when they consist of a single space.
*/
const deleteGroupBackward = target => deleteByGroup(target, false);
/**
Delete the selection or forward until the end of the next group.
*/
const deleteGroupForward = target => deleteByGroup(target, true);
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line. If the cursor is directly at the end of the
line, delete the line break after it.
*/
const deleteToLineEnd = view => deleteBy(view, range => {
    let lineEnd = view.lineBlockAt(range.head).to;
    return range.head < lineEnd ? lineEnd : Math.min(view.state.doc.length, range.head + 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line. If the cursor is directly at the start of the
line, delete the line break before it.
*/
const deleteToLineStart = view => deleteBy(view, range => {
    let lineStart = view.lineBlockAt(range.head).from;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the start of the line or the next line wrap before the cursor.
*/
const deleteLineBoundaryBackward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, false).head;
    return range.head > lineStart ? lineStart : Math.max(0, range.head - 1);
});
/**
Delete the selection, or, if it is a cursor selection, delete to
the end of the line or the next line wrap after the cursor.
*/
const deleteLineBoundaryForward = view => deleteBy(view, range => {
    let lineStart = view.moveToLineBoundary(range, true).head;
    return range.head < lineStart ? lineStart : Math.min(view.state.doc.length, range.head + 1);
});
/**
Delete all whitespace directly before a line end from the
document.
*/
const deleteTrailingWhitespace = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let pos = 0, prev = "", iter = state.doc.iter();;) {
        iter.next();
        if (iter.lineBreak || iter.done) {
            let trailing = prev.search(/\s+$/);
            if (trailing > -1)
                changes.push({ from: pos - (prev.length - trailing), to: pos });
            if (iter.done)
                break;
            prev = "";
        }
        else {
            prev = iter.value;
        }
        pos += iter.value.length;
    }
    if (!changes.length)
        return false;
    dispatch(state.update({ changes, userEvent: "delete" }));
    return true;
};
/**
Replace each selection range with a line break, leaving the cursor
on the line before the break.
*/
const splitLine = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        return { changes: { from: range.from, to: range.to, insert: Text.of(["", ""]) },
            range: dist_EditorSelection.cursor(range.from) };
    });
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Flip the characters before and after the cursor(s).
*/
const transposeChars = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let changes = state.changeByRange(range => {
        if (!range.empty || range.from == 0 || range.from == state.doc.length)
            return { range };
        let pos = range.from, line = state.doc.lineAt(pos);
        let from = pos == line.from ? pos - 1 : findClusterBreak(line.text, pos - line.from, false) + line.from;
        let to = pos == line.to ? pos + 1 : findClusterBreak(line.text, pos - line.from, true) + line.from;
        return { changes: { from, to, insert: state.doc.slice(pos, to).append(state.doc.slice(from, pos)) },
            range: dist_EditorSelection.cursor(to) };
    });
    if (changes.changes.empty)
        return false;
    dispatch(state.update(changes, { scrollIntoView: true, userEvent: "move.character" }));
    return true;
};
function selectedLineBlocks(state) {
    let blocks = [], upto = -1;
    for (let range of state.selection.ranges) {
        let startLine = state.doc.lineAt(range.from), endLine = state.doc.lineAt(range.to);
        if (!range.empty && range.to == endLine.from)
            endLine = state.doc.lineAt(range.to - 1);
        if (upto >= startLine.number) {
            let prev = blocks[blocks.length - 1];
            prev.to = endLine.to;
            prev.ranges.push(range);
        }
        else {
            blocks.push({ from: startLine.from, to: endLine.to, ranges: [range] });
        }
        upto = endLine.number + 1;
    }
    return blocks;
}
function moveLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [], ranges = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward ? block.to == state.doc.length : block.from == 0)
            continue;
        let nextLine = state.doc.lineAt(forward ? block.to + 1 : block.from - 1);
        let size = nextLine.length + 1;
        if (forward) {
            changes.push({ from: block.to, to: nextLine.to }, { from: block.from, insert: nextLine.text + state.lineBreak });
            for (let r of block.ranges)
                ranges.push(dist_EditorSelection.range(Math.min(state.doc.length, r.anchor + size), Math.min(state.doc.length, r.head + size)));
        }
        else {
            changes.push({ from: nextLine.from, to: block.from }, { from: block.to, insert: state.lineBreak + nextLine.text });
            for (let r of block.ranges)
                ranges.push(dist_EditorSelection.range(r.anchor - size, r.head - size));
        }
    }
    if (!changes.length)
        return false;
    dispatch(state.update({
        changes,
        scrollIntoView: true,
        selection: dist_EditorSelection.create(ranges, state.selection.mainIndex),
        userEvent: "move.line"
    }));
    return true;
}
/**
Move the selected lines up one line.
*/
const moveLineUp = ({ state, dispatch }) => moveLine(state, dispatch, false);
/**
Move the selected lines down one line.
*/
const moveLineDown = ({ state, dispatch }) => moveLine(state, dispatch, true);
function copyLine(state, dispatch, forward) {
    if (state.readOnly)
        return false;
    let changes = [];
    for (let block of selectedLineBlocks(state)) {
        if (forward)
            changes.push({ from: block.from, insert: state.doc.slice(block.from, block.to) + state.lineBreak });
        else
            changes.push({ from: block.to, insert: state.lineBreak + state.doc.slice(block.from, block.to) });
    }
    dispatch(state.update({ changes, scrollIntoView: true, userEvent: "input.copyline" }));
    return true;
}
/**
Create a copy of the selected lines. Keep the selection in the top copy.
*/
const copyLineUp = ({ state, dispatch }) => copyLine(state, dispatch, false);
/**
Create a copy of the selected lines. Keep the selection in the bottom copy.
*/
const copyLineDown = ({ state, dispatch }) => copyLine(state, dispatch, true);
/**
Delete selected lines.
*/
const deleteLine = view => {
    if (view.state.readOnly)
        return false;
    let { state } = view, changes = state.changes(selectedLineBlocks(state).map(({ from, to }) => {
        if (from > 0)
            from--;
        else if (to < state.doc.length)
            to++;
        return { from, to };
    }));
    let selection = updateSel(state.selection, range => view.moveVertically(range, true)).map(changes);
    view.dispatch({ changes, selection, scrollIntoView: true, userEvent: "delete.line" });
    return true;
};
/**
Replace the selection with a newline.
*/
const insertNewline = ({ state, dispatch }) => {
    dispatch(state.update(state.replaceSelection(state.lineBreak), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
function isBetweenBrackets(state, pos) {
    if (/\(\)|\[\]|\{\}/.test(state.sliceDoc(pos - 1, pos + 1)))
        return { from: pos, to: pos };
    let context = dist_syntaxTree(state).resolveInner(pos);
    let before = context.childBefore(pos), after = context.childAfter(pos), closedBy;
    if (before && after && before.to <= pos && after.from >= pos &&
        (closedBy = before.type.prop(dist_NodeProp.closedBy)) && closedBy.indexOf(after.name) > -1 &&
        state.doc.lineAt(before.to).from == state.doc.lineAt(after.from).from &&
        !/\S/.test(state.sliceDoc(before.to, after.from)))
        return { from: before.to, to: after.from };
    return null;
}
/**
Replace the selection with a newline and indent the newly created
line(s). If the current line consists only of whitespace, this
will also delete that whitespace. When the cursor is between
matching brackets, an additional newline will be inserted after
the cursor.
*/
const insertNewlineAndIndent = /*@__PURE__*/newlineAndIndent(false);
/**
Create a blank, indented line below the current line.
*/
const insertBlankLine = /*@__PURE__*/newlineAndIndent(true);
function newlineAndIndent(atEof) {
    return ({ state, dispatch }) => {
        if (state.readOnly)
            return false;
        let changes = state.changeByRange(range => {
            let { from, to } = range, line = state.doc.lineAt(from);
            let explode = !atEof && from == to && isBetweenBrackets(state, from);
            if (atEof)
                from = to = (to <= line.to ? line : state.doc.lineAt(to)).to;
            let cx = new IndentContext(state, { simulateBreak: from, simulateDoubleBreak: !!explode });
            let indent = getIndentation(cx, from);
            if (indent == null)
                indent = countColumn(/^\s*/.exec(state.doc.lineAt(from).text)[0], state.tabSize);
            while (to < line.to && /\s/.test(line.text[to - line.from]))
                to++;
            if (explode)
                ({ from, to } = explode);
            else if (from > line.from && from < line.from + 100 && !/\S/.test(line.text.slice(0, from)))
                from = line.from;
            let insert = ["", indentString(state, indent)];
            if (explode)
                insert.push(indentString(state, cx.lineIndent(line.from, -1)));
            return { changes: { from, to, insert: Text.of(insert) },
                range: dist_EditorSelection.cursor(from + 1 + insert[1].length) };
        });
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "input" }));
        return true;
    };
}
function changeBySelectedLine(state, f) {
    let atLine = -1;
    return state.changeByRange(range => {
        let changes = [];
        for (let pos = range.from; pos <= range.to;) {
            let line = state.doc.lineAt(pos);
            if (line.number > atLine && (range.empty || range.to > line.from)) {
                f(line, changes, range);
                atLine = line.number;
            }
            pos = line.to + 1;
        }
        let changeSet = state.changes(changes);
        return { changes,
            range: dist_EditorSelection.range(changeSet.mapPos(range.anchor, 1), changeSet.mapPos(range.head, 1)) };
    });
}
/**
Auto-indent the selected lines. This uses the [indentation service
facet](https://codemirror.net/6/docs/ref/#language.indentService) as source for auto-indent
information.
*/
const indentSelection = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let updated = Object.create(null);
    let context = new IndentContext(state, { overrideIndentation: start => {
            let found = updated[start];
            return found == null ? -1 : found;
        } });
    let changes = changeBySelectedLine(state, (line, changes, range) => {
        let indent = getIndentation(context, line.from);
        if (indent == null)
            return;
        if (!/\S/.test(line.text))
            indent = 0;
        let cur = /^\s*/.exec(line.text)[0];
        let norm = indentString(state, indent);
        if (cur != norm || range.from < line.from + cur.length) {
            updated[line.from] = indent;
            changes.push({ from: line.from, to: line.from + cur.length, insert: norm });
        }
    });
    if (!changes.changes.empty)
        dispatch(state.update(changes, { userEvent: "indent" }));
    return true;
};
/**
Add a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation to all selected
lines.
*/
const indentMore = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        changes.push({ from: line.from, insert: state.facet(indentUnit) });
    }), { userEvent: "input.indent" }));
    return true;
};
/**
Remove a [unit](https://codemirror.net/6/docs/ref/#language.indentUnit) of indentation from all
selected lines.
*/
const indentLess = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    dispatch(state.update(changeBySelectedLine(state, (line, changes) => {
        let space = /^\s*/.exec(line.text)[0];
        if (!space)
            return;
        let col = countColumn(space, state.tabSize), keep = 0;
        let insert = indentString(state, Math.max(0, col - getIndentUnit(state)));
        while (keep < space.length && keep < insert.length && space.charCodeAt(keep) == insert.charCodeAt(keep))
            keep++;
        changes.push({ from: line.from + keep, to: line.from + space.length, insert: insert.slice(keep) });
    }), { userEvent: "delete.dedent" }));
    return true;
};
/**
Insert a tab character at the cursor or, if something is selected,
use [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) to indent the entire
selection.
*/
const insertTab = ({ state, dispatch }) => {
    if (state.selection.ranges.some(r => !r.empty))
        return indentMore({ state, dispatch });
    dispatch(state.update(state.replaceSelection("\t"), { scrollIntoView: true, userEvent: "input" }));
    return true;
};
/**
Array of key bindings containing the Emacs-style bindings that are
available on macOS by default.

 - Ctrl-b: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - Ctrl-f: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-p: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - Ctrl-n: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Ctrl-a: [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Ctrl-e: [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - Ctrl-d: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-h: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Ctrl-k: [`deleteToLineEnd`](https://codemirror.net/6/docs/ref/#commands.deleteToLineEnd)
 - Ctrl-Alt-h: [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-o: [`splitLine`](https://codemirror.net/6/docs/ref/#commands.splitLine)
 - Ctrl-t: [`transposeChars`](https://codemirror.net/6/docs/ref/#commands.transposeChars)
 - Ctrl-v: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown)
 - Alt-v: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp)
*/
const emacsStyleKeymap = [
    { key: "Ctrl-b", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Ctrl-f", run: cursorCharRight, shift: selectCharRight },
    { key: "Ctrl-p", run: cursorLineUp, shift: selectLineUp },
    { key: "Ctrl-n", run: cursorLineDown, shift: selectLineDown },
    { key: "Ctrl-a", run: cursorLineStart, shift: selectLineStart },
    { key: "Ctrl-e", run: cursorLineEnd, shift: selectLineEnd },
    { key: "Ctrl-d", run: deleteCharForward },
    { key: "Ctrl-h", run: deleteCharBackward },
    { key: "Ctrl-k", run: deleteToLineEnd },
    { key: "Ctrl-Alt-h", run: deleteGroupBackward },
    { key: "Ctrl-o", run: splitLine },
    { key: "Ctrl-t", run: transposeChars },
    { key: "Ctrl-v", run: cursorPageDown },
];
/**
An array of key bindings closely sticking to platform-standard or
widely used bindings. (This includes the bindings from
[`emacsStyleKeymap`](https://codemirror.net/6/docs/ref/#commands.emacsStyleKeymap), with their `key`
property changed to `mac`.)

 - ArrowLeft: [`cursorCharLeft`](https://codemirror.net/6/docs/ref/#commands.cursorCharLeft) ([`selectCharLeft`](https://codemirror.net/6/docs/ref/#commands.selectCharLeft) with Shift)
 - ArrowRight: [`cursorCharRight`](https://codemirror.net/6/docs/ref/#commands.cursorCharRight) ([`selectCharRight`](https://codemirror.net/6/docs/ref/#commands.selectCharRight) with Shift)
 - Ctrl-ArrowLeft (Alt-ArrowLeft on macOS): [`cursorGroupLeft`](https://codemirror.net/6/docs/ref/#commands.cursorGroupLeft) ([`selectGroupLeft`](https://codemirror.net/6/docs/ref/#commands.selectGroupLeft) with Shift)
 - Ctrl-ArrowRight (Alt-ArrowRight on macOS): [`cursorGroupRight`](https://codemirror.net/6/docs/ref/#commands.cursorGroupRight) ([`selectGroupRight`](https://codemirror.net/6/docs/ref/#commands.selectGroupRight) with Shift)
 - Cmd-ArrowLeft (on macOS): [`cursorLineStart`](https://codemirror.net/6/docs/ref/#commands.cursorLineStart) ([`selectLineStart`](https://codemirror.net/6/docs/ref/#commands.selectLineStart) with Shift)
 - Cmd-ArrowRight (on macOS): [`cursorLineEnd`](https://codemirror.net/6/docs/ref/#commands.cursorLineEnd) ([`selectLineEnd`](https://codemirror.net/6/docs/ref/#commands.selectLineEnd) with Shift)
 - ArrowUp: [`cursorLineUp`](https://codemirror.net/6/docs/ref/#commands.cursorLineUp) ([`selectLineUp`](https://codemirror.net/6/docs/ref/#commands.selectLineUp) with Shift)
 - ArrowDown: [`cursorLineDown`](https://codemirror.net/6/docs/ref/#commands.cursorLineDown) ([`selectLineDown`](https://codemirror.net/6/docs/ref/#commands.selectLineDown) with Shift)
 - Cmd-ArrowUp (on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Cmd-ArrowDown (on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Ctrl-ArrowUp (on macOS): [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - Ctrl-ArrowDown (on macOS): [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - PageUp: [`cursorPageUp`](https://codemirror.net/6/docs/ref/#commands.cursorPageUp) ([`selectPageUp`](https://codemirror.net/6/docs/ref/#commands.selectPageUp) with Shift)
 - PageDown: [`cursorPageDown`](https://codemirror.net/6/docs/ref/#commands.cursorPageDown) ([`selectPageDown`](https://codemirror.net/6/docs/ref/#commands.selectPageDown) with Shift)
 - Home: [`cursorLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryBackward) ([`selectLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryBackward) with Shift)
 - End: [`cursorLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.cursorLineBoundaryForward) ([`selectLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.selectLineBoundaryForward) with Shift)
 - Ctrl-Home (Cmd-Home on macOS): [`cursorDocStart`](https://codemirror.net/6/docs/ref/#commands.cursorDocStart) ([`selectDocStart`](https://codemirror.net/6/docs/ref/#commands.selectDocStart) with Shift)
 - Ctrl-End (Cmd-Home on macOS): [`cursorDocEnd`](https://codemirror.net/6/docs/ref/#commands.cursorDocEnd) ([`selectDocEnd`](https://codemirror.net/6/docs/ref/#commands.selectDocEnd) with Shift)
 - Enter: [`insertNewlineAndIndent`](https://codemirror.net/6/docs/ref/#commands.insertNewlineAndIndent)
 - Ctrl-a (Cmd-a on macOS): [`selectAll`](https://codemirror.net/6/docs/ref/#commands.selectAll)
 - Backspace: [`deleteCharBackward`](https://codemirror.net/6/docs/ref/#commands.deleteCharBackward)
 - Delete: [`deleteCharForward`](https://codemirror.net/6/docs/ref/#commands.deleteCharForward)
 - Ctrl-Backspace (Alt-Backspace on macOS): [`deleteGroupBackward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupBackward)
 - Ctrl-Delete (Alt-Delete on macOS): [`deleteGroupForward`](https://codemirror.net/6/docs/ref/#commands.deleteGroupForward)
 - Cmd-Backspace (macOS): [`deleteLineBoundaryBackward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryBackward).
 - Cmd-Delete (macOS): [`deleteLineBoundaryForward`](https://codemirror.net/6/docs/ref/#commands.deleteLineBoundaryForward).
*/
const standardKeymap = /*@__PURE__*/[
    { key: "ArrowLeft", run: cursorCharLeft, shift: selectCharLeft, preventDefault: true },
    { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: cursorGroupLeft, shift: selectGroupLeft, preventDefault: true },
    { mac: "Cmd-ArrowLeft", run: cursorLineBoundaryLeft, shift: selectLineBoundaryLeft, preventDefault: true },
    { key: "ArrowRight", run: cursorCharRight, shift: selectCharRight, preventDefault: true },
    { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: cursorGroupRight, shift: selectGroupRight, preventDefault: true },
    { mac: "Cmd-ArrowRight", run: cursorLineBoundaryRight, shift: selectLineBoundaryRight, preventDefault: true },
    { key: "ArrowUp", run: cursorLineUp, shift: selectLineUp, preventDefault: true },
    { mac: "Cmd-ArrowUp", run: cursorDocStart, shift: selectDocStart },
    { mac: "Ctrl-ArrowUp", run: cursorPageUp, shift: selectPageUp },
    { key: "ArrowDown", run: cursorLineDown, shift: selectLineDown, preventDefault: true },
    { mac: "Cmd-ArrowDown", run: cursorDocEnd, shift: selectDocEnd },
    { mac: "Ctrl-ArrowDown", run: cursorPageDown, shift: selectPageDown },
    { key: "PageUp", run: cursorPageUp, shift: selectPageUp },
    { key: "PageDown", run: cursorPageDown, shift: selectPageDown },
    { key: "Home", run: cursorLineBoundaryBackward, shift: selectLineBoundaryBackward, preventDefault: true },
    { key: "Mod-Home", run: cursorDocStart, shift: selectDocStart },
    { key: "End", run: cursorLineBoundaryForward, shift: selectLineBoundaryForward, preventDefault: true },
    { key: "Mod-End", run: cursorDocEnd, shift: selectDocEnd },
    { key: "Enter", run: insertNewlineAndIndent },
    { key: "Mod-a", run: selectAll },
    { key: "Backspace", run: deleteCharBackward, shift: deleteCharBackward },
    { key: "Delete", run: deleteCharForward },
    { key: "Mod-Backspace", mac: "Alt-Backspace", run: deleteGroupBackward },
    { key: "Mod-Delete", mac: "Alt-Delete", run: deleteGroupForward },
    { mac: "Mod-Backspace", run: deleteLineBoundaryBackward },
    { mac: "Mod-Delete", run: deleteLineBoundaryForward }
].concat(/*@__PURE__*/emacsStyleKeymap.map(b => ({ mac: b.key, run: b.run, shift: b.shift })));
/**
The default keymap. Includes all bindings from
[`standardKeymap`](https://codemirror.net/6/docs/ref/#commands.standardKeymap) plus the following:

- Alt-ArrowLeft (Ctrl-ArrowLeft on macOS): [`cursorSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxLeft) ([`selectSyntaxLeft`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxLeft) with Shift)
- Alt-ArrowRight (Ctrl-ArrowRight on macOS): [`cursorSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.cursorSyntaxRight) ([`selectSyntaxRight`](https://codemirror.net/6/docs/ref/#commands.selectSyntaxRight) with Shift)
- Alt-ArrowUp: [`moveLineUp`](https://codemirror.net/6/docs/ref/#commands.moveLineUp)
- Alt-ArrowDown: [`moveLineDown`](https://codemirror.net/6/docs/ref/#commands.moveLineDown)
- Shift-Alt-ArrowUp: [`copyLineUp`](https://codemirror.net/6/docs/ref/#commands.copyLineUp)
- Shift-Alt-ArrowDown: [`copyLineDown`](https://codemirror.net/6/docs/ref/#commands.copyLineDown)
- Escape: [`simplifySelection`](https://codemirror.net/6/docs/ref/#commands.simplifySelection)
- Ctrl-Enter (Cmd-Enter on macOS): [`insertBlankLine`](https://codemirror.net/6/docs/ref/#commands.insertBlankLine)
- Alt-l (Ctrl-l on macOS): [`selectLine`](https://codemirror.net/6/docs/ref/#commands.selectLine)
- Ctrl-i (Cmd-i on macOS): [`selectParentSyntax`](https://codemirror.net/6/docs/ref/#commands.selectParentSyntax)
- Ctrl-[ (Cmd-[ on macOS): [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess)
- Ctrl-] (Cmd-] on macOS): [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore)
- Ctrl-Alt-\\ (Cmd-Alt-\\ on macOS): [`indentSelection`](https://codemirror.net/6/docs/ref/#commands.indentSelection)
- Shift-Ctrl-k (Shift-Cmd-k on macOS): [`deleteLine`](https://codemirror.net/6/docs/ref/#commands.deleteLine)
- Shift-Ctrl-\\ (Shift-Cmd-\\ on macOS): [`cursorMatchingBracket`](https://codemirror.net/6/docs/ref/#commands.cursorMatchingBracket)
- Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#commands.toggleComment).
- Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#commands.toggleBlockComment).
*/
const dist_defaultKeymap = /*@__PURE__*/[
    { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: cursorSyntaxLeft, shift: selectSyntaxLeft },
    { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: cursorSyntaxRight, shift: selectSyntaxRight },
    { key: "Alt-ArrowUp", run: moveLineUp },
    { key: "Shift-Alt-ArrowUp", run: copyLineUp },
    { key: "Alt-ArrowDown", run: moveLineDown },
    { key: "Shift-Alt-ArrowDown", run: copyLineDown },
    { key: "Escape", run: simplifySelection },
    { key: "Mod-Enter", run: insertBlankLine },
    { key: "Alt-l", mac: "Ctrl-l", run: selectLine },
    { key: "Mod-i", run: selectParentSyntax, preventDefault: true },
    { key: "Mod-[", run: indentLess },
    { key: "Mod-]", run: indentMore },
    { key: "Mod-Alt-\\", run: indentSelection },
    { key: "Shift-Mod-k", run: deleteLine },
    { key: "Shift-Mod-\\", run: cursorMatchingBracket },
    { key: "Mod-/", run: toggleComment },
    { key: "Alt-A", run: toggleBlockComment }
].concat(standardKeymap);
/**
A binding that binds Tab to [`indentMore`](https://codemirror.net/6/docs/ref/#commands.indentMore) and
Shift-Tab to [`indentLess`](https://codemirror.net/6/docs/ref/#commands.indentLess).
Please see the [Tab example](../../examples/tab/) before using
this.
*/
const indentWithTab = { key: "Tab", run: indentMore, shift: indentLess };



;// CONCATENATED MODULE: ./node_modules/crelt/index.js
function crelt() {
  var elt = arguments[0]
  if (typeof elt == "string") elt = document.createElement(elt)
  var i = 1, next = arguments[1]
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name]
      if (typeof value == "string") elt.setAttribute(name, value)
      else if (value != null) elt[name] = value
    }
    i++
  }
  for (; i < arguments.length; i++) add(elt, arguments[i])
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child))
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child)
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i])
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}

;// CONCATENATED MODULE: ./node_modules/@codemirror/search/dist/index.js




const basicNormalize = typeof String.prototype.normalize == "function"
    ? x => x.normalize("NFKD") : x => x;
/**
A search cursor provides an iterator over text matches in a
document.
*/
class SearchCursor {
    /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
    constructor(text, query, from = 0, to = text.length, normalize, test) {
        this.test = test;
        /**
        The current match (only holds a meaningful value after
        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
        `done` is false).
        */
        this.value = { from: 0, to: 0 };
        /**
        Whether the end of the iterated region has been reached.
        */
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return codePointAt(this.buffer, this.bufferPos);
    }
    /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
    next() {
        while (this.matches.length)
            this.matches.pop();
        return this.nextOverlapping();
    }
    /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
    nextOverlapping() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += codePointSize(next);
            let norm = this.normalize(str);
            for (let i = 0, pos = start;; i++) {
                let code = norm.charCodeAt(i);
                let match = this.match(code, pos);
                if (i == norm.length - 1) {
                    if (match) {
                        this.value = match;
                        return this;
                    }
                    break;
                }
                if (pos == start && i < str.length && str.charCodeAt(i) == code)
                    pos++;
            }
        }
    }
    match(code, pos) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: pos + 1 };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: pos + 1 };
            else
                this.matches.push(1, pos);
        }
        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))
            match = null;
        return match;
    }
}
if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function () { return this; };

const empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
/**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/
class RegExpCursor {
    /**
    Create a cursor that will search the given range in the given
    document. `query` should be the raw pattern (as you'd pass it to
    `new RegExp`).
    */
    constructor(text, query, options, from = 0, to = text.length) {
        this.text = text;
        this.to = to;
        this.curLine = "";
        /**
        Set to `true` when the cursor has reached the end of the search
        range.
        */
        this.done = false;
        /**
        Will contain an object with the extent of the match and the
        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
        sucessfully finds a match.
        */
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from);
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        }
        else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
            this.curLine = "";
        else
            this.getLine(0);
    }
    /**
    Move to the next match, if there is one.
    */
    next() {
        for (let off = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                if (from == this.curLineStart + this.curLine.length)
                    this.nextLine();
                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            }
            else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            }
            else {
                this.done = true;
                return this;
            }
        }
    }
}
const flattened = /*@__PURE__*/new WeakMap();
// Reusable (partially) flattened document strings
class FlattenedDoc {
    constructor(from, text) {
        this.from = from;
        this.text = text;
    }
    get to() { return this.from + this.text.length; }
    static get(doc, from, to) {
        let cached = flattened.get(doc);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to)
            return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to)
            text += doc.sliceString(cached.to, to);
        flattened.set(doc, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for (;;) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            // Skip empty matches directly after the last match
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                // If a match goes almost to the end of a noncomplete chunk, try
                // again, since it'll likely be able to match more
                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&
                    (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                    return this;
                }
            }
            if (this.flat.to == this.to) {
                this.done = true;
                return this;
            }
            // Grow the flattened doc
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
    }
}
if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
        function () { return this; };
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    }
    catch (_a) {
        return false;
    }
}
function toCharEnd(text, pos) {
    if (pos >= text.length)
        return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
        pos++;
    return pos;
}

function createLineDialog(view) {
    let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);
    let input = crelt("input", { class: "cm-textfield", name: "line", value: line });
    let dom = crelt("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
            if (event.keyCode == 27) { // Escape
                event.preventDefault();
                view.dispatch({ effects: dialogEffect.of(false) });
                view.focus();
            }
            else if (event.keyCode == 13) { // Enter
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event) => {
            event.preventDefault();
            go();
        }
    }, crelt("label", view.state.phrase("Go to line"), ": ", input), " ", crelt("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
            return;
        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign)
                pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state.doc.lines);
            line = Math.round(state.doc.lines * pc);
        }
        else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
        let selection = dist_EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));
        view.dispatch({
            effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],
            selection,
        });
        view.focus();
    }
    return { dom };
}
const dialogEffect = /*@__PURE__*/StateEffect.define();
const dialogField = /*@__PURE__*/StateField.define({
    create() { return true; },
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(dialogEffect))
                value = e.value;
        return value;
    },
    provide: f => showPanel.from(f, val => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.
*/
const gotoLine = view => {
    let panel = getPanel(view, createLineDialog);
    if (!panel) {
        let effects = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
            effects.push(StateEffect.appendConfig.of([dialogField, search_dist_baseTheme$1]));
        view.dispatch({ effects });
        panel = getPanel(view, createLineDialog);
    }
    if (panel)
        panel.dom.querySelector("input").select();
    return true;
};
const search_dist_baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": { fontSize: "80%" }
    }
});

const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
};
const highlightConfig = /*@__PURE__*/Facet.define({
    combine(options) {
        return combineConfig(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
/**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/
function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
        ext.push(highlightConfig.of(options));
    return ext;
}
const matchDeco = /*@__PURE__*/Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
// Whether the characters directly outside the given positions are non-word characters
function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != dist_CharCategory.Word) &&
        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != dist_CharCategory.Word);
}
// Whether the characters directly at the given positions are word characters
function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == dist_CharCategory.Word
        && check(state.sliceDoc(to - 1, to)) == dist_CharCategory.Word;
}
const matchHighlighter = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state } = view, sel = state.selection;
        if (sel.ranges.length > 1)
            return Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor)
                return Decoration.none;
            let word = state.wordAt(range.head);
            if (!word)
                return Decoration.none;
            check = state.charCategorizer(range.head);
            query = state.sliceDoc(word.from, word.to);
        }
        else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
                return Decoration.none;
            if (conf.wholeWords) {
                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?
                check = state.charCategorizer(range.head);
                if (!(insideWordBoundaries(check, state, range.from, range.to)
                    && insideWord(check, state, range.from, range.to)))
                    return Decoration.none;
            }
            else {
                query = state.sliceDoc(range.from, range.to).trim();
                if (!query)
                    return Decoration.none;
            }
        }
        let deco = [];
        for (let part of view.visibleRanges) {
            let cursor = new SearchCursor(state.doc, query, part.from, part.to);
            while (!cursor.next().done) {
                let { from, to } = cursor.value;
                if (!check || insideWordBoundaries(check, state, from, to)) {
                    if (range.empty && from <= range.from && to >= range.to)
                        deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from)
                        deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches)
                        return Decoration.none;
                }
            }
        }
        return Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
const defaultTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
// Select the words around the cursors.
const selectWord = ({ state, dispatch }) => {
    let { selection } = state;
    let newSel = dist_EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || dist_EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
        return false;
    dispatch(state.update({ selection: newSel }));
    return true;
};
// Find next occurrence of query relative to last cursor. Wrap around
// the document if there are no more matches.
function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
        cursor.next();
        if (cursor.done) {
            if (cycled)
                return null;
            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
        }
        else {
            if (cycled && ranges.some(r => r.from == cursor.value.from))
                continue;
            if (fullWord) {
                let word = state.wordAt(cursor.value.from);
                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                    continue;
            }
            return cursor.value;
        }
    }
}
/**
Select next occurrence of the current selection. Expand selection
to the surrounding word when the selection is empty.
*/
const selectNextOccurrence = ({ state, dispatch }) => {
    let { ranges } = state.selection;
    if (ranges.some(sel => sel.from === sel.to))
        return selectWord({ state, dispatch });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))
        return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
        return false;
    dispatch(state.update({
        selection: state.selection.addRange(dist_EditorSelection.range(range.from, range.to), false),
        effects: EditorView.scrollIntoView(range.to)
    }));
    return true;
};

const searchConfigFacet = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            top: false,
            caseSensitive: false,
            literal: false,
            regexp: false,
            wholeWord: false,
            createPanel: view => new SearchPanel(view),
            scrollToMatch: range => EditorView.scrollIntoView(range)
        });
    }
});
/**
Add search state to the editor configuration, and optionally
configure the search extension.
([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically
enable this if it isn't already on).
*/
function search(config) {
    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
}
/**
A search query. Part of the editor's search state.
*/
class SearchQuery {
    /**
    Create a query object.
    */
    constructor(config) {
        this.search = config.search;
        this.caseSensitive = !!config.caseSensitive;
        this.literal = !!config.literal;
        this.regexp = !!config.regexp;
        this.replace = config.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config.wholeWord;
    }
    /**
    @internal
    */
    unquote(text) {
        return this.literal ? text :
            text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
    }
    /**
    Compare this query to another query.
    */
    eq(other) {
        return this.search == other.search && this.replace == other.replace &&
            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&
            this.wholeWord == other.wholeWord;
    }
    /**
    @internal
    */
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    /**
    Get a search cursor for this query, searching through the given
    range in the given state.
    */
    getCursor(state, from = 0, to) {
        let st = state.doc ? state : EditorState.create({ doc: state });
        if (to == null)
            to = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
}
class dist_QueryType {
    constructor(spec) {
        this.spec = spec;
    }
}
function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
}
function stringWordTest(doc, categorizer) {
    return (from, to, buf, bufPos) => {
        if (bufPos > from || bufPos + buf.length < to) {
            bufPos = Math.max(0, from - 2);
            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
        }
        return (categorizer(charBefore(buf, from - bufPos)) != dist_CharCategory.Word ||
            categorizer(charAfter(buf, from - bufPos)) != dist_CharCategory.Word) &&
            (categorizer(charAfter(buf, to - bufPos)) != dist_CharCategory.Word ||
                categorizer(charBefore(buf, to - bufPos)) != dist_CharCategory.Word);
    };
}
class StringQuery extends dist_QueryType {
    constructor(spec) {
        super(spec);
    }
    nextMatch(state, curFrom, curTo) {
        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor.done)
            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
        return cursor.done ? null : cursor.value;
    }
    // Searching in reverse is, rather than implementing an inverted search
    // cursor, done by scanning chunk after chunk forward.
    prevMatchInRange(state, from, to) {
        for (let pos = to;;) {
            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, state, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
                range = cursor.value;
            if (range)
                return range;
            if (start == from)
                return null;
            pos -= 10000 /* FindPrev.ChunkSize */;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }
    matchAll(state, limit) {
        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
        ignoreCase: !spec.caseSensitive,
        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
    }, from, to);
}
function charBefore(str, index) {
    return str.slice(findClusterBreak(str, index, false), index);
}
function charAfter(str, index) {
    return str.slice(index, findClusterBreak(str, index));
}
function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length ||
        (categorizer(charBefore(match.input, match.index)) != dist_CharCategory.Word ||
            categorizer(charAfter(match.input, match.index)) != dist_CharCategory.Word) &&
            (categorizer(charAfter(match.input, match.index + match[0].length)) != dist_CharCategory.Word ||
                categorizer(charBefore(match.input, match.index + match[0].length)) != dist_CharCategory.Word);
}
class RegExpQuery extends dist_QueryType {
    nextMatch(state, curFrom, curTo) {
        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor.done)
            cursor = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
        for (let size = 1;; size++) {
            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);
            let cursor = regexpCursor(this.spec, state, start, to), range = null;
            while (!cursor.next().done)
                range = cursor.value;
            if (range && (start == from || range.from > start + 10))
                return range;
            if (start == from)
                return null;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
        return this.spec.unquote(this.spec.replace).replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$"
            : i == "&" ? result.match[0]
                : i != "0" && +i < result.match.length ? result.match[i]
                    : m);
    }
    matchAll(state, limit) {
        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
/**
A state effect that updates the current search query. Note that
this only has an effect if the search state has been initialized
(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
once).
*/
const setSearchQuery = /*@__PURE__*/StateEffect.define();
const togglePanel = /*@__PURE__*/StateEffect.define();
const searchState = /*@__PURE__*/StateField.define({
    create(state) {
        return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setSearchQuery))
                value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
                value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: f => showPanel.from(f, val => val.panel)
});
/**
Get the current search query from an editor state.
*/
function getSearchQuery(state) {
    let curState = state.field(searchState, false);
    return curState ? curState.query.spec : defaultQuery(state);
}
/**
Query whether the search panel is open in the given editor state.
*/
function searchPanelOpen(state) {
    var _a;
    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;
}
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = /*@__PURE__*/Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
            return Decoration.none;
        let { view } = this;
        let builder = new RangeSetBuilder();
        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)
                to = ranges[++i].to;
            query.highlight(view.state, from, to, (from, to) => {
                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: v => v.decorations
});
function searchCommand(f) {
    return view => {
        let state = view.state.field(searchState, false);
        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
const findNext = /*@__PURE__*/searchCommand((view, { query }) => {
    let { to } = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
        return false;
    let selection = dist_EditorSelection.single(next.from, next.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
const findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {
    let { state } = view, { from } = state.selection.main;
    let prev = query.prevMatch(state, from, from);
    if (!prev)
        return false;
    let selection = dist_EditorSelection.single(prev.from, prev.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],
        userEvent: "select.search"
    });
    selectSearchInput(view);
    return true;
});
/**
Select all instances of the search query.
*/
const selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1000);
    if (!ranges || !ranges.length)
        return false;
    view.dispatch({
        selection: dist_EditorSelection.create(ranges.map(r => dist_EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
    });
    return true;
});
/**
Select all instances of the currently selected text.
*/
const selectSelectionMatches = ({ state, dispatch }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
        return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
        if (ranges.length > 1000)
            return false;
        if (cur.value.from == from)
            main = ranges.length;
        ranges.push(dist_EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state.update({
        selection: dist_EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
    }));
    return true;
};
/**
Replace the current match of the search query.
*/
const replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    if (state.readOnly)
        return false;
    let next = query.nextMatch(state, from, from);
    if (!next)
        return false;
    let changes = [], selection, replacement;
    let effects = [];
    if (next.from == from && next.to == to) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state, next.from, next.to);
        effects.push(EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    if (next) {
        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
        selection = dist_EditorSelection.single(next.from - off, next.to - off);
        effects.push(announceMatch(view, next));
        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));
    }
    view.dispatch({
        changes, selection, effects,
        userEvent: "input.replace"
    });
    return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/
const replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {
    if (view.state.readOnly)
        return false;
    let changes = query.matchAll(view.state, 1e9).map(match => {
        let { from, to } = match;
        return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
        return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
        changes,
        effects: EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
    });
    return true;
});
function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
    var _a, _b, _c, _d, _e;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
        return fallback;
    let config = state.facet(searchConfigFacet);
    return new SearchQuery({
        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,
        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord
    });
}
function getSearchInput(view) {
    let panel = getPanel(view, createSearchPanel);
    return panel && panel.dom.querySelector("[main-field]");
}
function selectSearchInput(view) {
    let input = getSearchInput(view);
    if (input && input == view.root.activeElement)
        input.select();
}
/**
Make sure the search panel is open and focused.
*/
const openSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
        let searchInput = getSearchInput(view);
        if (searchInput && searchInput != view.root.activeElement) {
            let query = defaultQuery(view.state, state.query.spec);
            if (query.valid)
                view.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
        }
    }
    else {
        view.dispatch({ effects: [
                togglePanel.of(true),
                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)
            ] });
    }
    return true;
};
/**
Close the search panel.
*/
const closeSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
        return false;
    let panel = getPanel(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
        view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
 - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/
const searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Mod-Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true },
];
class SearchPanel {
    constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = crelt("input", {
            value: query.search,
            placeholder: phrase(view, "Find"),
            "aria-label": phrase(view, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.replaceField = crelt("input", {
            value: query.replace,
            placeholder: phrase(view, "Replace"),
            "aria-label": phrase(view, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.caseField = crelt("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: query.caseSensitive,
            onchange: this.commit
        });
        this.reField = crelt("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: query.regexp,
            onchange: this.commit
        });
        this.wordField = crelt("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: query.wholeWord,
            onchange: this.commit
        });
        function button(name, onclick, content) {
            return crelt("button", { class: "cm-button", name, onclick, type: "button" }, content);
        }
        this.dom = crelt("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view), [phrase(view, "next")]),
            button("prev", () => findPrevious(view), [phrase(view, "previous")]),
            button("select", () => selectMatches(view), [phrase(view, "all")]),
            crelt("label", null, [this.caseField, phrase(view, "match case")]),
            crelt("label", null, [this.reField, phrase(view, "regexp")]),
            crelt("label", null, [this.wordField, phrase(view, "by word")]),
            ...view.state.readOnly ? [] : [
                crelt("br"),
                this.replaceField,
                button("replace", () => replaceNext(view), [phrase(view, "replace")]),
                button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
            ],
            crelt("button", {
                name: "close",
                onclick: () => closeSearchPanel(view),
                "aria-label": phrase(view, "close"),
                type: "button"
            }, ["×"])
        ]);
    }
    commit() {
        let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value,
        });
        if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
    }
    keydown(e) {
        if (runScopeHandlers(this.view, e, "search-panel")) {
            e.preventDefault();
        }
        else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
        }
        else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
        }
    }
    update(update) {
        for (let tr of update.transactions)
            for (let effect of tr.effects) {
                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                    this.setQuery(effect.value);
            }
    }
    setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
    }
    mount() {
        this.searchField.select();
    }
    get pos() { return 80; }
    get top() { return this.view.state.facet(searchConfigFacet).top; }
}
function phrase(view, phrase) { return view.state.phrase(phrase); }
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                text = text.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                text = text.slice(0, i);
                break;
            }
    }
    return EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
const search_dist_baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
    searchState,
    /*@__PURE__*/Prec.low(searchHighlighter),
    search_dist_baseTheme
];



;// CONCATENATED MODULE: ./node_modules/@codemirror/autocomplete/dist/index.js




/**
An instance of this is passed to completion source functions.
*/
class CompletionContext {
    /**
    Create a new completion context. (Mostly useful for testing
    completion sources—in the editor, the extension will create
    these for you.)
    */
    constructor(
    /**
    The editor state that the completion happens in.
    */
    state, 
    /**
    The position at which the completion is happening.
    */
    pos, 
    /**
    Indicates whether completion was activated explicitly, or
    implicitly by typing. The usual way to respond to this is to
    only return completions when either there is part of a
    completable entity before the cursor, or `explicit` is true.
    */
    explicit) {
        this.state = state;
        this.pos = pos;
        this.explicit = explicit;
        /**
        @internal
        */
        this.abortListeners = [];
    }
    /**
    Get the extent, content, and (if there is a token) type of the
    token before `this.pos`.
    */
    tokenBefore(types) {
        let token = dist_syntaxTree(this.state).resolveInner(this.pos, -1);
        while (token && types.indexOf(token.name) < 0)
            token = token.parent;
        return token ? { from: token.from, to: this.pos,
            text: this.state.sliceDoc(token.from, this.pos),
            type: token.type } : null;
    }
    /**
    Get the match of the given expression directly before the
    cursor.
    */
    matchBefore(expr) {
        let line = this.state.doc.lineAt(this.pos);
        let start = Math.max(line.from, this.pos - 250);
        let str = line.text.slice(start - line.from, this.pos - line.from);
        let found = str.search(ensureAnchor(expr, false));
        return found < 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };
    }
    /**
    Yields true when the query has been aborted. Can be useful in
    asynchronous queries to avoid doing work that will be ignored.
    */
    get aborted() { return this.abortListeners == null; }
    /**
    Allows you to register abort handlers, which will be called when
    the query is
    [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
    */
    addEventListener(type, listener) {
        if (type == "abort" && this.abortListeners)
            this.abortListeners.push(listener);
    }
}
function toSet(chars) {
    let flat = Object.keys(chars).join("");
    let words = /\w/.test(flat);
    if (words)
        flat = flat.replace(/\w/g, "");
    return `[${words ? "\\w" : ""}${flat.replace(/[^\w\s]/g, "\\$&")}]`;
}
function prefixMatch(options) {
    let first = Object.create(null), rest = Object.create(null);
    for (let { label } of options) {
        first[label[0]] = true;
        for (let i = 1; i < label.length; i++)
            rest[label[i]] = true;
    }
    let source = toSet(first) + toSet(rest) + "*$";
    return [new RegExp("^" + source), new RegExp(source)];
}
/**
Given a a fixed array of options, return an autocompleter that
completes them.
*/
function completeFromList(list) {
    let options = list.map(o => typeof o == "string" ? { label: o } : o);
    let [validFor, match] = options.every(o => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : prefixMatch(options);
    return (context) => {
        let token = context.matchBefore(match);
        return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;
    };
}
/**
Wrap the given completion source so that it will only fire when the
cursor is in a syntax node with one of the given names.
*/
function ifIn(nodes, source) {
    return (context) => {
        for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return source(context);
            if (pos.type.isTop)
                break;
        }
        return null;
    };
}
/**
Wrap the given completion source so that it will not fire when the
cursor is in a syntax node with one of the given names.
*/
function ifNotIn(nodes, source) {
    return (context) => {
        for (let pos = dist_syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {
            if (nodes.indexOf(pos.name) > -1)
                return null;
            if (pos.type.isTop)
                break;
        }
        return source(context);
    };
}
class Option {
    constructor(completion, source, match, score) {
        this.completion = completion;
        this.source = source;
        this.match = match;
        this.score = score;
    }
}
function cur(state) { return state.selection.main.from; }
// Make sure the given regexp has a $ at its end and, if `start` is
// true, a ^ at its start.
function ensureAnchor(expr, start) {
    var _a;
    let { source } = expr;
    let addStart = start && source[0] != "^", addEnd = source[source.length - 1] != "$";
    if (!addStart && !addEnd)
        return expr;
    return new RegExp(`${addStart ? "^" : ""}(?:${source})${addEnd ? "$" : ""}`, (_a = expr.flags) !== null && _a !== void 0 ? _a : (expr.ignoreCase ? "i" : ""));
}
/**
This annotation is added to transactions that are produced by
picking a completion.
*/
const pickedCompletion = /*@__PURE__*/Annotation.define();
/**
Helper function that returns a transaction spec which inserts a
completion's text in the main selection range, and any other
selection range that has the same text in front of it.
*/
function insertCompletionText(state, text, from, to) {
    let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;
    return Object.assign(Object.assign({}, state.changeByRange(range => {
        if (range != main && from != to &&
            state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))
            return { range };
        return {
            changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: text },
            range: dist_EditorSelection.cursor(range.from + fromOff + text.length)
        };
    })), { scrollIntoView: true, userEvent: "input.complete" });
}
const SourceCache = /*@__PURE__*/new WeakMap();
function asSource(source) {
    if (!Array.isArray(source))
        return source;
    let known = SourceCache.get(source);
    if (!known)
        SourceCache.set(source, known = completeFromList(source));
    return known;
}
const startCompletionEffect = /*@__PURE__*/StateEffect.define();
const closeCompletionEffect = /*@__PURE__*/StateEffect.define();

// A pattern matcher for fuzzy completion matching. Create an instance
// once for a pattern, and then use that to match any number of
// completions.
class FuzzyMatcher {
    constructor(pattern) {
        this.pattern = pattern;
        this.chars = [];
        this.folded = [];
        // Buffers reused by calls to `match` to track matched character
        // positions.
        this.any = [];
        this.precise = [];
        this.byWord = [];
        this.score = 0;
        this.matched = [];
        for (let p = 0; p < pattern.length;) {
            let char = codePointAt(pattern, p), size = codePointSize(char);
            this.chars.push(char);
            let part = pattern.slice(p, p + size), upper = part.toUpperCase();
            this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));
            p += size;
        }
        this.astral = pattern.length != this.chars.length;
    }
    ret(score, matched) {
        this.score = score;
        this.matched = matched;
        return true;
    }
    // Matches a given word (completion) against the pattern (input).
    // Will return a boolean indicating whether there was a match and,
    // on success, set `this.score` to the score, `this.matched` to an
    // array of `from, to` pairs indicating the matched parts of `word`.
    //
    // The score is a number that is more negative the worse the match
    // is. See `Penalty` above.
    match(word) {
        if (this.pattern.length == 0)
            return this.ret(-100 /* Penalty.NotFull */, []);
        if (word.length < this.pattern.length)
            return false;
        let { chars, folded, any, precise, byWord } = this;
        // For single-character queries, only match when they occur right
        // at the start
        if (chars.length == 1) {
            let first = codePointAt(word, 0), firstSize = codePointSize(first);
            let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */;
            if (first == chars[0]) ;
            else if (first == folded[0])
                score += -200 /* Penalty.CaseFold */;
            else
                return false;
            return this.ret(score, [0, firstSize]);
        }
        let direct = word.indexOf(this.pattern);
        if (direct == 0)
            return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */, [0, this.pattern.length]);
        let len = chars.length, anyTo = 0;
        if (direct < 0) {
            for (let i = 0, e = Math.min(word.length, 200); i < e && anyTo < len;) {
                let next = codePointAt(word, i);
                if (next == chars[anyTo] || next == folded[anyTo])
                    any[anyTo++] = i;
                i += codePointSize(next);
            }
            // No match, exit immediately
            if (anyTo < len)
                return false;
        }
        // This tracks the extent of the precise (non-folded, not
        // necessarily adjacent) match
        let preciseTo = 0;
        // Tracks whether there is a match that hits only characters that
        // appear to be starting words. `byWordFolded` is set to true when
        // a case folded character is encountered in such a match
        let byWordTo = 0, byWordFolded = false;
        // If we've found a partial adjacent match, these track its state
        let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;
        let hasLower = /[a-z]/.test(word), wordAdjacent = true;
        // Go over the option's text, scanning for the various kinds of matches
        for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i < e && byWordTo < len;) {
            let next = codePointAt(word, i);
            if (direct < 0) {
                if (preciseTo < len && next == chars[preciseTo])
                    precise[preciseTo++] = i;
                if (adjacentTo < len) {
                    if (next == chars[adjacentTo] || next == folded[adjacentTo]) {
                        if (adjacentTo == 0)
                            adjacentStart = i;
                        adjacentEnd = i + 1;
                        adjacentTo++;
                    }
                    else {
                        adjacentTo = 0;
                    }
                }
            }
            let ch, type = next < 0xff
                ? (next >= 48 && next <= 57 || next >= 97 && next <= 122 ? 2 /* Tp.Lower */ : next >= 65 && next <= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */)
                : ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */);
            if (!i || type == 1 /* Tp.Upper */ && hasLower || prevType == 0 /* Tp.NonWord */ && type != 0 /* Tp.NonWord */) {
                if (chars[byWordTo] == next || (folded[byWordTo] == next && (byWordFolded = true)))
                    byWord[byWordTo++] = i;
                else if (byWord.length)
                    wordAdjacent = false;
            }
            prevType = type;
            i += codePointSize(next);
        }
        if (byWordTo == len && byWord[0] == 0 && wordAdjacent)
            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);
        if (adjacentTo == len && adjacentStart == 0)
            return this.ret(-200 /* Penalty.CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */), [0, adjacentEnd]);
        if (direct > -1)
            return this.ret(-700 /* Penalty.NotStart */ - word.length, [direct, direct + this.pattern.length]);
        if (adjacentTo == len)
            return this.ret(-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, [adjacentStart, adjacentEnd]);
        if (byWordTo == len)
            return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ +
                (wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);
        return chars.length == 2 ? false
            : this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);
    }
    result(score, positions, word) {
        let result = [], i = 0;
        for (let pos of positions) {
            let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);
            if (i && result[i - 1] == pos)
                result[i - 1] = to;
            else {
                result[i++] = pos;
                result[i++] = to;
            }
        }
        return this.ret(score - word.length, result);
    }
}

const completionConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            activateOnTyping: true,
            selectOnOpen: true,
            override: null,
            closeOnBlur: true,
            maxRenderedOptions: 100,
            defaultKeymap: true,
            tooltipClass: () => "",
            optionClass: () => "",
            aboveCursor: false,
            icons: true,
            addToOptions: [],
            positionInfo: defaultPositionInfo,
            compareCompletions: (a, b) => a.label.localeCompare(b.label),
            interactionDelay: 75,
            updateSyncTime: 100
        }, {
            defaultKeymap: (a, b) => a && b,
            closeOnBlur: (a, b) => a && b,
            icons: (a, b) => a && b,
            tooltipClass: (a, b) => c => joinClass(a(c), b(c)),
            optionClass: (a, b) => c => joinClass(a(c), b(c)),
            addToOptions: (a, b) => a.concat(b)
        });
    }
});
function joinClass(a, b) {
    return a ? b ? a + " " + b : a : b;
}
function defaultPositionInfo(view, list, option, info, space, tooltip) {
    let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;
    let side = "top", offset, maxWidth;
    let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;
    let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;
    if (left && spaceLeft < Math.min(infoWidth, spaceRight))
        left = false;
    else if (!left && spaceRight < Math.min(infoWidth, spaceLeft))
        left = true;
    if (infoWidth <= (left ? spaceLeft : spaceRight)) {
        offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;
        maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight);
    }
    else {
        narrow = true;
        maxWidth = Math.min(400 /* Info.Width */, (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */);
        let spaceBelow = space.bottom - list.bottom;
        if (spaceBelow >= infoHeight || spaceBelow > list.top) { // Below the completion
            offset = option.bottom - list.top;
        }
        else { // Above it
            side = "bottom";
            offset = list.bottom - option.top;
        }
    }
    let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;
    let scaleX = (list.right - list.left) / tooltip.offsetWidth;
    return {
        style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,
        class: "cm-completionInfo-" + (narrow ? (rtl ? "left-narrow" : "right-narrow") : left ? "left" : "right")
    };
}

function optionContent(config) {
    let content = config.addToOptions.slice();
    if (config.icons)
        content.push({
            render(completion) {
                let icon = document.createElement("div");
                icon.classList.add("cm-completionIcon");
                if (completion.type)
                    icon.classList.add(...completion.type.split(/\s+/g).map(cls => "cm-completionIcon-" + cls));
                icon.setAttribute("aria-hidden", "true");
                return icon;
            },
            position: 20
        });
    content.push({
        render(completion, _s, _v, match) {
            let labelElt = document.createElement("span");
            labelElt.className = "cm-completionLabel";
            let label = completion.displayLabel || completion.label, off = 0;
            for (let j = 0; j < match.length;) {
                let from = match[j++], to = match[j++];
                if (from > off)
                    labelElt.appendChild(document.createTextNode(label.slice(off, from)));
                let span = labelElt.appendChild(document.createElement("span"));
                span.appendChild(document.createTextNode(label.slice(from, to)));
                span.className = "cm-completionMatchedText";
                off = to;
            }
            if (off < label.length)
                labelElt.appendChild(document.createTextNode(label.slice(off)));
            return labelElt;
        },
        position: 50
    }, {
        render(completion) {
            if (!completion.detail)
                return null;
            let detailElt = document.createElement("span");
            detailElt.className = "cm-completionDetail";
            detailElt.textContent = completion.detail;
            return detailElt;
        },
        position: 80
    });
    return content.sort((a, b) => a.position - b.position).map(a => a.render);
}
function rangeAroundSelected(total, selected, max) {
    if (total <= max)
        return { from: 0, to: total };
    if (selected < 0)
        selected = 0;
    if (selected <= (total >> 1)) {
        let off = Math.floor(selected / max);
        return { from: off * max, to: (off + 1) * max };
    }
    let off = Math.floor((total - selected) / max);
    return { from: total - (off + 1) * max, to: total - off * max };
}
class CompletionTooltip {
    constructor(view, stateField, applyCompletion) {
        this.view = view;
        this.stateField = stateField;
        this.applyCompletion = applyCompletion;
        this.info = null;
        this.infoDestroy = null;
        this.placeInfoReq = {
            read: () => this.measureInfo(),
            write: (pos) => this.placeInfo(pos),
            key: this
        };
        this.space = null;
        this.currentClass = "";
        let cState = view.state.field(stateField);
        let { options, selected } = cState.open;
        let config = view.state.facet(completionConfig);
        this.optionContent = optionContent(config);
        this.optionClass = config.optionClass;
        this.tooltipClass = config.tooltipClass;
        this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);
        this.dom = document.createElement("div");
        this.dom.className = "cm-tooltip-autocomplete";
        this.updateTooltipClass(view.state);
        this.dom.addEventListener("mousedown", (e) => {
            let { options } = view.state.field(stateField).open;
            for (let dom = e.target, match; dom && dom != this.dom; dom = dom.parentNode) {
                if (dom.nodeName == "LI" && (match = /-(\d+)$/.exec(dom.id)) && +match[1] < options.length) {
                    this.applyCompletion(view, options[+match[1]]);
                    e.preventDefault();
                    return;
                }
            }
        });
        this.dom.addEventListener("focusout", (e) => {
            let state = view.state.field(this.stateField, false);
            if (state && state.tooltip && view.state.facet(completionConfig).closeOnBlur &&
                e.relatedTarget != view.contentDOM)
                view.dispatch({ effects: closeCompletionEffect.of(null) });
        });
        this.showOptions(options, cState.id);
    }
    mount() { this.updateSel(); }
    showOptions(options, id) {
        if (this.list)
            this.list.remove();
        this.list = this.dom.appendChild(this.createListBox(options, id, this.range));
        this.list.addEventListener("scroll", () => {
            if (this.info)
                this.view.requestMeasure(this.placeInfoReq);
        });
    }
    update(update) {
        var _a;
        let cState = update.state.field(this.stateField);
        let prevState = update.startState.field(this.stateField);
        this.updateTooltipClass(update.state);
        if (cState != prevState) {
            let { options, selected, disabled } = cState.open;
            if (!prevState.open || prevState.open.options != options) {
                this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);
                this.showOptions(options, cState.id);
            }
            this.updateSel();
            if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))
                this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!disabled);
        }
    }
    updateTooltipClass(state) {
        let cls = this.tooltipClass(state);
        if (cls != this.currentClass) {
            for (let c of this.currentClass.split(" "))
                if (c)
                    this.dom.classList.remove(c);
            for (let c of cls.split(" "))
                if (c)
                    this.dom.classList.add(c);
            this.currentClass = cls;
        }
    }
    positioned(space) {
        this.space = space;
        if (this.info)
            this.view.requestMeasure(this.placeInfoReq);
    }
    updateSel() {
        let cState = this.view.state.field(this.stateField), open = cState.open;
        if (open.selected > -1 && open.selected < this.range.from || open.selected >= this.range.to) {
            this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);
            this.showOptions(open.options, cState.id);
        }
        if (this.updateSelectedOption(open.selected)) {
            this.destroyInfo();
            let { completion } = open.options[open.selected];
            let { info } = completion;
            if (!info)
                return;
            let infoResult = typeof info === "string" ? document.createTextNode(info) : info(completion);
            if (!infoResult)
                return;
            if ("then" in infoResult) {
                infoResult.then(obj => {
                    if (obj && this.view.state.field(this.stateField, false) == cState)
                        this.addInfoPane(obj, completion);
                }).catch(e => dist_logException(this.view.state, e, "completion info"));
            }
            else {
                this.addInfoPane(infoResult, completion);
            }
        }
    }
    addInfoPane(content, completion) {
        this.destroyInfo();
        let wrap = this.info = document.createElement("div");
        wrap.className = "cm-tooltip cm-completionInfo";
        if (content.nodeType != null) {
            wrap.appendChild(content);
            this.infoDestroy = null;
        }
        else {
            let { dom, destroy } = content;
            wrap.appendChild(dom);
            this.infoDestroy = destroy || null;
        }
        this.dom.appendChild(wrap);
        this.view.requestMeasure(this.placeInfoReq);
    }
    updateSelectedOption(selected) {
        let set = null;
        for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {
            if (opt.nodeName != "LI" || !opt.id) {
                i--; // A section header
            }
            else if (i == selected) {
                if (!opt.hasAttribute("aria-selected")) {
                    opt.setAttribute("aria-selected", "true");
                    set = opt;
                }
            }
            else {
                if (opt.hasAttribute("aria-selected"))
                    opt.removeAttribute("aria-selected");
            }
        }
        if (set)
            dist_scrollIntoView(this.list, set);
        return set;
    }
    measureInfo() {
        let sel = this.dom.querySelector("[aria-selected]");
        if (!sel || !this.info)
            return null;
        let listRect = this.dom.getBoundingClientRect();
        let infoRect = this.info.getBoundingClientRect();
        let selRect = sel.getBoundingClientRect();
        let space = this.space;
        if (!space) {
            let win = this.dom.ownerDocument.defaultView || window;
            space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };
        }
        if (selRect.top > Math.min(space.bottom, listRect.bottom) - 10 ||
            selRect.bottom < Math.max(space.top, listRect.top) + 10)
            return null;
        return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);
    }
    placeInfo(pos) {
        if (this.info) {
            if (pos) {
                if (pos.style)
                    this.info.style.cssText = pos.style;
                this.info.className = "cm-tooltip cm-completionInfo " + (pos.class || "");
            }
            else {
                this.info.style.cssText = "top: -1e6px";
            }
        }
    }
    createListBox(options, id, range) {
        const ul = document.createElement("ul");
        ul.id = id;
        ul.setAttribute("role", "listbox");
        ul.setAttribute("aria-expanded", "true");
        ul.setAttribute("aria-label", this.view.state.phrase("Completions"));
        let curSection = null;
        for (let i = range.from; i < range.to; i++) {
            let { completion, match } = options[i], { section } = completion;
            if (section) {
                let name = typeof section == "string" ? section : section.name;
                if (name != curSection && (i > range.from || range.from == 0)) {
                    curSection = name;
                    if (typeof section != "string" && section.header) {
                        ul.appendChild(section.header(section));
                    }
                    else {
                        let header = ul.appendChild(document.createElement("completion-section"));
                        header.textContent = name;
                    }
                }
            }
            const li = ul.appendChild(document.createElement("li"));
            li.id = id + "-" + i;
            li.setAttribute("role", "option");
            let cls = this.optionClass(completion);
            if (cls)
                li.className = cls;
            for (let source of this.optionContent) {
                let node = source(completion, this.view.state, this.view, match);
                if (node)
                    li.appendChild(node);
            }
        }
        if (range.from)
            ul.classList.add("cm-completionListIncompleteTop");
        if (range.to < options.length)
            ul.classList.add("cm-completionListIncompleteBottom");
        return ul;
    }
    destroyInfo() {
        if (this.info) {
            if (this.infoDestroy)
                this.infoDestroy();
            this.info.remove();
            this.info = null;
        }
    }
    destroy() {
        this.destroyInfo();
    }
}
function completionTooltip(stateField, applyCompletion) {
    return (view) => new CompletionTooltip(view, stateField, applyCompletion);
}
function dist_scrollIntoView(container, element) {
    let parent = container.getBoundingClientRect();
    let self = element.getBoundingClientRect();
    let scaleY = parent.height / container.offsetHeight;
    if (self.top < parent.top)
        container.scrollTop -= (parent.top - self.top) / scaleY;
    else if (self.bottom > parent.bottom)
        container.scrollTop += (self.bottom - parent.bottom) / scaleY;
}

// Used to pick a preferred option when two options with the same
// label occur in the result.
function score(option) {
    return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +
        (option.type ? 1 : 0);
}
function sortOptions(active, state) {
    let options = [];
    let sections = null;
    let addOption = (option) => {
        options.push(option);
        let { section } = option.completion;
        if (section) {
            if (!sections)
                sections = [];
            let name = typeof section == "string" ? section : section.name;
            if (!sections.some(s => s.name == name))
                sections.push(typeof section == "string" ? { name } : section);
        }
    };
    for (let a of active)
        if (a.hasResult()) {
            let getMatch = a.result.getMatch;
            if (a.result.filter === false) {
                for (let option of a.result.options) {
                    addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));
                }
            }
            else {
                let matcher = new FuzzyMatcher(state.sliceDoc(a.from, a.to));
                for (let option of a.result.options)
                    if (matcher.match(option.label)) {
                        let matched = !option.displayLabel ? matcher.matched : getMatch ? getMatch(option, matcher.matched) : [];
                        addOption(new Option(option, a.source, matched, matcher.score + (option.boost || 0)));
                    }
            }
        }
    if (sections) {
        let sectionOrder = Object.create(null), pos = 0;
        let cmp = (a, b) => { var _a, _b; return ((_a = a.rank) !== null && _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null && _b !== void 0 ? _b : 1e9) || (a.name < b.name ? -1 : 1); };
        for (let s of sections.sort(cmp)) {
            pos -= 1e5;
            sectionOrder[s.name] = pos;
        }
        for (let option of options) {
            let { section } = option.completion;
            if (section)
                option.score += sectionOrder[typeof section == "string" ? section : section.name];
        }
    }
    let result = [], prev = null;
    let compare = state.facet(completionConfig).compareCompletions;
    for (let opt of options.sort((a, b) => (b.score - a.score) || compare(a.completion, b.completion))) {
        let cur = opt.completion;
        if (!prev || prev.label != cur.label || prev.detail != cur.detail ||
            (prev.type != null && cur.type != null && prev.type != cur.type) ||
            prev.apply != cur.apply || prev.boost != cur.boost)
            result.push(opt);
        else if (score(opt.completion) > score(prev))
            result[result.length - 1] = opt;
        prev = opt.completion;
    }
    return result;
}
class CompletionDialog {
    constructor(options, attrs, tooltip, timestamp, selected, disabled) {
        this.options = options;
        this.attrs = attrs;
        this.tooltip = tooltip;
        this.timestamp = timestamp;
        this.selected = selected;
        this.disabled = disabled;
    }
    setSelected(selected, id) {
        return selected == this.selected || selected >= this.options.length ? this
            : new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);
    }
    static build(active, state, id, prev, conf) {
        let options = sortOptions(active, state);
        if (!options.length) {
            return prev && active.some(a => a.state == 1 /* State.Pending */) ?
                new CompletionDialog(prev.options, prev.attrs, prev.tooltip, prev.timestamp, prev.selected, true) : null;
        }
        let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;
        if (prev && prev.selected != selected && prev.selected != -1) {
            let selectedValue = prev.options[prev.selected].completion;
            for (let i = 0; i < options.length; i++)
                if (options[i].completion == selectedValue) {
                    selected = i;
                    break;
                }
        }
        return new CompletionDialog(options, makeAttrs(id, selected), {
            pos: active.reduce((a, b) => b.hasResult() ? Math.min(a, b.from) : a, 1e8),
            create: createTooltip,
            above: conf.aboveCursor,
        }, prev ? prev.timestamp : Date.now(), selected, false);
    }
    map(changes) {
        return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
    }
}
class CompletionState {
    constructor(active, id, open) {
        this.active = active;
        this.id = id;
        this.open = open;
    }
    static start() {
        return new CompletionState(autocomplete_dist_none, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
    }
    update(tr) {
        let { state } = tr, conf = state.facet(completionConfig);
        let sources = conf.override ||
            state.languageDataAt("autocomplete", cur(state)).map(asSource);
        let active = sources.map(source => {
            let value = this.active.find(s => s.source == source) ||
                new ActiveSource(source, this.active.some(a => a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);
            return value.update(tr, conf);
        });
        if (active.length == this.active.length && active.every((a, i) => a == this.active[i]))
            active = this.active;
        let open = this.open;
        if (open && tr.docChanged)
            open = open.map(tr.changes);
        if (tr.selection || active.some(a => a.hasResult() && tr.changes.touchesRange(a.from, a.to)) ||
            !sameResults(active, this.active))
            open = CompletionDialog.build(active, state, this.id, open, conf);
        else if (open && open.disabled && !active.some(a => a.state == 1 /* State.Pending */))
            open = null;
        if (!open && active.every(a => a.state != 1 /* State.Pending */) && active.some(a => a.hasResult()))
            active = active.map(a => a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);
        for (let effect of tr.effects)
            if (effect.is(setSelectedEffect))
                open = open && open.setSelected(effect.value, this.id);
        return active == this.active && open == this.open ? this : new CompletionState(active, this.id, open);
    }
    get tooltip() { return this.open ? this.open.tooltip : null; }
    get attrs() { return this.open ? this.open.attrs : baseAttrs; }
}
function sameResults(a, b) {
    if (a == b)
        return true;
    for (let iA = 0, iB = 0;;) {
        while (iA < a.length && !a[iA].hasResult)
            iA++;
        while (iB < b.length && !b[iB].hasResult)
            iB++;
        let endA = iA == a.length, endB = iB == b.length;
        if (endA || endB)
            return endA == endB;
        if (a[iA++].result != b[iB++].result)
            return false;
    }
}
const baseAttrs = {
    "aria-autocomplete": "list"
};
function makeAttrs(id, selected) {
    let result = {
        "aria-autocomplete": "list",
        "aria-haspopup": "listbox",
        "aria-controls": id
    };
    if (selected > -1)
        result["aria-activedescendant"] = id + "-" + selected;
    return result;
}
const autocomplete_dist_none = [];
function getUserEvent(tr) {
    return tr.isUserEvent("input.type") ? "input" : tr.isUserEvent("delete.backward") ? "delete" : null;
}
class ActiveSource {
    constructor(source, state, explicitPos = -1) {
        this.source = source;
        this.state = state;
        this.explicitPos = explicitPos;
    }
    hasResult() { return false; }
    update(tr, conf) {
        let event = getUserEvent(tr), value = this;
        if (event)
            value = value.handleUserEvent(tr, event, conf);
        else if (tr.docChanged)
            value = value.handleChange(tr);
        else if (tr.selection && value.state != 0 /* State.Inactive */)
            value = new ActiveSource(value.source, 0 /* State.Inactive */);
        for (let effect of tr.effects) {
            if (effect.is(startCompletionEffect))
                value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value ? cur(tr.state) : -1);
            else if (effect.is(closeCompletionEffect))
                value = new ActiveSource(value.source, 0 /* State.Inactive */);
            else if (effect.is(setActiveEffect))
                for (let active of effect.value)
                    if (active.source == value.source)
                        value = active;
        }
        return value;
    }
    handleUserEvent(tr, type, conf) {
        return type == "delete" || !conf.activateOnTyping ? this.map(tr.changes) : new ActiveSource(this.source, 1 /* State.Pending */);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(cur(tr.startState)) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);
    }
    map(changes) {
        return changes.empty || this.explicitPos < 0 ? this : new ActiveSource(this.source, this.state, changes.mapPos(this.explicitPos));
    }
}
class ActiveResult extends ActiveSource {
    constructor(source, explicitPos, result, from, to) {
        super(source, 2 /* State.Result */, explicitPos);
        this.result = result;
        this.from = from;
        this.to = to;
    }
    hasResult() { return true; }
    handleUserEvent(tr, type, conf) {
        var _a;
        let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);
        let pos = cur(tr.state);
        if ((this.explicitPos < 0 ? pos <= from : pos < this.from) ||
            pos > to ||
            type == "delete" && cur(tr.startState) == this.from)
            return new ActiveSource(this.source, type == "input" && conf.activateOnTyping ? 1 /* State.Pending */ : 0 /* State.Inactive */);
        let explicitPos = this.explicitPos < 0 ? -1 : tr.changes.mapPos(this.explicitPos), updated;
        if (checkValid(this.result.validFor, tr.state, from, to))
            return new ActiveResult(this.source, explicitPos, this.result, from, to);
        if (this.result.update &&
            (updated = this.result.update(this.result, from, to, new CompletionContext(tr.state, pos, explicitPos >= 0))))
            return new ActiveResult(this.source, explicitPos, updated, updated.from, (_a = updated.to) !== null && _a !== void 0 ? _a : cur(tr.state));
        return new ActiveSource(this.source, 1 /* State.Pending */, explicitPos);
    }
    handleChange(tr) {
        return tr.changes.touchesRange(this.from, this.to) ? new ActiveSource(this.source, 0 /* State.Inactive */) : this.map(tr.changes);
    }
    map(mapping) {
        return mapping.empty ? this :
            new ActiveResult(this.source, this.explicitPos < 0 ? -1 : mapping.mapPos(this.explicitPos), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));
    }
}
function checkValid(validFor, state, from, to) {
    if (!validFor)
        return false;
    let text = state.sliceDoc(from, to);
    return typeof validFor == "function" ? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);
}
const setActiveEffect = /*@__PURE__*/StateEffect.define({
    map(sources, mapping) { return sources.map(s => s.map(mapping)); }
});
const setSelectedEffect = /*@__PURE__*/StateEffect.define();
const completionState = /*@__PURE__*/StateField.define({
    create() { return CompletionState.start(); },
    update(value, tr) { return value.update(tr); },
    provide: f => [
        showTooltip.from(f, val => val.tooltip),
        EditorView.contentAttributes.from(f, state => state.attrs)
    ]
});
function applyCompletion(view, option) {
    const apply = option.completion.apply || option.completion.label;
    let result = view.state.field(completionState).active.find(a => a.source == option.source);
    if (!(result instanceof ActiveResult))
        return false;
    if (typeof apply == "string")
        view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));
    else
        apply(view, option.completion, result.from, result.to);
    return true;
}
const createTooltip = /*@__PURE__*/completionTooltip(completionState, applyCompletion);

/**
Returns a command that moves the completion selection forward or
backward by the given amount.
*/
function moveCompletionSelection(forward, by = "option") {
    return (view) => {
        let cState = view.state.field(completionState, false);
        if (!cState || !cState.open || cState.open.disabled ||
            Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
            return false;
        let step = 1, tooltip;
        if (by == "page" && (tooltip = getTooltip(view, cState.open.tooltip)))
            step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /
                tooltip.dom.querySelector("li").offsetHeight) - 1);
        let { length } = cState.open.options;
        let selected = cState.open.selected > -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;
        if (selected < 0)
            selected = by == "page" ? 0 : length - 1;
        else if (selected >= length)
            selected = by == "page" ? length - 1 : 0;
        view.dispatch({ effects: setSelectedEffect.of(selected) });
        return true;
    };
}
/**
Accept the current completion.
*/
const acceptCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (view.state.readOnly || !cState || !cState.open || cState.open.selected < 0 || cState.open.disabled ||
        Date.now() - cState.open.timestamp < view.state.facet(completionConfig).interactionDelay)
        return false;
    return applyCompletion(view, cState.open.options[cState.open.selected]);
};
/**
Explicitly start autocompletion.
*/
const startCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState)
        return false;
    view.dispatch({ effects: startCompletionEffect.of(true) });
    return true;
};
/**
Close the currently active completion.
*/
const closeCompletion = (view) => {
    let cState = view.state.field(completionState, false);
    if (!cState || !cState.active.some(a => a.state != 0 /* State.Inactive */))
        return false;
    view.dispatch({ effects: closeCompletionEffect.of(null) });
    return true;
};
class RunningQuery {
    constructor(active, context) {
        this.active = active;
        this.context = context;
        this.time = Date.now();
        this.updates = [];
        // Note that 'undefined' means 'not done yet', whereas 'null' means
        // 'query returned null'.
        this.done = undefined;
    }
}
const MaxUpdateCount = 50, MinAbortTime = 1000;
const completionPlugin = /*@__PURE__*/dist_ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.debounceUpdate = -1;
        this.running = [];
        this.debounceAccept = -1;
        this.composing = 0 /* CompositionState.None */;
        for (let active of view.state.field(completionState).active)
            if (active.state == 1 /* State.Pending */)
                this.startQuery(active);
    }
    update(update) {
        let cState = update.state.field(completionState);
        if (!update.selectionSet && !update.docChanged && update.startState.field(completionState) == cState)
            return;
        let doesReset = update.transactions.some(tr => {
            return (tr.selection || tr.docChanged) && !getUserEvent(tr);
        });
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (doesReset ||
                query.updates.length + update.transactions.length > MaxUpdateCount && Date.now() - query.time > MinAbortTime) {
                for (let handler of query.context.abortListeners) {
                    try {
                        handler();
                    }
                    catch (e) {
                        dist_logException(this.view.state, e);
                    }
                }
                query.context.abortListeners = null;
                this.running.splice(i--, 1);
            }
            else {
                query.updates.push(...update.transactions);
            }
        }
        if (this.debounceUpdate > -1)
            clearTimeout(this.debounceUpdate);
        this.debounceUpdate = cState.active.some(a => a.state == 1 /* State.Pending */ && !this.running.some(q => q.active.source == a.source))
            ? setTimeout(() => this.startUpdate(), 50) : -1;
        if (this.composing != 0 /* CompositionState.None */)
            for (let tr of update.transactions) {
                if (getUserEvent(tr) == "input")
                    this.composing = 2 /* CompositionState.Changed */;
                else if (this.composing == 2 /* CompositionState.Changed */ && tr.selection)
                    this.composing = 3 /* CompositionState.ChangedAndMoved */;
            }
    }
    startUpdate() {
        this.debounceUpdate = -1;
        let { state } = this.view, cState = state.field(completionState);
        for (let active of cState.active) {
            if (active.state == 1 /* State.Pending */ && !this.running.some(r => r.active.source == active.source))
                this.startQuery(active);
        }
    }
    startQuery(active) {
        let { state } = this.view, pos = cur(state);
        let context = new CompletionContext(state, pos, active.explicitPos == pos);
        let pending = new RunningQuery(active, context);
        this.running.push(pending);
        Promise.resolve(active.source(context)).then(result => {
            if (!pending.context.aborted) {
                pending.done = result || null;
                this.scheduleAccept();
            }
        }, err => {
            this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            dist_logException(this.view.state, err);
        });
    }
    scheduleAccept() {
        if (this.running.every(q => q.done !== undefined))
            this.accept();
        else if (this.debounceAccept < 0)
            this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(completionConfig).updateSyncTime);
    }
    // For each finished query in this.running, try to create a result
    // or, if appropriate, restart the query.
    accept() {
        var _a;
        if (this.debounceAccept > -1)
            clearTimeout(this.debounceAccept);
        this.debounceAccept = -1;
        let updated = [];
        let conf = this.view.state.facet(completionConfig);
        for (let i = 0; i < this.running.length; i++) {
            let query = this.running[i];
            if (query.done === undefined)
                continue;
            this.running.splice(i--, 1);
            if (query.done) {
                let active = new ActiveResult(query.active.source, query.active.explicitPos, query.done, query.done.from, (_a = query.done.to) !== null && _a !== void 0 ? _a : cur(query.updates.length ? query.updates[0].startState : this.view.state));
                // Replay the transactions that happened since the start of
                // the request and see if that preserves the result
                for (let tr of query.updates)
                    active = active.update(tr, conf);
                if (active.hasResult()) {
                    updated.push(active);
                    continue;
                }
            }
            let current = this.view.state.field(completionState).active.find(a => a.source == query.active.source);
            if (current && current.state == 1 /* State.Pending */) {
                if (query.done == null) {
                    // Explicitly failed. Should clear the pending status if it
                    // hasn't been re-set in the meantime.
                    let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);
                    for (let tr of query.updates)
                        active = active.update(tr, conf);
                    if (active.state != 1 /* State.Pending */)
                        updated.push(active);
                }
                else {
                    // Cleared by subsequent transactions. Restart.
                    this.startQuery(current);
                }
            }
        }
        if (updated.length)
            this.view.dispatch({ effects: setActiveEffect.of(updated) });
    }
}, {
    eventHandlers: {
        blur(event) {
            let state = this.view.state.field(completionState, false);
            if (state && state.tooltip && this.view.state.facet(completionConfig).closeOnBlur) {
                let dialog = state.open && getTooltip(this.view, state.open.tooltip);
                if (!dialog || !dialog.dom.contains(event.relatedTarget))
                    this.view.dispatch({ effects: closeCompletionEffect.of(null) });
            }
        },
        compositionstart() {
            this.composing = 1 /* CompositionState.Started */;
        },
        compositionend() {
            if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {
                // Safari fires compositionend events synchronously, possibly
                // from inside an update, so dispatch asynchronously to avoid reentrancy
                setTimeout(() => this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);
            }
            this.composing = 0 /* CompositionState.None */;
        }
    }
});

const autocomplete_dist_baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-tooltip.cm-tooltip-autocomplete": {
        "& > ul": {
            fontFamily: "monospace",
            whiteSpace: "nowrap",
            overflow: "hidden auto",
            maxWidth_fallback: "700px",
            maxWidth: "min(700px, 95vw)",
            minWidth: "250px",
            maxHeight: "10em",
            height: "100%",
            listStyle: "none",
            margin: 0,
            padding: 0,
            "& > li, & > completion-section": {
                padding: "1px 3px",
                lineHeight: 1.2
            },
            "& > li": {
                overflowX: "hidden",
                textOverflow: "ellipsis",
                cursor: "pointer"
            },
            "& > completion-section": {
                display: "list-item",
                borderBottom: "1px solid silver",
                paddingLeft: "0.5em",
                opacity: 0.7
            }
        }
    },
    "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#17c",
        color: "white",
    },
    "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#777",
    },
    "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
        background: "#347",
        color: "white",
    },
    "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
        background: "#444",
    },
    ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
        content: '"···"',
        opacity: 0.5,
        display: "block",
        textAlign: "center"
    },
    ".cm-tooltip.cm-completionInfo": {
        position: "absolute",
        padding: "3px 9px",
        width: "max-content",
        maxWidth: `${400 /* Info.Width */}px`,
        boxSizing: "border-box"
    },
    ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
    ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
    ".cm-completionInfo.cm-completionInfo-left-narrow": { right: `${30 /* Info.Margin */}px` },
    ".cm-completionInfo.cm-completionInfo-right-narrow": { left: `${30 /* Info.Margin */}px` },
    "&light .cm-snippetField": { backgroundColor: "#00000022" },
    "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
    ".cm-snippetFieldPosition": {
        verticalAlign: "text-top",
        width: 0,
        height: "1.15em",
        display: "inline-block",
        margin: "0 -0.7px -.7em",
        borderLeft: "1.4px dotted #888"
    },
    ".cm-completionMatchedText": {
        textDecoration: "underline"
    },
    ".cm-completionDetail": {
        marginLeft: "0.5em",
        fontStyle: "italic"
    },
    ".cm-completionIcon": {
        fontSize: "90%",
        width: ".8em",
        display: "inline-block",
        textAlign: "center",
        paddingRight: ".6em",
        opacity: "0.6",
        boxSizing: "content-box"
    },
    ".cm-completionIcon-function, .cm-completionIcon-method": {
        "&:after": { content: "'ƒ'" }
    },
    ".cm-completionIcon-class": {
        "&:after": { content: "'○'" }
    },
    ".cm-completionIcon-interface": {
        "&:after": { content: "'◌'" }
    },
    ".cm-completionIcon-variable": {
        "&:after": { content: "'𝑥'" }
    },
    ".cm-completionIcon-constant": {
        "&:after": { content: "'𝐶'" }
    },
    ".cm-completionIcon-type": {
        "&:after": { content: "'𝑡'" }
    },
    ".cm-completionIcon-enum": {
        "&:after": { content: "'∪'" }
    },
    ".cm-completionIcon-property": {
        "&:after": { content: "'□'" }
    },
    ".cm-completionIcon-keyword": {
        "&:after": { content: "'🔑\uFE0E'" } // Disable emoji rendering
    },
    ".cm-completionIcon-namespace": {
        "&:after": { content: "'▢'" }
    },
    ".cm-completionIcon-text": {
        "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
    }
});

class FieldPos {
    constructor(field, line, from, to) {
        this.field = field;
        this.line = line;
        this.from = from;
        this.to = to;
    }
}
class FieldRange {
    constructor(field, from, to) {
        this.field = field;
        this.from = from;
        this.to = to;
    }
    map(changes) {
        let from = changes.mapPos(this.from, -1, MapMode.TrackDel);
        let to = changes.mapPos(this.to, 1, MapMode.TrackDel);
        return from == null || to == null ? null : new FieldRange(this.field, from, to);
    }
}
class Snippet {
    constructor(lines, fieldPositions) {
        this.lines = lines;
        this.fieldPositions = fieldPositions;
    }
    instantiate(state, pos) {
        let text = [], lineStart = [pos];
        let lineObj = state.doc.lineAt(pos), baseIndent = /^\s*/.exec(lineObj.text)[0];
        for (let line of this.lines) {
            if (text.length) {
                let indent = baseIndent, tabs = /^\t*/.exec(line)[0].length;
                for (let i = 0; i < tabs; i++)
                    indent += state.facet(indentUnit);
                lineStart.push(pos + indent.length - tabs);
                line = indent + line.slice(tabs);
            }
            text.push(line);
            pos += line.length + 1;
        }
        let ranges = this.fieldPositions.map(pos => new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));
        return { text, ranges };
    }
    static parse(template) {
        let fields = [];
        let lines = [], positions = [], m;
        for (let line of template.split(/\r\n?|\n/)) {
            while (m = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(line)) {
                let seq = m[1] ? +m[1] : null, name = m[2] || m[3] || "", found = -1;
                for (let i = 0; i < fields.length; i++) {
                    if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)
                        found = i;
                }
                if (found < 0) {
                    let i = 0;
                    while (i < fields.length && (seq == null || (fields[i].seq != null && fields[i].seq < seq)))
                        i++;
                    fields.splice(i, 0, { seq, name });
                    found = i;
                    for (let pos of positions)
                        if (pos.field >= found)
                            pos.field++;
                }
                positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));
                line = line.slice(0, m.index) + name + line.slice(m.index + m[0].length);
            }
            for (let esc; esc = /\\([{}])/.exec(line);) {
                line = line.slice(0, esc.index) + esc[1] + line.slice(esc.index + esc[0].length);
                for (let pos of positions)
                    if (pos.line == lines.length && pos.from > esc.index) {
                        pos.from--;
                        pos.to--;
                    }
            }
            lines.push(line);
        }
        return new Snippet(lines, positions);
    }
}
let fieldMarker = /*@__PURE__*/Decoration.widget({ widget: /*@__PURE__*/new class extends WidgetType {
        toDOM() {
            let span = document.createElement("span");
            span.className = "cm-snippetFieldPosition";
            return span;
        }
        ignoreEvent() { return false; }
    } });
let fieldRange = /*@__PURE__*/Decoration.mark({ class: "cm-snippetField" });
class ActiveSnippet {
    constructor(ranges, active) {
        this.ranges = ranges;
        this.active = active;
        this.deco = Decoration.set(ranges.map(r => (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));
    }
    map(changes) {
        let ranges = [];
        for (let r of this.ranges) {
            let mapped = r.map(changes);
            if (!mapped)
                return null;
            ranges.push(mapped);
        }
        return new ActiveSnippet(ranges, this.active);
    }
    selectionInsideField(sel) {
        return sel.ranges.every(range => this.ranges.some(r => r.field == this.active && r.from <= range.from && r.to >= range.to));
    }
}
const setActive = /*@__PURE__*/StateEffect.define({
    map(value, changes) { return value && value.map(changes); }
});
const moveToField = /*@__PURE__*/StateEffect.define();
const snippetState = /*@__PURE__*/StateField.define({
    create() { return null; },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setActive))
                return effect.value;
            if (effect.is(moveToField) && value)
                return new ActiveSnippet(value.ranges, effect.value);
        }
        if (value && tr.docChanged)
            value = value.map(tr.changes);
        if (value && tr.selection && !value.selectionInsideField(tr.selection))
            value = null;
        return value;
    },
    provide: f => EditorView.decorations.from(f, val => val ? val.deco : Decoration.none)
});
function fieldSelection(ranges, field) {
    return dist_EditorSelection.create(ranges.filter(r => r.field == field).map(r => dist_EditorSelection.range(r.from, r.to)));
}
/**
Convert a snippet template to a function that can
[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written
using syntax like this:

    "for (let ${index} = 0; ${index} < ${end}; ${index}++) {\n\t${}\n}"

Each `${}` placeholder (you may also use `#{}`) indicates a field
that the user can fill in. Its name, if any, will be the default
content for the field.

When the snippet is activated by calling the returned function,
the code is inserted at the given position. Newlines in the
template are indented by the indentation of the start line, plus
one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after
the newline.

On activation, (all instances of) the first field are selected.
The user can move between fields with Tab and Shift-Tab as long as
the fields are active. Moving to the last field or moving the
cursor out of the current field deactivates the fields.

The order of fields defaults to textual order, but you can add
numbers to placeholders (`${1}` or `${1:defaultText}`) to provide
a custom order.

To include a literal `{` or `}` in your template, put a backslash
in front of it. This will be removed and the brace will not be
interpreted as indicating a placeholder.
*/
function snippet(template) {
    let snippet = Snippet.parse(template);
    return (editor, completion, from, to) => {
        let { text, ranges } = snippet.instantiate(editor.state, from);
        let spec = {
            changes: { from, to, insert: Text.of(text) },
            scrollIntoView: true,
            annotations: completion ? pickedCompletion.of(completion) : undefined
        };
        if (ranges.length)
            spec.selection = fieldSelection(ranges, 0);
        if (ranges.length > 1) {
            let active = new ActiveSnippet(ranges, 0);
            let effects = spec.effects = [setActive.of(active)];
            if (editor.state.field(snippetState, false) === undefined)
                effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, autocomplete_dist_baseTheme]));
        }
        editor.dispatch(editor.state.update(spec));
    };
}
function moveField(dir) {
    return ({ state, dispatch }) => {
        let active = state.field(snippetState, false);
        if (!active || dir < 0 && active.active == 0)
            return false;
        let next = active.active + dir, last = dir > 0 && !active.ranges.some(r => r.field == next + dir);
        dispatch(state.update({
            selection: fieldSelection(active.ranges, next),
            effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),
            scrollIntoView: true
        }));
        return true;
    };
}
/**
A command that clears the active snippet, if any.
*/
const clearSnippet = ({ state, dispatch }) => {
    let active = state.field(snippetState, false);
    if (!active)
        return false;
    dispatch(state.update({ effects: setActive.of(null) }));
    return true;
};
/**
Move to the next snippet field, if available.
*/
const nextSnippetField = /*@__PURE__*/moveField(1);
/**
Move to the previous snippet field, if available.
*/
const prevSnippetField = /*@__PURE__*/moveField(-1);
/**
Check if there is an active snippet with a next field for
`nextSnippetField` to move to.
*/
function hasNextSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.ranges.some(r => r.field == active.active + 1));
}
/**
Returns true if there is an active snippet and a previous field
for `prevSnippetField` to move to.
*/
function hasPrevSnippetField(state) {
    let active = state.field(snippetState, false);
    return !!(active && active.active > 0);
}
const defaultSnippetKeymap = [
    { key: "Tab", run: nextSnippetField, shift: prevSnippetField },
    { key: "Escape", run: clearSnippet }
];
/**
A facet that can be used to configure the key bindings used by
snippets. The default binds Tab to
[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to
[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape
to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).
*/
const snippetKeymap = /*@__PURE__*/Facet.define({
    combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }
});
const addSnippetKeymap = /*@__PURE__*/Prec.highest(/*@__PURE__*/dist_keymap.compute([snippetKeymap], state => state.facet(snippetKeymap)));
/**
Create a completion from a snippet. Returns an object with the
properties from `completion`, plus an `apply` function that
applies the snippet.
*/
function snippetCompletion(template, completion) {
    return Object.assign(Object.assign({}, completion), { apply: snippet(template) });
}
const snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({
    mousedown(event, view) {
        let active = view.state.field(snippetState, false), pos;
        if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)
            return false;
        let match = active.ranges.find(r => r.from <= pos && r.to >= pos);
        if (!match || match.field == active.active)
            return false;
        view.dispatch({
            selection: fieldSelection(active.ranges, match.field),
            effects: setActive.of(active.ranges.some(r => r.field > match.field)
                ? new ActiveSnippet(active.ranges, match.field) : null),
            scrollIntoView: true
        });
        return true;
    }
});

function wordRE(wordChars) {
    let escaped = wordChars.replace(/[\]\-\\]/g, "\\$&");
    try {
        return new RegExp(`[\\p{Alphabetic}\\p{Number}_${escaped}]+`, "ug");
    }
    catch (_a) {
        return new RegExp(`[\w${escaped}]`, "g");
    }
}
function mapRE(re, f) {
    return new RegExp(f(re.source), re.unicode ? "u" : "");
}
const wordCaches = /*@__PURE__*/(/* unused pure expression or super */ null && (Object.create(null)));
function wordCache(wordChars) {
    return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);
}
function storeWords(doc, wordRE, result, seen, ignoreAt) {
    for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {
        let { value } = lines, m;
        wordRE.lastIndex = 0;
        while (m = wordRE.exec(value)) {
            if (!seen[m[0]] && pos + m.index != ignoreAt) {
                result.push({ type: "text", label: m[0] });
                seen[m[0]] = true;
                if (result.length >= 2000 /* C.MaxList */)
                    return;
            }
        }
        pos += value.length + 1;
    }
}
function collectWords(doc, cache, wordRE, to, ignoreAt) {
    let big = doc.length >= 1000 /* C.MinCacheLen */;
    let cached = big && cache.get(doc);
    if (cached)
        return cached;
    let result = [], seen = Object.create(null);
    if (doc.children) {
        let pos = 0;
        for (let ch of doc.children) {
            if (ch.length >= 1000 /* C.MinCacheLen */) {
                for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {
                    if (!seen[c.label]) {
                        seen[c.label] = true;
                        result.push(c);
                    }
                }
            }
            else {
                storeWords(ch, wordRE, result, seen, ignoreAt - pos);
            }
            pos += ch.length + 1;
        }
    }
    else {
        storeWords(doc, wordRE, result, seen, ignoreAt);
    }
    if (big && result.length < 2000 /* C.MaxList */)
        cache.set(doc, result);
    return result;
}
/**
A completion source that will scan the document for words (using a
[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and
return those as completions.
*/
const completeAnyWord = context => {
    let wordChars = context.state.languageDataAt("wordChars", context.pos).join("");
    let re = wordRE(wordChars);
    let token = context.matchBefore(mapRE(re, s => s + "$"));
    if (!token && !context.explicit)
        return null;
    let from = token ? token.from : context.pos;
    let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);
    return { from, options, validFor: mapRE(re, s => "^" + s) };
};

const dist_defaults = {
    brackets: ["(", "[", "{", "'", '"'],
    before: ")]}:;>",
    stringPrefixes: []
};
const closeBracketEffect = /*@__PURE__*/StateEffect.define({
    map(value, mapping) {
        let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);
        return mapped == null ? undefined : mapped;
    }
});
const closedBracket = /*@__PURE__*/new class extends RangeValue {
};
closedBracket.startSide = 1;
closedBracket.endSide = -1;
const bracketState = /*@__PURE__*/StateField.define({
    create() { return dist_RangeSet.empty; },
    update(value, tr) {
        value = value.map(tr.changes);
        if (tr.selection) {
            let line = tr.state.doc.lineAt(tr.selection.main.head);
            value = value.update({ filter: from => from >= line.from && from <= line.to });
        }
        for (let effect of tr.effects)
            if (effect.is(closeBracketEffect))
                value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });
        return value;
    }
});
/**
Extension to enable bracket-closing behavior. When a closeable
bracket is typed, its closing bracket is immediately inserted
after the cursor. When closing a bracket directly in front of a
closing bracket inserted by the extension, the cursor moves over
that bracket.
*/
function closeBrackets() {
    return [dist_inputHandler, bracketState];
}
const definedClosing = "()[]{}<>";
function closing(ch) {
    for (let i = 0; i < definedClosing.length; i += 2)
        if (definedClosing.charCodeAt(i) == ch)
            return definedClosing.charAt(i + 1);
    return fromCodePoint(ch < 128 ? ch : ch + 1);
}
function dist_config(state, pos) {
    return state.languageDataAt("closeBrackets", pos)[0] || dist_defaults;
}
const android = typeof navigator == "object" && /*@__PURE__*//Android\b/.test(navigator.userAgent);
const dist_inputHandler = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, insert) => {
    if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)
        return false;
    let sel = view.state.selection.main;
    if (insert.length > 2 || insert.length == 2 && codePointSize(codePointAt(insert, 0)) == 1 ||
        from != sel.from || to != sel.to)
        return false;
    let tr = insertBracket(view.state, insert);
    if (!tr)
        return false;
    view.dispatch(tr);
    return true;
});
/**
Command that implements deleting a pair of matching brackets when
the cursor is between them.
*/
const deleteBracketPair = ({ state, dispatch }) => {
    if (state.readOnly)
        return false;
    let conf = dist_config(state, state.selection.main.head);
    let tokens = conf.brackets || dist_defaults.brackets;
    let dont = null, changes = state.changeByRange(range => {
        if (range.empty) {
            let before = prevChar(state.doc, range.head);
            for (let token of tokens) {
                if (token == before && nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))
                    return { changes: { from: range.head - token.length, to: range.head + token.length },
                        range: dist_EditorSelection.cursor(range.head - token.length) };
            }
        }
        return { range: dont = range };
    });
    if (!dont)
        dispatch(state.update(changes, { scrollIntoView: true, userEvent: "delete.backward" }));
    return !dont;
};
/**
Close-brackets related key bindings. Binds Backspace to
[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).
*/
const closeBracketsKeymap = [
    { key: "Backspace", run: deleteBracketPair }
];
/**
Implements the extension's behavior on text insertion. If the
given string counts as a bracket in the language around the
selection, and replacing the selection with it requires custom
behavior (inserting a closing version or skipping past a
previously-closed bracket), this function returns a transaction
representing that custom behavior. (You only need this if you want
to programmatically insert brackets—the
[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will
take care of running this for user input.)
*/
function insertBracket(state, bracket) {
    let conf = dist_config(state, state.selection.main.head);
    let tokens = conf.brackets || dist_defaults.brackets;
    for (let tok of tokens) {
        let closed = closing(codePointAt(tok, 0));
        if (bracket == tok)
            return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) > -1, conf)
                : handleOpen(state, tok, closed, conf.before || dist_defaults.before);
        if (bracket == closed && closedBracketAt(state, state.selection.main.from))
            return handleClose(state, tok, closed);
    }
    return null;
}
function closedBracketAt(state, pos) {
    let found = false;
    state.field(bracketState).between(0, state.doc.length, from => {
        if (from == pos)
            found = true;
    });
    return found;
}
function nextChar(doc, pos) {
    let next = doc.sliceString(pos, pos + 2);
    return next.slice(0, codePointSize(codePointAt(next, 0)));
}
function prevChar(doc, pos) {
    let prev = doc.sliceString(pos - 2, pos);
    return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);
}
function handleOpen(state, open, close, closeBefore) {
    let dont = null, changes = state.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],
                effects: closeBracketEffect.of(range.to + open.length),
                range: dist_EditorSelection.range(range.anchor + open.length, range.head + open.length) };
        let next = nextChar(state.doc, range.head);
        if (!next || /\s/.test(next) || closeBefore.indexOf(next) > -1)
            return { changes: { insert: open + close, from: range.head },
                effects: closeBracketEffect.of(range.head + open.length),
                range: dist_EditorSelection.cursor(range.head + open.length) };
        return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function handleClose(state, _open, close) {
    let dont = null, changes = state.changeByRange(range => {
        if (range.empty && nextChar(state.doc, range.head) == close)
            return { changes: { from: range.head, to: range.head + close.length, insert: close },
                range: dist_EditorSelection.cursor(range.head + close.length) };
        return dont = { range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
// Handles cases where the open and close token are the same, and
// possibly triple quotes (as in `"""abc"""`-style quoting).
function handleSame(state, token, allowTriple, config) {
    let stringPrefixes = config.stringPrefixes || dist_defaults.stringPrefixes;
    let dont = null, changes = state.changeByRange(range => {
        if (!range.empty)
            return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],
                effects: closeBracketEffect.of(range.to + token.length),
                range: dist_EditorSelection.range(range.anchor + token.length, range.head + token.length) };
        let pos = range.head, next = nextChar(state.doc, pos), start;
        if (next == token) {
            if (nodeStart(state, pos)) {
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: dist_EditorSelection.cursor(pos + token.length) };
            }
            else if (closedBracketAt(state, pos)) {
                let isTriple = allowTriple && state.sliceDoc(pos, pos + token.length * 3) == token + token + token;
                let content = isTriple ? token + token + token : token;
                return { changes: { from: pos, to: pos + content.length, insert: content },
                    range: dist_EditorSelection.cursor(pos + content.length) };
            }
        }
        else if (allowTriple && state.sliceDoc(pos - 2 * token.length, pos) == token + token &&
            (start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) > -1 &&
            nodeStart(state, start)) {
            return { changes: { insert: token + token + token + token, from: pos },
                effects: closeBracketEffect.of(pos + token.length),
                range: dist_EditorSelection.cursor(pos + token.length) };
        }
        else if (state.charCategorizer(pos)(next) != dist_CharCategory.Word) {
            if (canStartStringAt(state, pos, stringPrefixes) > -1 && !probablyInString(state, pos, token, stringPrefixes))
                return { changes: { insert: token + token, from: pos },
                    effects: closeBracketEffect.of(pos + token.length),
                    range: dist_EditorSelection.cursor(pos + token.length) };
        }
        return { range: dont = range };
    });
    return dont ? null : state.update(changes, {
        scrollIntoView: true,
        userEvent: "input.type"
    });
}
function nodeStart(state, pos) {
    let tree = dist_syntaxTree(state).resolveInner(pos + 1);
    return tree.parent && tree.from == pos;
}
function probablyInString(state, pos, quoteToken, prefixes) {
    let node = dist_syntaxTree(state).resolveInner(pos, -1);
    let maxPrefix = prefixes.reduce((m, p) => Math.max(m, p.length), 0);
    for (let i = 0; i < 5; i++) {
        let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));
        let quotePos = start.indexOf(quoteToken);
        if (!quotePos || quotePos > -1 && prefixes.indexOf(start.slice(0, quotePos)) > -1) {
            let first = node.firstChild;
            while (first && first.from == node.from && first.to - first.from > quoteToken.length + quotePos) {
                if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)
                    return false;
                first = first.firstChild;
            }
            return true;
        }
        let parent = node.to == pos && node.parent;
        if (!parent)
            break;
        node = parent;
    }
    return false;
}
function canStartStringAt(state, pos, prefixes) {
    let charCat = state.charCategorizer(pos);
    if (charCat(state.sliceDoc(pos - 1, pos)) != dist_CharCategory.Word)
        return pos;
    for (let prefix of prefixes) {
        let start = pos - prefix.length;
        if (state.sliceDoc(start, pos) == prefix && charCat(state.sliceDoc(start - 1, start)) != dist_CharCategory.Word)
            return start;
    }
    return -1;
}

/**
Returns an extension that enables autocompletion.
*/
function autocompletion(config = {}) {
    return [
        completionState,
        completionConfig.of(config),
        completionPlugin,
        completionKeymapExt,
        autocomplete_dist_baseTheme
    ];
}
/**
Basic keybindings for autocompletion.

 - Ctrl-Space: [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)
 - Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)
 - ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`
 - ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, "page")`
 - Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)
*/
const completionKeymap = [
    { key: "Ctrl-Space", run: startCompletion },
    { key: "Escape", run: closeCompletion },
    { key: "ArrowDown", run: /*@__PURE__*/moveCompletionSelection(true) },
    { key: "ArrowUp", run: /*@__PURE__*/moveCompletionSelection(false) },
    { key: "PageDown", run: /*@__PURE__*/moveCompletionSelection(true, "page") },
    { key: "PageUp", run: /*@__PURE__*/moveCompletionSelection(false, "page") },
    { key: "Enter", run: acceptCompletion }
];
const completionKeymapExt = /*@__PURE__*/Prec.highest(/*@__PURE__*/dist_keymap.computeN([completionConfig], state => state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));
/**
Get the current completion status. When completions are available,
this will return `"active"`. When completions are pending (in the
process of being queried), this returns `"pending"`. Otherwise, it
returns `null`.
*/
function completionStatus(state) {
    let cState = state.field(completionState, false);
    return cState && cState.active.some(a => a.state == 1 /* State.Pending */) ? "pending"
        : cState && cState.active.some(a => a.state != 0 /* State.Inactive */) ? "active" : null;
}
const completionArrayCache = /*@__PURE__*/new WeakMap;
/**
Returns the available completions as an array.
*/
function currentCompletions(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    if (!open || open.disabled)
        return [];
    let completions = completionArrayCache.get(open.options);
    if (!completions)
        completionArrayCache.set(open.options, completions = open.options.map(o => o.completion));
    return completions;
}
/**
Return the currently selected completion, if any.
*/
function selectedCompletion(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.options[open.selected].completion : null;
}
/**
Returns the currently selected position in the active completion
list, or null if no completions are active.
*/
function selectedCompletionIndex(state) {
    var _a;
    let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;
    return open && !open.disabled && open.selected >= 0 ? open.selected : null;
}
/**
Create an effect that can be attached to a transaction to change
the currently selected completion.
*/
function setSelectedCompletion(index) {
    return setSelectedEffect.of(index);
}



;// CONCATENATED MODULE: ./node_modules/@codemirror/lint/dist/index.js




class SelectedDiagnostic {
    constructor(from, to, diagnostic) {
        this.from = from;
        this.to = to;
        this.diagnostic = diagnostic;
    }
}
class LintState {
    constructor(diagnostics, panel, selected) {
        this.diagnostics = diagnostics;
        this.panel = panel;
        this.selected = selected;
    }
    static init(diagnostics, panel, state) {
        // Filter the list of diagnostics for which to create markers
        let markedDiagnostics = diagnostics;
        let diagnosticFilter = state.facet(lintConfig).markerFilter;
        if (diagnosticFilter)
            markedDiagnostics = diagnosticFilter(markedDiagnostics);
        let ranges = Decoration.set(markedDiagnostics.map((d) => {
            // For zero-length ranges or ranges covering only a line break, create a widget
            return d.from == d.to || (d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from)
                ? Decoration.widget({
                    widget: new DiagnosticWidget(d),
                    diagnostic: d
                }).range(d.from)
                : Decoration.mark({
                    attributes: { class: "cm-lintRange cm-lintRange-" + d.severity + (d.markClass ? " " + d.markClass : "") },
                    diagnostic: d
                }).range(d.from, d.to);
        }), true);
        return new LintState(ranges, panel, findDiagnostic(ranges));
    }
}
function findDiagnostic(diagnostics, diagnostic = null, after = 0) {
    let found = null;
    diagnostics.between(after, 1e9, (from, to, { spec }) => {
        if (diagnostic && spec.diagnostic != diagnostic)
            return;
        found = new SelectedDiagnostic(from, to, spec.diagnostic);
        return false;
    });
    return found;
}
function hideTooltip(tr, tooltip) {
    let line = tr.startState.doc.lineAt(tooltip.pos);
    return !!(tr.effects.some(e => e.is(setDiagnosticsEffect)) || tr.changes.touchesRange(line.from, line.to));
}
function maybeEnableLint(state, effects) {
    return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of(lintExtensions));
}
/**
Returns a transaction spec which updates the current set of
diagnostics, and enables the lint extension if if wasn't already
active.
*/
function setDiagnostics(state, diagnostics) {
    return {
        effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])
    };
}
/**
The state effect that updates the set of active diagnostics. Can
be useful when writing an extension that needs to track these.
*/
const setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();
const dist_togglePanel = /*@__PURE__*/StateEffect.define();
const movePanelSelection = /*@__PURE__*/StateEffect.define();
const lintState = /*@__PURE__*/StateField.define({
    create() {
        return new LintState(Decoration.none, null, null);
    },
    update(value, tr) {
        if (tr.docChanged) {
            let mapped = value.diagnostics.map(tr.changes), selected = null;
            if (value.selected) {
                let selPos = tr.changes.mapPos(value.selected.from, 1);
                selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);
            }
            value = new LintState(mapped, value.panel, selected);
        }
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                value = LintState.init(effect.value, value.panel, tr.state);
            }
            else if (effect.is(dist_togglePanel)) {
                value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);
            }
            else if (effect.is(movePanelSelection)) {
                value = new LintState(value.diagnostics, value.panel, effect.value);
            }
        }
        return value;
    },
    provide: f => [showPanel.from(f, val => val.panel),
        EditorView.decorations.from(f, s => s.diagnostics)]
});
/**
Returns the number of active lint diagnostics in the given state.
*/
function diagnosticCount(state) {
    let lint = state.field(lintState, false);
    return lint ? lint.diagnostics.size : 0;
}
const activeMark = /*@__PURE__*/Decoration.mark({ class: "cm-lintRange cm-lintRange-active" });
function lintTooltip(view, pos, side) {
    let { diagnostics } = view.state.field(lintState);
    let found = [], stackStart = 2e8, stackEnd = 0;
    diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), (from, to, { spec }) => {
        if (pos >= from && pos <= to &&
            (from == to || ((pos > from || side > 0) && (pos < to || side < 0)))) {
            found.push(spec.diagnostic);
            stackStart = Math.min(from, stackStart);
            stackEnd = Math.max(to, stackEnd);
        }
    });
    let diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;
    if (diagnosticFilter)
        found = diagnosticFilter(found);
    if (!found.length)
        return null;
    return {
        pos: stackStart,
        end: stackEnd,
        above: view.state.doc.lineAt(stackStart).to < stackEnd,
        create() {
            return { dom: diagnosticsTooltip(view, found) };
        }
    };
}
function diagnosticsTooltip(view, diagnostics) {
    return crelt("ul", { class: "cm-tooltip-lint" }, diagnostics.map(d => renderDiagnostic(view, d, false)));
}
/**
Command to open and focus the lint panel.
*/
const openLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        view.dispatch({ effects: maybeEnableLint(view.state, [dist_togglePanel.of(true)]) });
    let panel = getPanel(view, LintPanel.open);
    if (panel)
        panel.dom.querySelector(".cm-panel-lint ul").focus();
    return true;
};
/**
Command to close the lint panel, when open.
*/
const closeLintPanel = (view) => {
    let field = view.state.field(lintState, false);
    if (!field || !field.panel)
        return false;
    view.dispatch({ effects: dist_togglePanel.of(false) });
    return true;
};
/**
Move the selection to the next diagnostic.
*/
const nextDiagnostic = (view) => {
    let field = view.state.field(lintState, false);
    if (!field)
        return false;
    let sel = view.state.selection.main, next = field.diagnostics.iter(sel.to + 1);
    if (!next.value) {
        next = field.diagnostics.iter(0);
        if (!next.value || next.from == sel.from && next.to == sel.to)
            return false;
    }
    view.dispatch({ selection: { anchor: next.from, head: next.to }, scrollIntoView: true });
    return true;
};
/**
Move the selection to the previous diagnostic.
*/
const previousDiagnostic = (view) => {
    let { state } = view, field = state.field(lintState, false);
    if (!field)
        return false;
    let sel = state.selection.main;
    let prevFrom, prevTo, lastFrom, lastTo;
    field.diagnostics.between(0, state.doc.length, (from, to) => {
        if (to < sel.to && (prevFrom == null || prevFrom < from)) {
            prevFrom = from;
            prevTo = to;
        }
        if (lastFrom == null || from > lastFrom) {
            lastFrom = from;
            lastTo = to;
        }
    });
    if (lastFrom == null || prevFrom == null && lastFrom == sel.from)
        return false;
    view.dispatch({ selection: { anchor: prevFrom !== null && prevFrom !== void 0 ? prevFrom : lastFrom, head: prevTo !== null && prevTo !== void 0 ? prevTo : lastTo }, scrollIntoView: true });
    return true;
};
/**
A set of default key bindings for the lint functionality.

- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)
- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)
*/
const lintKeymap = [
    { key: "Mod-Shift-m", run: openLintPanel, preventDefault: true },
    { key: "F8", run: nextDiagnostic }
];
const lintPlugin = /*@__PURE__*/(/* unused pure expression or super */ null && (ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.timeout = -1;
        this.set = true;
        let { delay } = view.state.facet(lintConfig);
        this.lintTime = Date.now() + delay;
        this.run = this.run.bind(this);
        this.timeout = setTimeout(this.run, delay);
    }
    run() {
        let now = Date.now();
        if (now < this.lintTime - 10) {
            this.timeout = setTimeout(this.run, this.lintTime - now);
        }
        else {
            this.set = false;
            let { state } = this.view, { sources } = state.facet(lintConfig);
            Promise.all(sources.map(source => Promise.resolve(source(this.view)))).then(annotations => {
                let all = annotations.reduce((a, b) => a.concat(b));
                if (this.view.state.doc == state.doc)
                    this.view.dispatch(setDiagnostics(this.view.state, all));
            }, error => { logException(this.view.state, error); });
        }
    }
    update(update) {
        let config = update.state.facet(lintConfig);
        if (update.docChanged || config != update.startState.facet(lintConfig) ||
            config.needsRefresh && config.needsRefresh(update)) {
            this.lintTime = Date.now() + config.delay;
            if (!this.set) {
                this.set = true;
                this.timeout = setTimeout(this.run, config.delay);
            }
        }
    }
    force() {
        if (this.set) {
            this.lintTime = Date.now();
            this.run();
        }
    }
    destroy() {
        clearTimeout(this.timeout);
    }
})));
const lintConfig = /*@__PURE__*/Facet.define({
    combine(input) {
        return Object.assign({ sources: input.map(i => i.source) }, combineConfig(input.map(i => i.config), {
            delay: 750,
            markerFilter: null,
            tooltipFilter: null,
            needsRefresh: null
        }, {
            needsRefresh: (a, b) => !a ? b : !b ? a : u => a(u) || b(u)
        }));
    }
});
/**
Given a diagnostic source, this function returns an extension that
enables linting with that source. It will be called whenever the
editor is idle (after its content changed).
*/
function linter(source, config = {}) {
    return [
        lintConfig.of({ source, config }),
        lintPlugin,
        lintExtensions
    ];
}
/**
Forces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the
editor is idle to run right away.
*/
function forceLinting(view) {
    let plugin = view.plugin(lintPlugin);
    if (plugin)
        plugin.force();
}
function assignKeys(actions) {
    let assigned = [];
    if (actions)
        actions: for (let { name } of actions) {
            for (let i = 0; i < name.length; i++) {
                let ch = name[i];
                if (/[a-zA-Z]/.test(ch) && !assigned.some(c => c.toLowerCase() == ch.toLowerCase())) {
                    assigned.push(ch);
                    continue actions;
                }
            }
            assigned.push("");
        }
    return assigned;
}
function renderDiagnostic(view, diagnostic, inPanel) {
    var _a;
    let keys = inPanel ? assignKeys(diagnostic.actions) : [];
    return crelt("li", { class: "cm-diagnostic cm-diagnostic-" + diagnostic.severity }, crelt("span", { class: "cm-diagnosticText" }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map((action, i) => {
        let fired = false, click = (e) => {
            e.preventDefault();
            if (fired)
                return;
            fired = true;
            let found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);
            if (found)
                action.apply(view, found.from, found.to);
        };
        let { name } = action, keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;
        let nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex),
            crelt("u", name.slice(keyIndex, keyIndex + 1)),
            name.slice(keyIndex + 1)];
        return crelt("button", {
            type: "button",
            class: "cm-diagnosticAction",
            onclick: click,
            onmousedown: click,
            "aria-label": ` Action: ${name}${keyIndex < 0 ? "" : ` (access key "${keys[i]})"`}.`
        }, nameElt);
    }), diagnostic.source && crelt("div", { class: "cm-diagnosticSource" }, diagnostic.source));
}
class DiagnosticWidget extends WidgetType {
    constructor(diagnostic) {
        super();
        this.diagnostic = diagnostic;
    }
    eq(other) { return other.diagnostic == this.diagnostic; }
    toDOM() {
        return crelt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
    }
}
class PanelItem {
    constructor(view, diagnostic) {
        this.diagnostic = diagnostic;
        this.id = "item_" + Math.floor(Math.random() * 0xffffffff).toString(16);
        this.dom = renderDiagnostic(view, diagnostic, true);
        this.dom.id = this.id;
        this.dom.setAttribute("role", "option");
    }
}
class LintPanel {
    constructor(view) {
        this.view = view;
        this.items = [];
        let onkeydown = (event) => {
            if (event.keyCode == 27) { // Escape
                closeLintPanel(this.view);
                this.view.focus();
            }
            else if (event.keyCode == 38 || event.keyCode == 33) { // ArrowUp, PageUp
                this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
            }
            else if (event.keyCode == 40 || event.keyCode == 34) { // ArrowDown, PageDown
                this.moveSelection((this.selectedIndex + 1) % this.items.length);
            }
            else if (event.keyCode == 36) { // Home
                this.moveSelection(0);
            }
            else if (event.keyCode == 35) { // End
                this.moveSelection(this.items.length - 1);
            }
            else if (event.keyCode == 13) { // Enter
                this.view.focus();
            }
            else if (event.keyCode >= 65 && event.keyCode <= 90 && this.selectedIndex >= 0) { // A-Z
                let { diagnostic } = this.items[this.selectedIndex], keys = assignKeys(diagnostic.actions);
                for (let i = 0; i < keys.length; i++)
                    if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {
                        let found = findDiagnostic(this.view.state.field(lintState).diagnostics, diagnostic);
                        if (found)
                            diagnostic.actions[i].apply(view, found.from, found.to);
                    }
            }
            else {
                return;
            }
            event.preventDefault();
        };
        let onclick = (event) => {
            for (let i = 0; i < this.items.length; i++) {
                if (this.items[i].dom.contains(event.target))
                    this.moveSelection(i);
            }
        };
        this.list = crelt("ul", {
            tabIndex: 0,
            role: "listbox",
            "aria-label": this.view.state.phrase("Diagnostics"),
            onkeydown,
            onclick
        });
        this.dom = crelt("div", { class: "cm-panel-lint" }, this.list, crelt("button", {
            type: "button",
            name: "close",
            "aria-label": this.view.state.phrase("close"),
            onclick: () => closeLintPanel(this.view)
        }, "×"));
        this.update();
    }
    get selectedIndex() {
        let selected = this.view.state.field(lintState).selected;
        if (!selected)
            return -1;
        for (let i = 0; i < this.items.length; i++)
            if (this.items[i].diagnostic == selected.diagnostic)
                return i;
        return -1;
    }
    update() {
        let { diagnostics, selected } = this.view.state.field(lintState);
        let i = 0, needsSync = false, newSelectedItem = null;
        diagnostics.between(0, this.view.state.doc.length, (_start, _end, { spec }) => {
            let found = -1, item;
            for (let j = i; j < this.items.length; j++)
                if (this.items[j].diagnostic == spec.diagnostic) {
                    found = j;
                    break;
                }
            if (found < 0) {
                item = new PanelItem(this.view, spec.diagnostic);
                this.items.splice(i, 0, item);
                needsSync = true;
            }
            else {
                item = this.items[found];
                if (found > i) {
                    this.items.splice(i, found - i);
                    needsSync = true;
                }
            }
            if (selected && item.diagnostic == selected.diagnostic) {
                if (!item.dom.hasAttribute("aria-selected")) {
                    item.dom.setAttribute("aria-selected", "true");
                    newSelectedItem = item;
                }
            }
            else if (item.dom.hasAttribute("aria-selected")) {
                item.dom.removeAttribute("aria-selected");
            }
            i++;
        });
        while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {
            needsSync = true;
            this.items.pop();
        }
        if (this.items.length == 0) {
            this.items.push(new PanelItem(this.view, {
                from: -1, to: -1,
                severity: "info",
                message: this.view.state.phrase("No diagnostics")
            }));
            needsSync = true;
        }
        if (newSelectedItem) {
            this.list.setAttribute("aria-activedescendant", newSelectedItem.id);
            this.view.requestMeasure({
                key: this,
                read: () => ({ sel: newSelectedItem.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
                write: ({ sel, panel }) => {
                    let scaleY = panel.height / this.list.offsetHeight;
                    if (sel.top < panel.top)
                        this.list.scrollTop -= (panel.top - sel.top) / scaleY;
                    else if (sel.bottom > panel.bottom)
                        this.list.scrollTop += (sel.bottom - panel.bottom) / scaleY;
                }
            });
        }
        else if (this.selectedIndex < 0) {
            this.list.removeAttribute("aria-activedescendant");
        }
        if (needsSync)
            this.sync();
    }
    sync() {
        let domPos = this.list.firstChild;
        function rm() {
            let prev = domPos;
            domPos = prev.nextSibling;
            prev.remove();
        }
        for (let item of this.items) {
            if (item.dom.parentNode == this.list) {
                while (domPos != item.dom)
                    rm();
                domPos = item.dom.nextSibling;
            }
            else {
                this.list.insertBefore(item.dom, domPos);
            }
        }
        while (domPos)
            rm();
    }
    moveSelection(selectedIndex) {
        if (this.selectedIndex < 0)
            return;
        let field = this.view.state.field(lintState);
        let selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);
        if (!selection)
            return;
        this.view.dispatch({
            selection: { anchor: selection.from, head: selection.to },
            scrollIntoView: true,
            effects: movePanelSelection.of(selection)
        });
    }
    static open(view) { return new LintPanel(view); }
}
function svg(content, attrs = `viewBox="0 0 40 40"`) {
    return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${attrs}>${encodeURIComponent(content)}</svg>')`;
}
function underline(color) {
    return svg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${color}" fill="none" stroke-width=".7"/>`, `width="6" height="3"`);
}
const lint_dist_baseTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-diagnostic": {
        padding: "3px 6px 3px 8px",
        marginLeft: "-1px",
        display: "block",
        whiteSpace: "pre-wrap"
    },
    ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
    ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
    ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
    ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
    ".cm-diagnosticAction": {
        font: "inherit",
        border: "none",
        padding: "2px 4px",
        backgroundColor: "#444",
        color: "white",
        borderRadius: "3px",
        marginLeft: "8px",
        cursor: "pointer"
    },
    ".cm-diagnosticSource": {
        fontSize: "70%",
        opacity: .7
    },
    ".cm-lintRange": {
        backgroundPosition: "left bottom",
        backgroundRepeat: "repeat-x",
        paddingBottom: "0.7px",
    },
    ".cm-lintRange-error": { backgroundImage: /*@__PURE__*/underline("#d11") },
    ".cm-lintRange-warning": { backgroundImage: /*@__PURE__*/underline("orange") },
    ".cm-lintRange-info": { backgroundImage: /*@__PURE__*/underline("#999") },
    ".cm-lintRange-hint": { backgroundImage: /*@__PURE__*/underline("#66d") },
    ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
    ".cm-tooltip-lint": {
        padding: 0,
        margin: 0
    },
    ".cm-lintPoint": {
        position: "relative",
        "&:after": {
            content: '""',
            position: "absolute",
            bottom: 0,
            left: "-2px",
            borderLeft: "3px solid transparent",
            borderRight: "3px solid transparent",
            borderBottom: "4px solid #d11"
        }
    },
    ".cm-lintPoint-warning": {
        "&:after": { borderBottomColor: "orange" }
    },
    ".cm-lintPoint-info": {
        "&:after": { borderBottomColor: "#999" }
    },
    ".cm-lintPoint-hint": {
        "&:after": { borderBottomColor: "#66d" }
    },
    ".cm-panel.cm-panel-lint": {
        position: "relative",
        "& ul": {
            maxHeight: "100px",
            overflowY: "auto",
            "& [aria-selected]": {
                backgroundColor: "#ddd",
                "& u": { textDecoration: "underline" }
            },
            "&:focus [aria-selected]": {
                background_fallback: "#bdf",
                backgroundColor: "Highlight",
                color_fallback: "white",
                color: "HighlightText"
            },
            "& u": { textDecoration: "none" },
            padding: 0,
            margin: 0
        },
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "2px",
            background: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        }
    }
});
function severityWeight(sev) {
    return sev == "error" ? 4 : sev == "warning" ? 3 : sev == "info" ? 2 : 1;
}
class LintGutterMarker extends GutterMarker {
    constructor(diagnostics) {
        super();
        this.diagnostics = diagnostics;
        this.severity = diagnostics.reduce((max, d) => severityWeight(max) < severityWeight(d.severity) ? d.severity : max, "hint");
    }
    toDOM(view) {
        let elt = document.createElement("div");
        elt.className = "cm-lint-marker cm-lint-marker-" + this.severity;
        let diagnostics = this.diagnostics;
        let diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;
        if (diagnosticsFilter)
            diagnostics = diagnosticsFilter(diagnostics);
        if (diagnostics.length)
            elt.onmouseover = () => gutterMarkerMouseOver(view, elt, diagnostics);
        return elt;
    }
}
function trackHoverOn(view, marker) {
    let mousemove = (event) => {
        let rect = marker.getBoundingClientRect();
        if (event.clientX > rect.left - 10 /* Hover.Margin */ && event.clientX < rect.right + 10 /* Hover.Margin */ &&
            event.clientY > rect.top - 10 /* Hover.Margin */ && event.clientY < rect.bottom + 10 /* Hover.Margin */)
            return;
        for (let target = event.target; target; target = target.parentNode) {
            if (target.nodeType == 1 && target.classList.contains("cm-tooltip-lint"))
                return;
        }
        window.removeEventListener("mousemove", mousemove);
        if (view.state.field(lintGutterTooltip))
            view.dispatch({ effects: setLintGutterTooltip.of(null) });
    };
    window.addEventListener("mousemove", mousemove);
}
function gutterMarkerMouseOver(view, marker, diagnostics) {
    function hovered() {
        let line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);
        const linePos = view.coordsAtPos(line.from);
        if (linePos) {
            view.dispatch({ effects: setLintGutterTooltip.of({
                    pos: line.from,
                    above: false,
                    create() {
                        return {
                            dom: diagnosticsTooltip(view, diagnostics),
                            getCoords: () => marker.getBoundingClientRect()
                        };
                    }
                }) });
        }
        marker.onmouseout = marker.onmousemove = null;
        trackHoverOn(view, marker);
    }
    let { hoverTime } = view.state.facet(lintGutterConfig);
    let hoverTimeout = setTimeout(hovered, hoverTime);
    marker.onmouseout = () => {
        clearTimeout(hoverTimeout);
        marker.onmouseout = marker.onmousemove = null;
    };
    marker.onmousemove = () => {
        clearTimeout(hoverTimeout);
        hoverTimeout = setTimeout(hovered, hoverTime);
    };
}
function markersForDiagnostics(doc, diagnostics) {
    let byLine = Object.create(null);
    for (let diagnostic of diagnostics) {
        let line = doc.lineAt(diagnostic.from);
        (byLine[line.from] || (byLine[line.from] = [])).push(diagnostic);
    }
    let markers = [];
    for (let line in byLine) {
        markers.push(new LintGutterMarker(byLine[line]).range(+line));
    }
    return dist_RangeSet.of(markers, true);
}
const lintGutterExtension = /*@__PURE__*/gutter({
    class: "cm-gutter-lint",
    markers: view => view.state.field(lintGutterMarkers),
});
const lintGutterMarkers = /*@__PURE__*/StateField.define({
    create() {
        return dist_RangeSet.empty;
    },
    update(markers, tr) {
        markers = markers.map(tr.changes);
        let diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;
        for (let effect of tr.effects) {
            if (effect.is(setDiagnosticsEffect)) {
                let diagnostics = effect.value;
                if (diagnosticFilter)
                    diagnostics = diagnosticFilter(diagnostics || []);
                markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));
            }
        }
        return markers;
    }
});
const setLintGutterTooltip = /*@__PURE__*/StateEffect.define();
const lintGutterTooltip = /*@__PURE__*/StateField.define({
    create() { return null; },
    update(tooltip, tr) {
        if (tooltip && tr.docChanged)
            tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), { pos: tr.changes.mapPos(tooltip.pos) });
        return tr.effects.reduce((t, e) => e.is(setLintGutterTooltip) ? e.value : t, tooltip);
    },
    provide: field => showTooltip.from(field)
});
const lintGutterTheme = /*@__PURE__*/EditorView.baseTheme({
    ".cm-gutter-lint": {
        width: "1.4em",
        "& .cm-gutterElement": {
            padding: ".2em"
        }
    },
    ".cm-lint-marker": {
        width: "1em",
        height: "1em"
    },
    ".cm-lint-marker-info": {
        content: /*@__PURE__*/svg(`<path fill="#aaf" stroke="#77e" stroke-width="6" stroke-linejoin="round" d="M5 5L35 5L35 35L5 35Z"/>`)
    },
    ".cm-lint-marker-warning": {
        content: /*@__PURE__*/svg(`<path fill="#fe8" stroke="#fd7" stroke-width="6" stroke-linejoin="round" d="M20 6L37 35L3 35Z"/>`),
    },
    ".cm-lint-marker-error": {
        content: /*@__PURE__*/svg(`<circle cx="20" cy="20" r="15" fill="#f87" stroke="#f43" stroke-width="6"/>`)
    },
});
const lintExtensions = [
    lintState,
    /*@__PURE__*/EditorView.decorations.compute([lintState], state => {
        let { selected, panel } = state.field(lintState);
        return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([
            activeMark.range(selected.from, selected.to)
        ]);
    }),
    /*@__PURE__*/hoverTooltip(lintTooltip, { hideOn: hideTooltip }),
    lint_dist_baseTheme
];
const lintGutterConfig = /*@__PURE__*/Facet.define({
    combine(configs) {
        return combineConfig(configs, {
            hoverTime: 300 /* Hover.Time */,
            markerFilter: null,
            tooltipFilter: null
        });
    }
});
/**
Returns an extension that installs a gutter showing markers for
each line that has diagnostics, which can be hovered over to see
the diagnostics.
*/
function lintGutter(config = {}) {
    return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];
}
/**
Iterate over the marked diagnostics for the given editor state,
calling `f` for each of them. Note that, if the document changed
since the diagnostics were created, the `Diagnostic` object will
hold the original outdated position, whereas the `to` and `from`
arguments hold the diagnostic's current position.
*/
function forEachDiagnostic(state, f) {
    let lState = state.field(lintState, false);
    if (lState && lState.diagnostics.size)
        for (let iter = RangeSet.iter([lState.diagnostics]); iter.value; iter.next())
            f(iter.value.spec.diagnostic, iter.from, iter.to);
}



;// CONCATENATED MODULE: ./node_modules/codemirror/dist/index.js









// (The superfluous function calls around the list of extensions work
// around current limitations in tree-shaking software.)
/**
This is an extension value that just pulls together a number of
extensions that you might want in a basic editor. It is meant as a
convenient helper to quickly set up CodeMirror without installing
and importing a lot of separate packages.

Specifically, it includes...

 - [the default command bindings](https://codemirror.net/6/docs/ref/#commands.defaultKeymap)
 - [line numbers](https://codemirror.net/6/docs/ref/#view.lineNumbers)
 - [special character highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars)
 - [the undo history](https://codemirror.net/6/docs/ref/#commands.history)
 - [a fold gutter](https://codemirror.net/6/docs/ref/#language.foldGutter)
 - [custom selection drawing](https://codemirror.net/6/docs/ref/#view.drawSelection)
 - [drop cursor](https://codemirror.net/6/docs/ref/#view.dropCursor)
 - [multiple selections](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)
 - [reindentation on input](https://codemirror.net/6/docs/ref/#language.indentOnInput)
 - [the default highlight style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle) (as fallback)
 - [bracket matching](https://codemirror.net/6/docs/ref/#language.bracketMatching)
 - [bracket closing](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets)
 - [autocompletion](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion)
 - [rectangular selection](https://codemirror.net/6/docs/ref/#view.rectangularSelection) and [crosshair cursor](https://codemirror.net/6/docs/ref/#view.crosshairCursor)
 - [active line highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLine)
 - [active line gutter highlighting](https://codemirror.net/6/docs/ref/#view.highlightActiveLineGutter)
 - [selection match highlighting](https://codemirror.net/6/docs/ref/#search.highlightSelectionMatches)
 - [search](https://codemirror.net/6/docs/ref/#search.searchKeymap)
 - [linting](https://codemirror.net/6/docs/ref/#lint.lintKeymap)

(You'll probably want to add some language package to your setup
too.)

This extension does not allow customization. The idea is that,
once you decide you want to configure your editor more precisely,
you take this package's source (which is just a bunch of imports
and an array literal), copy it into your own code, and adjust it
as desired.
*/
const basicSetup = /*@__PURE__*/(() => [
    lineNumbers(),
    highlightActiveLineGutter(),
    dist_highlightSpecialChars(),
    dist_history(),
    foldGutter(),
    dist_drawSelection(),
    dropCursor(),
    EditorState.allowMultipleSelections.of(true),
    indentOnInput(),
    dist_syntaxHighlighting(dist_defaultHighlightStyle, { fallback: true }),
    bracketMatching(),
    closeBrackets(),
    autocompletion(),
    rectangularSelection(),
    crosshairCursor(),
    highlightActiveLine(),
    highlightSelectionMatches(),
    dist_keymap.of([
        ...closeBracketsKeymap,
        ...dist_defaultKeymap,
        ...searchKeymap,
        ...dist_historyKeymap,
        ...foldKeymap,
        ...completionKeymap,
        ...lintKeymap
    ])
])();
/**
A minimal set of extensions to create a functional editor. Only
includes [the default keymap](https://codemirror.net/6/docs/ref/#commands.defaultKeymap), [undo
history](https://codemirror.net/6/docs/ref/#commands.history), [special character
highlighting](https://codemirror.net/6/docs/ref/#view.highlightSpecialChars), [custom selection
drawing](https://codemirror.net/6/docs/ref/#view.drawSelection), and [default highlight
style](https://codemirror.net/6/docs/ref/#language.defaultHighlightStyle).
*/
const minimalSetup = /*@__PURE__*/(/* unused pure expression or super */ null && ((() => [
    highlightSpecialChars(),
    history(),
    drawSelection(),
    syntaxHighlighting(defaultHighlightStyle, { fallback: true }),
    keymap.of([
        ...defaultKeymap,
        ...historyKeymap,
    ])
])()));



;// CONCATENATED MODULE: ./node_modules/@codemirror/theme-one-dark/dist/index.js




// Using https://github.com/one-dark/vscode-one-dark-theme/ as reference for the colors
const chalky = "#e5c07b", coral = "#e06c75", cyan = "#56b6c2", invalid = "#ffffff", ivory = "#abb2bf", stone = "#7d8799", // Brightened compared to original to increase contrast
malibu = "#61afef", sage = "#98c379", whiskey = "#d19a66", violet = "#c678dd", darkBackground = "#21252b", highlightBackground = "#2c313a", background = "#282c34", tooltipBackground = "#353a42", selection = "#3E4451", cursor = "#528bff";
/**
The colors used in the theme, as CSS color strings.
*/
const color = {
    chalky,
    coral,
    cyan,
    invalid,
    ivory,
    stone,
    malibu,
    sage,
    whiskey,
    violet,
    darkBackground,
    highlightBackground,
    background,
    tooltipBackground,
    selection,
    cursor
};
/**
The editor theme styles for One Dark.
*/
const oneDarkTheme = /*@__PURE__*/EditorView.theme({
    "&": {
        color: ivory,
        backgroundColor: background
    },
    ".cm-content": {
        caretColor: cursor
    },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: cursor },
    "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
    ".cm-panels": { backgroundColor: darkBackground, color: ivory },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
        backgroundColor: "#72a1ff59",
        outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
        backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: "#6699ff0b" },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
        backgroundColor: "#bad0f847"
    },
    ".cm-gutters": {
        backgroundColor: background,
        color: stone,
        border: "none"
    },
    ".cm-activeLineGutter": {
        backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
        backgroundColor: "transparent",
        border: "none",
        color: "#ddd"
    },
    ".cm-tooltip": {
        border: "none",
        backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
        borderTopColor: "transparent",
        borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
        borderTopColor: tooltipBackground,
        borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
        "& > ul > li[aria-selected]": {
            backgroundColor: highlightBackground,
            color: ivory
        }
    }
}, { dark: true });
/**
The highlighting style for code in the One Dark theme.
*/
const oneDarkHighlightStyle = /*@__PURE__*/HighlightStyle.define([
    { tag: tags.keyword,
        color: violet },
    { tag: [tags.name, tags.deleted, tags.character, tags.propertyName, tags.macroName],
        color: coral },
    { tag: [/*@__PURE__*/tags.function(tags.variableName), tags.labelName],
        color: malibu },
    { tag: [tags.color, /*@__PURE__*/tags.constant(tags.name), /*@__PURE__*/tags.standard(tags.name)],
        color: whiskey },
    { tag: [/*@__PURE__*/tags.definition(tags.name), tags.separator],
        color: ivory },
    { tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
        color: chalky },
    { tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, /*@__PURE__*/tags.special(tags.string)],
        color: cyan },
    { tag: [tags.meta, tags.comment],
        color: stone },
    { tag: tags.strong,
        fontWeight: "bold" },
    { tag: tags.emphasis,
        fontStyle: "italic" },
    { tag: tags.strikethrough,
        textDecoration: "line-through" },
    { tag: tags.link,
        color: stone,
        textDecoration: "underline" },
    { tag: tags.heading,
        fontWeight: "bold",
        color: coral },
    { tag: [tags.atom, tags.bool, /*@__PURE__*/tags.special(tags.variableName)],
        color: whiskey },
    { tag: [tags.processingInstruction, tags.string, tags.inserted],
        color: sage },
    { tag: tags.invalid,
        color: invalid },
]);
/**
Extension to enable the One Dark theme (both the editor theme and
the highlight style).
*/
const oneDark = [oneDarkTheme, /*@__PURE__*/dist_syntaxHighlighting(oneDarkHighlightStyle)];



;// CONCATENATED MODULE: ./node_modules/@lezer/lr/dist/index.js


/**
A parse stack. These are used internally by the parser to track
parsing progress. They also provide some properties and methods
that external code such as a tokenizer can use to get information
about the parse state.
*/
class Stack {
    /**
    @internal
    */
    constructor(
    /**
    The parse that this stack is part of @internal
    */
    p, 
    /**
    Holds state, input pos, buffer index triplets for all but the
    top state @internal
    */
    stack, 
    /**
    The current parse state @internal
    */
    state, 
    // The position at which the next reduce should take place. This
    // can be less than `this.pos` when skipped expressions have been
    // added to the stack (which should be moved outside of the next
    // reduction)
    /**
    @internal
    */
    reducePos, 
    /**
    The input position up to which this stack has parsed.
    */
    pos, 
    /**
    The dynamic score of the stack, including dynamic precedence
    and error-recovery penalties
    @internal
    */
    score, 
    // The output buffer. Holds (type, start, end, size) quads
    // representing nodes created by the parser, where `size` is
    // amount of buffer array entries covered by this node.
    /**
    @internal
    */
    buffer, 
    // The base offset of the buffer. When stacks are split, the split
    // instance shared the buffer history with its parent up to
    // `bufferBase`, which is the absolute offset (including the
    // offset of previous splits) into the buffer at which this stack
    // starts writing.
    /**
    @internal
    */
    bufferBase, 
    /**
    @internal
    */
    curContext, 
    /**
    @internal
    */
    lookAhead = 0, 
    // A parent stack from which this was split off, if any. This is
    // set up so that it always points to a stack that has some
    // additional buffer content, never to a stack with an equal
    // `bufferBase`.
    /**
    @internal
    */
    parent) {
        this.p = p;
        this.stack = stack;
        this.state = state;
        this.reducePos = reducePos;
        this.pos = pos;
        this.score = score;
        this.buffer = buffer;
        this.bufferBase = bufferBase;
        this.curContext = curContext;
        this.lookAhead = lookAhead;
        this.parent = parent;
    }
    /**
    @internal
    */
    toString() {
        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
    }
    // Start an empty stack
    /**
    @internal
    */
    static start(p, state, pos = 0) {
        let cx = p.parser.context;
        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);
    }
    /**
    The stack's current [context](#lr.ContextTracker) value, if
    any. Its type will depend on the context tracker's type
    parameter, or it will be `null` if there is no context
    tracker.
    */
    get context() { return this.curContext ? this.curContext.context : null; }
    // Push a state onto the stack, tracking its start position as well
    // as the buffer base at that point.
    /**
    @internal
    */
    pushState(state, start) {
        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);
        this.state = state;
    }
    // Apply a reduce action
    /**
    @internal
    */
    reduce(action) {
        var _a;
        let depth = action >> 19 /* Action.ReduceDepthShift */, type = action & 65535 /* Action.ValueMask */;
        let { parser } = this.p;
        let dPrec = parser.dynamicPrecedence(type);
        if (dPrec)
            this.score += dPrec;
        if (depth == 0) {
            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);
            // Zero-depth reductions are a special case—they add stuff to
            // the stack without popping anything off.
            if (type < parser.minRepeatTerm)
                this.storeNode(type, this.reducePos, this.reducePos, 4, true);
            this.reduceContext(type, this.reducePos);
            return;
        }
        // Find the base index into `this.stack`, content after which will
        // be dropped. Note that with `StayFlag` reductions we need to
        // consume two extra frames (the dummy parent node for the skipped
        // expression and the state that we'll be staying in, which should
        // be moved to `this.state`).
        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* Action.StayFlag */ ? 6 : 0);
        let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;
        // This is a kludge to try and detect overly deep left-associative
        // trees, which will not increase the parse stack depth and thus
        // won't be caught by the regular stack-depth limit check.
        if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {
            if (start == this.p.lastBigReductionStart) {
                this.p.bigReductionCount++;
                this.p.lastBigReductionSize = size;
            }
            else if (this.p.lastBigReductionSize < size) {
                this.p.bigReductionCount = 1;
                this.p.lastBigReductionStart = start;
                this.p.lastBigReductionSize = size;
            }
        }
        let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;
        // Store normal terms or `R -> R R` repeat reductions
        if (type < parser.minRepeatTerm || (action & 131072 /* Action.RepeatFlag */)) {
            let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;
            this.storeNode(type, start, pos, count + 4, true);
        }
        if (action & 262144 /* Action.StayFlag */) {
            this.state = this.stack[base];
        }
        else {
            let baseStateID = this.stack[base - 3];
            this.state = parser.getGoto(baseStateID, type, true);
        }
        while (this.stack.length > base)
            this.stack.pop();
        this.reduceContext(type, start);
    }
    // Shift a value into the buffer
    /**
    @internal
    */
    storeNode(term, start, end, size = 4, isReduce = false) {
        if (term == 0 /* Term.Err */ &&
            (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
            // Try to omit/merge adjacent error nodes
            let cur = this, top = this.buffer.length;
            if (top == 0 && cur.parent) {
                top = cur.bufferBase - cur.parent.bufferBase;
                cur = cur.parent;
            }
            if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {
                if (start == end)
                    return;
                if (cur.buffer[top - 2] >= start) {
                    cur.buffer[top - 2] = end;
                    return;
                }
            }
        }
        if (!isReduce || this.pos == end) { // Simple case, just append
            this.buffer.push(term, start, end, size);
        }
        else { // There may be skipped nodes that have to be moved forward
            let index = this.buffer.length;
            if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */)
                while (index > 0 && this.buffer[index - 2] > end) {
                    // Move this record forward
                    this.buffer[index] = this.buffer[index - 4];
                    this.buffer[index + 1] = this.buffer[index - 3];
                    this.buffer[index + 2] = this.buffer[index - 2];
                    this.buffer[index + 3] = this.buffer[index - 1];
                    index -= 4;
                    if (size > 4)
                        size -= 4;
                }
            this.buffer[index] = term;
            this.buffer[index + 1] = start;
            this.buffer[index + 2] = end;
            this.buffer[index + 3] = size;
        }
    }
    // Apply a shift action
    /**
    @internal
    */
    shift(action, type, start, end) {
        if (action & 131072 /* Action.GotoFlag */) {
            this.pushState(action & 65535 /* Action.ValueMask */, this.pos);
        }
        else if ((action & 262144 /* Action.StayFlag */) == 0) { // Regular shift
            let nextState = action, { parser } = this.p;
            if (end > this.pos || type <= parser.maxNode) {
                this.pos = end;
                if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))
                    this.reducePos = end;
            }
            this.pushState(nextState, start);
            this.shiftContext(type, start);
            if (type <= parser.maxNode)
                this.buffer.push(type, start, end, 4);
        }
        else { // Shift-and-stay, which means this is a skipped token
            this.pos = end;
            this.shiftContext(type, start);
            if (type <= this.p.parser.maxNode)
                this.buffer.push(type, start, end, 4);
        }
    }
    // Apply an action
    /**
    @internal
    */
    apply(action, next, nextStart, nextEnd) {
        if (action & 65536 /* Action.ReduceFlag */)
            this.reduce(action);
        else
            this.shift(action, next, nextStart, nextEnd);
    }
    // Add a prebuilt (reused) node into the buffer.
    /**
    @internal
    */
    useNode(value, next) {
        let index = this.p.reused.length - 1;
        if (index < 0 || this.p.reused[index] != value) {
            this.p.reused.push(value);
            index++;
        }
        let start = this.pos;
        this.reducePos = this.pos = start + value.length;
        this.pushState(next, start);
        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));
    }
    // Split the stack. Due to the buffer sharing and the fact
    // that `this.stack` tends to stay quite shallow, this isn't very
    // expensive.
    /**
    @internal
    */
    split() {
        let parent = this;
        let off = parent.buffer.length;
        // Because the top of the buffer (after this.pos) may be mutated
        // to reorder reductions and skipped tokens, and shared buffers
        // should be immutable, this copies any outstanding skipped tokens
        // to the new buffer, and puts the base pointer before them.
        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)
            off -= 4;
        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;
        // Make sure parent points to an actual parent with content, if there is such a parent.
        while (parent && base == parent.bufferBase)
            parent = parent.parent;
        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);
    }
    // Try to recover from an error by 'deleting' (ignoring) one token.
    /**
    @internal
    */
    recoverByDelete(next, nextEnd) {
        let isNode = next <= this.p.parser.maxNode;
        if (isNode)
            this.storeNode(next, this.pos, nextEnd, 4);
        this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);
        this.pos = this.reducePos = nextEnd;
        this.score -= 190 /* Recover.Delete */;
    }
    /**
    Check if the given term would be able to be shifted (optionally
    after some reductions) on this stack. This can be useful for
    external tokenizers that want to make sure they only provide a
    given token when it applies.
    */
    canShift(term) {
        for (let sim = new SimulatedStack(this);;) {
            let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);
            if (action == 0)
                return false;
            if ((action & 65536 /* Action.ReduceFlag */) == 0)
                return true;
            sim.reduce(action);
        }
    }
    // Apply up to Recover.MaxNext recovery actions that conceptually
    // inserts some missing token or rule.
    /**
    @internal
    */
    recoverByInsert(next) {
        if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */)
            return [];
        let nextStates = this.p.parser.nextStates(this.state);
        if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {
            let best = [];
            for (let i = 0, s; i < nextStates.length; i += 2) {
                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))
                    best.push(nextStates[i], s);
            }
            if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */)
                for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {
                    let s = nextStates[i + 1];
                    if (!best.some((v, i) => (i & 1) && v == s))
                        best.push(nextStates[i], s);
                }
            nextStates = best;
        }
        let result = [];
        for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {
            let s = nextStates[i + 1];
            if (s == this.state)
                continue;
            let stack = this.split();
            stack.pushState(s, this.pos);
            stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);
            stack.shiftContext(nextStates[i], this.pos);
            stack.reducePos = this.pos;
            stack.score -= 200 /* Recover.Insert */;
            result.push(stack);
        }
        return result;
    }
    // Force a reduce, if possible. Return false if that can't
    // be done.
    /**
    @internal
    */
    forceReduce() {
        let { parser } = this.p;
        let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);
        if ((reduce & 65536 /* Action.ReduceFlag */) == 0)
            return false;
        if (!parser.validAction(this.state, reduce)) {
            let depth = reduce >> 19 /* Action.ReduceDepthShift */, term = reduce & 65535 /* Action.ValueMask */;
            let target = this.stack.length - depth * 3;
            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {
                let backup = this.findForcedReduction();
                if (backup == null)
                    return false;
                reduce = backup;
            }
            this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
            this.score -= 100 /* Recover.Reduce */;
        }
        this.reducePos = this.pos;
        this.reduce(reduce);
        return true;
    }
    /**
    Try to scan through the automaton to find some kind of reduction
    that can be applied. Used when the regular ForcedReduce field
    isn't a valid action. @internal
    */
    findForcedReduction() {
        let { parser } = this.p, seen = [];
        let explore = (state, depth) => {
            if (seen.includes(state))
                return;
            seen.push(state);
            return parser.allActions(state, (action) => {
                if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;
                else if (action & 65536 /* Action.ReduceFlag */) {
                    let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;
                    if (rDepth > 1) {
                        let term = action & 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;
                        if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0)
                            return (rDepth << 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;
                    }
                }
                else {
                    let found = explore(action, depth + 1);
                    if (found != null)
                        return found;
                }
            });
        };
        return explore(this.state, 0);
    }
    /**
    @internal
    */
    forceAll() {
        while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {
            if (!this.forceReduce()) {
                this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
                break;
            }
        }
        return this;
    }
    /**
    Check whether this state has no further actions (assumed to be a direct descendant of the
    top state, since any other states must be able to continue
    somehow). @internal
    */
    get deadEnd() {
        if (this.stack.length != 3)
            return false;
        let { parser } = this.p;
        return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &&
            !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);
    }
    /**
    Restart the stack (put it back in its start state). Only safe
    when this.stack.length == 3 (state is directly below the top
    state). @internal
    */
    restart() {
        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);
        this.state = this.stack[0];
        this.stack.length = 0;
    }
    /**
    @internal
    */
    sameState(other) {
        if (this.state != other.state || this.stack.length != other.stack.length)
            return false;
        for (let i = 0; i < this.stack.length; i += 3)
            if (this.stack[i] != other.stack[i])
                return false;
        return true;
    }
    /**
    Get the parser used by this stack.
    */
    get parser() { return this.p.parser; }
    /**
    Test whether a given dialect (by numeric ID, as exported from
    the terms file) is enabled.
    */
    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }
    shiftContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    reduceContext(term, start) {
        if (this.curContext)
            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));
    }
    /**
    @internal
    */
    emitContext() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -3)
            this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
    }
    /**
    @internal
    */
    emitLookAhead() {
        let last = this.buffer.length - 1;
        if (last < 0 || this.buffer[last] != -4)
            this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
    }
    updateContext(context) {
        if (context != this.curContext.context) {
            let newCx = new StackContext(this.curContext.tracker, context);
            if (newCx.hash != this.curContext.hash)
                this.emitContext();
            this.curContext = newCx;
        }
    }
    /**
    @internal
    */
    setLookAhead(lookAhead) {
        if (lookAhead > this.lookAhead) {
            this.emitLookAhead();
            this.lookAhead = lookAhead;
        }
    }
    /**
    @internal
    */
    close() {
        if (this.curContext && this.curContext.tracker.strict)
            this.emitContext();
        if (this.lookAhead > 0)
            this.emitLookAhead();
    }
}
class StackContext {
    constructor(tracker, context) {
        this.tracker = tracker;
        this.context = context;
        this.hash = tracker.strict ? tracker.hash(context) : 0;
    }
}
// Used to cheaply run some reductions to scan ahead without mutating
// an entire stack
class SimulatedStack {
    constructor(start) {
        this.start = start;
        this.state = start.state;
        this.stack = start.stack;
        this.base = this.stack.length;
    }
    reduce(action) {
        let term = action & 65535 /* Action.ValueMask */, depth = action >> 19 /* Action.ReduceDepthShift */;
        if (depth == 0) {
            if (this.stack == this.start.stack)
                this.stack = this.stack.slice();
            this.stack.push(this.state, 0, 0);
            this.base += 3;
        }
        else {
            this.base -= (depth - 1) * 3;
        }
        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);
        this.state = goto;
    }
}
// This is given to `Tree.build` to build a buffer, and encapsulates
// the parent-stack-walking necessary to read the nodes.
class StackBufferCursor {
    constructor(stack, pos, index) {
        this.stack = stack;
        this.pos = pos;
        this.index = index;
        this.buffer = stack.buffer;
        if (this.index == 0)
            this.maybeNext();
    }
    static create(stack, pos = stack.bufferBase + stack.buffer.length) {
        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);
    }
    maybeNext() {
        let next = this.stack.parent;
        if (next != null) {
            this.index = this.stack.bufferBase - next.bufferBase;
            this.stack = next;
            this.buffer = next.buffer;
        }
    }
    get id() { return this.buffer[this.index - 4]; }
    get start() { return this.buffer[this.index - 3]; }
    get end() { return this.buffer[this.index - 2]; }
    get size() { return this.buffer[this.index - 1]; }
    next() {
        this.index -= 4;
        this.pos -= 4;
        if (this.index == 0)
            this.maybeNext();
    }
    fork() {
        return new StackBufferCursor(this.stack, this.pos, this.index);
    }
}

// See lezer-generator/src/encode.ts for comments about the encoding
// used here
function decodeArray(input, Type = Uint16Array) {
    if (typeof input != "string")
        return input;
    let array = null;
    for (let pos = 0, out = 0; pos < input.length;) {
        let value = 0;
        for (;;) {
            let next = input.charCodeAt(pos++), stop = false;
            if (next == 126 /* Encode.BigValCode */) {
                value = 65535 /* Encode.BigVal */;
                break;
            }
            if (next >= 92 /* Encode.Gap2 */)
                next--;
            if (next >= 34 /* Encode.Gap1 */)
                next--;
            let digit = next - 32 /* Encode.Start */;
            if (digit >= 46 /* Encode.Base */) {
                digit -= 46 /* Encode.Base */;
                stop = true;
            }
            value += digit;
            if (stop)
                break;
            value *= 46 /* Encode.Base */;
        }
        if (array)
            array[out++] = value;
        else
            array = new Type(value);
    }
    return array;
}

class CachedToken {
    constructor() {
        this.start = -1;
        this.value = -1;
        this.end = -1;
        this.extended = -1;
        this.lookAhead = 0;
        this.mask = 0;
        this.context = 0;
    }
}
const nullToken = new CachedToken;
/**
[Tokenizers](#lr.ExternalTokenizer) interact with the input
through this interface. It presents the input as a stream of
characters, tracking lookahead and hiding the complexity of
[ranges](#common.Parser.parse^ranges) from tokenizer code.
*/
class InputStream {
    /**
    @internal
    */
    constructor(
    /**
    @internal
    */
    input, 
    /**
    @internal
    */
    ranges) {
        this.input = input;
        this.ranges = ranges;
        /**
        @internal
        */
        this.chunk = "";
        /**
        @internal
        */
        this.chunkOff = 0;
        /**
        Backup chunk
        */
        this.chunk2 = "";
        this.chunk2Pos = 0;
        /**
        The character code of the next code unit in the input, or -1
        when the stream is at the end of the input.
        */
        this.next = -1;
        /**
        @internal
        */
        this.token = nullToken;
        this.rangeIndex = 0;
        this.pos = this.chunkPos = ranges[0].from;
        this.range = ranges[0];
        this.end = ranges[ranges.length - 1].to;
        this.readNext();
    }
    /**
    @internal
    */
    resolveOffset(offset, assoc) {
        let range = this.range, index = this.rangeIndex;
        let pos = this.pos + offset;
        while (pos < range.from) {
            if (!index)
                return null;
            let next = this.ranges[--index];
            pos -= range.from - next.to;
            range = next;
        }
        while (assoc < 0 ? pos > range.to : pos >= range.to) {
            if (index == this.ranges.length - 1)
                return null;
            let next = this.ranges[++index];
            pos += next.from - range.to;
            range = next;
        }
        return pos;
    }
    /**
    @internal
    */
    clipPos(pos) {
        if (pos >= this.range.from && pos < this.range.to)
            return pos;
        for (let range of this.ranges)
            if (range.to > pos)
                return Math.max(pos, range.from);
        return this.end;
    }
    /**
    Look at a code unit near the stream position. `.peek(0)` equals
    `.next`, `.peek(-1)` gives you the previous character, and so
    on.
    
    Note that looking around during tokenizing creates dependencies
    on potentially far-away content, which may reduce the
    effectiveness incremental parsing—when looking forward—or even
    cause invalid reparses when looking backward more than 25 code
    units, since the library does not track lookbehind.
    */
    peek(offset) {
        let idx = this.chunkOff + offset, pos, result;
        if (idx >= 0 && idx < this.chunk.length) {
            pos = this.pos + offset;
            result = this.chunk.charCodeAt(idx);
        }
        else {
            let resolved = this.resolveOffset(offset, 1);
            if (resolved == null)
                return -1;
            pos = resolved;
            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {
                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);
            }
            else {
                let i = this.rangeIndex, range = this.range;
                while (range.to <= pos)
                    range = this.ranges[++i];
                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);
                if (pos + this.chunk2.length > range.to)
                    this.chunk2 = this.chunk2.slice(0, range.to - pos);
                result = this.chunk2.charCodeAt(0);
            }
        }
        if (pos >= this.token.lookAhead)
            this.token.lookAhead = pos + 1;
        return result;
    }
    /**
    Accept a token. By default, the end of the token is set to the
    current stream position, but you can pass an offset (relative to
    the stream position) to change that.
    */
    acceptToken(token, endOffset = 0) {
        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;
        if (end == null || end < this.token.start)
            throw new RangeError("Token end out of bounds");
        this.token.value = token;
        this.token.end = end;
    }
    getChunk() {
        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
            let { chunk, chunkPos } = this;
            this.chunk = this.chunk2;
            this.chunkPos = this.chunk2Pos;
            this.chunk2 = chunk;
            this.chunk2Pos = chunkPos;
            this.chunkOff = this.pos - this.chunkPos;
        }
        else {
            this.chunk2 = this.chunk;
            this.chunk2Pos = this.chunkPos;
            let nextChunk = this.input.chunk(this.pos);
            let end = this.pos + nextChunk.length;
            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;
            this.chunkPos = this.pos;
            this.chunkOff = 0;
        }
    }
    readNext() {
        if (this.chunkOff >= this.chunk.length) {
            this.getChunk();
            if (this.chunkOff == this.chunk.length)
                return this.next = -1;
        }
        return this.next = this.chunk.charCodeAt(this.chunkOff);
    }
    /**
    Move the stream forward N (defaults to 1) code units. Returns
    the new value of [`next`](#lr.InputStream.next).
    */
    advance(n = 1) {
        this.chunkOff += n;
        while (this.pos + n >= this.range.to) {
            if (this.rangeIndex == this.ranges.length - 1)
                return this.setDone();
            n -= this.range.to - this.pos;
            this.range = this.ranges[++this.rangeIndex];
            this.pos = this.range.from;
        }
        this.pos += n;
        if (this.pos >= this.token.lookAhead)
            this.token.lookAhead = this.pos + 1;
        return this.readNext();
    }
    setDone() {
        this.pos = this.chunkPos = this.end;
        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];
        this.chunk = "";
        return this.next = -1;
    }
    /**
    @internal
    */
    reset(pos, token) {
        if (token) {
            this.token = token;
            token.start = pos;
            token.lookAhead = pos + 1;
            token.value = token.extended = -1;
        }
        else {
            this.token = nullToken;
        }
        if (this.pos != pos) {
            this.pos = pos;
            if (pos == this.end) {
                this.setDone();
                return this;
            }
            while (pos < this.range.from)
                this.range = this.ranges[--this.rangeIndex];
            while (pos >= this.range.to)
                this.range = this.ranges[++this.rangeIndex];
            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {
                this.chunkOff = pos - this.chunkPos;
            }
            else {
                this.chunk = "";
                this.chunkOff = 0;
            }
            this.readNext();
        }
        return this;
    }
    /**
    @internal
    */
    read(from, to) {
        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)
            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);
        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)
            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);
        if (from >= this.range.from && to <= this.range.to)
            return this.input.read(from, to);
        let result = "";
        for (let r of this.ranges) {
            if (r.from >= to)
                break;
            if (r.to > from)
                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));
        }
        return result;
    }
}
/**
@internal
*/
class TokenGroup {
    constructor(data, id) {
        this.data = data;
        this.id = id;
    }
    token(input, stack) {
        let { parser } = stack.p;
        dist_readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);
    }
}
TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/**
@hide
*/
class LocalTokenGroup {
    constructor(data, precTable, elseToken) {
        this.precTable = precTable;
        this.elseToken = elseToken;
        this.data = typeof data == "string" ? decodeArray(data) : data;
    }
    token(input, stack) {
        let start = input.pos, skipped = 0;
        for (;;) {
            let atEof = input.next < 0, nextPos = input.resolveOffset(1, 1);
            dist_readToken(this.data, input, stack, 0, this.data, this.precTable);
            if (input.token.value > -1)
                break;
            if (this.elseToken == null)
                return;
            if (!atEof)
                skipped++;
            if (nextPos == null)
                break;
            input.reset(nextPos, input.token);
        }
        if (skipped) {
            input.reset(start, input.token);
            input.acceptToken(this.elseToken, skipped);
        }
    }
}
LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;
/**
`@external tokens` declarations in the grammar should resolve to
an instance of this class.
*/
class ExternalTokenizer {
    /**
    Create a tokenizer. The first argument is the function that,
    given an input stream, scans for the types of tokens it
    recognizes at the stream's position, and calls
    [`acceptToken`](#lr.InputStream.acceptToken) when it finds
    one.
    */
    constructor(
    /**
    @internal
    */
    token, options = {}) {
        this.token = token;
        this.contextual = !!options.contextual;
        this.fallback = !!options.fallback;
        this.extend = !!options.extend;
    }
}
// Tokenizer data is stored a big uint16 array containing, for each
// state:
//
//  - A group bitmask, indicating what token groups are reachable from
//    this state, so that paths that can only lead to tokens not in
//    any of the current groups can be cut off early.
//
//  - The position of the end of the state's sequence of accepting
//    tokens
//
//  - The number of outgoing edges for the state
//
//  - The accepting tokens, as (token id, group mask) pairs
//
//  - The outgoing edges, as (start character, end character, state
//    index) triples, with end character being exclusive
//
// This function interprets that data, running through a stream as
// long as new states with the a matching group mask can be reached,
// and updating `input.token` when it matches a token.
function dist_readToken(data, input, stack, group, precTable, precOffset) {
    let state = 0, groupMask = 1 << group, { dialect } = stack.p.parser;
    scan: for (;;) {
        if ((groupMask & data[state]) == 0)
            break;
        let accEnd = data[state + 1];
        // Check whether this state can lead to a token in the current group
        // Accept tokens in this state, possibly overwriting
        // lower-precedence / shorter tokens
        for (let i = state + 3; i < accEnd; i += 2)
            if ((data[i + 1] & groupMask) > 0) {
                let term = data[i];
                if (dialect.allows(term) &&
                    (input.token.value == -1 || input.token.value == term ||
                        overrides(term, input.token.value, precTable, precOffset))) {
                    input.acceptToken(term);
                    break;
                }
            }
        let next = input.next, low = 0, high = data[state + 2];
        // Special case for EOF
        if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {
            state = data[accEnd + high * 3 - 1];
            continue scan;
        }
        // Do a binary search on the state's edges
        for (; low < high;) {
            let mid = (low + high) >> 1;
            let index = accEnd + mid + (mid << 1);
            let from = data[index], to = data[index + 1] || 0x10000;
            if (next < from)
                high = mid;
            else if (next >= to)
                low = mid + 1;
            else {
                state = data[index + 2];
                input.advance();
                continue scan;
            }
        }
        break;
    }
}
function findOffset(data, start, term) {
    for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)
        if (next == term)
            return i - start;
    return -1;
}
function overrides(token, prev, tableData, tableOffset) {
    let iPrev = findOffset(tableData, tableOffset, prev);
    return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;
}

// Environment variable used to control console output
const verbose = typeof process != "undefined" && process.env && /\bparse\b/.test(process.env.LOG);
let stackIDs = null;
function cutAt(tree, pos, side) {
    let cursor = tree.cursor(IterMode.IncludeAnonymous);
    cursor.moveTo(pos);
    for (;;) {
        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))
            for (;;) {
                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)
                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))
                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));
                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())
                    break;
                if (!cursor.parent())
                    return side < 0 ? 0 : tree.length;
            }
    }
}
class dist_FragmentCursor {
    constructor(fragments, nodeSet) {
        this.fragments = fragments;
        this.nodeSet = nodeSet;
        this.i = 0;
        this.fragment = null;
        this.safeFrom = -1;
        this.safeTo = -1;
        this.trees = [];
        this.start = [];
        this.index = [];
        this.nextFragment();
    }
    nextFragment() {
        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
        if (fr) {
            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;
            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;
            while (this.trees.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
            }
            this.trees.push(fr.tree);
            this.start.push(-fr.offset);
            this.index.push(0);
            this.nextStart = this.safeFrom;
        }
        else {
            this.nextStart = 1e9;
        }
    }
    // `pos` must be >= any previously given `pos` for this cursor
    nodeAt(pos) {
        if (pos < this.nextStart)
            return null;
        while (this.fragment && this.safeTo <= pos)
            this.nextFragment();
        if (!this.fragment)
            return null;
        for (;;) {
            let last = this.trees.length - 1;
            if (last < 0) { // End of tree
                this.nextFragment();
                return null;
            }
            let top = this.trees[last], index = this.index[last];
            if (index == top.children.length) {
                this.trees.pop();
                this.start.pop();
                this.index.pop();
                continue;
            }
            let next = top.children[index];
            let start = this.start[last] + top.positions[index];
            if (start > pos) {
                this.nextStart = start;
                return null;
            }
            if (next instanceof dist_Tree) {
                if (start == pos) {
                    if (start < this.safeFrom)
                        return null;
                    let end = start + next.length;
                    if (end <= this.safeTo) {
                        let lookAhead = next.prop(dist_NodeProp.lookAhead);
                        if (!lookAhead || end + lookAhead < this.fragment.to)
                            return next;
                    }
                }
                this.index[last]++;
                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node
                    this.trees.push(next);
                    this.start.push(start);
                    this.index.push(0);
                }
            }
            else {
                this.index[last]++;
                this.nextStart = start + next.length;
            }
        }
    }
}
class TokenCache {
    constructor(parser, stream) {
        this.stream = stream;
        this.tokens = [];
        this.mainToken = null;
        this.actions = [];
        this.tokens = parser.tokenizers.map(_ => new CachedToken);
    }
    getActions(stack) {
        let actionIndex = 0;
        let main = null;
        let { parser } = stack.p, { tokenizers } = parser;
        let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);
        let context = stack.curContext ? stack.curContext.hash : 0;
        let lookAhead = 0;
        for (let i = 0; i < tokenizers.length; i++) {
            if (((1 << i) & mask) == 0)
                continue;
            let tokenizer = tokenizers[i], token = this.tokens[i];
            if (main && !tokenizer.fallback)
                continue;
            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {
                this.updateCachedToken(token, tokenizer, stack);
                token.mask = mask;
                token.context = context;
            }
            if (token.lookAhead > token.end + 25 /* Safety.Margin */)
                lookAhead = Math.max(token.lookAhead, lookAhead);
            if (token.value != 0 /* Term.Err */) {
                let startIndex = actionIndex;
                if (token.extended > -1)
                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);
                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);
                if (!tokenizer.extend) {
                    main = token;
                    if (actionIndex > startIndex)
                        break;
                }
            }
        }
        while (this.actions.length > actionIndex)
            this.actions.pop();
        if (lookAhead)
            stack.setLookAhead(lookAhead);
        if (!main && stack.pos == this.stream.end) {
            main = new CachedToken;
            main.value = stack.p.parser.eofTerm;
            main.start = main.end = stack.pos;
            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);
        }
        this.mainToken = main;
        return this.actions;
    }
    getMainToken(stack) {
        if (this.mainToken)
            return this.mainToken;
        let main = new CachedToken, { pos, p } = stack;
        main.start = pos;
        main.end = Math.min(pos + 1, p.stream.end);
        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;
        return main;
    }
    updateCachedToken(token, tokenizer, stack) {
        let start = this.stream.clipPos(stack.pos);
        tokenizer.token(this.stream.reset(start, token), stack);
        if (token.value > -1) {
            let { parser } = stack.p;
            for (let i = 0; i < parser.specialized.length; i++)
                if (parser.specialized[i] == token.value) {
                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);
                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {
                        if ((result & 1) == 0 /* Specialize.Specialize */)
                            token.value = result >> 1;
                        else
                            token.extended = result >> 1;
                        break;
                    }
                }
        }
        else {
            token.value = 0 /* Term.Err */;
            token.end = this.stream.clipPos(start + 1);
        }
    }
    putAction(action, token, end, index) {
        // Don't add duplicate actions
        for (let i = 0; i < index; i += 3)
            if (this.actions[i] == action)
                return index;
        this.actions[index++] = action;
        this.actions[index++] = token;
        this.actions[index++] = end;
        return index;
    }
    addActions(stack, token, end, index) {
        let { state } = stack, { parser } = stack.p, { data } = parser;
        for (let set = 0; set < 2; set++) {
            for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {
                if (data[i] == 65535 /* Seq.End */) {
                    if (data[i + 1] == 1 /* Seq.Next */) {
                        i = pair(data, i + 2);
                    }
                    else {
                        if (index == 0 && data[i + 1] == 2 /* Seq.Other */)
                            index = this.putAction(pair(data, i + 2), token, end, index);
                        break;
                    }
                }
                if (data[i] == token)
                    index = this.putAction(pair(data, i + 1), token, end, index);
            }
        }
        return index;
    }
}
class dist_Parse {
    constructor(parser, input, fragments, ranges) {
        this.parser = parser;
        this.input = input;
        this.ranges = ranges;
        this.recovering = 0;
        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧
        this.minStackPos = 0;
        this.reused = [];
        this.stoppedAt = null;
        this.lastBigReductionStart = -1;
        this.lastBigReductionSize = 0;
        this.bigReductionCount = 0;
        this.stream = new InputStream(input, ranges);
        this.tokens = new TokenCache(parser, this.stream);
        this.topTerm = parser.top[1];
        let { from } = ranges[0];
        this.stacks = [Stack.start(this, parser.top[0], from)];
        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4
            ? new dist_FragmentCursor(fragments, parser.nodeSet) : null;
    }
    get parsedPos() {
        return this.minStackPos;
    }
    // Move the parser forward. This will process all parse stacks at
    // `this.pos` and try to advance them to a further position. If no
    // stack for such a position is found, it'll start error-recovery.
    //
    // When the parse is finished, this will return a syntax tree. When
    // not, it returns `null`.
    advance() {
        let stacks = this.stacks, pos = this.minStackPos;
        // This will hold stacks beyond `pos`.
        let newStacks = this.stacks = [];
        let stopped, stoppedTokens;
        // If a large amount of reductions happened with the same start
        // position, force the stack out of that production in order to
        // avoid creating a tree too deep to recurse through.
        // (This is an ugly kludge, because unfortunately there is no
        // straightforward, cheap way to check for this happening, due to
        // the history of reductions only being available in an
        // expensive-to-access format in the stack buffers.)
        if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {
            let [s] = stacks;
            while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) { }
            this.bigReductionCount = this.lastBigReductionSize = 0;
        }
        // Keep advancing any stacks at `pos` until they either move
        // forward or can't be advanced. Gather stacks that can't be
        // advanced further in `stopped`.
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i];
            for (;;) {
                this.tokens.mainToken = null;
                if (stack.pos > pos) {
                    newStacks.push(stack);
                }
                else if (this.advanceStack(stack, newStacks, stacks)) {
                    continue;
                }
                else {
                    if (!stopped) {
                        stopped = [];
                        stoppedTokens = [];
                    }
                    stopped.push(stack);
                    let tok = this.tokens.getMainToken(stack);
                    stoppedTokens.push(tok.value, tok.end);
                }
                break;
            }
        }
        if (!newStacks.length) {
            let finished = stopped && findFinished(stopped);
            if (finished) {
                if (verbose)
                    console.log("Finish with " + this.stackID(finished));
                return this.stackToTree(finished);
            }
            if (this.parser.strict) {
                if (verbose && stopped)
                    console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none"));
                throw new SyntaxError("No parse at " + pos);
            }
            if (!this.recovering)
                this.recovering = 5 /* Rec.Distance */;
        }
        if (this.recovering && stopped) {
            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]
                : this.runRecovery(stopped, stoppedTokens, newStacks);
            if (finished) {
                if (verbose)
                    console.log("Force-finish " + this.stackID(finished));
                return this.stackToTree(finished.forceAll());
            }
        }
        if (this.recovering) {
            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;
            if (newStacks.length > maxRemaining) {
                newStacks.sort((a, b) => b.score - a.score);
                while (newStacks.length > maxRemaining)
                    newStacks.pop();
            }
            if (newStacks.some(s => s.reducePos > pos))
                this.recovering--;
        }
        else if (newStacks.length > 1) {
            // Prune stacks that are in the same state, or that have been
            // running without splitting for a while, to avoid getting stuck
            // with multiple successful stacks running endlessly on.
            outer: for (let i = 0; i < newStacks.length - 1; i++) {
                let stack = newStacks[i];
                for (let j = i + 1; j < newStacks.length; j++) {
                    let other = newStacks[j];
                    if (stack.sameState(other) ||
                        stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {
                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {
                            newStacks.splice(j--, 1);
                        }
                        else {
                            newStacks.splice(i--, 1);
                            continue outer;
                        }
                    }
                }
            }
            if (newStacks.length > 12 /* Rec.MaxStackCount */)
                newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);
        }
        this.minStackPos = newStacks[0].pos;
        for (let i = 1; i < newStacks.length; i++)
            if (newStacks[i].pos < this.minStackPos)
                this.minStackPos = newStacks[i].pos;
        return null;
    }
    stopAt(pos) {
        if (this.stoppedAt != null && this.stoppedAt < pos)
            throw new RangeError("Can't move stoppedAt forward");
        this.stoppedAt = pos;
    }
    // Returns an updated version of the given stack, or null if the
    // stack can't advance normally. When `split` and `stacks` are
    // given, stacks split off by ambiguous operations will be pushed to
    // `split`, or added to `stacks` if they move `pos` forward.
    advanceStack(stack, stacks, split) {
        let start = stack.pos, { parser } = this;
        let base = verbose ? this.stackID(stack) + " -> " : "";
        if (this.stoppedAt != null && start > this.stoppedAt)
            return stack.forceReduce() ? stack : null;
        if (this.fragments) {
            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;
            for (let cached = this.fragments.nodeAt(start); cached;) {
                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;
                if (match > -1 && cached.length && (!strictCx || (cached.prop(dist_NodeProp.contextHash) || 0) == cxHash)) {
                    stack.useNode(cached, match);
                    if (verbose)
                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);
                    return true;
                }
                if (!(cached instanceof dist_Tree) || cached.children.length == 0 || cached.positions[0] > 0)
                    break;
                let inner = cached.children[0];
                if (inner instanceof dist_Tree && cached.positions[0] == 0)
                    cached = inner;
                else
                    break;
            }
        }
        let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);
        if (defaultReduce > 0) {
            stack.reduce(defaultReduce);
            if (verbose)
                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);
            return true;
        }
        if (stack.stack.length >= 8400 /* Rec.CutDepth */) {
            while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) { }
        }
        let actions = this.tokens.getActions(stack);
        for (let i = 0; i < actions.length;) {
            let action = actions[i++], term = actions[i++], end = actions[i++];
            let last = i == actions.length || !split;
            let localStack = last ? stack : stack.split();
            let main = this.tokens.mainToken;
            localStack.apply(action, term, main ? main.start : localStack.pos, end);
            if (verbose)
                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? "shift"
                    : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? "" : ", split"})`);
            if (last)
                return true;
            else if (localStack.pos > start)
                stacks.push(localStack);
            else
                split.push(localStack);
        }
        return false;
    }
    // Advance a given stack forward as far as it will go. Returns the
    // (possibly updated) stack if it got stuck, or null if it moved
    // forward and was given to `pushStackDedup`.
    advanceFully(stack, newStacks) {
        let pos = stack.pos;
        for (;;) {
            if (!this.advanceStack(stack, null, null))
                return false;
            if (stack.pos > pos) {
                pushStackDedup(stack, newStacks);
                return true;
            }
        }
    }
    runRecovery(stacks, tokens, newStacks) {
        let finished = null, restarted = false;
        for (let i = 0; i < stacks.length; i++) {
            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];
            let base = verbose ? this.stackID(stack) + " -> " : "";
            if (stack.deadEnd) {
                if (restarted)
                    continue;
                restarted = true;
                stack.restart();
                if (verbose)
                    console.log(base + this.stackID(stack) + " (restarted)");
                let done = this.advanceFully(stack, newStacks);
                if (done)
                    continue;
            }
            let force = stack.split(), forceBase = base;
            for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {
                if (verbose)
                    console.log(forceBase + this.stackID(force) + " (via force-reduce)");
                let done = this.advanceFully(force, newStacks);
                if (done)
                    break;
                if (verbose)
                    forceBase = this.stackID(force) + " -> ";
            }
            for (let insert of stack.recoverByInsert(token)) {
                if (verbose)
                    console.log(base + this.stackID(insert) + " (via recover-insert)");
                this.advanceFully(insert, newStacks);
            }
            if (this.stream.end > stack.pos) {
                if (tokenEnd == stack.pos) {
                    tokenEnd++;
                    token = 0 /* Term.Err */;
                }
                stack.recoverByDelete(token, tokenEnd);
                if (verbose)
                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);
                pushStackDedup(stack, newStacks);
            }
            else if (!finished || finished.score < stack.score) {
                finished = stack;
            }
        }
        return finished;
    }
    // Convert the stack's buffer to a syntax tree.
    stackToTree(stack) {
        stack.close();
        return dist_Tree.build({ buffer: StackBufferCursor.create(stack),
            nodeSet: this.parser.nodeSet,
            topID: this.topTerm,
            maxBufferLength: this.parser.bufferLength,
            reused: this.reused,
            start: this.ranges[0].from,
            length: stack.pos - this.ranges[0].from,
            minRepeatType: this.parser.minRepeatTerm });
    }
    stackID(stack) {
        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);
        if (!id)
            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));
        return id + stack;
    }
}
function pushStackDedup(stack, newStacks) {
    for (let i = 0; i < newStacks.length; i++) {
        let other = newStacks[i];
        if (other.pos == stack.pos && other.sameState(stack)) {
            if (newStacks[i].score < stack.score)
                newStacks[i] = stack;
            return;
        }
    }
    newStacks.push(stack);
}
class Dialect {
    constructor(source, flags, disabled) {
        this.source = source;
        this.flags = flags;
        this.disabled = disabled;
    }
    allows(term) { return !this.disabled || this.disabled[term] == 0; }
}
const id = x => x;
/**
Context trackers are used to track stateful context (such as
indentation in the Python grammar, or parent elements in the XML
grammar) needed by external tokenizers. You declare them in a
grammar file as `@context exportName from "module"`.

Context values should be immutable, and can be updated (replaced)
on shift or reduce actions.

The export used in a `@context` declaration should be of this
type.
*/
class ContextTracker {
    /**
    Define a context tracker.
    */
    constructor(spec) {
        this.start = spec.start;
        this.shift = spec.shift || id;
        this.reduce = spec.reduce || id;
        this.reuse = spec.reuse || id;
        this.hash = spec.hash || (() => 0);
        this.strict = spec.strict !== false;
    }
}
/**
Holds the parse tables for a given grammar, as generated by
`lezer-generator`, and provides [methods](#common.Parser) to parse
content with.
*/
class LRParser extends dist_Parser {
    /**
    @internal
    */
    constructor(spec) {
        super();
        /**
        @internal
        */
        this.wrappers = [];
        if (spec.version != 14 /* File.Version */)
            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);
        let nodeNames = spec.nodeNames.split(" ");
        this.minRepeatTerm = nodeNames.length;
        for (let i = 0; i < spec.repeatNodeCount; i++)
            nodeNames.push("");
        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);
        let nodeProps = [];
        for (let i = 0; i < nodeNames.length; i++)
            nodeProps.push([]);
        function setProp(nodeID, prop, value) {
            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);
        }
        if (spec.nodeProps)
            for (let propSpec of spec.nodeProps) {
                let prop = propSpec[0];
                if (typeof prop == "string")
                    prop = dist_NodeProp[prop];
                for (let i = 1; i < propSpec.length;) {
                    let next = propSpec[i++];
                    if (next >= 0) {
                        setProp(next, prop, propSpec[i++]);
                    }
                    else {
                        let value = propSpec[i + -next];
                        for (let j = -next; j > 0; j--)
                            setProp(propSpec[i++], prop, value);
                        i++;
                    }
                }
            }
        this.nodeSet = new NodeSet(nodeNames.map((name, i) => dist_NodeType.define({
            name: i >= this.minRepeatTerm ? undefined : name,
            id: i,
            props: nodeProps[i],
            top: topTerms.indexOf(i) > -1,
            error: i == 0,
            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1
        })));
        if (spec.propSources)
            this.nodeSet = this.nodeSet.extend(...spec.propSources);
        this.strict = false;
        this.bufferLength = DefaultBufferLength;
        let tokenArray = decodeArray(spec.tokenData);
        this.context = spec.context;
        this.specializerSpecs = spec.specialized || [];
        this.specialized = new Uint16Array(this.specializerSpecs.length);
        for (let i = 0; i < this.specializerSpecs.length; i++)
            this.specialized[i] = this.specializerSpecs[i].term;
        this.specializers = this.specializerSpecs.map(getSpecializer);
        this.states = decodeArray(spec.states, Uint32Array);
        this.data = decodeArray(spec.stateData);
        this.goto = decodeArray(spec.goto);
        this.maxTerm = spec.maxTerm;
        this.tokenizers = spec.tokenizers.map(value => typeof value == "number" ? new TokenGroup(tokenArray, value) : value);
        this.topRules = spec.topRules;
        this.dialects = spec.dialects || {};
        this.dynamicPrecedences = spec.dynamicPrecedences || null;
        this.tokenPrecTable = spec.tokenPrec;
        this.termNames = spec.termNames || null;
        this.maxNode = this.nodeSet.types.length - 1;
        this.dialect = this.parseDialect();
        this.top = this.topRules[Object.keys(this.topRules)[0]];
    }
    createParse(input, fragments, ranges) {
        let parse = new dist_Parse(this, input, fragments, ranges);
        for (let w of this.wrappers)
            parse = w(parse, input, fragments, ranges);
        return parse;
    }
    /**
    Get a goto table entry @internal
    */
    getGoto(state, term, loose = false) {
        let table = this.goto;
        if (term >= table[0])
            return -1;
        for (let pos = table[term + 1];;) {
            let groupTag = table[pos++], last = groupTag & 1;
            let target = table[pos++];
            if (last && loose)
                return target;
            for (let end = pos + (groupTag >> 1); pos < end; pos++)
                if (table[pos] == state)
                    return target;
            if (last)
                return -1;
        }
    }
    /**
    Check if this state has an action for a given terminal @internal
    */
    hasAction(state, terminal) {
        let data = this.data;
        for (let set = 0; set < 2; set++) {
            for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {
                if ((next = data[i]) == 65535 /* Seq.End */) {
                    if (data[i + 1] == 1 /* Seq.Next */)
                        next = data[i = pair(data, i + 2)];
                    else if (data[i + 1] == 2 /* Seq.Other */)
                        return pair(data, i + 2);
                    else
                        break;
                }
                if (next == terminal || next == 0 /* Term.Err */)
                    return pair(data, i + 1);
            }
        }
        return 0;
    }
    /**
    @internal
    */
    stateSlot(state, slot) {
        return this.states[(state * 6 /* ParseState.Size */) + slot];
    }
    /**
    @internal
    */
    stateFlag(state, flag) {
        return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;
    }
    /**
    @internal
    */
    validAction(state, action) {
        return !!this.allActions(state, a => a == action ? true : null);
    }
    /**
    @internal
    */
    allActions(state, action) {
        let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);
        let result = deflt ? action(deflt) : undefined;
        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {
            if (this.data[i] == 65535 /* Seq.End */) {
                if (this.data[i + 1] == 1 /* Seq.Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            result = action(pair(this.data, i + 1));
        }
        return result;
    }
    /**
    Get the states that can follow this one through shift actions or
    goto jumps. @internal
    */
    nextStates(state) {
        let result = [];
        for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {
            if (this.data[i] == 65535 /* Seq.End */) {
                if (this.data[i + 1] == 1 /* Seq.Next */)
                    i = pair(this.data, i + 2);
                else
                    break;
            }
            if ((this.data[i + 2] & (65536 /* Action.ReduceFlag */ >> 16)) == 0) {
                let value = this.data[i + 1];
                if (!result.some((v, i) => (i & 1) && v == value))
                    result.push(this.data[i], value);
            }
        }
        return result;
    }
    /**
    Configure the parser. Returns a new parser instance that has the
    given settings modified. Settings not provided in `config` are
    kept from the original parser.
    */
    configure(config) {
        // Hideous reflection-based kludge to make it easy to create a
        // slightly modified copy of a parser.
        let copy = Object.assign(Object.create(LRParser.prototype), this);
        if (config.props)
            copy.nodeSet = this.nodeSet.extend(...config.props);
        if (config.top) {
            let info = this.topRules[config.top];
            if (!info)
                throw new RangeError(`Invalid top rule name ${config.top}`);
            copy.top = info;
        }
        if (config.tokenizers)
            copy.tokenizers = this.tokenizers.map(t => {
                let found = config.tokenizers.find(r => r.from == t);
                return found ? found.to : t;
            });
        if (config.specializers) {
            copy.specializers = this.specializers.slice();
            copy.specializerSpecs = this.specializerSpecs.map((s, i) => {
                let found = config.specializers.find(r => r.from == s.external);
                if (!found)
                    return s;
                let spec = Object.assign(Object.assign({}, s), { external: found.to });
                copy.specializers[i] = getSpecializer(spec);
                return spec;
            });
        }
        if (config.contextTracker)
            copy.context = config.contextTracker;
        if (config.dialect)
            copy.dialect = this.parseDialect(config.dialect);
        if (config.strict != null)
            copy.strict = config.strict;
        if (config.wrap)
            copy.wrappers = copy.wrappers.concat(config.wrap);
        if (config.bufferLength != null)
            copy.bufferLength = config.bufferLength;
        return copy;
    }
    /**
    Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
    are registered for this parser.
    */
    hasWrappers() {
        return this.wrappers.length > 0;
    }
    /**
    Returns the name associated with a given term. This will only
    work for all terms when the parser was generated with the
    `--names` option. By default, only the names of tagged terms are
    stored.
    */
    getName(term) {
        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);
    }
    /**
    The eof term id is always allocated directly after the node
    types. @internal
    */
    get eofTerm() { return this.maxNode + 1; }
    /**
    The type of top node produced by the parser.
    */
    get topNode() { return this.nodeSet.types[this.top[1]]; }
    /**
    @internal
    */
    dynamicPrecedence(term) {
        let prec = this.dynamicPrecedences;
        return prec == null ? 0 : prec[term] || 0;
    }
    /**
    @internal
    */
    parseDialect(dialect) {
        let values = Object.keys(this.dialects), flags = values.map(() => false);
        if (dialect)
            for (let part of dialect.split(" ")) {
                let id = values.indexOf(part);
                if (id >= 0)
                    flags[id] = true;
            }
        let disabled = null;
        for (let i = 0; i < values.length; i++)
            if (!flags[i]) {
                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)
                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;
            }
        return new Dialect(dialect, flags, disabled);
    }
    /**
    Used by the output of the parser generator. Not available to
    user code. @hide
    */
    static deserialize(spec) {
        return new LRParser(spec);
    }
}
function pair(data, off) { return data[off] | (data[off + 1] << 16); }
function findFinished(stacks) {
    let best = null;
    for (let stack of stacks) {
        let stopped = stack.p.stoppedAt;
        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&
            stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &&
            (!best || best.score < stack.score))
            best = stack;
    }
    return best;
}
function getSpecializer(spec) {
    if (spec.external) {
        let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;
        return (value, stack) => (spec.external(value, stack) << 1) | mask;
    }
    return spec.get;
}



;// CONCATENATED MODULE: ./node_modules/@lezer/css/dist/index.js



// This file was generated by lezer-generator. You probably shouldn't edit it.
const descendantOp = 96,
  Unit = 1,
  callee = 97,
  identifier = 98,
  VariableName = 2;

/* Hand-written tokenizers for CSS tokens that can't be
   expressed by Lezer's built-in tokenizer. */

const space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197,
               8198, 8199, 8200, 8201, 8202, 8232, 8233, 8239, 8287, 12288];
const colon = 58, parenL = 40, underscore = 95, bracketL = 91, dash = 45, period = 46,
      hash = 35, percent = 37, ampersand = 38, backslash = 92, newline = 10;

function isAlpha(ch) { return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 161 }

function isDigit(ch) { return ch >= 48 && ch <= 57 }

const identifiers = new ExternalTokenizer((input, stack) => {
  for (let inside = false, dashes = 0, i = 0;; i++) {
    let {next} = input;
    if (isAlpha(next) || next == dash || next == underscore || (inside && isDigit(next))) {
      if (!inside && (next != dash || i > 0)) inside = true;
      if (dashes === i && next == dash) dashes++;
      input.advance();
    } else if (next == backslash && input.peek(1) != newline) {
      input.advance();
      if (input.next > -1) input.advance();
      inside = true;
    } else {
      if (inside)
        input.acceptToken(next == parenL ? callee : dashes == 2 && stack.canShift(VariableName) ? VariableName : identifier);
      break
    }
  }
});

const descendant = new ExternalTokenizer(input => {
  if (space.includes(input.peek(-1))) {
    let {next} = input;
    if (isAlpha(next) || next == underscore || next == hash || next == period ||
        next == bracketL || next == colon || next == dash || next == ampersand)
      input.acceptToken(descendantOp);
  }
});

const unitToken = new ExternalTokenizer(input => {
  if (!space.includes(input.peek(-1))) {
    let {next} = input;
    if (next == percent) { input.advance(); input.acceptToken(Unit); }
    if (isAlpha(next)) {
      do { input.advance(); } while (isAlpha(input.next))
      input.acceptToken(Unit);
    }
  }
});

const cssHighlighting = styleTags({
  "AtKeyword import charset namespace keyframes media supports": tags.definitionKeyword,
  "from to selector": tags.keyword,
  NamespaceName: tags.namespace,
  KeyframeName: tags.labelName,
  KeyframeRangeName: tags.operatorKeyword,
  TagName: tags.tagName,
  ClassName: tags.className,
  PseudoClassName: tags.constant(tags.className),
  IdName: tags.labelName,
  "FeatureName PropertyName": tags.propertyName,
  AttributeName: tags.attributeName,
  NumberLiteral: tags.number,
  KeywordQuery: tags.keyword,
  UnaryQueryOp: tags.operatorKeyword,
  "CallTag ValueName": tags.atom,
  VariableName: tags.variableName,
  Callee: tags.operatorKeyword,
  Unit: tags.unit,
  "UniversalSelector NestingSelector": tags.definitionOperator,
  MatchOp: tags.compareOperator,
  "ChildOp SiblingOp, LogicOp": tags.logicOperator,
  BinOp: tags.arithmeticOperator,
  Important: tags.modifier,
  Comment: tags.blockComment,
  ColorLiteral: tags.color,
  "ParenthesizedContent StringLiteral": tags.string,
  ":": tags.punctuation,
  "PseudoOp #": tags.derefOperator,
  "; ,": tags.separator,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_callee = {__proto__:null,lang:32, "nth-child":32, "nth-last-child":32, "nth-of-type":32, "nth-last-of-type":32, dir:32, "host-context":32, url:60, "url-prefix":60, domain:60, regexp:60, selector:134};
const spec_AtKeyword = {__proto__:null,"@import":114, "@media":138, "@charset":142, "@namespace":146, "@keyframes":152, "@supports":164};
const spec_identifier = {__proto__:null,not:128, only:128};
const parser = LRParser.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17,"(",48,"{"],
    ["closedBy", 18,")",49,"}"]
  ],
  propSources: [cssHighlighting],
  skippedNodes: [0,3,85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [descendant, unitToken, identifiers, 1, 2, 3, 4, new LocalTokenGroup("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: {"StyleSheet":[0,4],"Styles":[1,84]},
  specialized: [{term: 97, get: (value) => spec_callee[value] || -1},{term: 56, get: (value) => spec_AtKeyword[value] || -1},{term: 98, get: (value) => spec_identifier[value] || -1}],
  tokenPrec: 1169
});



;// CONCATENATED MODULE: ./node_modules/@codemirror/lang-css/dist/index.js




let _properties = null;
function properties() {
    if (!_properties && typeof document == "object" && document.body) {
        let { style } = document.body, names = [], seen = new Set;
        for (let prop in style)
            if (prop != "cssText" && prop != "cssFloat") {
                if (typeof style[prop] == "string") {
                    if (/[A-Z]/.test(prop))
                        prop = prop.replace(/[A-Z]/g, ch => "-" + ch.toLowerCase());
                    if (!seen.has(prop)) {
                        names.push(prop);
                        seen.add(prop);
                    }
                }
            }
        _properties = names.sort().map(name => ({ type: "property", label: name }));
    }
    return _properties || [];
}
const pseudoClasses = /*@__PURE__*/[
    "active", "after", "any-link", "autofill", "backdrop", "before",
    "checked", "cue", "default", "defined", "disabled", "empty",
    "enabled", "file-selector-button", "first", "first-child",
    "first-letter", "first-line", "first-of-type", "focus",
    "focus-visible", "focus-within", "fullscreen", "has", "host",
    "host-context", "hover", "in-range", "indeterminate", "invalid",
    "is", "lang", "last-child", "last-of-type", "left", "link", "marker",
    "modal", "not", "nth-child", "nth-last-child", "nth-last-of-type",
    "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range",
    "part", "placeholder", "placeholder-shown", "read-only", "read-write",
    "required", "right", "root", "scope", "selection", "slotted", "target",
    "target-text", "valid", "visited", "where"
].map(name => ({ type: "class", label: name }));
const values = /*@__PURE__*/[
    "above", "absolute", "activeborder", "additive", "activecaption", "after-white-space",
    "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always",
    "antialiased", "appworkspace", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column",
    "avoid-page", "avoid-region", "axis-pan", "background", "backwards", "baseline", "below",
    "bidi-override", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "capitalize",
    "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle",
    "cjk-decimal", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn",
    "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content",
    "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover",
    "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in",
    "destination-out", "destination-over", "difference", "disc", "discard", "disclosure-closed",
    "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize",
    "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end",
    "ethiopic-abegede-gez", "ethiopic-halehame-aa-er", "ethiopic-halehame-gez", "ew-resize", "exclusion",
    "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fill-box",
    "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from",
    "geometricPrecision", "graytext", "grid", "groove", "hand", "hard-light", "help", "hidden", "hide",
    "higher", "highlight", "highlighttext", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext",
    "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid",
    "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "justify", "keep-all",
    "landscape", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear",
    "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower",
    "lower-hexadecimal", "lower-latin", "lower-norwegian", "lowercase", "ltr", "luminosity", "manipulation",
    "match", "matrix", "matrix3d", "medium", "menu", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "n-resize", "narrower",
    "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none",
    "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize",
    "oblique", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "outset", "outside",
    "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused",
    "perspective", "pinch-zoom", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait",
    "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio",
    "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat",
    "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round",
    "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation",
    "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position",
    "se-resize", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show",
    "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps",
    "small-caption", "smaller", "soft-light", "solid", "source-atop", "source-in", "source-out",
    "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "start",
    "static", "status-bar", "stretch", "stroke", "stroke-box", "sub", "subpixel-antialiased", "svg_masks",
    "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell",
    "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row",
    "table-row-group", "text", "text-bottom", "text-top", "textarea", "textfield", "thick", "thin",
    "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "to", "top",
    "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent",
    "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up", "upper-latin",
    "uppercase", "url", "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill",
    "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe",
    "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"
].map(name => ({ type: "keyword", label: name })).concat(/*@__PURE__*/[
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
].map(name => ({ type: "constant", label: name })));
const dist_tags = /*@__PURE__*/[
    "a", "abbr", "address", "article", "aside", "b", "bdi", "bdo", "blockquote", "body",
    "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "dd", "del",
    "details", "dfn", "dialog", "div", "dl", "dt", "em", "figcaption", "figure", "footer",
    "form", "header", "hgroup", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "html", "i", "iframe",
    "img", "input", "ins", "kbd", "label", "legend", "li", "main", "meter", "nav", "ol", "output",
    "p", "pre", "ruby", "section", "select", "small", "source", "span", "strong", "sub", "summary",
    "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "tr", "u", "ul"
].map(name => ({ type: "type", label: name }));
const dist_identifier = /^(\w[\w-]*|-\w[\w-]*|)$/, variable = /^-(-[\w-]*)?$/;
function isVarArg(node, doc) {
    var _a;
    if (node.name == "(" || node.type.isError)
        node = node.parent || node;
    if (node.name != "ArgList")
        return false;
    let callee = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.firstChild;
    if ((callee === null || callee === void 0 ? void 0 : callee.name) != "Callee")
        return false;
    return doc.sliceString(callee.from, callee.to) == "var";
}
const VariablesByNode = /*@__PURE__*/new NodeWeakMap();
const declSelector = ["Declaration"];
function astTop(node) {
    for (let cur = node;;) {
        if (cur.type.isTop)
            return cur;
        if (!(cur = cur.parent))
            return node;
    }
}
function variableNames(doc, node, isVariable) {
    if (node.to - node.from > 4096) {
        let known = VariablesByNode.get(node);
        if (known)
            return known;
        let result = [], seen = new Set, cursor = node.cursor(IterMode.IncludeAnonymous);
        if (cursor.firstChild())
            do {
                for (let option of variableNames(doc, cursor.node, isVariable))
                    if (!seen.has(option.label)) {
                        seen.add(option.label);
                        result.push(option);
                    }
            } while (cursor.nextSibling());
        VariablesByNode.set(node, result);
        return result;
    }
    else {
        let result = [], seen = new Set;
        node.cursor().iterate(node => {
            var _a;
            if (isVariable(node) && node.matchContext(declSelector) && ((_a = node.node.nextSibling) === null || _a === void 0 ? void 0 : _a.name) == ":") {
                let name = doc.sliceString(node.from, node.to);
                if (!seen.has(name)) {
                    seen.add(name);
                    result.push({ label: name, type: "variable" });
                }
            }
        });
        return result;
    }
}
/**
Create a completion source for a CSS dialect, providing a
predicate for determining what kind of syntax node can act as a
completable variable. This is used by language modes like Sass and
Less to reuse this package's completion logic.
*/
const defineCSSCompletionSource = (isVariable) => context => {
    let { state, pos } = context, node = dist_syntaxTree(state).resolveInner(pos, -1);
    let isDash = node.type.isError && node.from == node.to - 1 && state.doc.sliceString(node.from, node.to) == "-";
    if (node.name == "PropertyName" ||
        (isDash || node.name == "TagName") && /^(Block|Styles)$/.test(node.resolve(node.to).name))
        return { from: node.from, options: properties(), validFor: dist_identifier };
    if (node.name == "ValueName")
        return { from: node.from, options: values, validFor: dist_identifier };
    if (node.name == "PseudoClassName")
        return { from: node.from, options: pseudoClasses, validFor: dist_identifier };
    if (isVariable(node) || (context.explicit || isDash) && isVarArg(node, state.doc))
        return { from: isVariable(node) || isDash ? node.from : pos,
            options: variableNames(state.doc, astTop(node), isVariable),
            validFor: variable };
    if (node.name == "TagName") {
        for (let { parent } = node; parent; parent = parent.parent)
            if (parent.name == "Block")
                return { from: node.from, options: properties(), validFor: dist_identifier };
        return { from: node.from, options: dist_tags, validFor: dist_identifier };
    }
    if (!context.explicit)
        return null;
    let above = node.resolve(pos), before = above.childBefore(pos);
    if (before && before.name == ":" && above.name == "PseudoClassSelector")
        return { from: pos, options: pseudoClasses, validFor: dist_identifier };
    if (before && before.name == ":" && above.name == "Declaration" || above.name == "ArgList")
        return { from: pos, options: values, validFor: dist_identifier };
    if (above.name == "Block" || above.name == "Styles")
        return { from: pos, options: properties(), validFor: dist_identifier };
    return null;
};
/**
CSS property, variable, and value keyword completion source.
*/
const cssCompletionSource = /*@__PURE__*/defineCSSCompletionSource(n => n.name == "VariableName");

/**
A language provider based on the [Lezer CSS
parser](https://github.com/lezer-parser/css), extended with
highlighting and indentation information.
*/
const cssLanguage = /*@__PURE__*/LRLanguage.define({
    name: "css",
    parser: /*@__PURE__*/parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                Declaration: /*@__PURE__*/continuedIndent()
            }),
            /*@__PURE__*/foldNodeProp.add({
                "Block KeyframeList": foldInside
            })
        ]
    }),
    languageData: {
        commentTokens: { block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*\}$/,
        wordChars: "-"
    }
});
/**
Language support for CSS.
*/
function css() {
    return new LanguageSupport(cssLanguage, cssLanguage.data.of({ autocomplete: cssCompletionSource }));
}



;// CONCATENATED MODULE: ./node_modules/@lezer/html/dist/index.js




// This file was generated by lezer-generator. You probably shouldn't edit it.
const scriptText = 54,
  StartCloseScriptTag = 1,
  styleText = 55,
  StartCloseStyleTag = 2,
  textareaText = 56,
  StartCloseTextareaTag = 3,
  EndTag = 4,
  SelfClosingEndTag = 5,
  StartTag = 6,
  StartScriptTag = 7,
  StartStyleTag = 8,
  StartTextareaTag = 9,
  StartSelfClosingTag = 10,
  StartCloseTag = 11,
  NoMatchStartCloseTag = 12,
  MismatchedStartCloseTag = 13,
  missingCloseTag = 57,
  IncompleteCloseTag = 14,
  commentContent$1 = 58,
  Element = 20,
  TagName = 22,
  Attribute = 23,
  AttributeName = 24,
  AttributeValue = 26,
  UnquotedAttributeValue = 27,
  ScriptText = 28,
  StyleText = 31,
  TextareaText = 34,
  OpenTag = 36,
  CloseTag = 37,
  Dialect_noMatch = 0,
  Dialect_selfClosing = 1;

/* Hand-written tokenizers for HTML. */

const selfClosers = {
  area: true, base: true, br: true, col: true, command: true,
  embed: true, frame: true, hr: true, img: true, input: true,
  keygen: true, link: true, meta: true, param: true, source: true,
  track: true, wbr: true, menuitem: true
};

const implicitlyClosed = {
  dd: true, li: true, optgroup: true, option: true, p: true,
  rp: true, rt: true, tbody: true, td: true, tfoot: true,
  th: true, tr: true
};

const closeOnOpen = {
  dd: {dd: true, dt: true},
  dt: {dd: true, dt: true},
  li: {li: true},
  option: {option: true, optgroup: true},
  optgroup: {optgroup: true},
  p: {
    address: true, article: true, aside: true, blockquote: true, dir: true,
    div: true, dl: true, fieldset: true, footer: true, form: true,
    h1: true, h2: true, h3: true, h4: true, h5: true, h6: true,
    header: true, hgroup: true, hr: true, menu: true, nav: true, ol: true,
    p: true, pre: true, section: true, table: true, ul: true
  },
  rp: {rp: true, rt: true},
  rt: {rp: true, rt: true},
  tbody: {tbody: true, tfoot: true},
  td: {td: true, th: true},
  tfoot: {tbody: true},
  th: {td: true, th: true},
  thead: {tbody: true, tfoot: true},
  tr: {tr: true}
};

function nameChar(ch) {
  return ch == 45 || ch == 46 || ch == 58 || ch >= 65 && ch <= 90 || ch == 95 || ch >= 97 && ch <= 122 || ch >= 161
}

function isSpace(ch) {
  return ch == 9 || ch == 10 || ch == 13 || ch == 32
}

let cachedName = null, cachedInput = null, cachedPos = 0;
function tagNameAfter(input, offset) {
  let pos = input.pos + offset;
  if (cachedPos == pos && cachedInput == input) return cachedName
  let next = input.peek(offset);
  while (isSpace(next)) next = input.peek(++offset);
  let name = "";
  for (;;) {
    if (!nameChar(next)) break
    name += String.fromCharCode(next);
    next = input.peek(++offset);
  }
  // Undefined to signal there's a <? or <!, null for just missing
  cachedInput = input; cachedPos = pos;
  return cachedName = name ? name.toLowerCase() : next == question || next == bang ? undefined : null
}

const lessThan = 60, greaterThan = 62, slash = 47, question = 63, bang = 33, dist_dash = 45;

function ElementContext(name, parent) {
  this.name = name;
  this.parent = parent;
  this.hash = parent ? parent.hash : 0;
  for (let i = 0; i < name.length; i++) this.hash += (this.hash << 4) + name.charCodeAt(i) + (name.charCodeAt(i) << 8);
}

const startTagTerms = [StartTag, StartSelfClosingTag, StartScriptTag, StartStyleTag, StartTextareaTag];

const elementContext = new ContextTracker({
  start: null,
  shift(context, term, stack, input) {
    return startTagTerms.indexOf(term) > -1 ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  reduce(context, term) {
    return term == Element && context ? context.parent : context
  },
  reuse(context, node, stack, input) {
    let type = node.type.id;
    return type == StartTag || type == OpenTag
      ? new ElementContext(tagNameAfter(input, 1) || "", context) : context
  },
  hash(context) { return context ? context.hash : 0 },
  strict: false
});

const tagStart = new ExternalTokenizer((input, stack) => {
  if (input.next != lessThan) {
    // End of file, close any open tags
    if (input.next < 0 && stack.context) input.acceptToken(missingCloseTag);
    return
  }
  input.advance();
  let close = input.next == slash;
  if (close) input.advance();
  let name = tagNameAfter(input, 0);
  if (name === undefined) return
  if (!name) return input.acceptToken(close ? IncompleteCloseTag : StartTag)

  let parent = stack.context ? stack.context.name : null;
  if (close) {
    if (name == parent) return input.acceptToken(StartCloseTag)
    if (parent && implicitlyClosed[parent]) return input.acceptToken(missingCloseTag, -2)
    if (stack.dialectEnabled(Dialect_noMatch)) return input.acceptToken(NoMatchStartCloseTag)
    for (let cx = stack.context; cx; cx = cx.parent) if (cx.name == name) return
    input.acceptToken(MismatchedStartCloseTag);
  } else {
    if (name == "script") return input.acceptToken(StartScriptTag)
    if (name == "style") return input.acceptToken(StartStyleTag)
    if (name == "textarea") return input.acceptToken(StartTextareaTag)
    if (selfClosers.hasOwnProperty(name)) return input.acceptToken(StartSelfClosingTag)
    if (parent && closeOnOpen[parent] && closeOnOpen[parent][name]) input.acceptToken(missingCloseTag, -1);
    else input.acceptToken(StartTag);
  }
}, {contextual: true});

const commentContent = new ExternalTokenizer(input => {
  for (let dashes = 0, i = 0;; i++) {
    if (input.next < 0) {
      if (i) input.acceptToken(commentContent$1);
      break
    }
    if (input.next == dist_dash) {
      dashes++;
    } else if (input.next == greaterThan && dashes >= 2) {
      if (i >= 3) input.acceptToken(commentContent$1, -2);
      break
    } else {
      dashes = 0;
    }
    input.advance();
  }
});

function inForeignElement(context) {
  for (; context; context = context.parent)
    if (context.name == "svg" || context.name == "math") return true
  return false
}

const endTag = new ExternalTokenizer((input, stack) => {
  if (input.next == slash && input.peek(1) == greaterThan) {
    let selfClosing = stack.dialectEnabled(Dialect_selfClosing) || inForeignElement(stack.context);
    input.acceptToken(selfClosing ? SelfClosingEndTag : EndTag, 2);
  } else if (input.next == greaterThan) {
    input.acceptToken(EndTag, 1);
  }
});

function contentTokenizer(tag, textToken, endToken) {
  let lastState = 2 + tag.length;
  return new ExternalTokenizer(input => {
    // state means:
    // - 0 nothing matched
    // - 1 '<' matched
    // - 2 '</' + possibly whitespace matched
    // - 3-(1+tag.length) part of the tag matched
    // - lastState whole tag + possibly whitespace matched
    for (let state = 0, matchedLen = 0, i = 0;; i++) {
      if (input.next < 0) {
        if (i) input.acceptToken(textToken);
        break
      }
      if (state == 0 && input.next == lessThan ||
          state == 1 && input.next == slash ||
          state >= 2 && state < lastState && input.next == tag.charCodeAt(state - 2)) {
        state++;
        matchedLen++;
      } else if ((state == 2 || state == lastState) && isSpace(input.next)) {
        matchedLen++;
      } else if (state == lastState && input.next == greaterThan) {
        if (i > matchedLen)
          input.acceptToken(textToken, -matchedLen);
        else
          input.acceptToken(endToken, -(matchedLen - 2));
        break
      } else if ((input.next == 10 /* '\n' */ || input.next == 13 /* '\r' */) && i) {
        input.acceptToken(textToken, 1);
        break
      } else {
        state = matchedLen = 0;
      }
      input.advance();
    }
  })
}

const scriptTokens = contentTokenizer("script", scriptText, StartCloseScriptTag);

const styleTokens = contentTokenizer("style", styleText, StartCloseStyleTag);

const textareaTokens = contentTokenizer("textarea", textareaText, StartCloseTextareaTag);

const htmlHighlighting = styleTags({
  "Text RawText": tags.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": tags.angleBracket,
  TagName: tags.tagName,
  "MismatchedCloseTag/TagName": [tags.tagName,  tags.invalid],
  AttributeName: tags.attributeName,
  "AttributeValue UnquotedAttributeValue": tags.attributeValue,
  Is: tags.definitionOperator,
  "EntityReference CharacterReference": tags.character,
  Comment: tags.blockComment,
  ProcessingInst: tags.processingInstruction,
  DoctypeDecl: tags.documentMeta
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const dist_parser = LRParser.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: elementContext,
  nodeProps: [
    ["closedBy", -10,1,2,3,7,8,9,10,11,12,13,"EndTag",6,"EndTag SelfClosingEndTag",-4,21,30,33,36,"CloseTag"],
    ["openedBy", 4,"StartTag StartCloseTag",5,"StartTag",-4,29,32,35,37,"OpenTag"],
    ["group", -9,14,17,18,19,20,39,40,41,42,"Entity",16,"Entity TextContent",-3,28,31,34,"TextContent Entity"]
  ],
  propSources: [htmlHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [scriptTokens, styleTokens, textareaTokens, endTag, tagStart, commentContent, 0, 1, 2, 3, 4, 5],
  topRules: {"Document":[0,15]},
  dialects: {noMatch: 0, selfClosing: 485},
  tokenPrec: 487
});

function dist_getAttrs(openTag, input) {
  let attrs = Object.create(null);
  for (let att of openTag.getChildren(Attribute)) {
    let name = att.getChild(AttributeName), value = att.getChild(AttributeValue) || att.getChild(UnquotedAttributeValue);
    if (name) attrs[input.read(name.from, name.to)] =
      !value ? "" : value.type.id == AttributeValue ? input.read(value.from + 1, value.to - 1) : input.read(value.from, value.to);
  }
  return attrs
}

function findTagName(openTag, input) {
  let tagNameNode = openTag.getChild(TagName);
  return tagNameNode ? input.read(tagNameNode.from, tagNameNode.to) : " "
}

function maybeNest(node, input, tags) {
  let attrs;
  for (let tag of tags) {
    if (!tag.attrs || tag.attrs(attrs || (attrs = dist_getAttrs(node.node.parent.firstChild, input))))
      return {parser: tag.parser}
  }
  return null
}

// tags?: {
//   tag: string,
//   attrs?: ({[attr: string]: string}) => boolean,
//   parser: Parser
// }[]
// attributes?: {
//   name: string,
//   tagName?: string,
//   parser: Parser
// }[]
 
function configureNesting(tags = [], attributes = []) {
  let script = [], style = [], textarea = [], other = [];
  for (let tag of tags) {
    let array = tag.tag == "script" ? script : tag.tag == "style" ? style : tag.tag == "textarea" ? textarea : other;
    array.push(tag);
  }
  let attrs = attributes.length ? Object.create(null) : null;
  for (let attr of attributes) (attrs[attr.name] || (attrs[attr.name] = [])).push(attr);

  return parseMixed((node, input) => {
    let id = node.type.id;
    if (id == ScriptText) return maybeNest(node, input, script)
    if (id == StyleText) return maybeNest(node, input, style)
    if (id == TextareaText) return maybeNest(node, input, textarea)

    if (id == Element && other.length) {
      let n = node.node, open = n.firstChild, tagName = open && findTagName(open, input), attrs;
      if (tagName) for (let tag of other) {
        if (tag.tag == tagName && (!tag.attrs || tag.attrs(attrs || (attrs = dist_getAttrs(n, input))))) {
          let close = n.lastChild;
          let to = close.type.id == CloseTag ? close.from : n.to;
          if (to > open.to)
            return {parser: tag.parser, overlay: [{from: open.to, to}]}
        }
      }
    }

    if (attrs && id == Attribute) {
      let n = node.node, nameNode;
      if (nameNode = n.firstChild) {
        let matches = attrs[input.read(nameNode.from, nameNode.to)];
        if (matches) for (let attr of matches) {
          if (attr.tagName && attr.tagName != findTagName(n.parent, input)) continue
          let value = n.lastChild;
          if (value.type.id == AttributeValue) {
            let from = value.from + 1;
            let last = value.lastChild, to = value.to - (last && last.isError ? 0 : 1);
            if (to > from) return {parser: attr.parser, overlay: [{from, to}]}
          } else if (value.type.id == UnquotedAttributeValue) {
            return {parser: attr.parser, overlay: [{from: value.from, to: value.to}]}
          }
        }
      }
    }
    return null
  })
}



;// CONCATENATED MODULE: ./node_modules/@lezer/javascript/dist/index.js



// This file was generated by lezer-generator. You probably shouldn't edit it.
const noSemi = 309,
  incdec = 1,
  incdecPrefix = 2,
  JSXStartTag = 3,
  insertSemi = 310,
  spaces = 312,
  dist_newline = 313,
  LineComment = 4,
  BlockComment = 5,
  Dialect_jsx = 0;

/* Hand-written tokenizers for JavaScript tokens that can't be
   expressed by lezer's built-in tokenizer. */

const dist_space = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200,
               8201, 8202, 8232, 8233, 8239, 8287, 12288];

const braceR = 125, semicolon = 59, dist_slash = 47, star = 42, plus = 43, minus = 45, lt = 60, comma = 44;

const trackNewline = new ContextTracker({
  start: false,
  shift(context, term) {
    return term == LineComment || term == BlockComment || term == spaces ? context : term == dist_newline
  },
  strict: false
});

const insertSemicolon = new ExternalTokenizer((input, stack) => {
  let {next} = input;
  if (next == braceR || next == -1 || stack.context)
    input.acceptToken(insertSemi);
}, {contextual: true, fallback: true});

const noSemicolon = new ExternalTokenizer((input, stack) => {
  let {next} = input, after;
  if (dist_space.indexOf(next) > -1) return
  if (next == dist_slash && ((after = input.peek(1)) == dist_slash || after == star)) return
  if (next != braceR && next != semicolon && next != -1 && !stack.context)
    input.acceptToken(noSemi);
}, {contextual: true});

const incdecToken = new ExternalTokenizer((input, stack) => {
  let {next} = input;
  if (next == plus || next == minus) {
    input.advance();
    if (next == input.next) {
      input.advance();
      let mayPostfix = !stack.context && stack.canShift(incdec);
      input.acceptToken(mayPostfix ? incdec : incdecPrefix);
    }
  }
}, {contextual: true});

function identifierChar(ch, start) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch == 95 || ch >= 192 ||
    !start && ch >= 48 && ch <= 57
}

const jsx = new ExternalTokenizer((input, stack) => {
  if (input.next != lt || !stack.dialectEnabled(Dialect_jsx)) return
  input.advance();
  if (input.next == dist_slash) return
  // Scan for an identifier followed by a comma or 'extends', don't
  // treat this as a start tag if present.
  let back = 0;
  while (dist_space.indexOf(input.next) > -1) { input.advance(); back++; }
  if (identifierChar(input.next, true)) {
    input.advance();
    back++;
    while (identifierChar(input.next, false)) { input.advance(); back++; }
    while (dist_space.indexOf(input.next) > -1) { input.advance(); back++; }
    if (input.next == comma) return
    for (let i = 0;; i++) {
      if (i == 7) {
        if (!identifierChar(input.next, true)) return
        break
      }
      if (input.next != "extends".charCodeAt(i)) break
      input.advance();
      back++;
    }
  }
  input.acceptToken(JSXStartTag, -back);
});

const jsHighlight = styleTags({
  "get set async static": tags.modifier,
  "for while do if else switch try catch finally return throw break continue default case": tags.controlKeyword,
  "in of await yield void typeof delete instanceof": tags.operatorKeyword,
  "let var const using function class extends": tags.definitionKeyword,
  "import export from": tags.moduleKeyword,
  "with debugger as new": tags.keyword,
  TemplateString: tags.special(tags.string),
  super: tags.atom,
  BooleanLiteral: tags.bool,
  this: tags.self,
  null: tags.null,
  Star: tags.modifier,
  VariableName: tags.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": tags.function(tags.variableName),
  VariableDefinition: tags.definition(tags.variableName),
  Label: tags.labelName,
  PropertyName: tags.propertyName,
  PrivatePropertyName: tags.special(tags.propertyName),
  "CallExpression/MemberExpression/PropertyName": tags.function(tags.propertyName),
  "FunctionDeclaration/VariableDefinition": tags.function(tags.definition(tags.variableName)),
  "ClassDeclaration/VariableDefinition": tags.definition(tags.className),
  PropertyDefinition: tags.definition(tags.propertyName),
  PrivatePropertyDefinition: tags.definition(tags.special(tags.propertyName)),
  UpdateOp: tags.updateOperator,
  "LineComment Hashbang": tags.lineComment,
  BlockComment: tags.blockComment,
  Number: tags.number,
  String: tags.string,
  Escape: tags.escape,
  ArithOp: tags.arithmeticOperator,
  LogicOp: tags.logicOperator,
  BitOp: tags.bitwiseOperator,
  CompareOp: tags.compareOperator,
  RegExp: tags.regexp,
  Equals: tags.definitionOperator,
  Arrow: tags.function(tags.punctuation),
  ": Spread": tags.punctuation,
  "( )": tags.paren,
  "[ ]": tags.squareBracket,
  "{ }": tags.brace,
  "InterpolationStart InterpolationEnd": tags.special(tags.brace),
  ".": tags.derefOperator,
  ", ;": tags.separator,
  "@": tags.meta,

  TypeName: tags.typeName,
  TypeDefinition: tags.definition(tags.typeName),
  "type enum interface implements namespace module declare": tags.definitionKeyword,
  "abstract global Privacy readonly override": tags.modifier,
  "is keyof unique infer": tags.operatorKeyword,

  JSXAttributeValue: tags.attributeValue,
  JSXText: tags.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": tags.angleBracket,
  "JSXIdentifier JSXNameSpacedName": tags.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": tags.attributeName,
  "JSXBuiltin/JSXIdentifier": tags.standard(tags.tagName)
});

// This file was generated by lezer-generator. You probably shouldn't edit it.
const dist_spec_identifier = {__proto__:null,export:18, as:23, from:31, default:34, async:39, function:40, extends:52, this:56, true:64, false:64, null:76, void:80, typeof:84, super:102, new:136, delete:152, yield:161, await:165, class:170, public:227, private:227, protected:227, readonly:229, instanceof:248, satisfies:251, in:252, const:254, import:286, keyof:339, unique:343, infer:349, is:385, abstract:405, implements:407, type:409, let:412, var:414, using:417, interface:423, enum:427, namespace:433, module:435, declare:439, global:443, for:462, of:471, while:474, with:478, do:482, if:486, else:488, switch:492, case:498, try:504, catch:508, finally:512, return:516, throw:520, break:524, continue:528, debugger:532};
const spec_word = {__proto__:null,async:123, get:125, set:127, declare:187, public:189, private:189, protected:189, static:191, abstract:193, override:195, readonly:201, accessor:203, new:389};
const spec_LessThan = {__proto__:null,"<":143};
const javascript_dist_parser = LRParser.deserialize({
  version: 14,
  states: "$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>pQ08SO1G0{O#>wQ08SO1G0{O#@oQ08SO1G0{O#CoQ(CYO'#ChO#EmQ(CYO1G1^O#EtQ(CYO'#JjO!,lQWO1G1dO#FUQ08SO,5?TOOQ07`-E<g-E<gO#FxQ08SO1G0{OOQ07b1G0{1G0{O#ITQ08SO1G1aO#IwQ&jO,5<TO#JPQ&jO,5<UO#JXQ&jO'#FlO#JpQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#JuQ&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#KWQ(CYO'#JiO#KbQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KgQ`O'#J}OOQ07b,5<a,5<aO#KoQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KtO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LPQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LoQ7[O,5=RO!(SQ7[O'#IpO#MbQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MlQpO'#CqO#NPQpO,5<nO#NWQWO'#KRO9aQWO'#KRO#NfQWO,5<pO!(SQ7[O,5<oO#NkQWO'#GUO#NvQWO,5<oO#N{QpO'#GRO$ YQpO'#KSO$ dQWO'#KSO!&dQ7[O'#KSO$ iQWO,5<sO$ nQ`O'#G^O!4eQ`O'#G^O$!PQWO'#G`O$!UQWO'#GbO!3fQWO'#GeO$!ZQ07hO'#ImO$!fQ`O,5<wOOQ07f,5<w,5<wO$!mQ`O'#G^O$!{Q`O'#G_O$#TQ`O'#G_O$#YQ7[O,5=RO$#jQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$#zQWO'#IrO$$VQWO,5?|O$$_QWO,59`O$%OQ7[O,59qOOQ07b,59q,59qO$%qQ7[O,5<fO$&dQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&nQWO,5<qO$&sQ7[O,5<vO$'TQWO'#JuO!$aQ^O1G1}O$'YQWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'_Q07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)dQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+hQ7[O'#EgOOQ07`,5?{,5?{O$+rQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,TQWO1G0qO$,YQWO'#ChO$,eQWO'#K[O$,mQWO,5=uO$,rQWO'#K[O$,wQWO'#K[O$-VQWO'#IzO$-eQWO,5@uO$-mQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-tQWO1G3`O$-yQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.OQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.TQWO1G2|O$.]Q`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.eQ7[O,5=nO9aQWO,5=nO$!UQWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.sQWO'#KYO$/OQWO,5=qOOQU1G.j1G.jO$/TQ07hO1G.jO@bQWO1G.jO$/`QWO1G.jO9kQ07hO1G.jO$1eQrO,5@wO$1uQWO,5@wO9ZQWO,5@wO$2QQ^O,5=xO$2XQWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2^Q^O1G3nO$6bQ^O'#HmOOQU1G3q1G3qO$6oQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6wQ^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;OQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;TQ(CYO,5:UOOQO,5;[,5;[O$;_Q`O'#I^O$;uQWO,5@WOOQ07b1G/o1G/oO$;}Q`O'#IdO$<XQWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<aQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<hQ07hO1G0iO$<sQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=RQ07hO1G0iOOQO1G0]1G0]O$=gQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=qQpO,5<eO$=yQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>TQWO1G5qO$>]QWO1G6OO$>eQrO1G6PO9ZQWO,5>}O$>oQ08SO1G5|O%[Q^O1G5|O$?PQ07hO1G5|O$?bQWO1G5{O$?bQWO1G5{O9ZQWO1G5{O$?jQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@OQWO,5?QO$'TQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@^QWO7+(_O$@iQ7[O7+(_O$@wQ08SO,5=RO$CSQ08SO,5=TO$E_Q08SO,5=RO$GpQ08SO,5=TO$JRQ08SO,59qO$LZQ08SO,5<fO$NfQ08SO,5<hO%!qQ08SO,5<vOOQ07b7+&]7+&]O%%SQ08SO7+&]O%%vQ7[O'#I_O%&QQWO,5@YOOQ07b1G/y1G/yO%&YQ^O'#I`O%&gQWO,5@ZO%&oQrO,5@ZOOQ07b1G0O1G0OO%&yQWO7+&fOOQ07b7+&f7+&fO%'OQ(CYO,5:eO%[Q^O7+&xO%'YQ(CYO,5:]O%'gQ(CYO,5:iO%'qQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%'{QtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(WQWO1G1yOOQ07b1G1{1G1{O%(]QpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(dQ08SO7+'hOOQ07b,5?V,5?VO%)WQpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)vQ7[O,5?YOOQ07b-E<l-E<lO%*iQ7[O,5?[OOQ07b-E<n-E<nO%*sQpO1G2qOOQ07b1G2Y1G2YO%*zQWO'#IjO%+YQWO,5@mO%+YQWO,5@mO%+bQWO,5@mO%+mQWO,5@mOOQO1G2[1G2[O%+{Q7[O1G2ZO!(SQ7[O1G2ZO%,]Q!LQO'#IlO%,mQWO,5@nO!&dQ7[O,5@nO%,uQpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'TQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-PQWO,5<zOOQ07`,5<|,5<|O$'TQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-XQWO,5<yO$!PQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%-{Q7[O1G2mO!(SQ7[O'#IpO%.nQ7[O1G2oO%.xQ7[O1G5iO%/SQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/aQWO1G2UO!(SQ7[O1G2]O%/fQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0YQWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0_QpO'#KTO#%sQWO7+(_O%0iQrO7+(_O$@aQWO7+(_O%0pQ08QO'#ChO%1TQ08QO,5<}O%1uQWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%1zQWO'#IyO%2cQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2cQWO,5@vO%2kQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2pQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2uQ08QO7+(gO!&dQ7[O7+(gO%3PQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3WQWO'#KXO%3cQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4rQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%4yQWO1G3YO%5UQ7[O1G3YO9kQ07hO1G3[O$!UQWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5dQWO'#IxO%5xQWO,5@tO%6QQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6]QWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6bQ07hO1G6cO%6lQ^O1G3dO%6sQWO1G3dO%6xQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7PQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7^QWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7cQ`O1G5sO%7wQ(CYO1G0vO%8RQWO1G0vOOQO1G/p1G/pO%8^Q(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=gQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8hQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8sQ07hO7+&TO%9RQ08SO7++hO%[Q^O7++hO%9cQWO7++gO%9cQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9kQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0iQrO<<KyO%9yQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:RQWO<<KyO%:^Q08SO,5?YO%<iQ08SO,5?[O%>tQ08SO1G2ZO%AVQ08SO1G2mO%CbQ08SO1G2oO%EmQ7[O,5>yOOQO-E<]-E<]O%EwQrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FRQWO1G5uOOQ07b<<JQ<<JQO%FZQ(CYO1G0qO%HeQ(CYO1G0{O%HlQ(CYO1G0{O%JpQ(CYO1G0{O%JwQ(CYO1G0{O%LlQ(CYO1G0{O%MSQ(CYO1G0{O& gQ(CYO1G0{O& nQ(CYO1G0{O&#rQ(CYO1G0{O&#yQ(CYO1G0{O&%qQ(CYO1G0{O&&UQ08SO<<JdO&'ZQ(CYO1G0{O&)PQ(CYO'#JdO&+SQ(CYO1G1aO&+aQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+kQWO1G1qO&+pQ(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&+zQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,YQWO1G6XO&,YQWO1G6XO&,bQWO1G6XO&,mQ7[O7+'uO&,}QpO,5?WO&-XQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-^QpO1G6YO&-hQWO1G6YOOQ07`1G2e1G2eO$'TQWO1G2eOOQ07`1G2d1G2dO&-pQWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&-uQWO1G2fO&-}QWO1G2eO&.qQ7[O,5?YOOQ07b-E<m-E<mO&/dQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/nQWO1G/_OOQ07b7+'p7+'pO&/sQ7[O7+'wO&0TQ08SO<<KTOOQ07b<<KT<<KTO&0wQWO1G0vO!&dQ7[O'#IsO&0|QWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1UQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&1xQWO,5?eO&1}QWO,5?eOOQO-E<w-E<wO&2]QWO1G6bO&2]QWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2eQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2uQ08QO<<LROOQU<<LS<<LSO%3PQpO<<LSO&2jQ`O'#IuO&2uQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&2}Q^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3XQ`O,5=oOOQU,5=o,5=oO&3`Q`O'#EcO&3tQWO7+(tO&3yQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4RQWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$!UQWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4^QWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4iQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4qQWO7++}O&4vQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&4{QWO7+)OO&5QQ^O7+)OO&5XQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5^QWO,5>YOOQU,5>[,5>[O&5cQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5hQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=gQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&5rQ07hO<<IoO&5}Q08SO<= SO&6_QWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6gQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0iQrOANAeO%[Q^OANAeO&6oQ08SO7+'uO&9QQ08SO,5?YO&;]Q08SO,5?[O&=hQ08SO7+'wO&?yQrO1G4fO&@TQ(CYO7+&]O&BXQ(CYO,5=RO&D`Q(CYO,5=TO&DpQ(CYO,5=RO&EQQ(CYO,5=TO&EbQ(CYO,59qO&GeQ(CYO,5<fO&IhQ(CYO,5<hO&KkQ(CYO,5<vO&MaQ(CYO7+'hO&MnQ(CYO7+'iO&M{QWO,5<YOOQO7+']7+']O&NQQ7[O<<KwOOQO1G4p1G4pO&NXQWO1G4pO&NdQWO1G4pO&NrQWO7++sO&NrQWO7++sO!&dQ7[O1G4rO&NzQpO1G4rO' UQWO7++tOOQ07`7+(P7+(PO$'TQWO7+(QO' ^QpO7+(QOOQ07`7+(O7+(OO$'TQWO7+(PO' eQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' jQ7[O<<NoOOQ07b7+$y7+$yO' tQpO,5?_OOQO-E<q-E<qO'!OQ08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!`QWO1G5PO'!eQWO7++|O'!eQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!mQWO,5?aOOQO-E<s-E<sO'!xQ(CYO1G6_O'%YQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&2}Q^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&3tQWO<<L`O'%dQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$!UQWO<<LbO9UQWO<<LbO'%lQ`O1G5OO'%wQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&PQWO<= iO'&UQWO<= jOOQU<<Lj<<LjO'&ZQWO<<LjO'&`Q^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&gQWO<<I|O'&rQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=gQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO'&|QWOG27PO%0iQrOG27PO''UQ(CYO<<JdO''cQ(CYO1G2ZO')XQ(CYO,5?YO'+[Q(CYO,5?[O'-_Q(CYO1G2mO'/bQ(CYO1G2oO'1eQ(CYO<<KTO'1rQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2PQWO7+*[O'2[QWO<= _O'2dQpO7+*^OOQ07`<<Kl<<KlO$'TQWO<<KlOOQ07`<<Kk<<KkO'2nQpO<<KlO$'TQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'2uQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'2}QWO7++yO&3tQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3VQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$!UQWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3_QWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=gQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3dQWOLD,kO'3lQ(CYO7+'uO'5bQ(CYO,5?YO'7eQ(CYO,5?[O'9hQ(CYO7+'wO';^Q7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'TQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';nQ(CYO7+*gOOQUG27fG27fO&3tQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO';xQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<SQ08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&3tQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>eQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@ZQrO'#JiO!*fQ^O'#DqO'@bQ^O'#D}O'@iQrO'#ChO'CPQrO'#ChO!*fQ^O'#EPO'CaQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EdQWO,5<eO'ElQ7[O,5;aO'GVQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ElQ7[O'#GgO!&dQ7[O'#GiO'ElQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ElQ7[O'#FzO!&dQ7[O'#F|O'ElQ7[O'#F|O!&dQ7[O'#G[O'ElQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CaQ^O1G0qO'G^Q(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O,5<oO'ElQ7[O,5<oO'CaQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ElQ7[O1G2ZO!&dQ7[O'#InO'ElQ7[O'#InO!&dQ7[O'#IpO'ElQ7[O'#IpO!&dQ7[O1G2]O'ElQ7[O1G2]O'CaQ^O7+'iO'CaQ^O7+&]O!&dQ7[OANAcO'ElQ7[OANAcO'GhQWO'#EkO'GmQWO'#EkO'GuQWO'#FZO'GzQWO'#EuO'HPQWO'#JyO'H[QWO'#JwO'HgQWO,5;VO'HlQ7[O,5<bO'HsQWO'#GTO'HxQWO'#GTO'H}QWO,5<cO'IVQWO,5;VO'I_Q(CYO1G1^O'IfQWO,5<oO'IkQWO,5<oO'IpQWO,5<qO'IuQWO,5<qO'IzQWO1G1}O'JPQWO1G0qO'JUQ7[O<<KwO'J]Q7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*sQpO1G2qO%*sQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V",
  stateData: "'Ka~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#v#ii#x#ii#y#ii'r#ii(h#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(o#ii~P#9lO(o#|O~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO(XVO(o#|O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O(p#ii~P#<^O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?OOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AiOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#CvO#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#CvO!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#LWO(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#LyO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$dO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%YO|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$%{O#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'jOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*TO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/kO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#CvOo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#LWO#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#LyO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$dO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%YO#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$%{O#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#CvO#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)_O|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*QO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-dO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.VOf(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3hOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#CvO#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#CvO`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)_O#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*QO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-dO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.VOf'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#CvOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FhO#j:lO~P%FhOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HsOn:nO~P%HsOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KOOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KOOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#v#ii#x#ii#y#ii#|#ii(h#ii(p#ii!Y#ii!Z#ii~O(o#ii~P%MjO(o#|O~P%MjOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO(XVO(o#|O#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O(p#ii~P& uO(p#}O~P& uOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$QO`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&&xO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#CvO#|!qi!Z!qi~P$'jO!Z6|O~O!Y']a!Z']a~P#CvO!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.YO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&.{O!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3hOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#CvO`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.YO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&.{O#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#CvO(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@bO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BiOj<gO|)zO!P){O(p%PO~P&@bOj<gO|)zO!P){O(o$}O~P&BiO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&&xO#|$jq!Y$jq!Z$jq~P#CvO#|$kq!Y$kq!Z$kq~P#CvO!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#CvOP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#SO![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#CvO!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#CvOP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&&xO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#CvO#|#_y!Y#_y!Z#_y~P#CvO!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&&xO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&&xOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#CvO!Y#d!Z!Z#d!Z~P#CvO#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&&xOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#SOP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'@vOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ElO!Z[X!ZeX~P'@vO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#CvO#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~",
  goto: "$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AuPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!f$Uc#X%n'|(S(n(u)U)V)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:r)Z)l-O.t2W2Z3_3g3h3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!b$Wc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:t)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z",
  nodeNames: "⚠ ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 371,
  context: trackNewline,
  nodeProps: [
    ["group", -26,8,16,18,65,201,205,209,210,212,215,218,228,230,236,238,240,242,245,251,257,259,261,263,265,267,268,"Statement",-32,12,13,28,31,32,38,48,51,52,54,59,67,75,79,81,83,84,106,107,116,117,134,137,139,140,141,142,144,145,164,165,167,"Expression",-23,27,29,33,37,39,41,168,170,172,173,175,176,177,179,180,181,183,184,185,195,197,199,200,"Type",-3,87,99,105,"ClassItem"],
    ["openedBy", 22,"<",34,"InterpolationStart",53,"[",57,"{",72,"(",157,"JSXStartCloseTag"],
    ["closedBy", 23,">",36,"InterpolationEnd",47,"]",58,"}",73,")",162,"JSXEndTag"]
  ],
  propSources: [jsHighlight],
  skippedNodes: [0,4,5,271],
  repeatNodeCount: 37,
  tokenData: "$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr",
  tokenizers: [noSemicolon, incdecToken, jsx, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, insertSemicolon, new LocalTokenGroup("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~", 141, 332), new LocalTokenGroup("j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~", 25, 315)],
  topRules: {"Script":[0,6],"SingleExpression":[1,269],"SingleClassItem":[2,270]},
  dialects: {jsx: 0, ts: 14602},
  dynamicPrecedences: {"69":1,"79":1,"81":1,"165":1,"193":1},
  specialized: [{term: 319, get: (value) => dist_spec_identifier[value] || -1},{term: 334, get: (value) => spec_word[value] || -1},{term: 70, get: (value) => spec_LessThan[value] || -1}],
  tokenPrec: 14626
});



;// CONCATENATED MODULE: ./node_modules/@codemirror/lang-javascript/dist/index.js







/**
A collection of JavaScript-related
[snippets](https://codemirror.net/6/docs/ref/#autocomplete.snippet).
*/
const snippets = [
    /*@__PURE__*/snippetCompletion("function ${name}(${params}) {\n\t${}\n}", {
        label: "function",
        detail: "definition",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n\t${}\n}", {
        label: "for",
        detail: "loop",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("for (let ${name} of ${collection}) {\n\t${}\n}", {
        label: "for",
        detail: "of loop",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("do {\n\t${}\n} while (${})", {
        label: "do",
        detail: "loop",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("while (${}) {\n\t${}\n}", {
        label: "while",
        detail: "loop",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("try {\n\t${}\n} catch (${error}) {\n\t${}\n}", {
        label: "try",
        detail: "/ catch block",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("if (${}) {\n\t${}\n}", {
        label: "if",
        detail: "block",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("if (${}) {\n\t${}\n} else {\n\t${}\n}", {
        label: "if",
        detail: "/ else block",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("class ${name} {\n\tconstructor(${params}) {\n\t\t${}\n\t}\n}", {
        label: "class",
        detail: "definition",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("import {${names}} from \"${module}\"\n${}", {
        label: "import",
        detail: "named",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("import ${name} from \"${module}\"\n${}", {
        label: "import",
        detail: "default",
        type: "keyword"
    })
];
/**
A collection of snippet completions for TypeScript. Includes the
JavaScript [snippets](https://codemirror.net/6/docs/ref/#lang-javascript.snippets).
*/
const typescriptSnippets = /*@__PURE__*/snippets.concat([
    /*@__PURE__*/snippetCompletion("interface ${name} {\n\t${}\n}", {
        label: "interface",
        detail: "definition",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("type ${name} = ${type}", {
        label: "type",
        detail: "definition",
        type: "keyword"
    }),
    /*@__PURE__*/snippetCompletion("enum ${name} {\n\t${}\n}", {
        label: "enum",
        detail: "definition",
        type: "keyword"
    })
]);

const cache = /*@__PURE__*/new NodeWeakMap();
const ScopeNodes = /*@__PURE__*/new Set([
    "Script", "Block",
    "FunctionExpression", "FunctionDeclaration", "ArrowFunction", "MethodDeclaration",
    "ForStatement"
]);
function defID(type) {
    return (node, def) => {
        let id = node.node.getChild("VariableDefinition");
        if (id)
            def(id, type);
        return true;
    };
}
const functionContext = ["FunctionDeclaration"];
const gatherCompletions = {
    FunctionDeclaration: /*@__PURE__*/defID("function"),
    ClassDeclaration: /*@__PURE__*/defID("class"),
    ClassExpression: () => true,
    EnumDeclaration: /*@__PURE__*/defID("constant"),
    TypeAliasDeclaration: /*@__PURE__*/defID("type"),
    NamespaceDeclaration: /*@__PURE__*/defID("namespace"),
    VariableDefinition(node, def) { if (!node.matchContext(functionContext))
        def(node, "variable"); },
    TypeDefinition(node, def) { def(node, "type"); },
    __proto__: null
};
function getScope(doc, node) {
    let cached = cache.get(node);
    if (cached)
        return cached;
    let completions = [], top = true;
    function def(node, type) {
        let name = doc.sliceString(node.from, node.to);
        completions.push({ label: name, type });
    }
    node.cursor(IterMode.IncludeAnonymous).iterate(node => {
        if (top) {
            top = false;
        }
        else if (node.name) {
            let gather = gatherCompletions[node.name];
            if (gather && gather(node, def) || ScopeNodes.has(node.name))
                return false;
        }
        else if (node.to - node.from > 8192) {
            // Allow caching for bigger internal nodes
            for (let c of getScope(doc, node.node))
                completions.push(c);
            return false;
        }
    });
    cache.set(node, completions);
    return completions;
}
const Identifier = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/;
const dontComplete = [
    "TemplateString", "String", "RegExp",
    "LineComment", "BlockComment",
    "VariableDefinition", "TypeDefinition", "Label",
    "PropertyDefinition", "PropertyName",
    "PrivatePropertyDefinition", "PrivatePropertyName",
    ".", "?."
];
/**
Completion source that looks up locally defined names in
JavaScript code.
*/
function localCompletionSource(context) {
    let inner = dist_syntaxTree(context.state).resolveInner(context.pos, -1);
    if (dontComplete.indexOf(inner.name) > -1)
        return null;
    let isWord = inner.name == "VariableName" ||
        inner.to - inner.from < 20 && Identifier.test(context.state.sliceDoc(inner.from, inner.to));
    if (!isWord && !context.explicit)
        return null;
    let options = [];
    for (let pos = inner; pos; pos = pos.parent) {
        if (ScopeNodes.has(pos.name))
            options = options.concat(getScope(context.state.doc, pos));
    }
    return {
        options,
        from: isWord ? inner.from : context.pos,
        validFor: Identifier
    };
}
function pathFor(read, member, name) {
    var _a;
    let path = [];
    for (;;) {
        let obj = member.firstChild, prop;
        if ((obj === null || obj === void 0 ? void 0 : obj.name) == "VariableName") {
            path.push(read(obj));
            return { path: path.reverse(), name };
        }
        else if ((obj === null || obj === void 0 ? void 0 : obj.name) == "MemberExpression" && ((_a = (prop = obj.lastChild)) === null || _a === void 0 ? void 0 : _a.name) == "PropertyName") {
            path.push(read(prop));
            member = obj;
        }
        else {
            return null;
        }
    }
}
/**
Helper function for defining JavaScript completion sources. It
returns the completable name and object path for a completion
context, or null if no name/property completion should happen at
that position. For example, when completing after `a.b.c` it will
return `{path: ["a", "b"], name: "c"}`. When completing after `x`
it will return `{path: [], name: "x"}`. When not in a property or
name, it will return null if `context.explicit` is false, and
`{path: [], name: ""}` otherwise.
*/
function completionPath(context) {
    let read = (node) => context.state.doc.sliceString(node.from, node.to);
    let inner = syntaxTree(context.state).resolveInner(context.pos, -1);
    if (inner.name == "PropertyName") {
        return pathFor(read, inner.parent, read(inner));
    }
    else if ((inner.name == "." || inner.name == "?.") && inner.parent.name == "MemberExpression") {
        return pathFor(read, inner.parent, "");
    }
    else if (dontComplete.indexOf(inner.name) > -1) {
        return null;
    }
    else if (inner.name == "VariableName" || inner.to - inner.from < 20 && Identifier.test(read(inner))) {
        return { path: [], name: read(inner) };
    }
    else if (inner.name == "MemberExpression") {
        return pathFor(read, inner, "");
    }
    else {
        return context.explicit ? { path: [], name: "" } : null;
    }
}
function enumeratePropertyCompletions(obj, top) {
    let options = [], seen = new Set;
    for (let depth = 0;; depth++) {
        for (let name of (Object.getOwnPropertyNames || Object.keys)(obj)) {
            if (!/^[a-zA-Z_$\xaa-\uffdc][\w$\xaa-\uffdc]*$/.test(name) || seen.has(name))
                continue;
            seen.add(name);
            let value;
            try {
                value = obj[name];
            }
            catch (_) {
                continue;
            }
            options.push({
                label: name,
                type: typeof value == "function" ? (/^[A-Z]/.test(name) ? "class" : top ? "function" : "method")
                    : top ? "variable" : "property",
                boost: -depth
            });
        }
        let next = Object.getPrototypeOf(obj);
        if (!next)
            return options;
        obj = next;
    }
}
/**
Defines a [completion source](https://codemirror.net/6/docs/ref/#autocomplete.CompletionSource) that
completes from the given scope object (for example `globalThis`).
Will enter properties of the object when completing properties on
a directly-named path.
*/
function scopeCompletionSource(scope) {
    let cache = new Map;
    return (context) => {
        let path = completionPath(context);
        if (!path)
            return null;
        let target = scope;
        for (let step of path.path) {
            target = target[step];
            if (!target)
                return null;
        }
        let options = cache.get(target);
        if (!options)
            cache.set(target, options = enumeratePropertyCompletions(target, !path.path.length));
        return {
            from: context.pos - path.name.length,
            options,
            validFor: Identifier
        };
    };
}

/**
A language provider based on the [Lezer JavaScript
parser](https://github.com/lezer-parser/javascript), extended with
highlighting and indentation information.
*/
const javascriptLanguage = /*@__PURE__*/LRLanguage.define({
    name: "javascript",
    parser: /*@__PURE__*/javascript_dist_parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\s*({|else\b)/ }),
                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\s*({|catch\b|finally\b)/ }),
                LabeledStatement: flatIndent,
                SwitchBody: context => {
                    let after = context.textAfter, closed = /^\s*\}/.test(after), isCase = /^\s*(case|default)\b/.test(after);
                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;
                },
                Block: /*@__PURE__*/delimitedIndent({ closing: "}" }),
                ArrowFunction: cx => cx.baseIndent + cx.unit,
                "TemplateString BlockComment": () => null,
                "Statement Property": /*@__PURE__*/continuedIndent({ except: /^{/ }),
                JSXElement(context) {
                    let closed = /^\s*<\//.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                JSXEscape(context) {
                    let closed = /\s*\}/.test(context.textAfter);
                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);
                },
                "JSXOpenTag JSXSelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                }
            }),
            /*@__PURE__*/foldNodeProp.add({
                "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType": foldInside,
                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }
            })
        ]
    }),
    languageData: {
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
        commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
        indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
        wordChars: "$"
    }
});
const jsxSublanguage = {
    test: node => /^JSX/.test(node.name),
    facet: /*@__PURE__*/defineLanguageFacet({ commentTokens: { block: { open: "{/*", close: "*/}" } } })
};
/**
A language provider for TypeScript.
*/
const typescriptLanguage = /*@__PURE__*/javascriptLanguage.configure({ dialect: "ts" }, "typescript");
/**
Language provider for JSX.
*/
const jsxLanguage = /*@__PURE__*/javascriptLanguage.configure({
    dialect: "jsx",
    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]
});
/**
Language provider for JSX + TypeScript.
*/
const tsxLanguage = /*@__PURE__*/javascriptLanguage.configure({
    dialect: "jsx ts",
    props: [/*@__PURE__*/sublanguageProp.add(n => n.isTop ? [jsxSublanguage] : undefined)]
}, "typescript");
let kwCompletion = (name) => ({ label: name, type: "keyword" });
const keywords = /*@__PURE__*/"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map(kwCompletion);
const typescriptKeywords = /*@__PURE__*/keywords.concat(/*@__PURE__*/["declare", "implements", "private", "protected", "public"].map(kwCompletion));
/**
JavaScript support. Includes [snippet](https://codemirror.net/6/docs/ref/#lang-javascript.snippets)
completion.
*/
function javascript(config = {}) {
    let lang = config.jsx ? (config.typescript ? tsxLanguage : jsxLanguage)
        : config.typescript ? typescriptLanguage : javascriptLanguage;
    let completions = config.typescript ? typescriptSnippets.concat(typescriptKeywords) : snippets.concat(keywords);
    return new LanguageSupport(lang, [
        javascriptLanguage.data.of({
            autocomplete: ifNotIn(dontComplete, completeFromList(completions))
        }),
        javascriptLanguage.data.of({
            autocomplete: localCompletionSource
        }),
        config.jsx ? autoCloseTags : [],
    ]);
}
function findOpenTag(node) {
    for (;;) {
        if (node.name == "JSXOpenTag" || node.name == "JSXSelfClosingTag" || node.name == "JSXFragmentTag")
            return node;
        if (node.name == "JSXEscape" || !node.parent)
            return null;
        node = node.parent;
    }
}
function elementName(doc, tree, max = doc.length) {
    for (let ch = tree === null || tree === void 0 ? void 0 : tree.firstChild; ch; ch = ch.nextSibling) {
        if (ch.name == "JSXIdentifier" || ch.name == "JSXBuiltin" || ch.name == "JSXNamespacedName" ||
            ch.name == "JSXMemberExpression")
            return doc.sliceString(ch.from, Math.min(ch.to, max));
    }
    return "";
}
const dist_android = typeof navigator == "object" && /*@__PURE__*//Android\b/.test(navigator.userAgent);
/**
Extension that will automatically insert JSX close tags when a `>` or
`/` is typed.
*/
const autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, defaultInsert) => {
    if ((dist_android ? view.composing : view.compositionStarted) || view.state.readOnly ||
        from != to || (text != ">" && text != "/") ||
        !javascriptLanguage.isActiveAt(view.state, from, -1))
        return false;
    let base = defaultInsert(), { state } = base;
    let closeTags = state.changeByRange(range => {
        var _a;
        let { head } = range, around = dist_syntaxTree(state).resolveInner(head - 1, -1), name;
        if (around.name == "JSXStartTag")
            around = around.parent;
        if (state.doc.sliceString(head - 1, head) != text || around.name == "JSXAttributeValue" && around.to > head) ;
        else if (text == ">" && around.name == "JSXFragmentTag") {
            return { range, changes: { from: head, insert: `</>` } };
        }
        else if (text == "/" && around.name == "JSXStartCloseTag") {
            let empty = around.parent, base = empty.parent;
            if (base && empty.from == head - 2 &&
                ((name = elementName(state.doc, base.firstChild, head)) || ((_a = base.firstChild) === null || _a === void 0 ? void 0 : _a.name) == "JSXFragmentTag")) {
                let insert = `${name}>`;
                return { range: dist_EditorSelection.cursor(head + insert.length, -1), changes: { from: head, insert } };
            }
        }
        else if (text == ">") {
            let openTag = findOpenTag(around);
            if (openTag &&
                !/^\/?>|^<\//.test(state.doc.sliceString(head, head + 2)) &&
                (name = elementName(state.doc, openTag, head)))
                return { range, changes: { from: head, insert: `</${name}>` } };
        }
        return { range };
    });
    if (closeTags.changes.empty)
        return false;
    view.dispatch([
        base,
        state.update(closeTags, { userEvent: "input.complete", scrollIntoView: true })
    ]);
    return true;
});

/**
Connects an [ESLint](https://eslint.org/) linter to CodeMirror's
[lint](https://codemirror.net/6/docs/ref/#lint) integration. `eslint` should be an instance of the
[`Linter`](https://eslint.org/docs/developer-guide/nodejs-api#linter)
class, and `config` an optional ESLint configuration. The return
value of this function can be passed to [`linter`](https://codemirror.net/6/docs/ref/#lint.linter)
to create a JavaScript linting extension.

Note that ESLint targets node, and is tricky to run in the
browser. The
[eslint-linter-browserify](https://github.com/UziTech/eslint-linter-browserify)
package may help with that (see
[example](https://github.com/UziTech/eslint-linter-browserify/blob/master/example/script.js)).
*/
function esLint(eslint, config) {
    if (!config) {
        config = {
            parserOptions: { ecmaVersion: 2019, sourceType: "module" },
            env: { browser: true, node: true, es6: true, es2015: true, es2017: true, es2020: true },
            rules: {}
        };
        eslint.getRules().forEach((desc, name) => {
            if (desc.meta.docs.recommended)
                config.rules[name] = 2;
        });
    }
    return (view) => {
        let { state } = view, found = [];
        for (let { from, to } of javascriptLanguage.findRegions(state)) {
            let fromLine = state.doc.lineAt(from), offset = { line: fromLine.number - 1, col: from - fromLine.from, pos: from };
            for (let d of eslint.verify(state.sliceDoc(from, to), config))
                found.push(translateDiagnostic(d, state.doc, offset));
        }
        return found;
    };
}
function mapPos(line, col, doc, offset) {
    return doc.line(line + offset.line).from + col + (line == 1 ? offset.col - 1 : -1);
}
function translateDiagnostic(input, doc, offset) {
    let start = mapPos(input.line, input.column, doc, offset);
    let result = {
        from: start,
        to: input.endLine != null && input.endColumn != 1 ? mapPos(input.endLine, input.endColumn, doc, offset) : start,
        message: input.message,
        source: input.ruleId ? "eslint:" + input.ruleId : "eslint",
        severity: input.severity == 1 ? "warning" : "error",
    };
    if (input.fix) {
        let { range, text } = input.fix, from = range[0] + offset.pos - start, to = range[1] + offset.pos - start;
        result.actions = [{
                name: "fix",
                apply(view, start) {
                    view.dispatch({ changes: { from: start + from, to: start + to, insert: text }, scrollIntoView: true });
                }
            }];
    }
    return result;
}



;// CONCATENATED MODULE: ./node_modules/@codemirror/lang-html/dist/index.js







const Targets = ["_blank", "_self", "_top", "_parent"];
const Charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
const Methods = ["get", "post", "put", "delete"];
const Encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
const Bool = ["true", "false"];
const S = {}; // Empty tag spec
const Tags = {
    a: {
        attrs: {
            href: null, ping: null, type: null,
            media: null,
            target: Targets,
            hreflang: null
        }
    },
    abbr: S,
    address: S,
    area: {
        attrs: {
            alt: null, coords: null, href: null, target: null, ping: null,
            media: null, hreflang: null, type: null,
            shape: ["default", "rect", "circle", "poly"]
        }
    },
    article: S,
    aside: S,
    audio: {
        attrs: {
            src: null, mediagroup: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["none", "metadata", "auto"],
            autoplay: ["autoplay"],
            loop: ["loop"],
            controls: ["controls"]
        }
    },
    b: S,
    base: { attrs: { href: null, target: Targets } },
    bdi: S,
    bdo: S,
    blockquote: { attrs: { cite: null } },
    body: S,
    br: S,
    button: {
        attrs: {
            form: null, formaction: null, name: null, value: null,
            autofocus: ["autofocus"],
            disabled: ["autofocus"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            type: ["submit", "reset", "button"]
        }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: S,
    center: S,
    cite: S,
    code: S,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
        attrs: {
            type: ["command", "checkbox", "radio"],
            label: null, icon: null, radiogroup: null, command: null, title: null,
            disabled: ["disabled"],
            checked: ["checked"]
        }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
    datalist: { attrs: { data: null } },
    dd: S,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["open"] } },
    dfn: S,
    div: S,
    dl: S,
    dt: S,
    em: S,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
    figcaption: S,
    figure: S,
    footer: S,
    form: {
        attrs: {
            action: null, name: null,
            "accept-charset": Charsets,
            autocomplete: ["on", "off"],
            enctype: Encs,
            method: Methods,
            novalidate: ["novalidate"],
            target: Targets
        }
    },
    h1: S, h2: S, h3: S, h4: S, h5: S, h6: S,
    head: {
        children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: S,
    hgroup: S,
    hr: S,
    html: {
        attrs: { manifest: null }
    },
    i: S,
    iframe: {
        attrs: {
            src: null, srcdoc: null, name: null, width: null, height: null,
            sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
            seamless: ["seamless"]
        }
    },
    img: {
        attrs: {
            alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"]
        }
    },
    input: {
        attrs: {
            alt: null, dirname: null, form: null, formaction: null,
            height: null, list: null, max: null, maxlength: null, min: null,
            name: null, pattern: null, placeholder: null, size: null, src: null,
            step: null, value: null, width: null,
            accept: ["audio/*", "video/*", "image/*"],
            autocomplete: ["on", "off"],
            autofocus: ["autofocus"],
            checked: ["checked"],
            disabled: ["disabled"],
            formenctype: Encs,
            formmethod: Methods,
            formnovalidate: ["novalidate"],
            formtarget: Targets,
            multiple: ["multiple"],
            readonly: ["readonly"],
            required: ["required"],
            type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
                "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
                "file", "submit", "image", "reset", "button"]
        }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: S,
    keygen: {
        attrs: {
            challenge: null, form: null, name: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            keytype: ["RSA"]
        }
    },
    label: { attrs: { for: null, form: null } },
    legend: S,
    li: { attrs: { value: null } },
    link: {
        attrs: {
            href: null, type: null,
            hreflang: null,
            media: null,
            sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
        }
    },
    map: { attrs: { name: null } },
    mark: S,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
        attrs: {
            content: null,
            charset: Charsets,
            name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
            "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
        }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: S,
    noscript: S,
    object: {
        attrs: {
            data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
            typemustmatch: ["typemustmatch"]
        }
    },
    ol: { attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
        children: ["li", "script", "template", "ul", "ol"] },
    optgroup: { attrs: { disabled: ["disabled"], label: null } },
    option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
    output: { attrs: { for: null, form: null, name: null } },
    p: S,
    param: { attrs: { name: null, value: null } },
    pre: S,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: S,
    rt: S,
    ruby: S,
    samp: S,
    script: {
        attrs: {
            type: ["text/javascript"],
            src: null,
            async: ["async"],
            defer: ["defer"],
            charset: Charsets
        }
    },
    section: S,
    select: {
        attrs: {
            form: null, name: null, size: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            multiple: ["multiple"]
        }
    },
    slot: { attrs: { name: null } },
    small: S,
    source: { attrs: { src: null, type: null, media: null } },
    span: S,
    strong: S,
    style: {
        attrs: {
            type: ["text/css"],
            media: null,
            scoped: null
        }
    },
    sub: S,
    summary: S,
    sup: S,
    table: S,
    tbody: S,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    template: S,
    textarea: {
        attrs: {
            dirname: null, form: null, maxlength: null, name: null, placeholder: null,
            rows: null, cols: null,
            autofocus: ["autofocus"],
            disabled: ["disabled"],
            readonly: ["readonly"],
            required: ["required"],
            wrap: ["soft", "hard"]
        }
    },
    tfoot: S,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: S,
    time: { attrs: { datetime: null } },
    title: S,
    tr: S,
    track: {
        attrs: {
            src: null, label: null, default: null,
            kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
            srclang: null
        }
    },
    ul: { children: ["li", "script", "template", "ul", "ol"] },
    var: S,
    video: {
        attrs: {
            src: null, poster: null, width: null, height: null,
            crossorigin: ["anonymous", "use-credentials"],
            preload: ["auto", "metadata", "none"],
            autoplay: ["autoplay"],
            mediagroup: ["movie"],
            muted: ["muted"],
            controls: ["controls"]
        }
    },
    wbr: S
};
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
    spellcheck: Bool,
    autocorrect: Bool,
    autocapitalize: Bool,
    style: null,
    tabindex: null,
    title: null,
    translate: ["yes", "no"],
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
    role: /*@__PURE__*/"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
    "aria-activedescendant": null,
    "aria-atomic": Bool,
    "aria-autocomplete": ["inline", "list", "both", "none"],
    "aria-busy": Bool,
    "aria-checked": ["true", "false", "mixed", "undefined"],
    "aria-controls": null,
    "aria-describedby": null,
    "aria-disabled": Bool,
    "aria-dropeffect": null,
    "aria-expanded": ["true", "false", "undefined"],
    "aria-flowto": null,
    "aria-grabbed": ["true", "false", "undefined"],
    "aria-haspopup": Bool,
    "aria-hidden": Bool,
    "aria-invalid": ["true", "false", "grammar", "spelling"],
    "aria-label": null,
    "aria-labelledby": null,
    "aria-level": null,
    "aria-live": ["off", "polite", "assertive"],
    "aria-multiline": Bool,
    "aria-multiselectable": Bool,
    "aria-owns": null,
    "aria-posinset": null,
    "aria-pressed": ["true", "false", "mixed", "undefined"],
    "aria-readonly": Bool,
    "aria-relevant": null,
    "aria-required": Bool,
    "aria-selected": ["true", "false", "undefined"],
    "aria-setsize": null,
    "aria-sort": ["ascending", "descending", "none", "other"],
    "aria-valuemax": null,
    "aria-valuemin": null,
    "aria-valuenow": null,
    "aria-valuetext": null
};
const eventAttributes = /*@__PURE__*/("beforeunload copy cut dragstart dragover dragleave dragenter dragend " +
    "drag paste focus blur change click load mousedown mouseenter mouseleave " +
    "mouseup keydown keyup resize scroll unload").split(" ").map(n => "on" + n);
for (let a of eventAttributes)
    GlobalAttrs[a] = null;
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = /*@__PURE__*/new Schema;
function dist_elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? doc.sliceString(name.from, Math.min(name.to, max)) : "";
}
function findParentElement(tree, skip = false) {
    for (; tree; tree = tree.parent)
        if (tree.name == "Element") {
            if (skip)
                skip = false;
            else
                return tree;
        }
    return null;
}
function allowedChildren(doc, tree, schema) {
    let parentInfo = schema.tags[dist_elementName(doc, findParentElement(tree))];
    return (parentInfo === null || parentInfo === void 0 ? void 0 : parentInfo.children) || schema.allTags;
}
function openTags(doc, tree) {
    let open = [];
    for (let parent = findParentElement(tree); parent && !parent.type.isTop; parent = findParentElement(parent.parent)) {
        let tagName = dist_elementName(doc, parent);
        if (tagName && parent.lastChild.name == "CloseTag")
            break;
        if (tagName && open.indexOf(tagName) < 0 && (tree.name == "EndTag" || tree.from >= parent.firstChild.to))
            open.push(tagName);
    }
    return open;
}
const lang_html_dist_identifier = /^[:\-\.\w\u00b7-\uffff]*$/;
function completeTag(state, schema, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    let parent = findParentElement(tree, true);
    return { from, to,
        options: allowedChildren(state.doc, parent, schema).map(tagName => ({ label: tagName, type: "type" })).concat(openTags(state.doc, tree).map((tag, i) => ({ label: "/" + tag, apply: "/" + tag + end,
            type: "type", boost: 99 - i }))),
        validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeCloseTag(state, tree, from, to) {
    let end = /\s*>/.test(state.sliceDoc(to, to + 5)) ? "" : ">";
    return { from, to,
        options: openTags(state.doc, tree).map((tag, i) => ({ label: tag, apply: tag + end, type: "type", boost: 99 - i })),
        validFor: lang_html_dist_identifier };
}
function completeStartTag(state, schema, tree, pos) {
    let options = [], level = 0;
    for (let tagName of allowedChildren(state.doc, tree, schema))
        options.push({ label: "<" + tagName, type: "type" });
    for (let open of openTags(state.doc, tree))
        options.push({ label: "</" + open + ">", type: "type", boost: 99 - level++ });
    return { from: pos, to: pos, options, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function completeAttrName(state, schema, tree, from, to) {
    let elt = findParentElement(tree), info = elt ? schema.tags[dist_elementName(state.doc, elt)] : null;
    let localAttrs = info && info.attrs ? Object.keys(info.attrs) : [];
    let names = info && info.globalAttrs === false ? localAttrs
        : localAttrs.length ? localAttrs.concat(schema.globalAttrNames) : schema.globalAttrNames;
    return { from, to,
        options: names.map(attrName => ({ label: attrName, type: "property" })),
        validFor: lang_html_dist_identifier };
}
function completeAttrValue(state, schema, tree, from, to) {
    var _a;
    let nameNode = (_a = tree.parent) === null || _a === void 0 ? void 0 : _a.getChild("AttributeName");
    let options = [], token = undefined;
    if (nameNode) {
        let attrName = state.sliceDoc(nameNode.from, nameNode.to);
        let attrs = schema.globalAttrs[attrName];
        if (!attrs) {
            let elt = findParentElement(tree), info = elt ? schema.tags[dist_elementName(state.doc, elt)] : null;
            attrs = (info === null || info === void 0 ? void 0 : info.attrs) && info.attrs[attrName];
        }
        if (attrs) {
            let base = state.sliceDoc(from, to).toLowerCase(), quoteStart = '"', quoteEnd = '"';
            if (/^['"]/.test(base)) {
                token = base[0] == '"' ? /^[^"]*$/ : /^[^']*$/;
                quoteStart = "";
                quoteEnd = state.sliceDoc(to, to + 1) == base[0] ? "" : base[0];
                base = base.slice(1);
                from++;
            }
            else {
                token = /^[^\s<>='"]*$/;
            }
            for (let value of attrs)
                options.push({ label: value, apply: quoteStart + value + quoteEnd, type: "constant" });
        }
    }
    return { from, to, options, validFor: token };
}
function htmlCompletionFor(schema, context) {
    let { state, pos } = context, tree = dist_syntaxTree(state).resolveInner(pos, -1), around = tree.resolve(pos);
    for (let scan = pos, before; around == tree && (before = tree.childBefore(scan));) {
        let last = before.lastChild;
        if (!last || !last.type.isError || last.from < last.to)
            break;
        around = tree = before;
        scan = last.from;
    }
    if (tree.name == "TagName") {
        return tree.parent && /CloseTag$/.test(tree.parent.name) ? completeCloseTag(state, tree, tree.from, pos)
            : completeTag(state, schema, tree, tree.from, pos);
    }
    else if (tree.name == "StartTag") {
        return completeTag(state, schema, tree, pos, pos);
    }
    else if (tree.name == "StartCloseTag" || tree.name == "IncompleteCloseTag") {
        return completeCloseTag(state, tree, pos, pos);
    }
    else if (context.explicit && (tree.name == "OpenTag" || tree.name == "SelfClosingTag") || tree.name == "AttributeName") {
        return completeAttrName(state, schema, tree, tree.name == "AttributeName" ? tree.from : pos, pos);
    }
    else if (tree.name == "Is" || tree.name == "AttributeValue" || tree.name == "UnquotedAttributeValue") {
        return completeAttrValue(state, schema, tree, tree.name == "Is" ? pos : tree.from, pos);
    }
    else if (context.explicit && (around.name == "Element" || around.name == "Text" || around.name == "Document")) {
        return completeStartTag(state, schema, tree, pos);
    }
    else {
        return null;
    }
}
/**
HTML tag completion. Opens and closes tags and attributes in a
context-aware way.
*/
function htmlCompletionSource(context) {
    return htmlCompletionFor(Schema.default, context);
}
/**
Create a completion source for HTML extended with additional tags
or attributes.
*/
function htmlCompletionSourceWith(config) {
    let { extraTags, extraGlobalAttributes: extraAttrs } = config;
    let schema = extraAttrs || extraTags ? new Schema(extraTags, extraAttrs) : Schema.default;
    return (context) => htmlCompletionFor(schema, context);
}

const jsonParser = /*@__PURE__*/javascriptLanguage.parser.configure({ top: "SingleExpression" });
const defaultNesting = [
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript" || attrs.lang == "ts",
        parser: typescriptLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/babel" || attrs.type == "text/jsx",
        parser: jsxLanguage.parser },
    { tag: "script",
        attrs: attrs => attrs.type == "text/typescript-jsx",
        parser: tsxLanguage.parser },
    { tag: "script",
        attrs(attrs) {
            return /^(importmap|speculationrules|application\/(.+\+)?json)$/i.test(attrs.type);
        },
        parser: jsonParser },
    { tag: "script",
        attrs(attrs) {
            return !attrs.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(attrs.type);
        },
        parser: javascriptLanguage.parser },
    { tag: "style",
        attrs(attrs) {
            return (!attrs.lang || attrs.lang == "css") && (!attrs.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(attrs.type));
        },
        parser: cssLanguage.parser }
];
const defaultAttrs = /*@__PURE__*/[
    { name: "style",
        parser: /*@__PURE__*/cssLanguage.parser.configure({ top: "Styles" }) }
].concat(/*@__PURE__*/eventAttributes.map(name => ({ name, parser: javascriptLanguage.parser })));
/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlPlain = /*@__PURE__*/LRLanguage.define({
    name: "html",
    parser: /*@__PURE__*/dist_parser.configure({
        props: [
            /*@__PURE__*/indentNodeProp.add({
                Element(context) {
                    let after = /^(\s*)(<\/)?/.exec(context.textAfter);
                    if (context.node.to <= context.pos + after[0].length)
                        return context.continue();
                    return context.lineIndent(context.node.from) + (after[2] ? 0 : context.unit);
                },
                "OpenTag CloseTag SelfClosingTag"(context) {
                    return context.column(context.node.from) + context.unit;
                },
                Document(context) {
                    if (context.pos + /\s*/.exec(context.textAfter)[0].length < context.node.to)
                        return context.continue();
                    let endElt = null, close;
                    for (let cur = context.node;;) {
                        let last = cur.lastChild;
                        if (!last || last.name != "Element" || last.to != cur.to)
                            break;
                        endElt = cur = last;
                    }
                    if (endElt && !((close = endElt.lastChild) && (close.name == "CloseTag" || close.name == "SelfClosingTag")))
                        return context.lineIndent(endElt.from) + context.unit;
                    return null;
                }
            }),
            /*@__PURE__*/foldNodeProp.add({
                Element(node) {
                    let first = node.firstChild, last = node.lastChild;
                    if (!first || first.name != "OpenTag")
                        return null;
                    return { from: first.to, to: last.name == "CloseTag" ? last.from : node.to };
                }
            }),
            /*@__PURE__*/bracketMatchingHandle.add({
                "OpenTag CloseTag": node => node.getChild("TagName")
            })
        ]
    }),
    languageData: {
        commentTokens: { block: { open: "<!--", close: "-->" } },
        indentOnInput: /^\s*<\/\w+\W$/,
        wordChars: "-._"
    }
});
/**
A language provider based on the [Lezer HTML
parser](https://github.com/lezer-parser/html), extended with the
JavaScript and CSS parsers to parse the content of `<script>` and
`<style>` tags.
*/
const htmlLanguage = /*@__PURE__*/htmlPlain.configure({
    wrap: /*@__PURE__*/configureNesting(defaultNesting, defaultAttrs)
});
/**
Language support for HTML, including
[`htmlCompletion`](https://codemirror.net/6/docs/ref/#lang-html.htmlCompletion) and JavaScript and
CSS support extensions.
*/
function dist_html(config = {}) {
    let dialect = "", wrap;
    if (config.matchClosingTags === false)
        dialect = "noMatch";
    if (config.selfClosingTags === true)
        dialect = (dialect ? dialect + " " : "") + "selfClosing";
    if (config.nestedLanguages && config.nestedLanguages.length ||
        config.nestedAttributes && config.nestedAttributes.length)
        wrap = configureNesting((config.nestedLanguages || []).concat(defaultNesting), (config.nestedAttributes || []).concat(defaultAttrs));
    let lang = wrap ? htmlPlain.configure({ wrap, dialect }) : dialect ? htmlLanguage.configure({ dialect }) : htmlLanguage;
    return new LanguageSupport(lang, [
        htmlLanguage.data.of({ autocomplete: htmlCompletionSourceWith(config) }),
        config.autoCloseTags !== false ? dist_autoCloseTags : [],
        javascript().support,
        css().support
    ]);
}
const dist_selfClosers = /*@__PURE__*/new Set(/*@__PURE__*/"area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
/**
Extension that will automatically insert close tags when a `>` or
`/` is typed.
*/
const dist_autoCloseTags = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, text, insertTransaction) => {
    if (view.composing || view.state.readOnly || from != to || (text != ">" && text != "/") ||
        !htmlLanguage.isActiveAt(view.state, from, -1))
        return false;
    let base = insertTransaction(), { state } = base;
    let closeTags = state.changeByRange(range => {
        var _a, _b, _c;
        let didType = state.doc.sliceString(range.from - 1, range.to) == text;
        let { head } = range, around = dist_syntaxTree(state).resolveInner(head - 1, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (didType && text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" &&
                (name = dist_elementName(state.doc, around.parent, head)) &&
                !dist_selfClosers.has(name)) {
                let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
                let insert = `</${name}>`;
                return { range, changes: { from: head, to, insert } };
            }
        }
        else if (didType && text == "/" && around.name == "IncompleteCloseTag") {
            let base = around.parent;
            if (around.from == head - 2 && ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" &&
                (name = dist_elementName(state.doc, base, head)) && !dist_selfClosers.has(name)) {
                let to = head + (state.doc.sliceString(head, head + 1) === ">" ? 1 : 0);
                let insert = `${name}>`;
                return {
                    range: dist_EditorSelection.cursor(head + insert.length, -1),
                    changes: { from: head, to, insert }
                };
            }
        }
        return { range };
    });
    if (closeTags.changes.empty)
        return false;
    view.dispatch([
        base,
        state.update(closeTags, {
            userEvent: "input.complete",
            scrollIntoView: true
        })
    ]);
    return true;
});



// EXTERNAL MODULE: ./node_modules/@qwex/codemirror-beautify/node_modules/js-beautify/js/index.js
var js = __webpack_require__(921);
;// CONCATENATED MODULE: ./node_modules/@qwex/codemirror-beautify/dist/index.js







function getBeautify(state) {
    const stateLanguage = state.facet(language);
    if (stateLanguage === cssLanguage) {
        return (text, config) => (0,js.css_beautify)(text, config);
    }
    else if (stateLanguage === htmlLanguage) {
        return (text, config) => (0,js.html_beautify)(text, config);
    }
    else if (stateLanguage === javascriptLanguage) {
        return (text, config) => (0,js.js_beautify)(text, config);
    }
    else {
        return (text, config) => text;
    }
}
function beautifyText(range, { state, dispatch }) {
    var _a;
    let textIter = state.doc.iterRange(range.from, range.to);
    let text = '';
    while (!textIter.done) {
        text += textIter.value;
        textIter = textIter.next();
    }
    const configRaw = (_a = state.facet(beautifyConfig)) !== null && _a !== void 0 ? _a : {};
    const beautified = getBeautify(state)(state.doc.toString(), Object.assign({ indent_size: getIndentUnit(state) }, configRaw));
    if (state.selection.asSingle()
        .main == range) {
        dispatch(state.update(state.replaceSelection(beautified)));
    }
    else {
        dispatch(({
            changes: {
                from: range.from,
                to: range.to,
                insert: beautified
            }
        }));
    }
    return true;
}
const autoFormatSelected = ({ state, dispatch }) => {
    const range = state.selection.asSingle()
        .main;
    return beautifyText(range, { state, dispatch });
};
const autoFormaAll = ({ state, dispatch }) => {
    return beautifyText(dist_EditorSelection.range(0, state.doc.length), { state, dispatch });
};
const beautifyConfig = /*@__PURE__*/Facet.define();



;// CONCATENATED MODULE: ./src/code_manager/model/CodeMirrorEditor.ts
var CodeMirrorEditor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CodeMirrorEditor_assign = (undefined && undefined.__assign) || function () {
    CodeMirrorEditor_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return CodeMirrorEditor_assign.apply(this, arguments);
};












var CodeMirrorEditor = /** @class */ (function (_super) {
    CodeMirrorEditor_extends(CodeMirrorEditor, _super);
    function CodeMirrorEditor() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.readOnlyCompartment = new Compartment();
        _this.lineNumbersCompartment = new Compartment();
        return _this;
    }
    CodeMirrorEditor.prototype.defaults = function () {
        return {
            input: '',
            label: '',
            codeName: '',
            theme: 'hopscotch',
            readOnly: true,
            lineNumbers: true,
            autoFormat: true,
            readOnlyRanges: function (targetState) {
                return [];
            },
        };
    };
    Object.defineProperty(CodeMirrorEditor.prototype, "readonly", {
        get: function () {
            return this.get('readOnly');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CodeMirrorEditor.prototype, "readOnlyRanges", {
        get: function () {
            return this.get('readOnlyRanges');
        },
        enumerable: false,
        configurable: true
    });
    CodeMirrorEditor.prototype.editorFromTextArea = function (textarea, config) {
        var _a;
        var view = new EditorView(CodeMirrorEditor_assign({ doc: textarea.value }, config));
        (_a = textarea.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(view.dom, textarea);
        textarea.style.display = 'none';
        if (textarea.form)
            textarea.form.addEventListener('submit', function () {
                textarea.value = view.state.doc.toString();
            });
        return view;
    };
    CodeMirrorEditor.prototype.getCodeLanguage = function (name) {
        switch (name) {
            case 'htmlmixed':
                return dist_html();
            case 'css':
                return css();
            case 'js':
                return javascript();
            default:
                return undefined;
        }
    };
    CodeMirrorEditor.prototype.setReadonlyState = function (readOnly) {
        var _a = this, editor = _a.editor, readOnlyCompartment = _a.readOnlyCompartment;
        if (editor) {
            var readonlyState = editor.state.update({
                effects: [readOnlyCompartment.reconfigure(EditorState.readOnly.of(readOnly))],
            });
            editor.update([readonlyState]);
        }
    };
    CodeMirrorEditor.prototype.init = function (el) {
        (0,index_all.bindAll)(this, 'onChange');
        var languageState = this.getCodeLanguage(this.get('codeName'));
        var extensions = [];
        extensions.push(basicSetup);
        extensions.push(oneDarkTheme);
        extensions.push(this.lineNumbersCompartment.of(lineNumbers()));
        extensions.push(dist_syntaxHighlighting(oneDarkHighlightStyle));
        languageState && extensions.push(languageState);
        extensions.push(this.readOnlyCompartment.of(EditorState.readOnly.of(this.readonly)));
        extensions.push(c(this.readOnlyRanges));
        var state = EditorState.create({
            doc: el.value,
            extensions: extensions,
        });
        this.editor = this.editorFromTextArea(el, CodeMirrorEditor_assign({ state: state }, this.attributes));
        this.element = el;
        this.editor.dom.addEventListener('change', this.onChange);
        return this;
    };
    CodeMirrorEditor.prototype.onChange = function () {
        this.trigger('update', this);
    };
    CodeMirrorEditor.prototype.getEditor = function () {
        return this.editor;
    };
    /**
     * The element where the viewer is attached
     * @return {HTMLElement}
     */
    CodeMirrorEditor.prototype.getElement = function () {
        return this.element;
    };
    /**
     * Set the element which contains the viewer attached.
     * Generally, it should be just a textarea, but some editor might require
     * a container for it some in that case this method can be used
     * @param {HTMLElement} el
     * @return {self}
     */
    CodeMirrorEditor.prototype.setElement = function (el) {
        this.element = el;
        return this;
    };
    /**
     * Focus the viewer
     * @return {self}
     */
    CodeMirrorEditor.prototype.focus = function () {
        this.getEditor().focus();
        return this;
    };
    CodeMirrorEditor.prototype.getContent = function () {
        var ed = this.getEditor();
        return ed && ed.state.doc;
    };
    /** @inheritdoc */
    CodeMirrorEditor.prototype.setContent = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var readonly = this.readonly;
        if (this.editor) {
            this.setReadonlyState(false);
            var state = this.editor.state;
            var update = state.update({ changes: { from: 0, to: state.doc.length, insert: value } });
            this.editor.update([update]);
            var autoFormat = this.get('autoFormat');
            var canAutoFormat = autoFormat === true || (Array.isArray(autoFormat) && autoFormat.includes(this.get('codeName')));
            if (canAutoFormat) {
                autoFormaAll(this.editor);
            }
            this.setReadonlyState(readonly);
        }
    };
    return CodeMirrorEditor;
}(common/* Model */.Hn));
/* harmony default export */ const model_CodeMirrorEditor = (CodeMirrorEditor);
// @ts-ignore
CodeMirrorEditor.prototype.CodeMirror = EditorView;

;// CONCATENATED MODULE: ./src/common/traits/view/TraitFunctionView.ts
var TraitFunctionView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TraitFunctionView_TraitTextView = /** @class */ (function (_super) {
    TraitFunctionView_extends(TraitTextView, _super);
    function TraitTextView(em, opts) {
        var _this = _super.call(this, em, opts) || this;
        _this.type = 'function';
        return _this;
    }
    Object.defineProperty(TraitTextView.prototype, "clsLabel", {
        get: function () {
            var ppfx = this.ppfx;
            return "".concat(ppfx, "field");
        },
        enumerable: false,
        configurable: true
    });
    TraitTextView.prototype.getInputElem = function () {
        var _a = this, input = _a.input, $input = _a.$input;
        return input || ($input && $input.get && $input.get(0)) || this.getElInput();
    };
    Object.defineProperty(TraitTextView.prototype, "inputValue", {
        get: function () {
            var _a;
            var el = this.getInputElem();
            return (_a = el === null || el === void 0 ? void 0 : el.value) !== null && _a !== void 0 ? _a : this.target.value;
        },
        set: function (value) {
            var el = this.getInputElem();
            el && (el.value = value);
        },
        enumerable: false,
        configurable: true
    });
    //   protected getInputEl() {
    //     // if (!this.$input) {
    //       const { em, name, type } = this;
    //       const value = this.target.value;
    //       const el = $(`<div class="${type}">`)!
    //       const editor = new CodeMirrorEditor({el})
    //       const input: JQuery<HTMLInputElement> = $(`<input type="${type}">`);
    //       const i18nAttr = em.t(`traitManager.traits.attributes.${name}`) || {};
    //       input.attr({
    //         placeholder: this.paceholder || value,
    //         ...i18nAttr,
    //       });
    //     //   if (!isUndefined(value)) {
    //     //     input.prop('value', value as any);
    //     //   }
    //     // }
    //     return el.get(0);
    //   }
    TraitTextView.prototype.templateInput = function () {
        return '';
    };
    TraitTextView.prototype.renderField = function () {
        var _a = this, $el = _a.$el, appendInput = _a.appendInput, elInput = _a.elInput;
        var inputs = $el.find('[data-input]');
        var el = inputs[inputs.length - 1];
        var txtarea = document.createElement('textarea');
        txtarea.value = 'function(){ \n //TODO: implementing it \n}';
        el.appendChild(txtarea);
        var editor = new model_CodeMirrorEditor({
            el: txtarea,
            readOnly: false,
            lineNumbers: false,
            codeName: 'js',
            readOnlyRanges: function (state) { return [
                { to: state.doc.line(1).to },
                { from: state.doc.line(state.doc.lines).from },
            ]; },
        });
        // const cont = document.createElement('div');
        // editor.set({
        // //   ...this.config.optsCodeViewer,
        //   readOnly: false,
        //   lineNumbers: false,
        //   readOnlyRanges: (state: EditorState) =>
        //   [{to: state.doc.line(1).to}, {from: state.doc.line(state.doc.lines).from}]
        // });
        editor.init(txtarea);
        // editor.setContent(`function(){ \n //TODO: implementing it \n}`)
        // editor.setElement(el);
        // if (!elInput) {
        //   this.elInput = this.getInputEl();
        //   appendInput ? el.appendChild(this.elInput!) : el.insertBefore(this.elInput!, el.firstChild);
        // }
    };
    return TraitTextView;
}(view_TraitInputView));
/* harmony default export */ const TraitFunctionView = (TraitFunctionView_TraitTextView);

;// CONCATENATED MODULE: ./src/common/traits/index.ts
var traits_assign = (undefined && undefined.__assign) || function () {
    traits_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return traits_assign.apply(this, arguments);
};














var InputFactory = /** @class */ (function () {
    function InputFactory() {
    }
    InputFactory.build = function (model, trait) {
        if (!(trait instanceof model_Trait)) {
            if ((0,index_all.isString)(trait)) {
                return new model_TraitSingle(trait, model, { label: trait });
            }
            else {
                switch (trait.type) {
                    case 'list':
                        return new model_TraitList(trait.name, model, traits_assign(traits_assign({}, trait), { name: trait.name }));
                    default:
                        return new model_TraitSingle(trait.name, model, trait);
                }
            }
        }
        else {
            return trait;
        }
    };
    /**
     * Build props object by their name
     */
    InputFactory.buildView = function (target, em, opts) {
        var type;
        var prop = traits_assign({ name: target.name }, opts);
        if (opts !== undefined) {
            type = opts.type;
            prop = opts;
        }
        var view;
        switch (target.name) {
            case 'target':
                var options = em.Traits.config.optionsTarget;
                view = new view_TraitSelectView(em, traits_assign(traits_assign({ name: target.name }, prop), { default: false, options: options }));
                break;
            default:
                if (target instanceof model_TraitGroup) {
                    view = new view_TraitsView(em, traits_assign(traits_assign(traits_assign({}, target.opts), opts), { traits: target.traits }));
                }
                else {
                    var ViewClass = this.getView(type, prop);
                    //@ts-ignore
                    view = new ViewClass(em, opts);
                }
                break;
        }
        return view.setTarget(target);
    };
    InputFactory.getView = function (type, opts) {
        switch (type) {
            case 'text':
                return view_TraitTextView;
            case 'number':
                return opts.units ? TraitNumberUnitView : TraitNumberView;
            case 'select':
                return view_TraitSelectView;
            case 'checkbox':
                return view_TraitCheckboxView;
            case 'color':
                return view_TraitColorView;
            case 'button':
                return view_TraitButtonView;
            case 'list':
                return view_TraitListView;
            case 'function':
                return TraitFunctionView;
            default:
                return view_TraitTextView;
        }
    };
    return InputFactory;
}());
/* harmony default export */ const common_traits = (InputFactory);

;// CONCATENATED MODULE: ./src/dom_components/model/Component.ts
var Component_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Component_assign = (undefined && undefined.__assign) || function () {
    Component_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Component_assign.apply(this, arguments);
};
var Component_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Component_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};








var escapeRegExp = function (str) {
    return str.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&');
};
var avoidInline = function (em) { return !!(em === null || em === void 0 ? void 0 : em.getConfig().avoidInlineStyle); };
var eventDrag = 'component:drag';
var keySymbols = '__symbols';
var keySymbol = '__symbol';
var keySymbolOvrd = '__symbol_ovrd';
var keyUpdate = 'component:update';
var keyUpdateInside = "".concat(keyUpdate, "-inside");
/**
 * The Component object represents a single node of our template structure, so when you update its properties the changes are
 * immediately reflected on the canvas and in the code to export (indeed, when you ask to export the code we just go through all
 * the tree of nodes).
 * An example on how to update properties:
 * ```js
 * component.set({
 *  tagName: 'span',
 *  attributes: { ... },
 *  removable: false,
 * });
 * component.get('tagName');
 * // -> 'span'
 * ```
 *
 * [Component]: component.html
 *
 * @property {String} [type=''] Component type, eg. `text`, `image`, `video`, etc.
 * @property {String} [tagName='div'] HTML tag of the component, eg. `span`. Default: `div`
 * @property {Object} [attributes={}] Key-value object of the component's attributes, eg. `{ title: 'Hello' }` Default: `{}`
 * @property {String} [name=''] Name of the component. Will be used, for example, in Layers and badges
 * @property {Boolean} [removable=true] When `true` the component is removable from the canvas, default: `true`
 * @property {Boolean|String|Function} [draggable=true] Indicates if it's possible to drag the component inside others.
 *  You can also specify a query string to indentify elements,
 *  eg. `'.some-class[title=Hello], [data-gjs-type=column]'` means you can drag the component only inside elements
 *  containing `some-class` class and `Hello` title, and `column` components. In the case of a function, target and destination components are passed as arguments, return a Boolean to indicate if the drag is possible. Default: `true`
 * @property {Boolean|String|Function} [droppable=true] Indicates if it's possible to drop other components inside. You can use
 * a query string as with `draggable`. In the case of a function, target and destination components are passed as arguments, return a Boolean to indicate if the drop is possible. Default: `true`
 * @property {Boolean} [badgable=true] Set to false if you don't want to see the badge (with the name) over the component. Default: `true`
 * @property {Boolean|Array<String>} [stylable=true] True if it's possible to style the component.
 * You can also indicate an array of CSS properties which is possible to style, eg. `['color', 'width']`, all other properties
 * will be hidden from the style manager. Default: `true`
 * @property {Array<String>} [stylable-require=[]] Indicate an array of style properties to show up which has been marked as `toRequire`. Default: `[]`
 * @property {Array<String>} [unstylable=[]] Indicate an array of style properties which should be hidden from the style manager. Default: `[]`
 * @property {Boolean} [highlightable=true] It can be highlighted with 'dotted' borders if true. Default: `true`
 * @property {Boolean} [copyable=true] True if it's possible to clone the component. Default: `true`
 * @property {Boolean} [resizable=false] Indicates if it's possible to resize the component. It's also possible to pass an object as [options for the Resizer](https://github.com/GrapesJS/grapesjs/blob/master/src/utils/Resizer.js). Default: `false`
 * @property {Boolean} [editable=false] Allow to edit the content of the component (used on Text components). Default: `false`
 * @property {Boolean} [layerable=true] Set to `false` if you need to hide the component inside Layers. Default: `true`
 * @property {Boolean} [selectable=true] Allow component to be selected when clicked. Default: `true`
 * @property {Boolean} [hoverable=true] Shows a highlight outline when hovering on the element if `true`. Default: `true`
 * @property {Boolean} [locked=false] Disable the selection of the component and its children in the canvas. Default: `false`
 * @property {Boolean} [void=false] This property is used by the HTML exporter as void elements don't have closing tags, eg. `<br/>`, `<hr/>`, etc. Default: `false`
 * @property {Object} [style={}] Component default style, eg. `{ width: '100px', height: '100px', 'background-color': 'red' }`
 * @property {String} [styles=''] Component related styles, eg. `.my-component-class { color: red }`
 * @property {String} [content=''] Content of the component (not escaped) which will be appended before children rendering. Default: `''`
 * @property {String} [icon=''] Component's icon, this string will be inserted before the name (in Layers and badge), eg. it can be an HTML string '<i class="fa fa-square-o"></i>'. Default: `''`
 * @property {String|Function} [script=''] Component's javascript. More about it [here](/modules/Components-js.html). Default: `''`
 * @property {String|Function} [script-export=''] You can specify javascript available only in export functions (eg. when you get the HTML).
 * If this property is defined it will overwrite the `script` one (in export functions). Default: `''`
 * @property {Array<Object|String>} [traits=''] Component's traits. More about it [here](/modules/Traits.html). Default: `['id', 'title']`
 * @property {Array<String>} [propagate=[]] Indicates an array of properties which will be inhereted by all NEW appended children.
 *  For example if you create a component likes this: `{ removable: false, draggable: false, propagate: ['removable', 'draggable'] }`
 *  and append some new component inside, the new added component will get the exact same properties indicated in the `propagate` array (and the `propagate` property itself). Default: `[]`
 * @property {Array<Object>} [toolbar=null] Set an array of items to show up inside the toolbar when the component is selected (move, clone, delete).
 * Eg. `toolbar: [ { attributes: {class: 'fa fa-arrows'}, command: 'tlb-move' }, ... ]`.
 * By default, when `toolbar` property is falsy the editor will add automatically commands `core:component-exit` (select parent component, added if there is one), `tlb-move` (added if `draggable`) , `tlb-clone` (added if `copyable`), `tlb-delete` (added if `removable`).
 * @property {Collection<Component>} [components=null] Children components. Default: `null`
 * @property {Object} [delegate=null] Delegate commands to other components. Available commands `remove` | `move` | `copy` | `select`. eg. `{ remove: (cmp) => cmp.closestType('other-type') }`
 *
 * @module docsjs.Component
 */
var Component = /** @class */ (function (_super) {
    Component_extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Component.prototype, "defaults", {
        /**
         * @private
         * @ts-ignore */
        get: function () {
            var _a;
            return _a = {
                    tagName: 'div',
                    type: '',
                    name: '',
                    removable: true,
                    draggable: true,
                    droppable: true,
                    badgable: true,
                    stylable: true,
                    'stylable-require': '',
                    'style-signature': '',
                    unstylable: '',
                    highlightable: true,
                    copyable: true,
                    resizable: false,
                    editable: false,
                    layerable: true,
                    selectable: true,
                    hoverable: true,
                    locked: false,
                    void: false,
                    state: '', // Indicates if the component is in some CSS state like ':hover', ':active', etc.
                    status: '', // State, eg. 'selected'
                    content: '',
                    icon: '',
                    style: '',
                    styles: '', // Component related styles
                    classes: '', // Array of classes
                    script: '',
                    'script-props': '',
                    'script-export': '',
                    attributes: {},
                    traits: ['id', 'title'],
                    propagate: '',
                    dmode: '',
                    toolbar: null,
                    delegate: null
                },
                _a[keySymbol] = 0,
                _a[keySymbols] = 0,
                _a[keySymbolOvrd] = 0,
                _a._undo = true,
                _a._undoexc = ['status', 'open'],
                _a;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "classes", {
        get: function () {
            return this.get('classes');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "traits", {
        get: function () {
            return this.get('traits');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "content", {
        get: function () {
            var _a;
            return (_a = this.get('content')) !== null && _a !== void 0 ? _a : '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "toolbar", {
        get: function () {
            return this.get('toolbar') || [];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "resizable", {
        get: function () {
            return this.get('resizable');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Component.prototype, "delegate", {
        get: function () {
            return this.get('delegate');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Hook method, called once the model is created
     */
    Component.prototype.init = function () { };
    /**
     * Hook method, called when the model has been updated (eg. updated some model's property)
     * @param {String} property Property name, if triggered after some property update
     * @param {*} value Property value, if triggered after some property update
     * @param {*} previous Property previous value, if triggered after some property update
     */
    Component.prototype.updated = function (property, value, previous) { };
    /**
     * Hook method, called once the model has been removed
     */
    Component.prototype.removed = function () { };
    Component.prototype.initialize = function (props, opt) {
        var _this = this;
        if (props === void 0) { props = {}; }
        if (opt === void 0) { opt = {}; }
        (0,index_all.bindAll)(this, '__upSymbProps', '__upSymbCls', '__upSymbComps');
        var em = opt.em;
        // Propagate properties from parent if indicated
        var parent = this.parent();
        var parentAttr = parent === null || parent === void 0 ? void 0 : parent.attributes;
        var propagate = this.get('propagate');
        propagate && this.set('propagate', (0,index_all.isArray)(propagate) ? propagate : [propagate]);
        if (parentAttr && parentAttr.propagate && !propagate) {
            var newAttr_1 = {};
            var toPropagate = parentAttr.propagate;
            toPropagate.forEach(function (prop) { return (newAttr_1[prop] = parent.get(prop)); });
            newAttr_1.propagate = toPropagate;
            this.set(Component_assign(Component_assign({}, newAttr_1), props));
        }
        // Check void elements
        if (opt && opt.config && opt.config.voidElements.indexOf(this.get('tagName')) >= 0) {
            this.set('void', true);
        }
        opt.em = em;
        this.opt = opt;
        this.em = em;
        this.frame = opt.frame;
        this.config = opt.config || {};
        this.set('attributes', Component_assign(Component_assign({}, ((0,index_all.result)(this, 'defaults').attributes || {})), (this.get('attributes') || {})));
        this.ccid = Component.createId(this, opt);
        this.initClasses();
        this.initComponents();
        this.initTraits();
        this.initToolbar();
        this.initScriptProps();
        this.listenTo(this, 'change:script', this.scriptUpdated);
        this.listenTo(this, 'change:tagName', this.tagUpdated);
        this.listenTo(this, 'change:attributes', this.attrUpdated);
        this.listenTo(this, 'change:attributes:id', this._idUpdated);
        this.on('change:toolbar', this.__emitUpdateTlb);
        this.on('change', this.__onChange);
        this.on(keyUpdateInside, this.__propToParent);
        this.set('status', '');
        this.views = [];
        // Register global updates for collection properties
        ['classes', 'components'].forEach(function (name) {
            var events = "add remove ".concat(name !== 'components' ? 'change' : '');
            _this.listenTo(_this.get(name), events.trim(), function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return _this.emitUpdate.apply(_this, Component_spreadArray([name], args, false));
            });
        });
        if (!opt.temporary) {
            // Add component styles
            var cssc = em && em.Css;
            var _a = this.attributes, styles = _a.styles, type = _a.type;
            if (styles && cssc) {
                cssc.addCollection(styles, { avoidUpdateStyle: true }, { group: "cmp:".concat(type) });
            }
            this.__postAdd();
            this.init();
            this.__isSymbolOrInst() && this.__initSymb();
            em && em.trigger('component:create', this);
        }
    };
    Component.prototype.__postAdd = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var um = em === null || em === void 0 ? void 0 : em.UndoManager;
        var comps = this.components();
        if (um && !this.__hasUm) {
            um.add(comps);
            um.add(this.getSelectors());
            this.__hasUm = true;
        }
        opts.recursive && comps.map(function (c) { return c.__postAdd(opts); });
    };
    Component.prototype.__postRemove = function () {
        var em = this.em;
        var um = em === null || em === void 0 ? void 0 : em.get('UndoManager');
        if (um) {
            um.remove(this.components());
            um.remove(this.getSelectors());
            delete this.__hasUm;
        }
    };
    Component.prototype.__onChange = function (m, opts) {
        var _this = this;
        var changed = this.changedAttributes() || {};
        (0,index_all.keys)(changed).forEach(function (prop) { return _this.emitUpdate(prop); });
        ['status', 'open', 'toolbar', 'traits'].forEach(function (name) { return delete changed[name]; });
        // Propagate component prop changes
        if (!(0,mixins.isEmptyObj)(changed)) {
            this.__changesUp(opts);
            this.__propSelfToParent({ component: this, changed: changed, options: opts });
        }
    };
    Component.prototype.__onStyleChange = function (newStyles) {
        var _this = this;
        var em = this.em;
        if (!em)
            return;
        var event = 'component:styleUpdate';
        var styleKeys = (0,index_all.keys)(newStyles);
        var pros = { style: newStyles };
        em.trigger(event, this, pros);
        styleKeys.forEach(function (key) { return em.trigger("".concat(event, ":").concat(key), _this, pros); });
    };
    Component.prototype.__changesUp = function (opts) {
        var _a = this, em = _a.em, frame = _a.frame;
        [frame, em].forEach(function (md) { return md && md.changesUp(opts); });
    };
    Component.prototype.__propSelfToParent = function (props) {
        this.trigger(keyUpdate, props);
        this.__propToParent(props);
    };
    Component.prototype.__propToParent = function (props) {
        var parent = this.parent();
        parent && parent.trigger(keyUpdateInside, props);
    };
    Component.prototype.__emitUpdateTlb = function () {
        this.emitUpdate('toolbar');
    };
    /**
     * Check component's type
     * @param  {string}  type Component type
     * @return {Boolean}
     * @example
     * component.is('image')
     * // -> false
     */
    Component.prototype.is = function (type) {
        return !!(this.get('type') == type);
    };
    /**
     * Return all the propeties
     * @returns {Object}
     */
    Component.prototype.props = function () {
        return this.attributes;
    };
    /**
     * Get the index of the component in the parent collection.
     * @return {Number}
     */
    Component.prototype.index = function () {
        var collection = this.collection;
        return collection ? collection.indexOf(this) : 0;
    };
    /**
     * Change the drag mode of the component.
     * To get more about this feature read: https://github.com/GrapesJS/grapesjs/issues/1936
     * @param {String} value Drag mode, options: `'absolute'` | `'translate'` | `''`
     * @returns {this}
     */
    Component.prototype.setDragMode = function (value) {
        return this.set('dmode', value);
    };
    /**
     * Get the drag mode of the component.
     * @returns {String} Drag mode value, options: `'absolute'` | `'translate'` | `''`
     */
    Component.prototype.getDragMode = function () {
        return this.get('dmode') || '';
    };
    /**
     * Find inner components by query string.
     * **ATTENTION**: this method works only with already rendered component
     * @param  {String} query Query string
     * @return {Array} Array of components
     * @example
     * component.find('div > .class');
     * // -> [Component, Component, ...]
     */
    Component.prototype.find = function (query) {
        var _a;
        var result = [];
        var $els = (_a = this.view) === null || _a === void 0 ? void 0 : _a.$el.find(query);
        $els === null || $els === void 0 ? void 0 : $els.each(function (i) {
            var $el = $els.eq(i);
            var model = $el.data('model');
            model && result.push(model);
        });
        return result;
    };
    /**
     * Find all inner components by component type.
     * The advantage of this method over `find` is that you can use it
     * also before rendering the component
     * @param {String} type Component type
     * @returns {Array<Component>}
     * @example
     * const allImages = component.findType('image');
     * console.log(allImages[0]) // prints the first found component
     */
    Component.prototype.findType = function (type) {
        var result = [];
        var find = function (components) {
            return components.forEach(function (item) {
                item.is(type) && result.push(item);
                find(item.components());
            });
        };
        find(this.components());
        return result;
    };
    /**
     * Find the closest parent component by query string.
     * **ATTENTION**: this method works only with already rendered component
     * @param  {string} query Query string
     * @return {Component}
     * @example
     * component.closest('div.some-class');
     * // -> Component
     */
    Component.prototype.closest = function (query) {
        var _a;
        var result = (_a = this.view) === null || _a === void 0 ? void 0 : _a.$el.closest(query);
        return (result === null || result === void 0 ? void 0 : result.length) ? result.data('model') : undefined;
    };
    /**
     * Find the closest parent component by its type.
     * The advantage of this method over `closest` is that you can use it
     * also before rendering the component
     * @param {String} type Component type
     * @returns {Component} Found component, otherwise `undefined`
     * @example
     * const Section = component.closestType('section');
     * console.log(Section);
     */
    Component.prototype.closestType = function (type) {
        var parent = this.parent();
        while (parent && !parent.is(type)) {
            parent = parent.parent();
        }
        return parent;
    };
    /**
     * The method returns a Boolean value indicating whether the passed
     * component is a descendant of a given component
     * @param {Component} component Component to check
     * @returns {Boolean}
     */
    Component.prototype.contains = function (component) {
        var result = !1;
        if (!component)
            return result;
        var contains = function (components) {
            !result &&
                components.forEach(function (item) {
                    if (item === component)
                        result = !0;
                    !result && contains(item.components());
                });
        };
        contains(this.components());
        return result;
    };
    /**
     * Once the tag is updated I have to rerender the element
     * @private
     */
    Component.prototype.tagUpdated = function () {
        this.trigger('rerender');
    };
    /**
     * Replace a component with another one
     * @param {String|Component} el Component or HTML string
     * @param {Object} [opts={}] Options for the append action
     * @returns {Array<Component>} New replaced components
     * @example
     * const result = component.replaceWith('<div>Some new content</div>');
     * // result -> [Component]
     */
    Component.prototype.replaceWith = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var coll = this.collection;
        var at = coll.indexOf(this);
        coll.remove(this);
        var result = coll.add(el, Component_assign(Component_assign({}, opts), { at: at }));
        return (0,index_all.isArray)(result) ? result : [result];
    };
    /**
     * Emit changes for each updated attribute
     * @private
     */
    Component.prototype.attrUpdated = function (m, v, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var attrs = this.get('attributes');
        // Handle classes
        var classes = attrs.class;
        classes && this.setClass(classes);
        delete attrs.class;
        // Handle style
        var style = attrs.style;
        style && this.setStyle(style);
        delete attrs.style;
        var attrPrev = Component_assign({}, this.previous('attributes'));
        var diff = (0,mixins.shallowDiff)(attrPrev, this.get('attributes'));
        (0,index_all.keys)(diff).forEach(function (pr) { return _this.trigger("change:attributes:".concat(pr), _this, diff[pr], opts); });
    };
    /**
     * Update attributes of the component
     * @param {Object} attrs Key value attributes
     * @param {Object} options Options for the model update
     * @return {this}
     * @example
     * component.setAttributes({ id: 'test', 'data-key': 'value' });
     */
    Component.prototype.setAttributes = function (attrs, opts) {
        if (opts === void 0) { opts = {}; }
        this.set('attributes', Component_assign({}, attrs), opts);
        return this;
    };
    /**
     * Add attributes to the component
     * @param {Object} attrs Key value attributes
     * @param {Object} options Options for the model update
     * @return {this}
     * @example
     * component.addAttributes({ 'data-key': 'value' });
     */
    Component.prototype.addAttributes = function (attrs, opts) {
        if (opts === void 0) { opts = {}; }
        return this.setAttributes(Component_assign(Component_assign({}, this.getAttributes({ noClass: true })), attrs), opts);
    };
    /**
     * Remove attributes from the component
     * @param {String|Array<String>} attrs Array of attributes to remove
     * @param {Object} options Options for the model update
     * @return {this}
     * @example
     * component.removeAttributes('some-attr');
     * component.removeAttributes(['some-attr1', 'some-attr2']);
     */
    Component.prototype.removeAttributes = function (attrs, opts) {
        if (attrs === void 0) { attrs = []; }
        if (opts === void 0) { opts = {}; }
        var attrArr = Array.isArray(attrs) ? attrs : [attrs];
        var compAttr = this.getAttributes();
        attrArr.map(function (i) { return delete compAttr[i]; });
        return this.setAttributes(compAttr, opts);
    };
    /**
     * Get the style of the component
     * @return {Object}
     */
    Component.prototype.getStyle = function (options, optsAdd) {
        if (options === void 0) { options = {}; }
        if (optsAdd === void 0) { optsAdd = {}; }
        var em = this.em;
        var prop = (0,index_all.isString)(options) ? options : '';
        var opts = prop ? optsAdd : options;
        if (avoidInline(em) && !opts.inline) {
            var state = em.get('state');
            var cc = em.Css;
            var rule = cc.getIdRule(this.getId(), Component_assign({ state: state }, opts));
            this.rule = rule;
            if (rule) {
                return rule.getStyle(prop);
            }
        }
        return _super.prototype.getStyle.call(this, prop);
    };
    /**
     * Set the style on the component
     * @param {Object} prop Key value style object
     * @return {Object}
     * @example
     * component.setStyle({ color: 'red' });
     */
    Component.prototype.setStyle = function (prop, opts) {
        var _this = this;
        if (prop === void 0) { prop = {}; }
        if (opts === void 0) { opts = {}; }
        var _a = this, opt = _a.opt, em = _a.em;
        if (avoidInline(em) && !opt.temporary && !opts.inline) {
            var style = this.get('style') || {};
            prop = (0,index_all.isString)(prop) ? this.parseStyle(prop) : prop;
            prop = Component_assign(Component_assign({}, prop), style);
            var state = em.get('state');
            var cc = em.Css;
            var propOrig = this.getStyle(opts);
            this.rule = cc.setIdRule(this.getId(), prop, Component_assign({ state: state }, opts));
            var diff = (0,mixins.shallowDiff)(propOrig, prop);
            this.set('style', '', { silent: true });
            (0,index_all.keys)(diff).forEach(function (pr) { return _this.trigger("change:style:".concat(pr)); });
        }
        else {
            prop = _super.prototype.setStyle.apply(this, arguments);
        }
        if (!opt.temporary) {
            this.__onStyleChange(opts.addStyle || prop);
        }
        return prop;
    };
    /**
     * Return all component's attributes
     * @return {Object}
     */
    Component.prototype.getAttributes = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var classes = [];
        var attributes = Component_assign({}, this.get('attributes'));
        var sm = em === null || em === void 0 ? void 0 : em.Selectors;
        var id = this.getId();
        // Add classes
        if (opts.noClass) {
            delete attributes.class;
        }
        else {
            this.classes.forEach(function (cls) { return classes.push((0,index_all.isString)(cls) ? cls : cls.getName()); });
            classes.length && (attributes.class = classes.join(' '));
        }
        // Add style
        if (!opts.noStyle) {
            var style = this.get('style');
            if ((0,mixins.isObject)(style) && !(0,mixins.isEmptyObj)(style)) {
                attributes.style = this.styleToString({ inline: 1 });
            }
        }
        // Check if we need an ID on the component
        if (!(0,index_all.has)(attributes, 'id')) {
            var addId = false;
            // If we don't rely on inline styling we have to check
            // for the ID selector
            if (avoidInline(em) || !(0,index_all.isEmpty)(this.getStyle())) {
                addId = !!(sm === null || sm === void 0 ? void 0 : sm.get(id, sm.Selector.TYPE_ID));
            }
            if (
            // Symbols should always have an id
            this.__getSymbol() ||
                this.__getSymbols() ||
                // Components with script should always have an id
                this.get('script-export') ||
                this.get('script')) {
                addId = true;
            }
            if (addId) {
                attributes.id = id;
            }
        }
        return attributes;
    };
    /**
     * Add classes
     * @param {Array<String>|String} classes Array or string of classes
     * @return {Array} Array of added selectors
     * @example
     * model.addClass('class1');
     * model.addClass('class1 class2');
     * model.addClass(['class1', 'class2']);
     * // -> [SelectorObject, ...]
     */
    Component.prototype.addClass = function (classes) {
        var added = this.em.Selectors.addClass(classes);
        return this.classes.add(added);
    };
    /**
     * Set classes (resets current collection)
     * @param {Array<String>|String} classes Array or string of classes
     * @return {Array} Array of added selectors
     * @example
     * model.setClass('class1');
     * model.setClass('class1 class2');
     * model.setClass(['class1', 'class2']);
     * // -> [SelectorObject, ...]
     */
    Component.prototype.setClass = function (classes) {
        this.classes.reset();
        return this.addClass(classes);
    };
    /**
     * Remove classes
     * @param {Array<String>|String} classes Array or string of classes
     * @return {Array} Array of removed selectors
     * @example
     * model.removeClass('class1');
     * model.removeClass('class1 class2');
     * model.removeClass(['class1', 'class2']);
     * // -> [SelectorObject, ...]
     */
    Component.prototype.removeClass = function (classes) {
        var removed = [];
        classes = (0,index_all.isArray)(classes) ? classes : [classes];
        var selectors = this.classes;
        var type = model_Selector.TYPE_CLASS;
        classes.forEach(function (classe) {
            var classes = classe.split(' ');
            classes.forEach(function (name) {
                var selector = selectors.where({ name: name, type: type })[0];
                selector && removed.push(selectors.remove(selector));
            });
        });
        return removed;
    };
    /**
     * Returns component's classes as an array of strings
     * @return {Array}
     */
    Component.prototype.getClasses = function () {
        var attr = this.getAttributes();
        var classStr = attr.class;
        return classStr ? classStr.split(' ') : [];
    };
    Component.prototype.__logSymbol = function (type, toUp, opts) {
        if (opts === void 0) { opts = {}; }
        var symbol = this.__getSymbol();
        var symbols = this.__getSymbols();
        if (!symbol && !symbols)
            return;
        this.em.log(type, { model: this, toUp: toUp, context: 'symbols', opts: opts });
    };
    Component.prototype.__initSymb = function () {
        if (this.__symbReady)
            return;
        this.on('change', this.__upSymbProps);
        this.__symbReady = true;
    };
    Component.prototype.__isSymbol = function () {
        return (0,index_all.isArray)(this.get(keySymbols));
    };
    Component.prototype.__isSymbolOrInst = function () {
        return !!(this.__isSymbol() || this.get(keySymbol));
    };
    Component.prototype.__isSymbolTop = function () {
        var parent = this.parent();
        var symb = this.__isSymbolOrInst();
        return symb && (!parent || (parent && !parent.__isSymbol() && !parent.__getSymbol()));
    };
    Component.prototype.__isSymbolNested = function () {
        if (!this.__isSymbolOrInst() || this.__isSymbolTop())
            return false;
        var symbTopSelf = (this.__isSymbol() ? this : this.__getSymbol()).__getSymbTop();
        var symbTop = this.__getSymbTop();
        var symbTopMain = symbTop.__isSymbol() ? symbTop : symbTop.__getSymbol();
        return symbTopMain !== symbTopSelf;
    };
    Component.prototype.__getAllById = function () {
        var em = this.em;
        return em ? em.Components.allById() : {};
    };
    Component.prototype.__getSymbol = function () {
        var symb = this.get(keySymbol);
        if (symb && (0,index_all.isString)(symb)) {
            var ref = this.__getAllById()[symb];
            if (ref) {
                symb = ref;
                this.set(keySymbol, ref);
            }
            else {
                symb = 0;
            }
        }
        return symb;
    };
    Component.prototype.__getSymbols = function () {
        var _this = this;
        var symbs = this.get(keySymbols);
        if (symbs && (0,index_all.isArray)(symbs)) {
            symbs.forEach(function (symb, idx) {
                if (symb && (0,index_all.isString)(symb)) {
                    symbs[idx] = _this.__getAllById()[symb];
                }
            });
            symbs = symbs.filter(function (symb) { return symb && !(0,index_all.isString)(symb); });
        }
        return symbs;
    };
    Component.prototype.__isSymbOvrd = function (prop) {
        if (prop === void 0) { prop = ''; }
        var ovrd = this.get(keySymbolOvrd);
        var prp = prop.split(':')[0];
        var props = prop !== prp ? [prop, prp] : [prop];
        return ovrd === true || ((0,index_all.isArray)(ovrd) && props.some(function (p) { return ovrd.indexOf(p) >= 0; }));
    };
    Component.prototype.__getSymbToUp = function (opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var result = [];
        var changed = opts.changed;
        if (opts.fromInstance ||
            opts.noPropagate ||
            opts.fromUndo ||
            // Avoid updating others if the current component has override
            (changed && this.__isSymbOvrd(changed))) {
            return result;
        }
        var symbols = this.__getSymbols() || [];
        var symbol = this.__getSymbol();
        var all = symbol ? Component_spreadArray([symbol], (symbol.__getSymbols() || []), true) : symbols;
        result = all
            .filter(function (s) { return s !== _this; })
            // Avoid updating those with override
            .filter(function (s) { return !(changed && s.__isSymbOvrd(changed)); });
        return result;
    };
    Component.prototype.__getSymbTop = function (opts) {
        var result = this;
        var parent = this.parent(opts);
        while (parent && (parent.__isSymbol() || parent.__getSymbol())) {
            result = parent;
            parent = parent.parent(opts);
        }
        return result;
    };
    Component.prototype.__upSymbProps = function (m, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var changed = this.changedAttributes() || {};
        var attrs = changed.attributes || {};
        delete changed.status;
        delete changed.open;
        delete changed[keySymbols];
        delete changed[keySymbol];
        delete changed[keySymbolOvrd];
        delete changed.attributes;
        delete attrs.id;
        if (!(0,mixins.isEmptyObj)(attrs))
            changed.attributes = attrs;
        if (!(0,mixins.isEmptyObj)(changed)) {
            var toUp = this.__getSymbToUp(opts);
            // Avoid propagating overrides to other symbols
            (0,index_all.keys)(changed).map(function (prop) {
                if (_this.__isSymbOvrd(prop))
                    delete changed[prop];
            });
            this.__logSymbol('props', toUp, { opts: opts, changed: changed });
            toUp.forEach(function (child) {
                var propsChanged = Component_assign({}, changed);
                // Avoid updating those with override
                (0,index_all.keys)(propsChanged).map(function (prop) {
                    if (child.__isSymbOvrd(prop))
                        delete propsChanged[prop];
                });
                child.set(propsChanged, Component_assign({ fromInstance: _this }, opts));
            });
        }
    };
    Component.prototype.__upSymbCls = function (m, c, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var toUp = this.__getSymbToUp(opts);
        this.__logSymbol('classes', toUp, { opts: opts });
        toUp.forEach(function (child) {
            // @ts-ignore This will propagate the change up to __upSymbProps
            child.set('classes', _this.get('classes'), { fromInstance: _this });
        });
        this.__changesUp(opts);
    };
    Component.prototype.__upSymbComps = function (m, c, o) {
        var _this = this;
        var optUp = o || c || {};
        var fromInstance = optUp.fromInstance, fromUndo = optUp.fromUndo;
        var toUpOpts = { fromInstance: fromInstance, fromUndo: fromUndo };
        var isTemp = m.opt.temporary;
        // Reset
        if (!o) {
            var toUp = this.__getSymbToUp(Component_assign(Component_assign({}, toUpOpts), { changed: 'components:reset' }));
            // @ts-ignore
            var cmps_1 = m.models;
            this.__logSymbol('reset', toUp, { components: cmps_1 });
            toUp.forEach(function (symb) {
                var newMods = cmps_1.map(function (mod) { return mod.clone({ symbol: true }); });
                // @ts-ignore
                symb.components().reset(newMods, Component_assign({ fromInstance: _this }, c));
            });
            // Add
        }
        else if (o.add) {
            var addedInstances_1 = [];
            var isMainSymb_1 = !!this.__getSymbols();
            var toUp = this.__getSymbToUp(Component_assign(Component_assign({}, toUpOpts), { changed: 'components:add' }));
            if (toUp.length) {
                var addSymb = m.__getSymbol();
                addedInstances_1 = (addSymb ? addSymb.__getSymbols() : m.__getSymbols()) || [];
                addedInstances_1 = Component_spreadArray([], addedInstances_1, true);
                addedInstances_1.push(addSymb ? addSymb : m);
            }
            !isTemp &&
                this.__logSymbol('add', toUp, {
                    opts: o,
                    addedInstances: addedInstances_1.map(function (c) { return c.cid; }),
                    added: m.cid,
                });
            // Here, before appending a new symbol, I have to ensure there are no previously
            // created symbols (eg. used mainly when drag components around)
            toUp.forEach(function (symb) {
                var symbTop = symb.__getSymbTop();
                var symbPrev = addedInstances_1.filter(function (addedInst) {
                    var addedTop = addedInst.__getSymbTop({ prev: 1 });
                    return symbTop && addedTop && addedTop === symbTop;
                })[0];
                var toAppend = symbPrev || m.clone({ symbol: true, symbolInv: isMainSymb_1 });
                symb.append(toAppend, Component_assign({ fromInstance: _this }, o));
            });
            // Remove
        }
        else {
            // Remove instance reference from the symbol
            var symb = m.__getSymbol();
            symb &&
                !o.temporary &&
                symb.set(keySymbols, symb.__getSymbols().filter(function (i) { return i !== m; }));
            // Propagate remove only if the component is an inner symbol
            if (!m.__isSymbolTop()) {
                var changed_1 = 'components:remove';
                var index_1 = o.index;
                var parent_1 = m.parent();
                var opts_1 = Component_assign({ fromInstance: m }, o);
                var isSymbNested = m.__isSymbolNested();
                var toUpFn = function (symb) {
                    var symbPrnt = symb.parent();
                    symbPrnt && !symbPrnt.__isSymbOvrd(changed_1) && symb.remove(opts_1);
                };
                // Check if the parent allows the removing
                var toUp = !(parent_1 === null || parent_1 === void 0 ? void 0 : parent_1.__isSymbOvrd(changed_1)) ? m.__getSymbToUp(toUpOpts) : [];
                if (isSymbNested) {
                    toUp = parent_1 === null || parent_1 === void 0 ? void 0 : parent_1.__getSymbToUp(Component_assign(Component_assign({}, toUpOpts), { changed: changed_1 }));
                    toUpFn = function (symb) {
                        var toRemove = symb.components().at(index_1);
                        toRemove && toRemove.remove(Component_assign({ fromInstance: parent_1 }, opts_1));
                    };
                }
                !isTemp &&
                    this.__logSymbol('remove', toUp, {
                        opts: o,
                        removed: m.cid,
                        isSymbNested: isSymbNested,
                    });
                toUp.forEach(toUpFn);
            }
        }
        this.__changesUp(optUp);
    };
    Component.prototype.initClasses = function (m, c, opts) {
        if (opts === void 0) { opts = {}; }
        var event = 'change:classes';
        var _a = this.get('attributes') || {}, attrCls = _a.class, restAttr = Component_rest(_a, ["class"]);
        var toListen = [this, event, this.initClasses];
        var cls = this.get('classes') || attrCls || [];
        var clsArr = (0,index_all.isString)(cls) ? cls.split(' ') : cls;
        this.stopListening.apply(this, toListen);
        var classes = this.normalizeClasses(clsArr);
        var selectors = new model_Selectors([]);
        this.set('classes', selectors, opts);
        selectors.add(classes);
        selectors.on('add remove reset', this.__upSymbCls);
        // Clear attributes from classes
        attrCls && classes.length && this.set('attributes', restAttr);
        // @ts-ignore
        this.listenTo.apply(this, toListen);
        return this;
    };
    Component.prototype.initComponents = function () {
        var event = 'change:components';
        var toListen = [this, event, this.initComponents];
        this.stopListening.apply(this, toListen);
        // Have to add components after the init, otherwise the parent
        // is not visible
        var comps = new model_Components([], this.opt);
        comps.parent = this;
        var components = this.get('components');
        var addChild = !this.opt.avoidChildren;
        this.set('components', comps);
        addChild && components && comps.add((0,index_all.isFunction)(components) ? components(this) : components, this.opt);
        comps.on('add remove reset', this.__upSymbComps);
        // @ts-ignore
        this.listenTo.apply(this, toListen);
        return this;
    };
    Component.prototype.initTraits = function (changed) {
        var em = this.em;
        var event = 'change:traits';
        this.off(event, this.initTraits);
        this.__loadTraits();
        this.on(event, this.initTraits);
        changed && em && em.trigger('component:toggled');
        return this;
    };
    Component.prototype.initScriptProps = function () {
        if (this.opt.temporary)
            return;
        var prop = 'script-props';
        var toListen = ["change:".concat(prop), this.initScriptProps];
        this.off.apply(this, toListen);
        var prevProps = this.previous(prop) || [];
        var newProps = this.get(prop) || [];
        var prevPropsEv = prevProps.map(function (e) { return "change:".concat(e); }).join(' ');
        var newPropsEv = newProps.map(function (e) { return "change:".concat(e); }).join(' ');
        prevPropsEv && this.off(prevPropsEv, this.__scriptPropsChange);
        newPropsEv && this.on(newPropsEv, this.__scriptPropsChange);
        // @ts-ignore
        this.on.apply(this, toListen);
    };
    Component.prototype.__scriptPropsChange = function (m, v, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.avoidStore)
            return;
        this.trigger('rerender');
    };
    /**
     * Add new component children
     * @param  {Component|String} components Component to add
     * @param {Object} [opts={}] Options for the append action
     * @return {Array} Array of appended components
     * @example
     * someComponent.get('components').length // -> 0
     * const videoComponent = someComponent.append('<video></video><div></div>')[0];
     * // This will add 2 components (`video` and `div`) to your `someComponent`
     * someComponent.get('components').length // -> 2
     * // You can pass components directly
     * otherComponent.append(otherComponent2);
     * otherComponent.append([otherComponent3, otherComponent4]);
     * // append at specific index (eg. at the beginning)
     * someComponent.append(otherComponent, { at: 0 });
     */
    Component.prototype.append = function (components, opts) {
        if (opts === void 0) { opts = {}; }
        var compArr = (0,index_all.isArray)(components) ? Component_spreadArray([], components, true) : [components];
        var toAppend = compArr.map(function (comp) {
            if ((0,index_all.isString)(comp)) {
                return comp;
            }
            else {
                // I have to remove components from the old container before adding them to a new one
                comp.collection && comp.collection.remove(comp, { temporary: true });
                return comp;
            }
        });
        var result = this.components().add(toAppend, opts);
        return (0,index_all.isArray)(result) ? result : [result];
    };
    /**
     * Set new collection if `components` are provided, otherwise the
     * current collection is returned
     * @param  {Component|Component[]|String} [components] Component Definitions or HTML string
     * @param {Object} [opts={}] Options, same as in `Component.append()`
     * @returns {Collection|Array<[Component]>}
     * @example
     * // Set new collection
     * component.components('<span></span><div></div>');
     * // Get current collection
     * const collection = component.components();
     * console.log(collection.length);
     * // -> 2
     */
    Component.prototype.components = function (components, opts) {
        if (opts === void 0) { opts = {}; }
        var coll = this.get('components');
        if ((0,index_all.isUndefined)(components)) {
            return coll;
        }
        else {
            coll.reset(undefined, opts);
            return components ? this.append(components, opts) : [];
        }
    };
    /**
     * If exists, returns the child component at specific index.
     * @param {Number} index Index of the component to return
     * @returns {[Component]|null}
     * @example
     * // Return first child
     * component.getChildAt(0);
     * // Return second child
     * component.getChildAt(1);
     */
    Component.prototype.getChildAt = function (index) {
        return this.components().at(index || 0) || undefined;
    };
    /**
     * If exists, returns the last child component.
     * @returns {[Component]|null}
     * @example
     * const lastChild = component.getLastChild();
     */
    Component.prototype.getLastChild = function () {
        var children = this.components();
        return children.at(children.length - 1) || null;
    };
    /**
     * Remove all inner components
     * * @return {this}
     */
    Component.prototype.empty = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.components().reset(undefined, opts);
        return this;
    };
    /**
     * Get the parent component, if exists
     * @return {Component|null}
     * @example
     * component.parent();
     * // -> Component
     */
    Component.prototype.parent = function (opts) {
        if (opts === void 0) { opts = {}; }
        var coll = this.collection || (opts.prev && this.prevColl);
        return coll ? coll.parent : undefined;
    };
    /**
     * Return all parents of the component.
     * @returns {Array<Component>}
     */
    Component.prototype.parents = function () {
        var parent = this.parent();
        return parent ? [parent].concat(parent.parents()) : [];
    };
    /**
     * Script updated
     * @private
     */
    Component.prototype.scriptUpdated = function () {
        this.set('scriptUpdated', 1);
    };
    /**
     * Init toolbar
     * @private
     */
    Component.prototype.initToolbar = function () {
        var em = this.em;
        var model = this;
        var ppfx = (em && em.getConfig().stylePrefix) || '';
        if (!model.get('toolbar') && em) {
            var tb = [];
            model.collection &&
                tb.push({
                    label: em.getIcon('arrowUp'),
                    command: function (ed) { return ed.runCommand('core:component-exit', { force: 1 }); },
                });
            model.get('draggable') &&
                tb.push({
                    attributes: { class: "".concat(ppfx, "no-touch-actions"), draggable: true },
                    label: em.getIcon('move'),
                    command: 'tlb-move',
                });
            model.get('copyable') &&
                tb.push({
                    label: em.getIcon('copy'),
                    command: 'tlb-clone',
                });
            model.get('removable') &&
                tb.push({
                    label: em.getIcon('delete'),
                    command: 'tlb-delete',
                });
            model.set('toolbar', tb);
        }
    };
    Component.prototype.__loadTraits = function (tr) {
        var _this = this;
        var traits = tr || this.traits;
        this.set('traits', traits.map(function (trait) { return common_traits.build(_this, trait); }));
        var attrs = Component_assign({}, this.get('attributes'));
        this.traits.forEach(function (trait) {
            if (!trait.changeProp) {
                var name_1 = trait.name;
                var value = trait.value;
                if (name_1 && value)
                    attrs[name_1] = value;
            }
        });
        traits.length && this.set('attributes', attrs);
        return this;
    };
    /**
     * Get traits.
     * @returns {Array<Trait>}
     * @example
     * const traits = component.getTraits();
     * console.log(traits);
     * // [Trait, Trait, Trait, ...]
     */
    Component.prototype.getTraits = function () {
        return this.traits;
    };
    /**
     * Replace current collection of traits with a new one.
     * @param {Array<Object>} traits Array of trait definitions
     * @returns {Array<Trait>}
     * @example
     * const traits = component.setTraits([{ type: 'checkbox', name: 'disabled'}, ...]);
     * console.log(traits);
     * // [Trait, ...]
     */
    Component.prototype.setTraits = function (traits) {
        var tr = (0,index_all.isArray)(traits) ? traits : [traits];
        this.__loadTraits(tr);
        return this.getTraits();
    };
    /**
     * Get the trait by id/name.
     * @param  {String} id The `id` or `name` of the trait
     * @return {Trait|null} Trait getModelToStyle
     * @example
     * const traitTitle = component.getTrait('title');
     * traitTitle && traitTitle.set('label', 'New label');
     */
    Component.prototype.getTrait = function (id) {
        return this.traits.find(function (trait) { return trait.name === id; }) || null;
    };
    /**
     * Update a trait.
     * @param  {String} id The `id` or `name` of the trait
     * @param  {Object} props Object with the props to update
     * @return {this}
     * @example
     * component.updateTrait('title', {
     *  type: 'select',
     *  options: [ 'Option 1', 'Option 2' ],
     * });
     */
    Component.prototype.updateTrait = function (id, props) {
        var _a;
        var trait = this.getTrait(id);
        trait === null || trait === void 0 ? void 0 : trait.updateOpts(props);
        (_a = this.em) === null || _a === void 0 ? void 0 : _a.trigger('component:toggled');
        return this;
    };
    /**
     * Get the trait position index by id/name. Useful in case you want to
     * replace some trait, at runtime, with something else.
     * @param  {String} id The `id` or `name` of the trait
     * @return {Number} Index position of the current trait
     * @example
     * const traitTitle = component.getTraitIndex('title');
     * console.log(traitTitle); // 1
     */
    Component.prototype.getTraitIndex = function (id) {
        var trait = this.getTrait(id);
        return trait ? this.traits.indexOf(trait) : -1;
    };
    /**
     * Remove trait/s by id/s.
     * @param  {String|Array<String>} id The `id`/`name` of the trait (or an array)
     * @return {Array<Trait>} Array of removed traits
     * @example
     * component.removeTrait('title');
     * component.removeTrait(['title', 'id']);
     */
    Component.prototype.removeTrait = function (id) {
        var _this = this;
        var _a;
        var ids = (0,index_all.isArray)(id) ? id : [id];
        var removed = ids.map(function (id) {
            var index = _this.getTraitIndex(id);
            if (index != -1) {
                return _this.traits.splice(index, 1)[0];
            }
        });
        (_a = this.em) === null || _a === void 0 ? void 0 : _a.trigger('component:toggled');
        return (0,index_all.isArray)(removed) ? removed : [removed];
    };
    /**
     * Add new trait/s.
     * @param  {String|Object|Array<String|Object>} trait Trait to add (or an array of traits)
     * @param  {Options} opts Options for the add
     * @return {Array<Trait>} Array of added traits
     * @example
     * component.addTrait('title', { at: 1 }); // Add title trait (`at` option is the position index)
     * component.addTrait({
     *  type: 'checkbox',
     *  name: 'disabled',
     * });
     * component.addTrait(['title', {...}, ...]);
     */
    Component.prototype.addTrait = function (trait, opts) {
        var _this = this;
        var _a;
        if (opts === void 0) { opts = {}; }
        var traits = (0,index_all.isArray)(trait) ? trait : [trait];
        var added = traits.map(function (add) {
            var tr = common_traits.build(_this, add);
            _this.traits.push(tr);
            return tr;
        });
        (_a = this.em) === null || _a === void 0 ? void 0 : _a.trigger('component:toggled');
        return added;
    };
    /**
     * Normalize input classes from array to array of objects
     * @param {Array} arr
     * @return {Array}
     * @private
     */
    Component.prototype.normalizeClasses = function (arr) {
        var res = [];
        var em = this.em;
        var clm = em === null || em === void 0 ? void 0 : em.Selectors;
        if (!clm)
            return [];
        // @ts-ignore
        if (arr.models)
            return Component_spreadArray([], arr.models, true);
        arr.forEach(function (val) { return res.push(clm.add(val)); });
        return res;
    };
    /**
     * Override original clone method
     * @private
     */
    Component.prototype.clone = function (opt) {
        if (opt === void 0) { opt = {}; }
        var em = this.em;
        var attr = Component_assign({}, this.attributes);
        var opts = Component_assign({}, this.opt);
        var id = this.getId();
        var cssc = em === null || em === void 0 ? void 0 : em.Css;
        attr.attributes = Component_assign({}, attr.attributes);
        delete attr.attributes.id;
        // @ts-ignore
        attr.components = [];
        // @ts-ignore
        attr.classes = [];
        attr.traits = [];
        if (this.__isSymbolTop()) {
            opt.symbol = true;
        }
        this.get('components').each(function (md, i) {
            // @ts-ignore
            attr.components[i] = md.clone(Component_assign(Component_assign({}, opt), { _inner: 1 }));
        });
        this.traits.forEach(function (md, i) {
            attr.traits[i] = Component_assign(Component_assign({}, md.opts), { name: md.name });
        });
        this.get('classes').each(function (md, i) {
            // @ts-ignore
            attr.classes[i] = md.get('name');
        });
        attr.status = '';
        // @ts-ignore
        opts.collection = null;
        // @ts-ignore
        var cloned = new this.constructor(attr, opts);
        // Clone component specific rules
        var newId = "#".concat(cloned.getId());
        var rulesToClone = cssc ? cssc.getRules("#".concat(id)) : [];
        rulesToClone.forEach(function (rule) {
            var newRule = rule.clone();
            // @ts-ignore
            newRule.set('selectors', [newId]);
            cssc.getAll().add(newRule);
        });
        // Symbols
        // If I clone an inner symbol, I have to reset it
        cloned.set(keySymbols, 0);
        var symbol = this.__getSymbol();
        var symbols = this.__getSymbols();
        if (!opt.symbol && (symbol || symbols)) {
            cloned.set(keySymbol, 0);
            cloned.set(keySymbols, 0);
        }
        else if (symbol) {
            // Contains already a reference to a symbol
            symbol.set(keySymbols, Component_spreadArray(Component_spreadArray([], symbol.__getSymbols(), true), [cloned], false));
            cloned.__initSymb();
        }
        else if (opt.symbol) {
            // Request to create a symbol
            if (this.__isSymbol()) {
                // Already a symbol, cloned should be an instance
                this.set(keySymbols, Component_spreadArray(Component_spreadArray([], symbols, true), [cloned], false));
                cloned.set(keySymbol, this);
                cloned.__initSymb();
            }
            else if (opt.symbolInv) {
                // Inverted, cloned is the instance, the origin is the main symbol
                this.set(keySymbols, [cloned]);
                cloned.set(keySymbol, this);
                [this, cloned].map(function (i) { return i.__initSymb(); });
            }
            else {
                // Cloned becomes the main symbol
                cloned.set(keySymbols, [this]);
                [this, cloned].map(function (i) { return i.__initSymb(); });
                this.set(keySymbol, cloned);
            }
        }
        var event = 'component:clone';
        em && em.trigger(event, cloned);
        this.trigger(event, cloned);
        return cloned;
    };
    /**
     * Get the name of the component.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.noCustom] Avoid custom name assigned to the component.
     * @returns {String}
     * */
    Component.prototype.getName = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var _a = this.attributes, type = _a.type, tagName = _a.tagName, name = _a.name;
        var defName = type || tagName;
        var nameTag = !type ? tagName : '';
        var i18nPfx = 'domComponents.names.';
        var i18nName = name && (em === null || em === void 0 ? void 0 : em.t("".concat(i18nPfx).concat(name)));
        var i18nNameTag = nameTag && (em === null || em === void 0 ? void 0 : em.t("".concat(i18nPfx).concat(nameTag)));
        var i18nDefName = em && (em.t("".concat(i18nPfx).concat(type)) || em.t("".concat(i18nPfx).concat(tagName)));
        var customName = this.get('custom-name');
        return ((!opts.noCustom ? customName : '') || // Used in Layers (when the user changes the name)
            i18nName || // Use local component `name` key (eg. `domComponents.names.myComponentName`)
            name || // Use component `name` key
            i18nNameTag || // Use local component `tagName` key (eg. `domComponents.names.div`)
            (0,mixins.capitalize)(nameTag) || // Use component `tagName` key
            i18nDefName || // Use local component `type` key (eg. `domComponents.names.image`)
            (0,mixins.capitalize)(defName) // Use component `type` key
        );
    };
    /**
     * Get the icon string
     * @return {String}
     */
    Component.prototype.getIcon = function () {
        var icon = this.get('icon');
        return icon ? icon + ' ' : '';
    };
    /**
     * Return HTML string of the component
     * @param {Object} [opts={}] Options
     * @param {String} [opts.tag] Custom tagName
     * @param {Object|Function} [opts.attributes=null] You can pass an object of custom attributes to replace with the current ones or you can even pass a function to generate attributes dynamically.
     * @param {Boolean} [opts.withProps] Include component properties as `data-gjs-*` attributes. This allows you to have re-importable HTML.
     * @param {Boolean} [opts.altQuoteAttr] In case the attribute value contains a `"` char, instead of escaping it (`attr="value &quot;"`), the attribute will be quoted using single quotes (`attr='value "'`).
     * @return {String} HTML string
     * @example
     * // Simple HTML return
     * component.set({ tagName: 'span' });
     * component.setAttributes({ title: 'Hello' });
     * component.toHTML();
     * // -> <span title="Hello"></span>
     *
     * // Custom attributes
     * component.toHTML({ attributes: { 'data-test': 'Hello' } });
     * // -> <span data-test="Hello"></span>
     *
     * // Custom dynamic attributes
     * component.toHTML({
     *  attributes(component, attributes) {
     *    if (component.get('tagName') == 'span') {
     *      attributes.title = 'Custom attribute';
     *    }
     *    return attributes;
     *  },
     * });
     * // -> <span title="Custom attribute"></span>
     */
    Component.prototype.toHTML = function (opts) {
        if (opts === void 0) { opts = {}; }
        var model = this;
        var attrs = [];
        var customTag = opts.tag;
        var tag = customTag || model.get('tagName');
        var sTag = model.get('void');
        var customAttr = opts.attributes;
        var attributes = this.getAttrToHTML();
        delete opts.tag;
        // Get custom attributes if requested
        if (customAttr) {
            if ((0,index_all.isFunction)(customAttr)) {
                attributes = customAttr(model, attributes) || {};
            }
            else if ((0,mixins.isObject)(customAttr)) {
                attributes = customAttr;
            }
        }
        if (opts.withProps) {
            var props = this.toJSON();
            (0,index_all.forEach)(props, function (value, key) {
                var skipProps = ['classes', 'attributes', 'components'];
                if (key[0] !== '_' && skipProps.indexOf(key) < 0) {
                    attributes["data-gjs-".concat(key)] = (0,index_all.isArray)(value) || (0,mixins.isObject)(value) ? JSON.stringify(value) : value;
                }
            });
        }
        for (var attr in attributes) {
            var val = attributes[attr];
            if (!(0,index_all.isUndefined)(val) && val !== null) {
                if ((0,index_all.isBoolean)(val)) {
                    val && attrs.push(attr);
                }
                else {
                    var valueRes = '';
                    if (opts.altQuoteAttr && (0,index_all.isString)(val) && val.indexOf('"') >= 0) {
                        valueRes = "'".concat(val.replace(/'/g, '&apos;'), "'");
                    }
                    else {
                        var value = (0,index_all.isString)(val) ? val.replace(/"/g, '&quot;') : val;
                        valueRes = "\"".concat(value, "\"");
                    }
                    attrs.push("".concat(attr, "=").concat(valueRes));
                }
            }
        }
        var attrString = attrs.length ? " ".concat(attrs.join(' ')) : '';
        var inner = model.getInnerHTML(opts);
        var code = "<".concat(tag).concat(attrString).concat(sTag ? '/' : '', ">").concat(inner);
        !sTag && (code += "</".concat(tag, ">"));
        return code;
    };
    /**
     * Get inner HTML of the component
     * @param {Object} [opts={}] Same options of `toHTML`
     * @returns {String} HTML string
     */
    Component.prototype.getInnerHTML = function (opts) {
        return this.__innerHTML(opts);
    };
    Component.prototype.__innerHTML = function (opts) {
        if (opts === void 0) { opts = {}; }
        var cmps = this.components();
        return !cmps.length ? this.content : cmps.map(function (c) { return c.toHTML(opts); }).join('');
    };
    /**
     * Returns object of attributes for HTML
     * @return {Object}
     * @private
     */
    Component.prototype.getAttrToHTML = function () {
        var attrs = this.getAttributes();
        if (avoidInline(this.em)) {
            delete attrs.style;
        }
        return attrs;
    };
    /**
     * Return a shallow copy of the model's attributes for JSON
     * stringification.
     * @return {Object}
     * @private
     */
    Component.prototype.toJSON = function (opts) {
        if (opts === void 0) { opts = {}; }
        var obj = backbone.Model.prototype.toJSON.call(this, opts);
        obj.attributes = this.getAttributes();
        delete obj.attributes.class;
        delete obj.toolbar;
        delete obj.traits;
        delete obj.status;
        delete obj.open; // used in Layers
        delete obj._undoexc;
        delete obj.delegate;
        if (!opts.fromUndo) {
            var symbol = obj[keySymbol];
            var symbols = obj[keySymbols];
            if (symbols && (0,index_all.isArray)(symbols)) {
                obj[keySymbols] = symbols.filter(function (i) { return i; }).map(function (i) { return (i.getId ? i.getId() : i); });
            }
            if (symbol && !(0,index_all.isString)(symbol)) {
                obj[keySymbol] = symbol.getId();
            }
        }
        if (this.em.getConfig().avoidDefaults) {
            this.getChangedProps(obj);
        }
        return obj;
    };
    /**
     * Return an object containing only changed props
     */
    Component.prototype.getChangedProps = function (res) {
        var obj = res || backbone.Model.prototype.toJSON.apply(this);
        var defaults = (0,index_all.result)(this, 'defaults');
        (0,index_all.forEach)(defaults, function (value, key) {
            if (['type'].indexOf(key) === -1 && obj[key] === value) {
                delete obj[key];
            }
        });
        if ((0,index_all.isEmpty)(obj.type)) {
            delete obj.type;
        }
        (0,index_all.forEach)(['attributes', 'style'], function (prop) {
            if ((0,index_all.isEmpty)(defaults[prop]) && (0,index_all.isEmpty)(obj[prop])) {
                delete obj[prop];
            }
        });
        (0,index_all.forEach)(['classes', 'components'], function (prop) {
            if (!obj[prop] || ((0,index_all.isEmpty)(defaults[prop]) && !obj[prop].length)) {
                delete obj[prop];
            }
        });
        return obj;
    };
    /**
     * Return the component id
     * @return {String}
     */
    Component.prototype.getId = function () {
        var attrs = this.get('attributes') || {};
        return attrs.id || this.ccid || this.cid;
    };
    /**
     * Set new id on the component
     * @param {String} id
     * @return {this}
     */
    Component.prototype.setId = function (id, opts) {
        var attrs = Component_assign({}, this.get('attributes'));
        attrs.id = id;
        this.set('attributes', attrs, opts);
        return this;
    };
    /**
     * Get the DOM element of the component.
     * This works only if the component is already rendered
     * @param {Frame} frame Specific frame from which taking the element
     * @return {HTMLElement}
     */
    Component.prototype.getEl = function (frame) {
        var view = this.getView(frame);
        return view && view.el;
    };
    /**
     * Get the View of the component.
     * This works only if the component is already rendered
     * @param {Frame} frame Get View of a specific frame
     * @return {ComponentView}
     */
    Component.prototype.getView = function (frame) {
        var _a = this, view = _a.view, views = _a.views, em = _a.em;
        var frm = frame || (em === null || em === void 0 ? void 0 : em.getCurrentFrameModel());
        if (frm) {
            view = views.filter(function (view) { return view.frameView === frm.view; })[0];
        }
        return view;
    };
    Component.prototype.getCurrentView = function () {
        var frameView = this.em.getCurrentFrame();
        var frame = frameView === null || frameView === void 0 ? void 0 : frameView.model;
        return this.getView(frame);
    };
    Component.prototype.__getScriptProps = function () {
        var modelProps = this.props();
        var scrProps = this.get('script-props') || [];
        return scrProps.reduce(function (acc, prop) {
            acc[prop] = modelProps[prop];
            return acc;
        }, {});
    };
    /**
     * Return script in string format, cleans 'function() {..' from scripts
     * if it's a function
     * @param {string|Function} script
     * @return {string}
     * @private
     */
    Component.prototype.getScriptString = function (script) {
        var _this = this;
        var scr = script || this.get('script') || '';
        if (!scr) {
            return scr;
        }
        if (this.get('script-props')) {
            scr = scr.toString().trim();
        }
        else {
            // Deprecated
            // Need to convert script functions to strings
            if ((0,index_all.isFunction)(scr)) {
                var scrStr = scr.toString().trim();
                scrStr = scrStr.slice(scrStr.indexOf('{') + 1, scrStr.lastIndexOf('}'));
                scr = scrStr.trim();
            }
            var config = this.em.getConfig();
            var tagVarStart = escapeRegExp(config.tagVarStart || '{[ ');
            var tagVarEnd = escapeRegExp(config.tagVarEnd || ' ]}');
            var reg = new RegExp("".concat(tagVarStart, "([\\w\\d-]*)").concat(tagVarEnd), 'g');
            scr = scr.replace(reg, function (match, v) {
                // If at least one match is found I have to track this change for a
                // better optimization inside JS generator
                _this.scriptUpdated();
                var result = _this.attributes[v] || '';
                return (0,index_all.isArray)(result) || typeof result == 'object' ? JSON.stringify(result) : result;
            });
        }
        return scr;
    };
    Component.prototype.emitUpdate = function (property) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var em = this.em;
        var event = keyUpdate + (property ? ":".concat(property) : '');
        var item = property && this.get(property);
        // @ts-ignore
        property && this.updated.apply(this, Component_spreadArray([property, item, property && this.previous(property)], args, false));
        this.trigger.apply(this, Component_spreadArray([event], args, false));
        em && em.trigger.apply(em, Component_spreadArray([event, this], args, false));
        ['components', 'classes'].indexOf(property) >= 0 &&
            this.__propSelfToParent({
                component: this,
                changed: (_a = {}, _a[property] = item, _a),
                options: args[2] || args[1] || {},
            });
    };
    /**
     * Execute callback function on itself and all inner components
     * @param  {Function} clb Callback function, the model is passed as an argument
     * @return {this}
     * @example
     * component.onAll(component => {
     *  // do something with component
     * })
     */
    Component.prototype.onAll = function (clb) {
        if ((0,index_all.isFunction)(clb)) {
            clb(this);
            this.components().forEach(function (model) { return model.onAll(clb); });
        }
        return this;
    };
    /**
     * Execute a callback function on all inner child components.
     * @param  {Function} clb Callback function, the child component is passed as an argument
     * @example
     * component.forEachChild(child => {
     *  console.log(child)
     * })
     */
    Component.prototype.forEachChild = function (clb) {
        if ((0,index_all.isFunction)(clb)) {
            this.components().forEach(function (child) {
                clb(child);
                child.forEachChild(clb);
            });
        }
    };
    /**
     * Remove the component
     * @return {this}
     */
    Component.prototype.remove = function (opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var coll = this.collection;
        var remove = function () {
            coll && coll.remove(_this, Component_assign(Component_assign({}, opts), { action: 'remove-component' }));
            // Component without parent
            if (!coll) {
                _this.components('', opts);
                _this.components().removeChildren(_this, undefined, opts);
            }
        };
        var rmOpts = Component_assign({}, opts);
        [this, em].map(function (i) { return i.trigger('component:remove:before', _this, remove, rmOpts); });
        !rmOpts.abort && remove();
        return this;
    };
    /**
     * Move the component to another destination component
     * @param {Component} component Destination component (so the current one will be appended as a child)
     * @param {Object} opts Options for the append action
     * @returns {this}
     * @example
     * // Move the selected component on top of the wrapper
     * const dest = editor.getWrapper();
     * editor.getSelected().move(dest, { at: 0 });
     */
    Component.prototype.move = function (component, opts) {
        if (opts === void 0) { opts = {}; }
        if (component) {
            var at = opts.at;
            var index = this.index();
            var sameParent = component === this.parent();
            var sameIndex = index === at || index === at - 1;
            if (!sameParent || !sameIndex) {
                if (sameParent && at && at > index) {
                    opts.at = at - 1;
                }
                this.remove({ temporary: 1 });
                component.append(this, opts);
                this.emitUpdate();
            }
        }
        return this;
    };
    /**
     * Check if the component is an instance of some component type.
     * @param {String} type Component type
     * @returns {Boolean}
     * @example
     * // Add a new component type by extending an existing one
     * editor.Components.addType('text-ext', { extend: 'text' });
     * // Append a new component somewhere
     * const newTextExt = editor.getSelected().append({ type: 'text-ext' })[0];
     * newTextExt.isInstanceOf('text-ext'); // true
     * newTextExt.isInstanceOf('text'); // true
     */
    Component.prototype.isInstanceOf = function (type) {
        var _a, _b;
        var cmp = (_b = (_a = this.em) === null || _a === void 0 ? void 0 : _a.Components.getType(type)) === null || _b === void 0 ? void 0 : _b.model;
        if (!cmp)
            return false;
        return this instanceof cmp;
    };
    /**
     * Check if the component is a child of some other component (or component type)
     * @param {[Component]|String} component Component parent to check. In case a string is passed,
     *  the check will be performed on the component type.
     * @returns {Boolean}
     * @example
     * const newTextComponent = editor.getSelected().append({
     *  type: 'text',
     *  components: 'My text <b>here</b>',
     * })[0];
     * const innerComponent = newTextComponent.find('b')[0];
     * innerComponent.isChildOf(newTextComponent); // true
     * innerComponent.isChildOf('text'); // true
     */
    Component.prototype.isChildOf = function (component) {
        var byType = (0,index_all.isString)(component);
        var parent = this.parent();
        while (parent) {
            if (byType) {
                if (parent.isInstanceOf(component)) {
                    return true;
                }
            }
            else {
                if (parent === component) {
                    return true;
                }
            }
            parent = parent.parent();
        }
        return false;
    };
    /**
     * Reset id of the component and any of its style rule
     * @param {Object} [opts={}] Options
     * @return {this}
     * @private
     */
    Component.prototype.resetId = function (opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var oldId = this.getId();
        if (!oldId)
            return this;
        var newId = Component.createId(this);
        this.setId(newId);
        var rule = em === null || em === void 0 ? void 0 : em.Css.getIdRule(oldId);
        var selector = rule === null || rule === void 0 ? void 0 : rule.get('selectors').at(0);
        selector === null || selector === void 0 ? void 0 : selector.set('name', newId);
        return this;
    };
    Component.prototype._getStyleRule = function (_a) {
        var _b = _a === void 0 ? {} : _a, id = _b.id;
        var em = this.em;
        var idS = id || this.getId();
        return em === null || em === void 0 ? void 0 : em.Css.getIdRule(idS);
    };
    Component.prototype._getStyleSelector = function (opts) {
        var rule = this._getStyleRule(opts);
        return rule === null || rule === void 0 ? void 0 : rule.get('selectors').at(0);
    };
    Component.prototype._idUpdated = function (m, v, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.idUpdate)
            return;
        var ccid = this.ccid;
        var id = (this.get('attributes') || {}).id;
        var idPrev = (this.previous('attributes') || {}).id || ccid;
        var list = Component.getList(this);
        // If the ID already exists I need to rollback to the old one
        if (list[id] || (!id && idPrev)) {
            return this.setId(idPrev, { idUpdate: true });
        }
        // Remove the old ID reference and add the new one
        delete list[idPrev];
        list[id] = this;
        this.ccid = id;
        // Update the style selector name
        var selector = this._getStyleSelector({ id: idPrev });
        selector && selector.set({ name: id, label: id });
    };
    Component.getDefaults = function () {
        return (0,index_all.result)(this.prototype, 'defaults');
    };
    Component.isComponent = function (el) {
        return { tagName: (0,mixins.toLowerCase)(el.tagName) };
    };
    Component.ensureInList = function (model) {
        var list = Component.getList(model);
        var id = model.getId();
        var current = list[id];
        if (!current) {
            // Insert in list
            list[id] = model;
        }
        else if (current !== model) {
            // Create new ID
            var nextId = Component.getIncrementId(id, list);
            model.setId(nextId);
            list[nextId] = model;
        }
        model.components().forEach(function (i) { return Component.ensureInList(i); });
    };
    Component.createId = function (model, opts) {
        if (opts === void 0) { opts = {}; }
        var list = Component.getList(model);
        var _a = opts.idMap, idMap = _a === void 0 ? {} : _a;
        var id = model.get('attributes').id;
        var nextId;
        if (id) {
            nextId = Component.getIncrementId(id, list, opts);
            model.setId(nextId);
            if (id !== nextId)
                idMap[id] = nextId;
        }
        else {
            nextId = Component.getNewId(list);
        }
        list[nextId] = model;
        return nextId;
    };
    Component.getNewId = function (list) {
        var count = Object.keys(list).length;
        // Testing 1000000 components with `+ 2` returns 0 collisions
        var ilen = count.toString().length + 2;
        var uid = (Math.random() + 1.1).toString(36).slice(-ilen);
        var newId = "i".concat(uid);
        while (list[newId]) {
            newId = Component.getNewId(list);
        }
        return newId;
    };
    Component.getIncrementId = function (id, list, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = opts.keepIds, keepIds = _a === void 0 ? [] : _a;
        var counter = 1;
        var newId = id;
        if (keepIds.indexOf(id) < 0) {
            while (list[newId]) {
                counter++;
                newId = "".concat(id, "-").concat(counter);
            }
        }
        return newId;
    };
    Component.getList = function (model) {
        var _a = model.opt, opt = _a === void 0 ? {} : _a;
        // @ts-ignore
        var domc = opt.domc, em = opt.em;
        var dm = domc || (em === null || em === void 0 ? void 0 : em.Components);
        return dm ? dm.componentsById : {};
    };
    Component.checkId = function (components, styles, list, opts) {
        if (styles === void 0) { styles = []; }
        if (list === void 0) { list = {}; }
        if (opts === void 0) { opts = {}; }
        var comps = (0,index_all.isArray)(components) ? components : [components];
        var _a = opts.keepIds, keepIds = _a === void 0 ? [] : _a, _b = opts.idMap, idMap = _b === void 0 ? {} : _b;
        comps.forEach(function (comp) {
            comp.attributes;
            var _a = comp.attributes, attributes = _a === void 0 ? {} : _a, components = comp.components;
            var id = attributes.id;
            // Check if we have collisions with current components
            if (id && list[id] && keepIds.indexOf(id) < 0) {
                var newId_1 = Component.getIncrementId(id, list);
                idMap[id] = newId_1;
                attributes.id = newId_1;
                // Update passed styles
                (0,index_all.isArray)(styles) &&
                    styles.forEach(function (style) {
                        var selectors = style.selectors;
                        selectors.forEach(function (sel, idx) {
                            if (sel === "#".concat(id))
                                selectors[idx] = "#".concat(newId_1);
                        });
                    });
            }
            components && Component.checkId(components, styles, list, opts);
        });
    };
    return Component;
}(model_StyleableModel));
/* harmony default export */ const model_Component = (Component);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTextNode.ts
var ComponentTextNode_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTextNode_assign = (undefined && undefined.__assign) || function () {
    ComponentTextNode_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTextNode_assign.apply(this, arguments);
};


var ComponentTextNode = /** @class */ (function (_super) {
    ComponentTextNode_extends(ComponentTextNode, _super);
    function ComponentTextNode() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTextNode.prototype, "defaults", {
        get: function () {
            return ComponentTextNode_assign(ComponentTextNode_assign({}, _super.prototype.defaults), { tagName: '', droppable: false, layerable: false, selectable: false, editable: true });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTextNode.prototype.toHTML = function () {
        var content = this.content;
        var parent = this.parent();
        return (parent === null || parent === void 0 ? void 0 : parent.is('script')) ? content : this.__escapeContent(content);
    };
    ComponentTextNode.prototype.__escapeContent = function (content) {
        return (0,mixins.escapeNodeContent)(content);
    };
    ComponentTextNode.isComponent = function (el) {
        var _a;
        if (el.nodeType === 3) {
            return {
                type: 'textnode',
                content: (_a = el.textContent) !== null && _a !== void 0 ? _a : '',
            };
        }
    };
    return ComponentTextNode;
}(model_Component));
/* harmony default export */ const model_ComponentTextNode = (ComponentTextNode);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentComment.ts
var ComponentComment_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentComment_assign = (undefined && undefined.__assign) || function () {
    ComponentComment_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentComment_assign.apply(this, arguments);
};

var ComponentComment = /** @class */ (function (_super) {
    ComponentComment_extends(ComponentComment, _super);
    function ComponentComment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentComment.prototype, "defaults", {
        get: function () {
            // @ts-ignore
            return ComponentComment_assign({}, _super.prototype.defaults);
        },
        enumerable: false,
        configurable: true
    });
    ComponentComment.prototype.toHTML = function () {
        return "<!--".concat(this.content, "-->");
    };
    ComponentComment.isComponent = function (el) {
        var _a;
        if (el.nodeType == 8) {
            return {
                tagName: 'NULL',
                type: 'comment',
                content: (_a = el.textContent) !== null && _a !== void 0 ? _a : '',
            };
        }
    };
    return ComponentComment;
}(model_ComponentTextNode));
/* harmony default export */ const model_ComponentComment = (ComponentComment);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentFrame.ts
var ComponentFrame_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentFrame_assign = (undefined && undefined.__assign) || function () {
    ComponentFrame_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentFrame_assign.apply(this, arguments);
};


var type = 'iframe';
var ComponentFrame = /** @class */ (function (_super) {
    ComponentFrame_extends(ComponentFrame, _super);
    function ComponentFrame() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentFrame.prototype, "defaults", {
        get: function () {
            return ComponentFrame_assign(ComponentFrame_assign({}, _super.prototype.defaults), { type: type, tagName: type, droppable: false, resizable: true, traits: ['id', 'title', 'src'], attributes: { frameborder: '0' } });
        },
        enumerable: false,
        configurable: true
    });
    ComponentFrame.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === type;
    };
    return ComponentFrame;
}(model_Component));
/* harmony default export */ const model_ComponentFrame = (ComponentFrame);
// ComponentFrame.isComponent = el => toLowerCase(el.tagName) === type;

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentImage.ts
var ComponentImage_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentImage_assign = (undefined && undefined.__assign) || function () {
    ComponentImage_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentImage_assign.apply(this, arguments);
};



var svgAttrs = 'xmlns="http://www.w3.org/2000/svg" width="100" viewBox="0 0 24 24" style="fill: rgba(0,0,0,0.15); transform: scale(0.75)"';
var ComponentImage = /** @class */ (function (_super) {
    ComponentImage_extends(ComponentImage, _super);
    function ComponentImage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentImage.prototype, "defaults", {
        get: function () {
            return ComponentImage_assign(ComponentImage_assign({}, _super.prototype.defaults), { type: 'image', tagName: 'img', void: true, droppable: 0, editable: 1, highlightable: 0, resizable: { ratioDefault: 1 }, traits: ['alt'], src: "<svg ".concat(svgAttrs, ">\n        <path d=\"M8.5 13.5l2.5 3 3.5-4.5 4.5 6H5m16 1V5a2 2 0 0 0-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2z\"></path>\n      </svg>"), 
                // Fallback image in case the src can't be loaded
                // If you use SVG, xmlns="http://www.w3.org/2000/svg" is required
                fallback: "<svg ".concat(svgAttrs, ">\n        <path d=\"M2.28 3L1 4.27l2 2V19c0 1.1.9 2 2 2h12.73l2 2L21 21.72 2.28 3m2.55 0L21 19.17V5a2 2 0 0 0-2-2H4.83M8.5 13.5l2.5 3 1-1.25L14.73 18H5l3.5-4.5z\"></path>\n      </svg>"), 
                // File to load asynchronously once the model is rendered
                file: '' });
        },
        enumerable: false,
        configurable: true
    });
    ComponentImage.prototype.initialize = function (props, opts) {
        _super.prototype.initialize.call(this, props, opts);
        var src = this.get('attributes').src;
        if (src && (0,mixins.buildBase64UrlFromSvg)((0,index_all.result)(this, 'defaults').src) !== src) {
            this.set('src', src, { silent: true });
        }
    };
    ComponentImage.prototype.initToolbar = function () {
        _super.prototype.initToolbar.call(this);
        var em = this.em;
        if (em) {
            var cmd = em.Commands;
            var cmdName = 'image-editor';
            // Add Image Editor button only if the default command exists
            if (cmd.has(cmdName)) {
                var hasButtonBool = false;
                var tb = this.get('toolbar');
                for (var i = 0; i < tb.length; i++) {
                    if (tb[i].command === 'image-editor') {
                        hasButtonBool = true;
                        break;
                    }
                }
                if (!hasButtonBool) {
                    tb.push({
                        attributes: { class: 'fa fa-pencil' },
                        command: cmdName,
                    });
                    this.set('toolbar', tb);
                }
            }
        }
    };
    /**
     * Returns object of attributes for HTML
     * @return {Object}
     * @private
     */
    ComponentImage.prototype.getAttrToHTML = function () {
        var attr = _super.prototype.getAttrToHTML.call(this);
        var src = this.getSrcResult();
        if (src)
            attr.src = src;
        return attr;
    };
    ComponentImage.prototype.getSrcResult = function (opt) {
        if (opt === void 0) { opt = {}; }
        var src = this.get(opt.fallback ? 'fallback' : 'src') || '';
        var result = src;
        if (src && src.substr(0, 4) === '<svg') {
            result = (0,mixins.buildBase64UrlFromSvg)(src);
        }
        return result;
    };
    ComponentImage.prototype.isDefaultSrc = function () {
        var src = this.get('src');
        var srcDef = (0,index_all.result)(this, 'defaults').src;
        return src === srcDef || src === (0,mixins.buildBase64UrlFromSvg)(srcDef);
    };
    /**
     * Return a shallow copy of the model's attributes for JSON
     * stringification.
     * @return {Object}
     * @private
     */
    ComponentImage.prototype.toJSON = function (opts) {
        var obj = _super.prototype.toJSON.call(this, opts);
        var attributes = obj.attributes;
        if (attributes && obj.src === attributes.src) {
            delete obj.src;
        }
        return obj;
    };
    /**
     * Parse uri
     * @param  {string} uri
     * @return {object}
     * @private
     */
    ComponentImage.prototype.parseUri = function (uri) {
        var result = {};
        var getQueryObject = function (search) {
            if (search === void 0) { search = ''; }
            var query = {};
            var qrs = search.substring(1).split('&');
            for (var i = 0; i < qrs.length; i++) {
                var pair = qrs[i].split('=');
                var name_1 = decodeURIComponent(pair[0]);
                if (name_1)
                    query[name_1] = decodeURIComponent(pair[1] || '');
            }
            return query;
        };
        if ((0,mixins.hasWin)()) {
            result = document.createElement('a');
            result.href = uri;
        }
        else if (typeof URL !== 'undefined') {
            try {
                result = new URL(uri);
            }
            catch (e) { }
        }
        return {
            hostname: result.hostname || '',
            pathname: result.pathname || '',
            protocol: result.protocol || '',
            search: result.search || '',
            hash: result.hash || '',
            port: result.port || '',
            query: getQueryObject(result.search),
        };
    };
    ComponentImage.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === 'img';
    };
    return ComponentImage;
}(model_Component));
/* harmony default export */ const model_ComponentImage = (ComponentImage);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentText.ts
var ComponentText_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentText_assign = (undefined && undefined.__assign) || function () {
    ComponentText_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentText_assign.apply(this, arguments);
};


var ComponentText = /** @class */ (function (_super) {
    ComponentText_extends(ComponentText, _super);
    function ComponentText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentText.prototype, "defaults", {
        get: function () {
            return ComponentText_assign(ComponentText_assign({}, _super.prototype.defaults), { type: 'text', droppable: false, editable: true });
        },
        enumerable: false,
        configurable: true
    });
    ComponentText.prototype.initialize = function (props, opts) {
        _super.prototype.initialize.call(this, props, opts);
        this.__checkInnerChilds();
    };
    ComponentText.prototype.__checkInnerChilds = function () {
        var disableTextInnerChilds = this.em.Components.config.disableTextInnerChilds;
        if (disableTextInnerChilds) {
            var disableChild_1 = function (child) {
                if (!child.isInstanceOf('textnode')) {
                    child.set({
                        locked: true,
                        layerable: false,
                    });
                }
            };
            if ((0,index_all.isFunction)(disableTextInnerChilds)) {
                this.forEachChild(function (child) {
                    disableTextInnerChilds(child) && disableChild_1(child);
                });
            }
            else {
                this.forEachChild(disableChild_1);
            }
        }
    };
    return ComponentText;
}(model_Component));
/* harmony default export */ const model_ComponentText = (ComponentText);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentLabel.ts
var ComponentLabel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentLabel_assign = (undefined && undefined.__assign) || function () {
    ComponentLabel_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentLabel_assign.apply(this, arguments);
};


var ComponentLabel_type = 'label';
var ComponentLabel = /** @class */ (function (_super) {
    ComponentLabel_extends(ComponentLabel, _super);
    function ComponentLabel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentLabel.prototype, "defaults", {
        get: function () {
            return ComponentLabel_assign(ComponentLabel_assign({}, _super.prototype.defaults), { type: ComponentLabel_type, tagName: ComponentLabel_type, traits: ['id', 'title', 'for'] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentLabel.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentLabel_type;
    };
    return ComponentLabel;
}(model_ComponentText));
/* harmony default export */ const model_ComponentLabel = (ComponentLabel);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentLink.ts
var ComponentLink_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentLink_assign = (undefined && undefined.__assign) || function () {
    ComponentLink_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentLink_assign.apply(this, arguments);
};



var ComponentLink_type = 'link';
var ComponentLink = /** @class */ (function (_super) {
    ComponentLink_extends(ComponentLink, _super);
    function ComponentLink() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentLink.prototype, "defaults", {
        get: function () {
            return ComponentLink_assign(ComponentLink_assign({}, _super.prototype.defaults), { type: ComponentLink_type, tagName: 'a', traits: ['title', 'href', 'target'] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentLink.isComponent = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var result;
        if ((0,mixins.toLowerCase)(el.tagName) === 'a') {
            var textTags_1 = opts.textTags || [];
            result = { type: ComponentLink_type, editable: false };
            // The link is editable only if, at least, one of its
            // children is a text node (not empty one)
            var children = el.childNodes;
            var len = children.length;
            if (!len)
                delete result.editable;
            (0,index_all.forEach)(children, function (child) {
                var tagName = child.tagName;
                if ((child.nodeType == 3 && child.textContent.trim() !== '') ||
                    (tagName && textTags_1.indexOf((0,mixins.toLowerCase)(tagName)) >= 0)) {
                    delete result.editable;
                }
            });
        }
        return result;
    };
    return ComponentLink;
}(model_ComponentText));
/* harmony default export */ const model_ComponentLink = (ComponentLink);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentMap.ts
var ComponentMap_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentMap_assign = (undefined && undefined.__assign) || function () {
    ComponentMap_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentMap_assign.apply(this, arguments);
};


var ComponentMap = /** @class */ (function (_super) {
    ComponentMap_extends(ComponentMap, _super);
    function ComponentMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentMap.prototype, "defaults", {
        /** @ts-ignore */
        get: function () {
            // @ts-ignore
            var defs = _super.prototype.defaults;
            return ComponentMap_assign(ComponentMap_assign({}, defs), { type: 'map', src: '', void: false, mapUrl: 'https://maps.google.com/maps', tagName: 'iframe', mapType: 'q', address: '', zoom: '1', attributes: { frameborder: 0 }, 
                // @ts-ignore
                toolbar: defs.toolbar, traits: [
                    {
                        label: 'Address',
                        name: 'address',
                        placeholder: 'eg. London, UK',
                        changeProp: true,
                    },
                    {
                        type: 'select',
                        label: 'Map type',
                        name: 'mapType',
                        changeProp: true,
                        options: [
                            { value: 'q', name: 'Roadmap' },
                            { value: 'w', name: 'Satellite' },
                        ],
                    },
                    {
                        label: 'Zoom',
                        name: 'zoom',
                        type: 'range',
                        min: 1,
                        max: 20,
                        changeProp: true,
                    },
                ] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentMap.prototype.initialize = function (props, opts) {
        if (this.get('src'))
            this.parseFromSrc();
        else
            this.updateSrc();
        _super.prototype.initialize.call(this, props, opts);
        this.listenTo(this, 'change:address change:zoom change:mapType', this.updateSrc);
    };
    ComponentMap.prototype.updateSrc = function () {
        this.set('src', this.getMapUrl());
    };
    /**
     * Returns url of the map
     * @return {string}
     * @private
     */
    ComponentMap.prototype.getMapUrl = function () {
        var addr = this.get('address');
        var zoom = this.get('zoom');
        var type = this.get('mapType');
        addr = addr ? '&q=' + addr : '';
        zoom = zoom ? '&z=' + zoom : '';
        type = type ? '&t=' + type : '';
        var result = this.get('mapUrl') + '?' + addr + zoom + type;
        result += '&output=embed';
        return result;
    };
    /**
     * Set attributes by src string
     * @private
     */
    ComponentMap.prototype.parseFromSrc = function () {
        var uri = this.parseUri(this.get('src'));
        var qr = uri.query;
        if (qr.q)
            this.set('address', qr.q);
        if (qr.z)
            this.set('zoom', qr.z);
        if (qr.t)
            this.set('mapType', qr.t);
    };
    ComponentMap.isComponent = function (el) {
        if ((0,mixins.toLowerCase)(el.tagName) == 'iframe' && /maps\.google\.com/.test(el.src)) {
            return { type: 'map', src: el.src };
        }
    };
    return ComponentMap;
}(model_ComponentImage));
/* harmony default export */ const model_ComponentMap = (ComponentMap);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentScript.ts
var ComponentScript_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentScript_assign = (undefined && undefined.__assign) || function () {
    ComponentScript_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentScript_assign.apply(this, arguments);
};


var ComponentScript_type = 'script';
var ComponentScript = /** @class */ (function (_super) {
    ComponentScript_extends(ComponentScript, _super);
    function ComponentScript() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentScript.prototype, "defaults", {
        get: function () {
            return ComponentScript_assign(ComponentScript_assign({}, _super.prototype.defaults), { type: ComponentScript_type, tagName: ComponentScript_type, droppable: false, draggable: false, layerable: false, highlightable: false });
        },
        enumerable: false,
        configurable: true
    });
    ComponentScript.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentScript_type;
    };
    return ComponentScript;
}(model_Component));
/* harmony default export */ const model_ComponentScript = (ComponentScript);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentSvg.ts
var ComponentSvg_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentSvg_assign = (undefined && undefined.__assign) || function () {
    ComponentSvg_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentSvg_assign.apply(this, arguments);
};


var ComponentSvg_type = 'svg';
var ComponentSvg = /** @class */ (function (_super) {
    ComponentSvg_extends(ComponentSvg, _super);
    function ComponentSvg() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentSvg.prototype, "defaults", {
        get: function () {
            return ComponentSvg_assign(ComponentSvg_assign({}, _super.prototype.defaults), { type: ComponentSvg_type, tagName: ComponentSvg_type, highlightable: false, resizable: { ratioDefault: true } });
        },
        enumerable: false,
        configurable: true
    });
    ComponentSvg.prototype.getName = function () {
        var name = this.get('tagName');
        var customName = this.get('custom-name');
        name = name.charAt(0).toUpperCase() + name.slice(1);
        return customName || name;
    };
    ComponentSvg.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentSvg_type;
    };
    return ComponentSvg;
}(model_Component));
/* harmony default export */ const model_ComponentSvg = (ComponentSvg);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentSvgIn.ts
var ComponentSvgIn_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentSvgIn_assign = (undefined && undefined.__assign) || function () {
    ComponentSvgIn_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentSvgIn_assign.apply(this, arguments);
};

/**
 * Component for inner SVG elements
 */
var ComponentSvgIn = /** @class */ (function (_super) {
    ComponentSvgIn_extends(ComponentSvgIn, _super);
    function ComponentSvgIn() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentSvgIn.prototype, "defaults", {
        get: function () {
            return ComponentSvgIn_assign(ComponentSvgIn_assign({}, _super.prototype.defaults), { selectable: false, hoverable: false, layerable: false });
        },
        enumerable: false,
        configurable: true
    });
    ComponentSvgIn.isComponent = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        return !!opts.inSvg;
    };
    return ComponentSvgIn;
}(model_ComponentSvg));
/* harmony default export */ const model_ComponentSvgIn = (ComponentSvgIn);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTable.ts
var ComponentTable_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTable_assign = (undefined && undefined.__assign) || function () {
    ComponentTable_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTable_assign.apply(this, arguments);
};


var ComponentTable_type = 'table';
var ComponentTable = /** @class */ (function (_super) {
    ComponentTable_extends(ComponentTable, _super);
    function ComponentTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTable.prototype, "defaults", {
        get: function () {
            return ComponentTable_assign(ComponentTable_assign({}, _super.prototype.defaults), { type: ComponentTable_type, tagName: ComponentTable_type, droppable: ['tbody', 'thead', 'tfoot'] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTable.prototype.initialize = function (props, opts) {
        _super.prototype.initialize.call(this, props, opts);
        var components = this.get('components');
        !components.length && components.add({ type: 'tbody' });
    };
    ComponentTable.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentTable_type;
    };
    return ComponentTable;
}(model_Component));
/* harmony default export */ const model_ComponentTable = (ComponentTable);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTableBody.ts
var ComponentTableBody_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTableBody_assign = (undefined && undefined.__assign) || function () {
    ComponentTableBody_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTableBody_assign.apply(this, arguments);
};


var ComponentTableBody_type = 'tbody';
var ComponentTableBody = /** @class */ (function (_super) {
    ComponentTableBody_extends(ComponentTableBody, _super);
    function ComponentTableBody() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTableBody.prototype, "defaults", {
        get: function () {
            return ComponentTableBody_assign(ComponentTableBody_assign({}, _super.prototype.defaults), { type: ComponentTableBody_type, tagName: ComponentTableBody_type, draggable: ['table'], droppable: ['tr'], columns: 1, rows: 1 });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTableBody.prototype.initialize = function (props, opts) {
        _super.prototype.initialize.call(this, props, opts);
        var components = this.get('components');
        var columns = this.get('columns');
        var rows = this.get('rows');
        // Init components if empty
        if (!components.length) {
            var rowsToAdd = [];
            while (rows--) {
                var columnsToAdd = [];
                var clm = columns;
                while (clm--) {
                    columnsToAdd.push({
                        type: 'cell',
                        classes: ['cell'],
                    });
                }
                rowsToAdd.push({
                    type: 'row',
                    classes: ['row'],
                    components: columnsToAdd,
                });
            }
            components.add(rowsToAdd);
        }
    };
    ComponentTableBody.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentTableBody_type;
    };
    return ComponentTableBody;
}(model_Component));
/* harmony default export */ const model_ComponentTableBody = (ComponentTableBody);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTableCell.ts
var ComponentTableCell_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTableCell_assign = (undefined && undefined.__assign) || function () {
    ComponentTableCell_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTableCell_assign.apply(this, arguments);
};


var ComponentTableCell = /** @class */ (function (_super) {
    ComponentTableCell_extends(ComponentTableCell, _super);
    function ComponentTableCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTableCell.prototype, "defaults", {
        get: function () {
            return ComponentTableCell_assign(ComponentTableCell_assign({}, _super.prototype.defaults), { type: 'cell', tagName: 'td', draggable: ['tr'] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTableCell.isComponent = function (el) {
        return ['td', 'th'].indexOf((0,mixins.toLowerCase)(el.tagName)) >= 0;
    };
    return ComponentTableCell;
}(model_Component));
/* harmony default export */ const model_ComponentTableCell = (ComponentTableCell);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTableFoot.ts
var ComponentTableFoot_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTableFoot_assign = (undefined && undefined.__assign) || function () {
    ComponentTableFoot_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTableFoot_assign.apply(this, arguments);
};


var ComponentTableFoot_type = 'tfoot';
var ComponentTableFoot = /** @class */ (function (_super) {
    ComponentTableFoot_extends(ComponentTableFoot, _super);
    function ComponentTableFoot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTableFoot.prototype, "defaults", {
        get: function () {
            return ComponentTableFoot_assign(ComponentTableFoot_assign({}, _super.prototype.defaults), { type: ComponentTableFoot_type, tagName: ComponentTableFoot_type });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTableFoot.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentTableFoot_type;
    };
    return ComponentTableFoot;
}(model_ComponentTableBody));
/* harmony default export */ const model_ComponentTableFoot = (ComponentTableFoot);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTableHead.ts
var ComponentTableHead_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTableHead_assign = (undefined && undefined.__assign) || function () {
    ComponentTableHead_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTableHead_assign.apply(this, arguments);
};


var ComponentTableHead_type = 'thead';
var ComponentTableHead = /** @class */ (function (_super) {
    ComponentTableHead_extends(ComponentTableHead, _super);
    function ComponentTableHead() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTableHead.prototype, "defaults", {
        get: function () {
            return ComponentTableHead_assign(ComponentTableHead_assign({}, _super.prototype.defaults), { type: ComponentTableHead_type, tagName: ComponentTableHead_type });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTableHead.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === ComponentTableHead_type;
    };
    return ComponentTableHead;
}(model_ComponentTableBody));
/* harmony default export */ const model_ComponentTableHead = (ComponentTableHead);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentTableRow.ts
var ComponentTableRow_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTableRow_assign = (undefined && undefined.__assign) || function () {
    ComponentTableRow_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTableRow_assign.apply(this, arguments);
};


var tagName = 'tr';
var ComponentTableRow = /** @class */ (function (_super) {
    ComponentTableRow_extends(ComponentTableRow, _super);
    function ComponentTableRow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentTableRow.prototype, "defaults", {
        get: function () {
            return ComponentTableRow_assign(ComponentTableRow_assign({}, _super.prototype.defaults), { tagName: tagName, draggable: ['thead', 'tbody', 'tfoot'], droppable: ['th', 'td'] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentTableRow.isComponent = function (el) {
        return (0,mixins.toLowerCase)(el.tagName) === tagName;
    };
    return ComponentTableRow;
}(model_Component));
/* harmony default export */ const model_ComponentTableRow = (ComponentTableRow);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentVideo.ts
var ComponentVideo_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentVideo_assign = (undefined && undefined.__assign) || function () {
    ComponentVideo_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentVideo_assign.apply(this, arguments);
};


var ComponentVideo_type = 'video';
var yt = 'yt';
var vi = 'vi';
var ytnc = 'ytnc';
var defProvider = 'so';
var hasParam = function (value) { return value && value !== '0'; };
var ComponentVideo = /** @class */ (function (_super) {
    ComponentVideo_extends(ComponentVideo, _super);
    function ComponentVideo() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentVideo.prototype, "defaults", {
        get: function () {
            return ComponentVideo_assign(ComponentVideo_assign({}, _super.prototype.defaults), { type: ComponentVideo_type, tagName: ComponentVideo_type, videoId: '', void: false, provider: defProvider, ytUrl: 'https://www.youtube.com/embed/', ytncUrl: 'https://www.youtube-nocookie.com/embed/', viUrl: 'https://player.vimeo.com/video/', loop: false, poster: '', muted: 0, autoplay: false, controls: true, color: '', list: '', src: '', rel: 1, modestbranding: 0, sources: [], attributes: { allowfullscreen: 'allowfullscreen' } });
        },
        enumerable: false,
        configurable: true
    });
    ComponentVideo.prototype.initialize = function (props, opts) {
        this.em = opts.em;
        if (this.get('src'))
            this.parseFromSrc();
        this.updatePropsFromAttr();
        this.updateTraits();
        this.on('change:provider', this.updateTraits);
        this.on('change:videoId change:provider', this.updateSrc);
        _super.prototype.initialize.call(this, props, opts);
    };
    ComponentVideo.prototype.updatePropsFromAttr = function () {
        if (this.get('provider') === defProvider) {
            var _a = this.get('attributes'), controls = _a.controls, autoplay = _a.autoplay, loop = _a.loop;
            var toUp = {};
            if ((0,mixins.isDef)(controls))
                toUp.controls = !!controls;
            if ((0,mixins.isDef)(autoplay))
                toUp.autoplay = !!autoplay;
            if ((0,mixins.isDef)(loop))
                toUp.loop = !!loop;
            if (!(0,mixins.isEmptyObj)(toUp)) {
                this.set(toUp);
            }
        }
    };
    /**
     * Update traits by provider
     * @private
     */
    ComponentVideo.prototype.updateTraits = function () {
        var em = this.em;
        var prov = this.get('provider');
        var tagName = 'iframe';
        var traits;
        switch (prov) {
            case yt:
            case ytnc:
                traits = this.getYoutubeTraits();
                break;
            case vi:
                traits = this.getVimeoTraits();
                break;
            default:
                tagName = 'video';
                traits = this.getSourceTraits();
        }
        this.set({ tagName: tagName }, { silent: true }); // avoid break in view
        // @ts-ignore
        this.set({ traits: traits });
        em.get('ready') && em.trigger('component:toggled');
    };
    /**
     * Set attributes by src string
     */
    ComponentVideo.prototype.parseFromSrc = function () {
        var prov = this.get('provider');
        var uri = this.parseUri(this.get('src'));
        var qr = uri.query;
        switch (prov) {
            case yt:
            case ytnc:
            case vi:
                this.set('videoId', uri.pathname.split('/').pop());
                qr.list && this.set('list', qr.list);
                hasParam(qr.autoplay) && this.set('autoplay', true);
                hasParam(qr.loop) && this.set('loop', true);
                parseInt(qr.controls) === 0 && this.set('controls', false);
                hasParam(qr.color) && this.set('color', qr.color);
                qr.rel === '0' && this.set('rel', 0);
                qr.modestbranding === '1' && this.set('modestbranding', 1);
                break;
            default:
        }
    };
    /**
     * Update src on change of video ID
     * @private
     */
    ComponentVideo.prototype.updateSrc = function () {
        var prov = this.get('provider');
        var src = '';
        switch (prov) {
            case yt:
                src = this.getYoutubeSrc();
                break;
            case ytnc:
                src = this.getYoutubeNoCookieSrc();
                break;
            case vi:
                src = this.getVimeoSrc();
                break;
        }
        this.set({ src: src });
    };
    /**
     * Returns object of attributes for HTML
     * @return {Object}
     * @private
     */
    ComponentVideo.prototype.getAttrToHTML = function () {
        var attr = _super.prototype.getAttrToHTML.call(this);
        var prov = this.get('provider');
        switch (prov) {
            case yt:
            case ytnc:
            case vi:
                break;
            default:
                attr.loop = !!this.get('loop');
                attr.autoplay = !!this.get('autoplay');
                attr.controls = !!this.get('controls');
        }
        return attr;
    };
    // Listen provider change and switch traits, in TraitView listen traits change
    /**
     * Return the provider trait
     * @return {Object}
     * @private
     */
    ComponentVideo.prototype.getProviderTrait = function () {
        return {
            type: 'select',
            label: 'Provider',
            name: 'provider',
            changeProp: true,
            options: [
                { value: 'so', name: 'HTML5 Source' },
                { value: yt, name: 'Youtube' },
                { value: ytnc, name: 'Youtube (no cookie)' },
                { value: vi, name: 'Vimeo' },
            ],
        };
    };
    /**
     * Return traits for the source provider
     * @return {Array<Object>}
     * @private
     */
    ComponentVideo.prototype.getSourceTraits = function () {
        return [
            this.getProviderTrait(),
            {
                label: 'Source',
                name: 'src',
                placeholder: 'eg. ./media/video.mp4',
                changeProp: true,
            },
            {
                label: 'Poster',
                name: 'poster',
                placeholder: 'eg. ./media/image.jpg',
            },
            this.getAutoplayTrait(),
            this.getLoopTrait(),
            this.getControlsTrait(),
        ];
    };
    /**
     * Return traits for the source provider
     * @return {Array<Object>}
     * @private
     */
    ComponentVideo.prototype.getYoutubeTraits = function () {
        return [
            this.getProviderTrait(),
            {
                label: 'Video ID',
                name: 'videoId',
                placeholder: 'eg. jNQXAC9IVRw',
                changeProp: true,
            },
            this.getAutoplayTrait(),
            this.getLoopTrait(),
            this.getControlsTrait(),
            {
                type: 'checkbox',
                label: 'Related',
                name: 'rel',
                changeProp: true,
            },
            {
                type: 'checkbox',
                label: 'Modest',
                name: 'modestbranding',
                changeProp: true,
            },
        ];
    };
    /**
     * Return traits for the source provider
     * @return {Array<Object>}
     * @private
     */
    ComponentVideo.prototype.getVimeoTraits = function () {
        return [
            this.getProviderTrait(),
            {
                label: 'Video ID',
                name: 'videoId',
                placeholder: 'eg. 123456789',
                changeProp: true,
            },
            {
                label: 'Color',
                name: 'color',
                placeholder: 'eg. FF0000',
                changeProp: true,
            },
            this.getAutoplayTrait(),
            this.getLoopTrait(),
        ];
    };
    /**
     * Return object trait
     * @return {Object}
     * @private
     */
    ComponentVideo.prototype.getAutoplayTrait = function () {
        return {
            type: 'checkbox',
            label: 'Autoplay',
            name: 'autoplay',
            changeProp: true,
        };
    };
    /**
     * Return object trait
     * @return {Object}
     * @private
     */
    ComponentVideo.prototype.getLoopTrait = function () {
        return {
            type: 'checkbox',
            label: 'Loop',
            name: 'loop',
            changeProp: true,
        };
    };
    /**
     * Return object trait
     * @return {Object}
     * @private
     */
    ComponentVideo.prototype.getControlsTrait = function () {
        return {
            type: 'checkbox',
            label: 'Controls',
            name: 'controls',
            changeProp: true,
        };
    };
    /**
     * Returns url to youtube video
     * @return {string}
     * @private
     */
    ComponentVideo.prototype.getYoutubeSrc = function () {
        var id = this.get('videoId');
        var url = this.get('ytUrl');
        var list = this.get('list');
        url += id + (id.indexOf('?') < 0 ? '?' : '');
        url += list ? "&list=".concat(list) : '';
        url += this.get('autoplay') ? '&autoplay=1&mute=1' : '';
        url += !this.get('controls') ? '&controls=0&showinfo=0' : '';
        // Loop works only with playlist enabled
        // https://stackoverflow.com/questions/25779966/youtube-iframe-loop-doesnt-work
        url += this.get('loop') ? "&loop=1&playlist=".concat(id) : '';
        url += this.get('rel') ? '' : '&rel=0';
        url += this.get('modestbranding') ? '&modestbranding=1' : '';
        return url;
    };
    /**
     * Returns url to youtube no cookie video
     * @return {string}
     * @private
     */
    ComponentVideo.prototype.getYoutubeNoCookieSrc = function () {
        var url = this.getYoutubeSrc();
        url = url.replace(this.get('ytUrl'), this.get('ytncUrl'));
        return url;
    };
    /**
     * Returns url to vimeo video
     * @return {string}
     * @private
     */
    ComponentVideo.prototype.getVimeoSrc = function () {
        var url = this.get('viUrl');
        url += this.get('videoId') + '?';
        url += this.get('autoplay') ? '&autoplay=1&muted=1' : '';
        url += this.get('loop') ? '&loop=1' : '';
        url += !this.get('controls') ? '&title=0&portrait=0&badge=0' : '';
        url += this.get('color') ? '&color=' + this.get('color') : '';
        return url;
    };
    ComponentVideo.isComponent = function (el) {
        var tagName = el.tagName, src = el.src;
        var isYtProv = /youtube\.com\/embed/.test(src);
        var isYtncProv = /youtube-nocookie\.com\/embed/.test(src);
        var isViProv = /player\.vimeo\.com\/video/.test(src);
        var isExtProv = isYtProv || isYtncProv || isViProv;
        if ((0,mixins.toLowerCase)(tagName) == ComponentVideo_type || ((0,mixins.toLowerCase)(tagName) == 'iframe' && isExtProv)) {
            var result = { type: 'video' };
            if (src)
                result.src = src;
            if (isExtProv) {
                if (isYtProv)
                    result.provider = yt;
                else if (isYtncProv)
                    result.provider = ytnc;
                else if (isViProv)
                    result.provider = vi;
            }
            return result;
        }
    };
    return ComponentVideo;
}(model_ComponentImage));
/* harmony default export */ const model_ComponentVideo = (ComponentVideo);

;// CONCATENATED MODULE: ./src/dom_components/model/ComponentWrapper.ts
var ComponentWrapper_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentWrapper_assign = (undefined && undefined.__assign) || function () {
    ComponentWrapper_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentWrapper_assign.apply(this, arguments);
};

var ComponentWrapper = /** @class */ (function (_super) {
    ComponentWrapper_extends(ComponentWrapper, _super);
    function ComponentWrapper() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ComponentWrapper.prototype, "defaults", {
        get: function () {
            return ComponentWrapper_assign(ComponentWrapper_assign({}, _super.prototype.defaults), { tagName: 'body', removable: false, copyable: false, draggable: false, components: [], traits: [], stylable: [
                    'background',
                    'background-color',
                    'background-image',
                    'background-repeat',
                    'background-attachment',
                    'background-position',
                    'background-size',
                ] });
        },
        enumerable: false,
        configurable: true
    });
    ComponentWrapper.prototype.__postAdd = function () {
        var _a;
        var um = (_a = this.em) === null || _a === void 0 ? void 0 : _a.UndoManager;
        !this.__hasUm && (um === null || um === void 0 ? void 0 : um.add(this));
        return _super.prototype.__postAdd.call(this);
    };
    ComponentWrapper.prototype.__postRemove = function () {
        var _a;
        var um = (_a = this.em) === null || _a === void 0 ? void 0 : _a.UndoManager;
        um === null || um === void 0 ? void 0 : um.remove(this);
        return _super.prototype.__postRemove.call(this);
    };
    ComponentWrapper.isComponent = function () {
        return false;
    };
    return ComponentWrapper;
}(model_Component));
/* harmony default export */ const model_ComponentWrapper = (ComponentWrapper);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentsView.ts
var ComponentsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var ComponentsView = /** @class */ (function (_super) {
    ComponentsView_extends(ComponentsView, _super);
    function ComponentsView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.compView = view_ComponentView;
        return _this;
    }
    ComponentsView.prototype.initialize = function (o) {
        this.opts = o || {};
        this.config = o.config || {};
        // @ts-ignore
        this.em = this.config.em;
        var coll = this.collection;
        this.listenTo(coll, 'add', this.addTo);
        this.listenTo(coll, 'reset', this.resetChildren);
        this.listenTo(coll, 'remove', this.removeChildren);
    };
    ComponentsView.prototype.removeChildren = function (removed, coll, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        removed.views.forEach(function (view) {
            if (!view)
                return;
            var childrenView = view.childrenView, scriptContainer = view.scriptContainer;
            childrenView && childrenView.stopListening();
            (0,dom/* removeEl */.L_)(scriptContainer);
            view.remove.apply(view);
        });
        var inner = removed.components();
        inner.forEach(function (it) { return _this.removeChildren(it, coll, opts); });
    };
    /**
     * Add to collection
     * @param {Model} model
     * @param {Collection} coll
     * @param {Object} opts
     * @private
     * */
    ComponentsView.prototype.addTo = function (model, coll, opts) {
        if (coll === void 0) { coll = {}; }
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var i = this.collection.indexOf(model);
        this.addToCollection(model, null, i);
        if (em && !opts.temporary) {
            var triggerAdd_1 = function (model) {
                em.trigger('component:add', model);
                model.components().forEach(function (comp) { return triggerAdd_1(comp); });
            };
            triggerAdd_1(model);
        }
    };
    /**
     * Add new object to collection
     * @param  {Object}  Model
     * @param  {Object}   Fragment collection
     * @param  {Integer}  Index of append
     *
     * @return   {Object}   Object rendered
     * @private
     * */
    ComponentsView.prototype.addToCollection = function (model, fragmentEl, index) {
        // if (!this.compView) this.compView = require('./ComponentView').default;
        var _a = this, config = _a.config, opts = _a.opts, em = _a.em;
        var fragment = fragmentEl || null;
        var frameView = config.frameView;
        var sameFrameView = (frameView === null || frameView === void 0 ? void 0 : frameView.model) && model.getView(frameView.model);
        var dt = opts.componentTypes || (em === null || em === void 0 ? void 0 : em.Components.getTypes());
        var type = model.get('type') || 'default';
        var viewObject = this.compView;
        for (var it_1 = 0; it_1 < dt.length; it_1++) {
            if (dt[it_1].id == type) {
                viewObject = dt[it_1].view;
                break;
            }
        }
        var view = sameFrameView ||
            new viewObject({
                model: model,
                // @ts-ignore
                config: config,
                componentTypes: dt,
            });
        var rendered;
        try {
            // Avoid breaking on DOM rendering (eg. invalid attribute name)
            rendered = view.render().el;
        }
        catch (error) {
            rendered = document.createTextNode('');
            em.logError(error);
        }
        if (fragment) {
            fragment.appendChild(rendered);
        }
        else {
            var parent_1 = this.parentEl;
            var children = parent_1.childNodes;
            if (!(0,index_all.isUndefined)(index)) {
                var lastIndex = children.length == index;
                // If the added model is the last of collection
                // need to change the logic of append
                if (lastIndex) {
                    index--;
                }
                // In case the added is new in the collection index will be -1
                if (lastIndex || !children.length) {
                    parent_1.appendChild(rendered);
                }
                else {
                    parent_1.insertBefore(rendered, children[index]);
                }
            }
            else {
                parent_1.appendChild(rendered);
            }
        }
        if (!model.opt.temporary) {
            em === null || em === void 0 ? void 0 : em.trigger('component:mount', model);
        }
        return rendered;
    };
    ComponentsView.prototype.resetChildren = function (models, _a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, _c = _b.previousModels, previousModels = _c === void 0 ? [] : _c;
        this.parentEl.innerHTML = '';
        previousModels.forEach(function (md) { return _this.removeChildren(md, _this.collection); });
        models.each(function (model) { return _this.addToCollection(model); });
    };
    ComponentsView.prototype.render = function (parent) {
        var _this = this;
        var el = this.el;
        var frag = document.createDocumentFragment();
        this.parentEl = parent || this.el;
        this.collection.each(function (model) { return _this.addToCollection(model, frag); });
        el.innerHTML = '';
        el.appendChild(frag);
        return this;
    };
    return ComponentsView;
}(common/* View */.G7));
/* harmony default export */ const view_ComponentsView = (ComponentsView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentView.ts
var ComponentView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentView_assign = (undefined && undefined.__assign) || function () {
    ComponentView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentView_assign.apply(this, arguments);
};









var ComponentView = /** @class */ (function (_super) {
    ComponentView_extends(ComponentView, _super);
    function ComponentView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @ts-ignore */
    ComponentView.prototype.className = function () {
        return this.getClasses();
    };
    /** @ts-ignore */
    ComponentView.prototype.tagName = function () {
        return this.model.get('tagName');
    };
    ComponentView.prototype.preinitialize = function (opt) {
        if (opt === void 0) { opt = {}; }
        this.opts = opt;
    };
    ComponentView.prototype.initialize = function (opt) {
        if (opt === void 0) { opt = {}; }
        var model = this.model;
        var config = opt.config || {};
        var em = config.em;
        var modelOpt = model.opt || {};
        var _a = this, $el = _a.$el, el = _a.el;
        this.opts = opt;
        this.modelOpt = modelOpt;
        this.config = config;
        this.em = em;
        this.pfx = config.stylePrefix || '';
        this.ppfx = config.pStylePrefix || '';
        this.attr = model.get('attributes');
        this.classe = this.attr.class || [];
        this.listenTo(model, 'change:style', this.updateStyle);
        this.listenTo(model, 'change:attributes', this.renderAttributes);
        this.listenTo(model, 'change:highlightable', this.updateHighlight);
        this.listenTo(model, 'change:status change:locked', this.updateStatus);
        this.listenTo(model, 'change:script rerender', this.reset);
        this.listenTo(model, 'change:content', this.updateContent);
        this.listenTo(model, 'change', this.handleChange);
        this.listenTo(model, 'active', this.onActive);
        this.listenTo(model, 'disable', this.onDisable);
        $el.data('model', model);
        (0,mixins.setViewEl)(el, this);
        model.view = this;
        this.frameView && model.views.push(this);
        this.initClasses();
        this.initComponents({ avoidRender: true });
        this.events = ComponentView_assign(ComponentView_assign({}, this.constructor.getEvents()), { dragstart: 'handleDragStart' });
        this.delegateEvents();
        !modelOpt.temporary && this.init(this._clbObj());
    };
    Object.defineProperty(ComponentView.prototype, "__cmpStyleOpts", {
        get: function () {
            return { state: '', mediaText: '' };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ComponentView.prototype, "frameView", {
        get: function () {
            return this.opts.config.frameView;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ComponentView.prototype, "createDoc", {
        get: function () {
            var _a, _b;
            var doc = ((_a = this.frameView) === null || _a === void 0 ? void 0 : _a.getDoc()) || document;
            return ((_b = this.opts.config) === null || _b === void 0 ? void 0 : _b.useFrameDoc) ? doc : document;
        },
        enumerable: false,
        configurable: true
    });
    ComponentView.prototype.__isDraggable = function () {
        var _a = this, model = _a.model, config = _a.config;
        var draggable = model.attributes.draggable;
        return config.draggableComponents && draggable;
    };
    ComponentView.prototype._clbObj = function () {
        var _a = this, em = _a.em, model = _a.model, el = _a.el;
        return {
            editor: em === null || em === void 0 ? void 0 : em.getEditor(),
            model: model,
            el: el,
        };
    };
    /**
     * Initialize callback
     */
    ComponentView.prototype.init = function (opts) { };
    /**
     * Remove callback
     */
    ComponentView.prototype.removed = function (opts) { };
    /**
     * On render callback
     */
    ComponentView.prototype.onRender = function (opts) { };
    /**
     * Callback executed when the `active` event is triggered on component
     */
    ComponentView.prototype.onActive = function (ev) { };
    /**
     * Callback executed when the `disable` event is triggered on component
     */
    ComponentView.prototype.onDisable = function (opts) { };
    ComponentView.prototype.remove = function () {
        var _a;
        _super.prototype.remove.call(this);
        var _b = this, model = _b.model, $el = _b.$el;
        var views = model.views;
        var frame = this.frameView || {};
        model.components().forEach(function (comp) {
            var view = comp.getView(frame.model);
            view === null || view === void 0 ? void 0 : view.remove();
        });
        (_a = this.childrenView) === null || _a === void 0 ? void 0 : _a.remove();
        views.splice(views.indexOf(this), 1);
        this.removed(this._clbObj());
        $el.data({ model: '', collection: '', view: '' });
        // delete model.view; // Sorter relies on this property
        return this;
    };
    ComponentView.prototype.handleDragStart = function (event) {
        if (!this.__isDraggable())
            return false;
        event.stopPropagation();
        event.preventDefault();
        this.em.Commands.run('tlb-move', {
            target: this.model,
            event: event,
        });
    };
    ComponentView.prototype.initClasses = function () {
        var model = this.model;
        var classes = model.classes;
        var event = 'change:classes';
        if (classes instanceof model_Selectors) {
            this.stopListening(model, event, this.initClasses);
            this.listenTo(model, event, this.initClasses);
            this.listenTo(classes, 'add remove change reset', this.updateClasses);
            classes.length && this.importClasses();
        }
    };
    ComponentView.prototype.initComponents = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, model = _a.model, $el = _a.$el, childrenView = _a.childrenView;
        var event = 'change:components';
        var comps = model.get('components');
        var toListen = [model, event, this.initComponents];
        if (comps instanceof model_Components) {
            $el.data('collection', comps);
            childrenView && childrenView.remove();
            this.stopListening.apply(this, toListen);
            !opts.avoidRender && this.renderChildren();
            // @ts-ignore
            this.listenTo.apply(this, toListen);
        }
    };
    /**
     * Handle any property change
     * @private
     */
    ComponentView.prototype.handleChange = function () {
        var model = this.model;
        var chgArr = (0,index_all.keys)(model.changed);
        if (chgArr.length === 1 && chgArr[0] === 'status')
            return;
        model.emitUpdate();
        for (var prop in model.changed) {
            model.emitUpdate(prop);
        }
    };
    /**
     * Import, if possible, classes inside main container
     * @private
     * */
    ComponentView.prototype.importClasses = function () {
        var _a = this, em = _a.em, model = _a.model;
        var sm = em.Selectors;
        sm && model.classes.forEach(function (s) { return sm.add(s.getName()); });
    };
    /**
     * Update item on status change
     * @param  {Event} e
     * @private
     * */
    ComponentView.prototype.updateStatus = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, em = _a.em, el = _a.el, ppfx = _a.ppfx, model = _a.model;
        var canvas = em === null || em === void 0 ? void 0 : em.Canvas;
        var extHl = canvas === null || canvas === void 0 ? void 0 : canvas.config.extHl;
        var status = model.get('status');
        var selectedCls = "".concat(ppfx, "selected");
        var selectedParentCls = "".concat(selectedCls, "-parent");
        var freezedCls = "".concat(ppfx, "freezed");
        var hoveredCls = "".concat(ppfx, "hovered");
        var noPointerCls = "".concat(ppfx, "no-pointer");
        var toRemove = [selectedCls, selectedParentCls, freezedCls, hoveredCls, noPointerCls];
        var selCls = extHl && !opts.noExtHl ? '' : selectedCls;
        this.$el.removeClass(toRemove.join(' '));
        var actualCls = el.getAttribute('class') || '';
        var cls = [actualCls];
        var noCustomSpotSelect = !(canvas === null || canvas === void 0 ? void 0 : canvas.hasCustomSpot(CanvasSpot/* CanvasSpotBuiltInTypes */.q.Select));
        var noCustomSpotTarget = !(canvas === null || canvas === void 0 ? void 0 : canvas.hasCustomSpot(CanvasSpot/* CanvasSpotBuiltInTypes */.q.Target));
        switch (status) {
            case 'selected':
                noCustomSpotSelect && cls.push(selCls);
                break;
            case 'selected-parent':
                noCustomSpotTarget && cls.push(selectedParentCls);
                break;
            case 'freezed':
                cls.push(freezedCls);
                break;
            case 'freezed-selected':
                cls.push(freezedCls);
                noCustomSpotSelect && cls.push(selCls);
                break;
            case 'hovered':
                !opts.avoidHover && cls.push(hoveredCls);
                break;
        }
        model.get('locked') && cls.push(noPointerCls);
        var clsStr = cls.filter(Boolean).join(' ');
        clsStr && el.setAttribute('class', clsStr);
    };
    /**
     * Update highlight attribute
     * @private
     * */
    ComponentView.prototype.updateHighlight = function () {
        var model = this.model;
        var isTextable = model.get('textable');
        var hl = model.get('highlightable') && (isTextable || !model.isChildOf('text'));
        this.setAttribute('data-gjs-highlightable', hl ? true : '');
    };
    /**
     * Update style attribute
     * @private
     * */
    ComponentView.prototype.updateStyle = function (m, v, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, model = _a.model, em = _a.em;
        if (avoidInline(em) && !opts.inline) {
            var styleOpts = this.__cmpStyleOpts;
            var style = model.getStyle(styleOpts);
            !(0,index_all.isEmpty)(style) && model.setStyle(style, styleOpts);
        }
        else {
            this.setAttribute('style', model.styleToString(opts));
        }
    };
    /**
     * Update classe attribute
     * @private
     * */
    ComponentView.prototype.updateClasses = function () {
        var str = this.model.classes.pluck('name').join(' ');
        this.setAttribute('class', str);
        // Regenerate status class
        this.updateStatus();
        this.onAttrUpdate();
    };
    /**
     * Update single attribute
     * @param {[type]} name  [description]
     * @param {[type]} value [description]
     */
    ComponentView.prototype.setAttribute = function (name, value) {
        var el = this.$el;
        value ? el.attr(name, value) : el.removeAttr(name);
    };
    /**
     * Get classes from attributes.
     * This method is called before initialize
     *
     * @return  {Array}|null
     * @private
     * */
    ComponentView.prototype.getClasses = function () {
        return this.model.getClasses().join(' ');
    };
    /**
     * Update attributes
     * @private
     * */
    ComponentView.prototype.updateAttributes = function () {
        var attrs = [];
        var _a = this, model = _a.model, $el = _a.$el, el = _a.el;
        var _b = model.attributes, textable = _b.textable, type = _b.type;
        var defaultAttr = ComponentView_assign(ComponentView_assign({ id: model.getId(), 'data-gjs-type': type || 'default' }, (this.__isDraggable() && { draggable: true })), (textable && { contenteditable: 'false' }));
        // Remove all current attributes
        (0,index_all.each)(el.attributes, function (attr) { return attrs.push(attr.nodeName); });
        attrs.forEach(function (attr) { return $el.removeAttr(attr); });
        this.updateStyle();
        this.updateHighlight();
        var attr = ComponentView_assign(ComponentView_assign({}, defaultAttr), model.getAttributes());
        // Remove all `false` attributes
        (0,index_all.keys)(attr).forEach(function (key) { return attr[key] === false && delete attr[key]; });
        $el.attr(attr);
    };
    /**
     * Update component content
     * @private
     * */
    ComponentView.prototype.updateContent = function () {
        var content = this.model.content;
        var hasComps = this.model.components().length;
        this.getChildrenContainer().innerHTML = hasComps ? '' : content;
    };
    /**
     * Prevent default helper
     * @param  {Event} e
     * @private
     */
    ComponentView.prototype.prevDef = function (e) {
        e.preventDefault();
    };
    /**
     * Render component's script
     * @private
     */
    ComponentView.prototype.updateScript = function () {
        var _a = this, model = _a.model, em = _a.em;
        if (!model.get('script'))
            return;
        em === null || em === void 0 ? void 0 : em.Canvas.getCanvasView().updateScript(this);
    };
    /**
     * Return children container
     * Differently from a simple component where children container is the
     * component itself
     * <my-comp>
     *  <!--
     *    <child></child> ...
     *   -->
     * </my-comp>
     * You could have the children container more deeper
     * <my-comp>
     *  <div></div>
     *  <div></div>
     *  <div>
     *    <div>
     *      <!--
     *        <child></child> ...
     *      -->
     *    </div>
     *  </div>
     * </my-comp>
     * @return HTMLElement
     * @private
     */
    ComponentView.prototype.getChildrenContainer = function () {
        var container = this.el;
        if (typeof this.getChildrenSelector == 'function') {
            container = this.el.querySelector(this.getChildrenSelector());
        }
        else if (typeof this.getTemplate == 'function') {
            // Need to find deepest first child
        }
        return container;
    };
    /**
     * This returns rect informations not affected by the canvas zoom.
     * The method `getBoundingClientRect` doesn't work here and we
     * have to take in account offsetParent
     */
    ComponentView.prototype.getOffsetRect = function () {
        var rect = { top: 0, left: 0, bottom: 0, right: 0 };
        var target = this.el;
        var gtop = 0;
        var gleft = 0;
        var assignRect = function (el) {
            var offsetParent = el.offsetParent;
            if (offsetParent) {
                gtop += offsetParent.offsetTop;
                gleft += offsetParent.offsetLeft;
                assignRect(offsetParent);
            }
            else {
                rect.top = target.offsetTop + gtop;
                rect.left = target.offsetLeft + gleft;
                rect.bottom = rect.top + target.offsetHeight;
                rect.right = rect.left + target.offsetWidth;
            }
        };
        assignRect(target);
        return rect;
    };
    ComponentView.prototype.isInViewport = function () {
        var _a = this, el = _a.el, em = _a.em, frameView = _a.frameView;
        var canvasView = em.Canvas.getCanvasView();
        var elRect = canvasView.getElBoxRect(el, { local: true });
        var frameEl = frameView.el;
        var frameH = frameEl.clientHeight;
        var frameW = frameEl.clientWidth;
        var elTop = elRect.y;
        var elRight = elRect.x;
        var elBottom = elTop + elRect.height;
        var elLeft = elRight + elRect.width;
        var isTopInside = elTop >= 0 && elTop < frameH;
        var isBottomInside = elBottom > 0 && elBottom < frameH;
        var isLeftInside = elLeft >= 0 && elLeft < frameW;
        var isRightInside = elRight > 0 && elRight <= frameW;
        var partiallyIn = (isTopInside || isBottomInside) && (isLeftInside || isRightInside);
        return partiallyIn;
    };
    ComponentView.prototype.scrollIntoView = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var isInViewport = this.isInViewport();
        if (!isInViewport || opts.force) {
            var el = this.el;
            // PATCH: scrollIntoView won't work with multiple requests from iframes
            if (opts.behavior !== 'smooth') {
                var rect = this.getOffsetRect();
                (_a = el.ownerDocument.defaultView) === null || _a === void 0 ? void 0 : _a.scrollTo(0, rect.top);
            }
            else {
                el.scrollIntoView(ComponentView_assign({ behavior: 'smooth', block: 'nearest' }, opts));
            }
        }
    };
    /**
     * Recreate the element of the view
     */
    ComponentView.prototype.reset = function () {
        var el = this.el;
        // @ts-ignore
        this.el = '';
        this._ensureElement();
        this._setData();
        (0,dom/* replaceWith */.dL)(el, this.el);
        this.render();
    };
    ComponentView.prototype._setData = function () {
        var model = this.model;
        var collection = model.components();
        var view = this;
        this.$el.data({ model: model, collection: collection, view: view });
    };
    ComponentView.prototype._createElement = function (tagName) {
        return this.createDoc.createElement(tagName);
    };
    /**
     * Render children components
     * @private
     */
    ComponentView.prototype.renderChildren = function () {
        this.updateContent();
        var container = this.getChildrenContainer();
        var view = this.childrenView ||
            new view_ComponentsView({
                // @ts-ignore
                collection: this.model.get('components'),
                config: this.config,
                componentTypes: this.opts.componentTypes,
            });
        view.render(container);
        this.childrenView = view;
        var childNodes = Array.prototype.slice.call(view.el.childNodes);
        for (var i = 0, len = childNodes.length; i < len; i++) {
            container.appendChild(childNodes.shift());
        }
    };
    ComponentView.prototype.renderAttributes = function () {
        this.updateAttributes();
        this.updateClasses();
    };
    ComponentView.prototype.onAttrUpdate = function () { };
    ComponentView.prototype.render = function () {
        this.renderAttributes();
        if (this.modelOpt.temporary)
            return this;
        this.renderChildren();
        this.updateScript();
        (0,mixins.setViewEl)(this.el, this);
        this.postRender();
        return this;
    };
    ComponentView.prototype.postRender = function () {
        if (!this.modelOpt.temporary) {
            this.onRender(this._clbObj());
        }
    };
    ComponentView.getEvents = function () {
        return (0,index_all.result)(this.prototype, 'events');
    };
    return ComponentView;
}(common/* View */.G7));
/* harmony default export */ const view_ComponentView = (ComponentView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTextNodeView.ts
var ComponentTextNodeView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTextNodeView = /** @class */ (function (_super) {
    ComponentTextNodeView_extends(ComponentTextNodeView, _super);
    function ComponentTextNodeView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Clear methods used on Nodes with attributes
    ComponentTextNodeView.prototype._setAttributes = function () { };
    ComponentTextNodeView.prototype.renderAttributes = function () { };
    ComponentTextNodeView.prototype.updateStatus = function () { };
    ComponentTextNodeView.prototype.updateClasses = function () { };
    ComponentTextNodeView.prototype.setAttribute = function () { };
    ComponentTextNodeView.prototype.updateAttributes = function () { };
    ComponentTextNodeView.prototype.initClasses = function () { };
    ComponentTextNodeView.prototype.initComponents = function () { };
    ComponentTextNodeView.prototype.delegateEvents = function () {
        return this;
    };
    ComponentTextNodeView.prototype._createElement = function () {
        return document.createTextNode('');
    };
    ComponentTextNodeView.prototype.render = function () {
        var _a = this, model = _a.model, el = _a.el;
        if (model.opt.temporary)
            return this;
        el.textContent = model.content;
        return this;
    };
    return ComponentTextNodeView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTextNodeView = (ComponentTextNodeView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentCommentView.ts
var ComponentCommentView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentCommentView = /** @class */ (function (_super) {
    ComponentCommentView_extends(ComponentCommentView, _super);
    function ComponentCommentView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentCommentView.prototype._createElement = function () {
        return document.createComment(this.model.content);
    };
    return ComponentCommentView;
}(view_ComponentTextNodeView));
/* harmony default export */ const view_ComponentCommentView = (ComponentCommentView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentFrameView.ts
var ComponentFrameView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ComponentFrameView = /** @class */ (function (_super) {
    ComponentFrameView_extends(ComponentFrameView, _super);
    function ComponentFrameView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentFrameView.prototype.tagName = function () {
        return 'div';
    };
    ComponentFrameView.prototype.initialize = function (props) {
        _super.prototype.initialize.call(this, props);
        this.listenTo(this.model, 'change:attributes:src', this.updateSrc);
    };
    ComponentFrameView.prototype.updateSrc = function () {
        var frame = (0,dom/* find */.sE)(this.el, 'iframe')[0];
        frame && (0,dom/* attrUp */.FW)(frame, { src: this.__getSrc() });
    };
    ComponentFrameView.prototype.render = function () {
        _super.prototype.render.call(this);
        var frame = (0,dom/* createEl */.ut)('iframe', {
            class: "".concat(this.ppfx, "no-pointer"),
            style: 'width: 100%; height: 100%; border: none',
            src: this.__getSrc(),
        });
        this.el.appendChild(frame);
        return this;
    };
    ComponentFrameView.prototype.__getSrc = function () {
        return this.model.getAttributes().src || '';
    };
    return ComponentFrameView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentFrameView = (ComponentFrameView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentImageView.ts
var ComponentImageView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ComponentImageView = /** @class */ (function (_super) {
    ComponentImageView_extends(ComponentImageView, _super);
    function ComponentImageView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentImageView.prototype.tagName = function () {
        return 'img';
    };
    ComponentImageView.prototype.events = function () {
        return {
            dblclick: 'onActive',
            click: 'initResize',
            error: 'onError',
            load: 'onLoad',
            dragstart: 'noDrag',
        };
    };
    ComponentImageView.prototype.initialize = function (props) {
        _super.prototype.initialize.call(this, props);
        this.listenTo(this.model, 'change:src', this.updateSrc);
        this.classEmpty = "".concat(this.ppfx, "plh-image");
        this.fetchFile();
    };
    /**
     * Fetch file if exists
     */
    ComponentImageView.prototype.fetchFile = function () {
        if (this.modelOpt.temporary)
            return;
        var _a = this, model = _a.model, em = _a.em;
        var file = model.get('file');
        if (file && em) {
            var fu = em.Assets.FileUploader();
            fu === null || fu === void 0 ? void 0 : fu.uploadFile({
                // @ts-ignore
                dataTransfer: { files: [file] },
            }, function (res) {
                var obj = res && res.data && res.data[0];
                var src = obj && ((0,index_all.isString)(obj) ? obj : obj.src);
                src && model.set({ src: src });
            });
            model.set('file', '');
        }
    };
    /**
     * Update src attribute
     * @private
     * */
    ComponentImageView.prototype.updateSrc = function () {
        var model = this.model;
        model.addAttributes({ src: model.getSrcResult() });
        this.updateClasses();
    };
    ComponentImageView.prototype.updateClasses = function () {
        _super.prototype.updateClasses.call(this);
        var _a = this, el = _a.el, classEmpty = _a.classEmpty, model = _a.model;
        var srcExists = model.getSrcResult() && !model.isDefaultSrc();
        var method = srcExists ? 'remove' : 'add';
        el.classList[method](classEmpty);
    };
    /**
     * Open dialog for image changing
     * @param  {Object}  e  Event
     * @private
     * */
    ComponentImageView.prototype.onActive = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
        var _a = this, em = _a.em, model = _a.model;
        var am = em === null || em === void 0 ? void 0 : em.Assets;
        if (am && model.get('editable')) {
            am.open({
                select: function (asset, complete) {
                    model.set({ src: asset.getSrc() });
                    complete && am.close();
                },
                target: model,
                types: ['image'],
                accept: 'image/*',
            });
        }
    };
    ComponentImageView.prototype.onError = function () {
        var fallback = this.model.getSrcResult({ fallback: true });
        if (fallback) {
            this.el.src = fallback;
        }
    };
    ComponentImageView.prototype.onLoad = function () {
        // Used to update component tools box (eg. toolbar, resizer) once the image is loaded
        this.em.trigger('change:canvasOffset');
    };
    ComponentImageView.prototype.noDrag = function (ev) {
        ev.preventDefault();
        return false;
    };
    ComponentImageView.prototype.render = function () {
        this.renderAttributes();
        if (this.modelOpt.temporary)
            return this;
        this.updateSrc();
        var _a = this, $el = _a.$el, model = _a.model;
        var cls = $el.attr('class') || '';
        !model.get('src') && $el.attr('class', "".concat(cls, " ").concat(this.classEmpty).trim());
        this.postRender();
        return this;
    };
    return ComponentImageView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentImageView = (ComponentImageView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTextView.ts
var ComponentTextView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ComponentTextView_assign = (undefined && undefined.__assign) || function () {
    ComponentTextView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ComponentTextView_assign.apply(this, arguments);
};
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};





var ComponentTextView = /** @class */ (function (_super) {
    ComponentTextView_extends(ComponentTextView, _super);
    function ComponentTextView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentTextView.prototype.events = function () {
        return {
            dblclick: 'onActive',
            input: 'onInput',
        };
    };
    ComponentTextView.prototype.initialize = function (props) {
        _super.prototype.initialize.call(this, props);
        (0,index_all.bindAll)(this, 'disableEditing', 'onDisable');
        var model = this.model;
        var em = this.em;
        this.listenTo(model, 'focus', this.onActive);
        this.listenTo(model, 'change:content', this.updateContentText);
        this.listenTo(model, 'sync:content', this.syncContent);
        this.rte = em === null || em === void 0 ? void 0 : em.RichTextEditor;
    };
    ComponentTextView.prototype.updateContentText = function (m, v, opts) {
        if (opts === void 0) { opts = {}; }
        !opts.fromDisable && this.disableEditing();
    };
    ComponentTextView.prototype.canActivate = function () {
        var _a = this, model = _a.model, rteEnabled = _a.rteEnabled, em = _a.em;
        var modelInEdit = em === null || em === void 0 ? void 0 : em.getEditing();
        var sameInEdit = modelInEdit === model;
        var result = true;
        var isInnerText = false;
        var delegate;
        if (rteEnabled || !model.get('editable') || sameInEdit || (isInnerText = model.isChildOf('text'))) {
            result = false;
            // If the current is inner text, select the closest text
            if (isInnerText && !model.get('textable')) {
                var parent_1 = model.parent();
                while (parent_1 && !parent_1.isInstanceOf('text')) {
                    parent_1 = parent_1.parent();
                }
                if (parent_1 && parent_1.get('editable')) {
                    delegate = parent_1;
                }
                else {
                    result = true;
                }
            }
        }
        return { result: result, delegate: delegate };
    };
    /**
     * Enable element content editing
     * @private
     * */
    ComponentTextView.prototype.onActive = function (ev) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var _c, rte, em, _d, result, delegate, _e, _f, err_1;
            return __generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        _c = this, rte = _c.rte, em = _c.em;
                        _d = this.canActivate(), result = _d.result, delegate = _d.delegate;
                        // We place this before stopPropagation in case of nested
                        // text components will not block the editing (#1394)
                        if (!result) {
                            if (delegate) {
                                (_a = ev === null || ev === void 0 ? void 0 : ev.stopPropagation) === null || _a === void 0 ? void 0 : _a.call(ev);
                                em.setSelected(delegate);
                                delegate.trigger('active', ev);
                            }
                            return [2 /*return*/];
                        }
                        (_b = ev === null || ev === void 0 ? void 0 : ev.stopPropagation) === null || _b === void 0 ? void 0 : _b.call(ev);
                        _e = this;
                        return [4 /*yield*/, this.getContent()];
                    case 1:
                        _e.lastContent = _g.sent();
                        if (!rte) return [3 /*break*/, 5];
                        _g.label = 2;
                    case 2:
                        _g.trys.push([2, 4, , 5]);
                        _f = this;
                        return [4 /*yield*/, rte.enable(this, this.activeRte, { event: ev })];
                    case 3:
                        _f.activeRte = _g.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _g.sent();
                        em.logError(err_1);
                        return [3 /*break*/, 5];
                    case 5:
                        this.toggleEvents(true);
                        return [2 /*return*/];
                }
            });
        });
    };
    ComponentTextView.prototype.onDisable = function (opts) {
        this.disableEditing(opts);
    };
    /**
     * Disable element content editing
     * @private
     * */
    ComponentTextView.prototype.disableEditing = function (opts) {
        if (opts === void 0) { opts = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, model, rte, activeRte, em, editable, err_2, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this, model = _a.model, rte = _a.rte, activeRte = _a.activeRte, em = _a.em;
                        editable = model && model.get('editable');
                        if (!rte) return [3 /*break*/, 8];
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, rte.disable(this, activeRte, opts)];
                    case 2:
                        _c.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_2 = _c.sent();
                        em.logError(err_2);
                        return [3 /*break*/, 4];
                    case 4:
                        _b = editable;
                        if (!_b) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.getContent()];
                    case 5:
                        _b = (_c.sent()) !== this.lastContent;
                        _c.label = 6;
                    case 6:
                        if (!_b) return [3 /*break*/, 8];
                        return [4 /*yield*/, this.syncContent(opts)];
                    case 7:
                        _c.sent();
                        this.lastContent = '';
                        _c.label = 8;
                    case 8:
                        this.toggleEvents();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * get content from RTE
     * @return string
     */
    ComponentTextView.prototype.getContent = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, rte, activeRte, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, rte = _a.rte, activeRte = _a.activeRte;
                        result = '';
                        if (!rte) return [3 /*break*/, 2];
                        return [4 /*yield*/, rte.getContent(this, activeRte)];
                    case 1:
                        result = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Merge content from the DOM to the model
     */
    ComponentTextView.prototype.syncContent = function (opts) {
        if (opts === void 0) { opts = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, model, rte, rteEnabled, content, comps, contentOpt;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this, model = _a.model, rte = _a.rte, rteEnabled = _a.rteEnabled;
                        if (!rteEnabled && !opts.force)
                            return [2 /*return*/];
                        return [4 /*yield*/, this.getContent()];
                    case 1:
                        content = _b.sent();
                        comps = model.components();
                        contentOpt = ComponentTextView_assign({ fromDisable: 1 }, opts);
                        model.set('content', '', contentOpt);
                        // If there is a custom RTE the content is just added staticly
                        // inside 'content'
                        if ((rte === null || rte === void 0 ? void 0 : rte.customRte) && !rte.customRte.parseContent) {
                            comps.length &&
                                comps.reset(undefined, ComponentTextView_assign(ComponentTextView_assign({}, opts), { 
                                    // @ts-ignore
                                    keepIds: getComponentIds(comps) }));
                            model.set('content', content, contentOpt);
                        }
                        else {
                            comps.resetFromString(content, opts);
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    ComponentTextView.prototype.insertComponent = function (content, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = this, model = _b.model, el = _b.el;
        var doc = el.ownerDocument;
        var selection = doc.getSelection();
        if (selection === null || selection === void 0 ? void 0 : selection.rangeCount) {
            var range = selection.getRangeAt(0);
            var textNode = range.startContainer;
            var offset_1 = range.startOffset;
            var textModel_1 = (0,mixins.getComponentModel)(textNode);
            var newCmps_1 = [];
            if (textModel_1 && ((_a = textModel_1.is) === null || _a === void 0 ? void 0 : _a.call(textModel_1, 'textnode'))) {
                var cmps = textModel_1.collection;
                cmps.forEach(function (cmp) {
                    if (cmp === textModel_1) {
                        var type = 'textnode';
                        var cnt = cmp.content;
                        newCmps_1.push({ type: type, content: cnt.slice(0, offset_1) });
                        newCmps_1.push(content);
                        newCmps_1.push({ type: type, content: cnt.slice(offset_1) });
                    }
                    else {
                        newCmps_1.push(cmp);
                    }
                });
                var result = newCmps_1.filter(Boolean);
                var index = result.indexOf(content);
                cmps.reset(result, opts);
                return cmps.at(index);
            }
        }
        return model.append(content, opts);
    };
    /**
     * Callback on input event
     * @param  {Event} e
     */
    ComponentTextView.prototype.onInput = function () {
        var em = this.em;
        var evPfx = 'component';
        var ev = ["".concat(evPfx, ":update"), "".concat(evPfx, ":input")].join(' ');
        // Update toolbars
        em && em.trigger(ev, this.model);
    };
    /**
     * Isolate disable propagation method
     * @param {Event}
     * @private
     * */
    ComponentTextView.prototype.disablePropagation = function (e) {
        e.stopPropagation();
    };
    /**
     * Enable/Disable events
     * @param {Boolean} enable
     */
    ComponentTextView.prototype.toggleEvents = function (enable) {
        var _a = this, em = _a.em, model = _a.model, $el = _a.$el;
        var mixins = { on: dom.on, off: dom/* off */.S1 };
        var method = enable ? 'on' : 'off';
        em.setEditing(enable ? this : false);
        this.rteEnabled = !!enable;
        // The ownerDocument is from the frame
        var elDocs = [this.el.ownerDocument, document];
        mixins.off(elDocs, 'mousedown', this.onDisable);
        mixins[method](elDocs, 'mousedown', this.onDisable);
        em[method]('toolbar:run:before', this.onDisable);
        if (model) {
            model[method]('removed', this.onDisable);
            model.trigger("rte:".concat(enable ? 'enable' : 'disable'));
        }
        // @ts-ignore Avoid closing edit mode on component click
        $el === null || $el === void 0 ? void 0 : $el.off('mousedown', this.disablePropagation);
        // @ts-ignore
        $el && $el[method]('mousedown', this.disablePropagation);
        // Fixes #2210 but use this also as a replacement
        // of this fix: bd7b804f3b46eb45b4398304b2345ce870f232d2
        if (this.config.draggableComponents) {
            var el = this.el;
            while (el) {
                el.draggable = enable ? !1 : !0;
                // Note: el.parentNode is sometimes null here
                el = el.parentNode;
                if (el && el.tagName == 'BODY') {
                    // @ts-ignore
                    el = 0;
                }
            }
        }
    };
    return ComponentTextView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTextView = (ComponentTextView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentLinkView.ts
var ComponentLinkView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentLinkView = /** @class */ (function (_super) {
    ComponentLinkView_extends(ComponentLinkView, _super);
    function ComponentLinkView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentLinkView.prototype.render = function () {
        _super.prototype.render.call(this);
        // I need capturing instead of bubbling as bubbled clicks from other
        // children will execute the link event
        this.el.addEventListener('click', this.prevDef, true);
        return this;
    };
    return ComponentLinkView;
}(view_ComponentTextView));
/* harmony default export */ const view_ComponentLinkView = (ComponentLinkView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentLabelView.ts
var ComponentLabelView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentLabelView = /** @class */ (function (_super) {
    ComponentLabelView_extends(ComponentLabelView, _super);
    function ComponentLabelView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentLabelView;
}(view_ComponentLinkView));
/* harmony default export */ const view_ComponentLabelView = (ComponentLabelView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentMapView.ts
var ComponentMapView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentMapView = /** @class */ (function (_super) {
    ComponentMapView_extends(ComponentMapView, _super);
    function ComponentMapView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentMapView.prototype.tagName = function () {
        return 'div';
    };
    ComponentMapView.prototype.events = function () {
        return {};
    };
    ComponentMapView.prototype.initialize = function (props) {
        _super.prototype.initialize.call(this, props);
        this.classEmpty = this.ppfx + 'plh-map';
    };
    /**
     * Update the map on the canvas
     * @private
     */
    ComponentMapView.prototype.updateSrc = function () {
        this.getIframe().src = this.model.get('src');
    };
    ComponentMapView.prototype.getIframe = function () {
        if (!this.iframe) {
            var ifrm = document.createElement('iframe');
            ifrm.src = this.model.get('src');
            ifrm.frameBorder = '0';
            ifrm.style.height = '100%';
            ifrm.style.width = '100%';
            ifrm.className = this.ppfx + 'no-pointer';
            this.iframe = ifrm;
        }
        return this.iframe;
    };
    ComponentMapView.prototype.render = function () {
        _super.prototype.render.call(this);
        this.updateClasses();
        this.el.appendChild(this.getIframe());
        return this;
    };
    return ComponentMapView;
}(view_ComponentImageView));
/* harmony default export */ const view_ComponentMapView = (ComponentMapView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentScriptView.ts
var ComponentScriptView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentScriptView = /** @class */ (function (_super) {
    ComponentScriptView_extends(ComponentScriptView, _super);
    function ComponentScriptView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentScriptView.prototype.tagName = function () {
        return 'script';
    };
    ComponentScriptView.prototype.events = function () {
        return {};
    };
    return ComponentScriptView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentScriptView = (ComponentScriptView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentSvgView.ts
var ComponentSvgView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentSvgView = /** @class */ (function (_super) {
    ComponentSvgView_extends(ComponentSvgView, _super);
    function ComponentSvgView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentSvgView.prototype._createElement = function (tagName) {
        return document.createElementNS('http://www.w3.org/2000/svg', tagName);
    };
    return ComponentSvgView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentSvgView = (ComponentSvgView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableBodyView.ts
var ComponentTableBodyView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTableBodyView = /** @class */ (function (_super) {
    ComponentTableBodyView_extends(ComponentTableBodyView, _super);
    function ComponentTableBodyView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentTableBodyView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTableBodyView = (ComponentTableBodyView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableCellView.ts
var ComponentTableCellView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTableCellView = /** @class */ (function (_super) {
    ComponentTableCellView_extends(ComponentTableCellView, _super);
    function ComponentTableCellView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentTableCellView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTableCellView = (ComponentTableCellView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableFootView.ts
var ComponentTableFootView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTableFootView = /** @class */ (function (_super) {
    ComponentTableFootView_extends(ComponentTableFootView, _super);
    function ComponentTableFootView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentTableFootView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTableFootView = (ComponentTableFootView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableHeadView.ts
var ComponentTableHeadView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTableHeadView = /** @class */ (function (_super) {
    ComponentTableHeadView_extends(ComponentTableHeadView, _super);
    function ComponentTableHeadView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentTableHeadView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTableHeadView = (ComponentTableHeadView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableRowView.ts
var ComponentTableRowView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentTableRowView = /** @class */ (function (_super) {
    ComponentTableRowView_extends(ComponentTableRowView, _super);
    function ComponentTableRowView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ComponentTableRowView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentTableRowView = (ComponentTableRowView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentTableView.ts

/* harmony default export */ const ComponentTableView = (view_ComponentView.extend({
    events: {},
}));

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentVideoView.ts
var ComponentVideoView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var ComponentVideoView = /** @class */ (function (_super) {
    ComponentVideoView_extends(ComponentVideoView, _super);
    function ComponentVideoView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentVideoView.prototype.tagName = function () {
        return 'div';
    };
    // @ts-ignore
    ComponentVideoView.prototype.events = function () {
        return {};
    };
    ComponentVideoView.prototype.initialize = function () {
        // @ts-ignore
        view_ComponentView.prototype.initialize.apply(this, arguments);
        var model = this.model;
        var props = ['loop', 'autoplay', 'controls', 'color', 'rel', 'modestbranding', 'poster'];
        var events = props.map(function (p) { return "change:".concat(p); }).join(' ');
        this.listenTo(model, 'change:provider', this.updateProvider);
        this.listenTo(model, 'change:src', this.updateSrc);
        this.listenTo(model, events, this.updateVideo);
    };
    /**
     * Rerender on update of the provider
     * @private
     */
    ComponentVideoView.prototype.updateProvider = function () {
        var prov = this.model.get('provider');
        this.el.innerHTML = '';
        this.el.appendChild(this.renderByProvider(prov));
    };
    /**
     * Update the source of the video
     * @private
     */
    ComponentVideoView.prototype.updateSrc = function () {
        var _a = this, model = _a.model, videoEl = _a.videoEl;
        if (!videoEl)
            return;
        var prov = model.get('provider');
        var src = model.get('src');
        switch (prov) {
            case 'yt':
                src = model.getYoutubeSrc();
                break;
            case 'ytnc':
                src = model.getYoutubeNoCookieSrc();
                break;
            case 'vi':
                src = model.getVimeoSrc();
                break;
        }
        videoEl.src = src;
    };
    /**
     * Update video parameters
     * @private
     */
    ComponentVideoView.prototype.updateVideo = function () {
        var _a = this, model = _a.model, videoEl = _a.videoEl;
        var prov = model.get('provider');
        switch (prov) {
            case 'yt':
            case 'ytnc':
            case 'vi':
                model.trigger('change:videoId');
                break;
            default: {
                if (videoEl) {
                    var el = videoEl;
                    el.loop = model.get('loop');
                    el.autoplay = model.get('autoplay');
                    el.controls = model.get('controls');
                    el.poster = model.get('poster');
                }
            }
        }
    };
    ComponentVideoView.prototype.renderByProvider = function (prov) {
        var videoEl;
        switch (prov) {
            case 'yt':
                videoEl = this.renderYoutube();
                break;
            case 'ytnc':
                videoEl = this.renderYoutubeNoCookie();
                break;
            case 'vi':
                videoEl = this.renderVimeo();
                break;
            default:
                videoEl = this.renderSource();
        }
        this.videoEl = videoEl;
        return videoEl;
    };
    ComponentVideoView.prototype.renderSource = function () {
        var el = document.createElement('video');
        el.src = this.model.get('src');
        this.initVideoEl(el);
        return el;
    };
    ComponentVideoView.prototype.renderYoutube = function () {
        var el = document.createElement('iframe');
        el.src = this.model.getYoutubeSrc();
        el.frameBorder = '0';
        el.setAttribute('allowfullscreen', 'true');
        this.initVideoEl(el);
        return el;
    };
    ComponentVideoView.prototype.renderYoutubeNoCookie = function () {
        var el = document.createElement('iframe');
        el.src = this.model.getYoutubeNoCookieSrc();
        el.frameBorder = '0';
        el.setAttribute('allowfullscreen', 'true');
        this.initVideoEl(el);
        return el;
    };
    ComponentVideoView.prototype.renderVimeo = function () {
        var el = document.createElement('iframe');
        el.src = this.model.getVimeoSrc();
        el.frameBorder = '0';
        el.setAttribute('allowfullscreen', 'true');
        this.initVideoEl(el);
        return el;
    };
    ComponentVideoView.prototype.initVideoEl = function (el) {
        el.className = this.ppfx + 'no-pointer';
        el.style.height = '100%';
        el.style.width = '100%';
    };
    ComponentVideoView.prototype.render = function () {
        view_ComponentView.prototype.render.apply(this);
        this.updateClasses();
        var prov = this.model.get('provider');
        this.el.appendChild(this.renderByProvider(prov));
        this.updateVideo();
        return this;
    };
    return ComponentVideoView;
}(view_ComponentImageView));
/* harmony default export */ const view_ComponentVideoView = (ComponentVideoView);

;// CONCATENATED MODULE: ./src/dom_components/view/ComponentWrapperView.ts
var ComponentWrapperView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ComponentWrapperView = /** @class */ (function (_super) {
    ComponentWrapperView_extends(ComponentWrapperView, _super);
    function ComponentWrapperView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ComponentWrapperView.prototype.tagName = function () {
        return 'div';
    };
    return ComponentWrapperView;
}(view_ComponentView));
/* harmony default export */ const view_ComponentWrapperView = (ComponentWrapperView);

;// CONCATENATED MODULE: ./src/dom_components/index.ts
var dom_components_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var dom_components_assign = (undefined && undefined.__assign) || function () {
    dom_components_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return dom_components_assign.apply(this, arguments);
};
var dom_components_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
/**
 * With this module is possible to manage components inside the canvas. You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/dom_components/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  domComponents: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('component:create', () => { ... });
 *
 * // Use the API
 * const cmp = editor.Components;
 * cmp.addType(...);
 * ```
 *
 * ## Available Events
 * * `component:create` - Component is created (only the model, is not yet mounted in the canvas), called after the init() method
 * * `component:mount` - Component is mounted to an element and rendered in canvas
 * * `component:add` - Triggered when a new component is added to the editor, the model is passed as an argument to the callback
 * * `component:remove` - Triggered when a component is removed, the model is passed as an argument to the callback
 * * `component:remove:before` - Triggered before the remove of the component, the model, remove function (if aborted via options, with this function you can complete the remove) and options (use options.abort = true to prevent remove), are passed as arguments to the callback
 * * `component:clone` - Triggered when a component is cloned, the new model is passed as an argument to the callback
 * * `component:update` - Triggered when a component is updated (moved, styled, etc.), the model is passed as an argument to the callback
 * * `component:update:{propertyName}` - Listen any property change, the model is passed as an argument to the callback
 * * `component:styleUpdate` - Triggered when the style of the component is updated, the model is passed as an argument to the callback
 * * `component:styleUpdate:{propertyName}` - Listen for a specific style property change, the model is passed as an argument to the callback
 * * `component:selected` - New component selected, the selected model is passed as an argument to the callback
 * * `component:deselected` - Component deselected, the deselected model is passed as an argument to the callback
 * * `component:toggled` - Component selection changed, toggled model is passed as an argument to the callback
 * * `component:type:add` - New component type added, the new type is passed as an argument to the callback
 * * `component:type:update` - Component type updated, the updated type is passed as an argument to the callback
 * * `component:drag:start` - Component drag started. Passed an object, to the callback, containing the `target` (component to drag), `parent` (parent of the component) and `index` (component index in the parent)
 * * `component:drag` - During component drag. Passed the same object as in `component:drag:start` event, but in this case, `parent` and `index` are updated by the current pointer
 * * `component:drag:end` - Component drag ended. Passed the same object as in `component:drag:start` event, but in this case, `parent` and `index` are updated by the final pointer
 * * `component:resize` - During component resize.
 *
 * ## Methods
 * * [getWrapper](#getwrapper)
 * * [getComponents](#getcomponents)
 * * [addComponent](#addcomponent)
 * * [clear](#clear)
 * * [addType](#addtype)
 * * [getType](#gettype)
 * * [getTypes](#gettypes)
 *
 * * [Component]: component.html
 *
 * @module Components
 */













































/** @private */
var CanMoveReason;
(function (CanMoveReason) {
    /**
     * Invalid source. This is a default value and should be ignored in case the `result` is true
     */
    CanMoveReason[CanMoveReason["InvalidSource"] = 0] = "InvalidSource";
    /**
     * Source doesn't accept target as destination.
     */
    CanMoveReason[CanMoveReason["SourceReject"] = 1] = "SourceReject";
    /**
     * Target doesn't accept source.
     */
    CanMoveReason[CanMoveReason["TargetReject"] = 2] = "TargetReject";
})(CanMoveReason || (CanMoveReason = {}));
var ComponentManager = /** @class */ (function (_super) {
    dom_components_extends(ComponentManager, _super);
    /**
     * Initialize module. Called on a new instance of the editor with configurations passed
     * inside 'domComponents' field
     * @param {Object} config Configurations
     * @private
     */
    function ComponentManager(em) {
        var _this = _super.call(this, em, 'DomComponents', new model_Components(undefined, { em: em })) || this;
        _this.componentTypes = [
            {
                id: 'cell',
                model: model_ComponentTableCell,
                view: view_ComponentTableCellView,
            },
            {
                id: 'row',
                model: model_ComponentTableRow,
                view: view_ComponentTableRowView,
            },
            {
                id: 'table',
                model: model_ComponentTable,
                view: ComponentTableView,
            },
            {
                id: 'thead',
                model: model_ComponentTableHead,
                view: view_ComponentTableHeadView,
            },
            {
                id: 'tbody',
                model: model_ComponentTableBody,
                view: view_ComponentTableBodyView,
            },
            {
                id: 'tfoot',
                model: model_ComponentTableFoot,
                view: view_ComponentTableFootView,
            },
            {
                id: 'map',
                model: model_ComponentMap,
                view: view_ComponentMapView,
            },
            {
                id: 'link',
                model: model_ComponentLink,
                view: view_ComponentLinkView,
            },
            {
                id: 'label',
                model: model_ComponentLabel,
                view: view_ComponentLabelView,
            },
            {
                id: 'video',
                model: model_ComponentVideo,
                view: view_ComponentVideoView,
            },
            {
                id: 'image',
                model: model_ComponentImage,
                view: view_ComponentImageView,
            },
            {
                id: 'script',
                model: model_ComponentScript,
                view: view_ComponentScriptView,
            },
            {
                id: 'svg-in',
                model: model_ComponentSvgIn,
                view: view_ComponentSvgView,
            },
            {
                id: 'svg',
                model: model_ComponentSvg,
                view: view_ComponentSvgView,
            },
            {
                id: 'iframe',
                model: model_ComponentFrame,
                view: view_ComponentFrameView,
            },
            {
                id: 'comment',
                model: model_ComponentComment,
                view: view_ComponentCommentView,
            },
            {
                id: 'textnode',
                model: model_ComponentTextNode,
                view: view_ComponentTextNodeView,
            },
            {
                id: 'text',
                model: model_ComponentText,
                view: view_ComponentTextView,
            },
            {
                id: 'wrapper',
                model: model_ComponentWrapper,
                view: view_ComponentWrapperView,
            },
            {
                id: 'default',
                model: model_Component,
                view: view_ComponentView,
            },
        ];
        _this.componentsById = {};
        _this.Component = model_Component;
        _this.Components = model_Components;
        _this.ComponentView = view_ComponentView;
        _this.ComponentsView = view_ComponentsView;
        /**
         * Name of the module
         * @type {String}
         * @private
         */
        //name = "DomComponents";
        _this.storageKey = 'components';
        if (em) {
            //@ts-ignore
            _this.config.components = em.config.components || _this.config.components;
        }
        for (var name in dom_components_config_config) {
            //@ts-ignore
            if (!(name in _this.config))
                _this.config[name] = dom_components_config_config[name];
        }
        var ppfx = _this.config.pStylePrefix;
        if (ppfx)
            _this.config.stylePrefix = ppfx + _this.config.stylePrefix;
        // Load dependencies
        if (em) {
            em.get('Parser').compTypes = _this.componentTypes;
            em.on('change:componentHovered', _this.componentHovered, _this);
            var selected_1 = em.get('selected');
            em.listenTo(selected_1, 'add', function (sel, c, opts) { return _this.selectAdd(selected_1.getComponent(sel), opts); });
            em.listenTo(selected_1, 'remove', function (sel, c, opts) { return _this.selectRemove(selected_1.getComponent(sel), opts); });
        }
        return _this;
    }
    ComponentManager.prototype.load = function (data) {
        var _this = this;
        return this.loadProjectData(data, {
            onResult: function (result) {
                var wrapper = _this.getWrapper();
                if (!wrapper) {
                    _this.em.Pages.add({}, { select: true });
                    wrapper = _this.getWrapper();
                }
                if ((0,index_all.isArray)(result)) {
                    result.length && wrapper.components(result);
                }
                else {
                    var _a = result.components, components = _a === void 0 ? [] : _a, rest = dom_components_rest(result, ["components"]);
                    wrapper.set(rest);
                    //@ts-ignore
                    wrapper.components(components);
                }
            },
        });
    };
    ComponentManager.prototype.store = function () {
        return {};
    };
    /**
     * Returns the main wrapper.
     * @return {Object}
     * @private
     */
    ComponentManager.prototype.getComponent = function () {
        var sel = this.em.Pages.getSelected();
        var frame = sel === null || sel === void 0 ? void 0 : sel.getMainFrame();
        return frame === null || frame === void 0 ? void 0 : frame.getComponent();
    };
    /**
     * Returns root component inside the canvas. Something like `<body>` inside HTML page
     * The wrapper doesn't differ from the original Component Model
     * @return {[Component]} Root Component
     * @example
     * // Change background of the wrapper and set some attribute
     * var wrapper = cmp.getWrapper();
     * wrapper.set('style', {'background-color': 'red'});
     * wrapper.set('attributes', {'title': 'Hello!'});
     */
    ComponentManager.prototype.getWrapper = function () {
        return this.getComponent();
    };
    /**
     * Returns wrapper's children collection. Once you have the collection you can
     * add other Components(Models) inside. Each component can have several nested
     * components inside and you can nest them as more as you wish.
     * @return {Components} Collection of components
     * @example
     * // Let's add some component
     * var wrapperChildren = cmp.getComponents();
     * var comp1 = wrapperChildren.add({
     *   style: { 'background-color': 'red'}
     * });
     * var comp2 = wrapperChildren.add({
     *   tagName: 'span',
     *   attributes: { title: 'Hello!'}
     * });
     * // Now let's add an other one inside first component
     * // First we have to get the collection inside. Each
     * // component has 'components' property
     * var comp1Children = comp1.get('components');
     * // Procede as before. You could also add multiple objects
     * comp1Children.add([
     *   { style: { 'background-color': 'blue'}},
     *   { style: { height: '100px', width: '100px'}}
     * ]);
     * // Remove comp2
     * wrapperChildren.remove(comp2);
     */
    ComponentManager.prototype.getComponents = function () {
        var wrp = this.getWrapper();
        return wrp === null || wrp === void 0 ? void 0 : wrp.components();
    };
    /**
     * Add new components to the wrapper's children. It's the same
     * as 'cmp.getComponents().add(...)'
     * @param {Object|[Component]|Array<Object>} component Component/s to add
     * @param {string} [component.tagName='div'] Tag name
     * @param {string} [component.type=''] Type of the component. Available: ''(default), 'text', 'image'
     * @param {boolean} [component.removable=true] If component is removable
     * @param {boolean} [component.draggable=true] If is possible to move the component around the structure
     * @param {boolean} [component.droppable=true] If is possible to drop inside other components
     * @param {boolean} [component.badgable=true] If the badge is visible when the component is selected
     * @param {boolean} [component.stylable=true] If is possible to style component
     * @param {boolean} [component.copyable=true] If is possible to copy&paste the component
     * @param {string} [component.content=''] String inside component
     * @param {Object} [component.style={}] Style object
     * @param {Object} [component.attributes={}] Attribute object
     * @param {Object} opt the options object to be used by the [Components.add]{@link getComponents} method
     * @return {[Component]|Array<[Component]>} Component/s added
     * @example
     * // Example of a new component with some extra property
     * var comp1 = cmp.addComponent({
     *   tagName: 'div',
     *   removable: true, // Can't remove it
     *   draggable: true, // Can't move it
     *   copyable: true, // Disable copy/past
     *   content: 'Content text', // Text inside component
     *   style: { color: 'red'},
     *   attributes: { title: 'here' }
     * });
     */
    ComponentManager.prototype.addComponent = function (component, opt) {
        if (opt === void 0) { opt = {}; }
        return this.getComponents().add(component, opt);
    };
    /**
     * Render and returns wrapper element with all components inside.
     * Once the wrapper is rendered, and it's what happens when you init the editor,
     * the all new components will be added automatically and property changes are all
     * updated immediately
     * @return {HTMLElement}
     * @private
     */
    ComponentManager.prototype.render = function () {
        var _a;
        return (_a = this.componentView) === null || _a === void 0 ? void 0 : _a.render().el;
    };
    /**
     * Remove all components
     * @return {this}
     */
    ComponentManager.prototype.clear = function (opts) {
        if (opts === void 0) { opts = {}; }
        var components = this.getComponents();
        //@ts-ignore
        components === null || components === void 0 ? void 0 : components.filter(Boolean).forEach(function (i) { return i.remove(opts); });
        return this;
    };
    /**
     * Set components
     * @param {Object|string} components HTML string or components model
     * @param {Object} opt the options object to be used by the {@link addComponent} method
     * @return {this}
     * @private
     */
    ComponentManager.prototype.setComponents = function (components, opt) {
        if (opt === void 0) { opt = {}; }
        this.clear(opt).addComponent(components, opt);
    };
    /**
     * Add new component type.
     * Read more about this in [Define New Component](https://grapesjs.com/docs/modules/Components.html#define-new-component)
     * @param {string} type Component ID
     * @param {Object} methods Component methods
     * @return {this}
     */
    ComponentManager.prototype.addType = function (type, methods) {
        var em = this.em;
        var _a = methods.model, model = _a === void 0 ? {} : _a, _b = methods.view, view = _b === void 0 ? {} : _b, isComponent = methods.isComponent, extend = methods.extend, extendView = methods.extendView, _c = methods.extendFn, extendFn = _c === void 0 ? [] : _c, _d = methods.extendFnView, extendFnView = _d === void 0 ? [] : _d;
        var compType = this.getType(type);
        var extendType = this.getType(extend);
        var extendViewType = this.getType(extendView);
        var typeToExtend = extendType ? extendType : compType ? compType : this.getType('default');
        var modelToExt = typeToExtend.model;
        var viewToExt = extendViewType ? extendViewType.view : typeToExtend.view;
        // Function for extending source object methods
        var getExtendedObj = function (fns, target, srcToExt) {
            return fns.reduce(function (res, next) {
                var fn = target[next];
                var parentFn = srcToExt.prototype[next];
                if (fn && parentFn) {
                    res[next] = function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        parentFn.bind(this).apply(void 0, args);
                        fn.bind(this).apply(void 0, args);
                    };
                }
                return res;
            }, {});
        };
        // If the model/view is a simple object I need to extend it
        if (typeof model === 'object') {
            var modelDefaults_1 = { defaults: model.defaults };
            delete model.defaults;
            methods.model = modelToExt.extend(dom_components_assign(dom_components_assign({}, model), getExtendedObj(extendFn, model, modelToExt)), {
                isComponent: compType && !extendType && !isComponent ? modelToExt.isComponent : isComponent || (function () { return 0; }),
            });
            // Reassign the defaults getter to the model
            Object.defineProperty(methods.model.prototype, 'defaults', {
                get: function () { return (dom_components_assign(dom_components_assign({}, ((0,index_all.result)(modelToExt.prototype, 'defaults') || {})), ((0,index_all.result)(modelDefaults_1, 'defaults') || {}))); },
            });
        }
        if (typeof view === 'object') {
            methods.view = viewToExt.extend(dom_components_assign(dom_components_assign({}, view), getExtendedObj(extendFnView, view, viewToExt)));
        }
        if (compType) {
            compType.model = methods.model;
            compType.view = methods.view;
        }
        else {
            // @ts-ignore
            methods.id = type;
            this.componentTypes.unshift(methods);
        }
        var event = "component:type:".concat(compType ? 'update' : 'add');
        em === null || em === void 0 ? void 0 : em.trigger(event, compType || methods);
        return this;
    };
    ComponentManager.prototype.getType = function (type) {
        var df = this.componentTypes;
        for (var it = 0; it < df.length; it++) {
            var dfId = df[it].id;
            if (dfId == type) {
                return df[it];
            }
        }
        return;
    };
    /**
     * Remove component type
     * @param {string} type Component ID
     * @returns {Object|undefined} Removed component type, undefined otherwise
     */
    ComponentManager.prototype.removeType = function (id) {
        var df = this.componentTypes;
        var type = this.getType(id);
        if (!type)
            return;
        var index = df.indexOf(type);
        df.splice(index, 1);
        return type;
    };
    /**
     * Return the array of all types
     * @return {Array}
     */
    ComponentManager.prototype.getTypes = function () {
        return this.componentTypes;
    };
    ComponentManager.prototype.selectAdd = function (component, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        if (component) {
            component.set({
                status: 'selected',
            });
            ['component:selected', 'component:toggled'].forEach(function (event) { return _this.em.trigger(event, component, opts); });
        }
    };
    ComponentManager.prototype.selectRemove = function (component, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        if (component) {
            var em = this.em;
            component.set({
                status: '',
                state: '',
            });
            ['component:deselected', 'component:toggled'].forEach(function (event) { return _this.em.trigger(event, component, opts); });
        }
    };
    /**
     * Triggered when the component is hovered
     * @private
     */
    ComponentManager.prototype.componentHovered = function () {
        var em = this.em;
        var model = em.get('componentHovered');
        var previous = em.previous('componentHovered');
        var state = 'hovered';
        // Deselect the previous component
        previous &&
            previous.get('status') == state &&
            previous.set({
                status: '',
                state: '',
            });
        model && (0,index_all.isEmpty)(model.get('status')) && model.set('status', state);
    };
    ComponentManager.prototype.getShallowWrapper = function () {
        var _a = this, shallow = _a.shallow, em = _a.em;
        if (!shallow && em) {
            var shallowEm = em.shallow;
            if (!shallowEm)
                return;
            var domc = shallowEm.Components;
            domc.componentTypes = this.componentTypes;
            shallow = domc.getWrapper();
            if (shallow) {
                var events = [keyUpdate, keyUpdateInside].join(' ');
                shallow.on(events, (0,index_all.debounce)(function () { return shallow === null || shallow === void 0 ? void 0 : shallow.components(''); }, 100));
            }
            this.shallow = shallow;
        }
        return shallow;
    };
    /**
     * Check if the object is a [Component].
     * @param {Object} obj
     * @returns {Boolean}
     * @example
     * cmp.isComponent(editor.getSelected()); // true
     * cmp.isComponent({}); // false
     */
    ComponentManager.prototype.isComponent = function (obj) {
        return (0,mixins.isComponent)(obj);
    };
    /**
     * Check if a component can be moved inside another one.
     * @param {[Component]} target The target component is the one that is supposed to receive the source one.
     * @param {[Component]|String} source The source can be another component, a component definition or an HTML string.
     * @param {Number} [index] Index position, if not specified, the check will be performed against appending the source to the target.
     * @returns {Object} Object containing the `result` (Boolean), `source`, `target` (as Components), and a `reason` (Number) with these meanings:
     * * `0` - Invalid source. This is a default value and should be ignored in case the `result` is true.
     * * `1` - Source doesn't accept target as destination.
     * * `2` - Target doesn't accept source.
     * @example
     * const rootComponent = editor.getWrapper();
     * const someComponent = editor.getSelected();
     *
     * // Check with two components
     * editor.Components.canMove(rootComponent, someComponent);
     *
     * // Check with component definition
     * editor.Components.canMove(rootComponent, { tagName: 'a', draggable: false });
     *
     * // Check with HTML string
     * editor.Components.canMove(rootComponent, '<form>...</form>');
     */
    ComponentManager.prototype.canMove = function (target, source, index) {
        var result = {
            result: false,
            reason: CanMoveReason.InvalidSource,
            target: target,
            source: null,
        };
        if (!source || !target)
            return result;
        var srcModel = (0,mixins.isComponent)(source) ? source : null;
        if (!srcModel) {
            var wrapper = this.getShallowWrapper();
            srcModel = (wrapper === null || wrapper === void 0 ? void 0 : wrapper.append(source)[0]) || null;
        }
        result.source = srcModel;
        if (!srcModel)
            return result;
        // Check if the source is draggable in the target
        var draggable = srcModel.get('draggable');
        if ((0,index_all.isFunction)(draggable)) {
            draggable = !!draggable(srcModel, target, index);
        }
        else {
            var el = target.getEl();
            draggable = (0,index_all.isArray)(draggable) ? draggable.join(',') : draggable;
            draggable = (0,index_all.isString)(draggable) ? el === null || el === void 0 ? void 0 : el.matches(draggable) : draggable;
        }
        if (!draggable)
            return dom_components_assign(dom_components_assign({}, result), { reason: CanMoveReason.SourceReject });
        // Check if the target accepts the source
        var droppable = target.get('droppable');
        if ((0,index_all.isFunction)(droppable)) {
            droppable = !!droppable(srcModel, target, index);
        }
        else {
            if (droppable === false && target.isInstanceOf('text') && srcModel.get('textable')) {
                droppable = true;
            }
            else {
                var el = srcModel.getEl();
                droppable = (0,index_all.isArray)(droppable) ? droppable.join(',') : droppable;
                droppable = (0,index_all.isString)(droppable) ? el === null || el === void 0 ? void 0 : el.matches(droppable) : droppable;
            }
        }
        // Ensure the target is not inside the source
        var isTargetInside = [target].concat(target.parents()).indexOf(srcModel) > -1;
        if (!droppable || isTargetInside)
            return dom_components_assign(dom_components_assign({}, result), { reason: CanMoveReason.TargetReject });
        return dom_components_assign(dom_components_assign({}, result), { result: true });
    };
    ComponentManager.prototype.allById = function () {
        return this.componentsById;
    };
    ComponentManager.prototype.getById = function (id) {
        return this.componentsById[id] || null;
    };
    ComponentManager.prototype.destroy = function () {
        var _a;
        var all = this.allById();
        Object.keys(all).forEach(function (id) { return all[id] && all[id].remove(); });
        (_a = this.componentView) === null || _a === void 0 ? void 0 : _a.remove();
        [this.em, this.componentsById, this.componentView].forEach(function (i) { return (i = {}); });
    };
    return ComponentManager;
}(ItemManagerModule));
/* harmony default export */ const dom_components = (ComponentManager);

;// CONCATENATED MODULE: ./src/css_composer/config/config.ts
var css_composer_config_config_config = {
    stylePrefix: 'css-',
    rules: [],
};
/* harmony default export */ const css_composer_config_config = (css_composer_config_config_config);

;// CONCATENATED MODULE: ./src/code_manager/model/CssGenerator.ts
var CssGenerator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var maxValue = Number.MAX_VALUE;
var getMediaLength = function (mediaQuery) {
    var length = /(-?\d*\.?\d+)\w{0,}/.exec(mediaQuery);
    return !length ? '' : length[0];
};
var CssGenerator = /** @class */ (function (_super) {
    CssGenerator_extends(CssGenerator, _super);
    function CssGenerator() {
        var _this = _super.call(this) || this;
        (0,index_all.bindAll)(_this, 'sortRules');
        _this.compCls = [];
        _this.ids = [];
        return _this;
    }
    /**
     * Get CSS from a component
     * @param {Model} model
     * @return {String}
     */
    CssGenerator.prototype.buildFromModel = function (model, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var code = '';
        var em = this.em;
        var avoidInline = em && em.getConfig().avoidInlineStyle;
        var style = model.styleToString();
        var classes = model.classes;
        this.ids.push("#".concat(model.getId()));
        // Let's know what classes I've found
        classes.forEach(function (model) { return _this.compCls.push(model.getFullName()); });
        if (!avoidInline && style) {
            code = "#".concat(model.getId(), "{").concat(style, "}");
        }
        var components = model.components();
        components.forEach(function (model) { return (code += _this.buildFromModel(model, opts)); });
        return code;
    };
    CssGenerator.prototype.build = function (model, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var json = opts.json;
        var em = opts.em;
        var cssc = opts.cssc || (em === null || em === void 0 ? void 0 : em.Css);
        this.em = em;
        this.compCls = [];
        this.ids = [];
        this.model = model;
        var codeJson = [];
        var code = model ? this.buildFromModel(model, opts) : '';
        var clearStyles = (0,index_all.isUndefined)(opts.clearStyles) && em ? em.getConfig().clearStyles : opts.clearStyles;
        if (cssc) {
            var rules = opts.rules || cssc.getAll();
            var atRules_1 = {};
            var dump_1 = [];
            if (opts.onlyMatched && model && (0,mixins.hasWin)()) {
                rules = this.matchedRules(model, rules);
            }
            rules.forEach(function (rule) {
                var atRule = rule.getAtRule();
                if (atRule) {
                    var mRules = atRules_1[atRule];
                    if (mRules) {
                        mRules.push(rule);
                    }
                    else {
                        atRules_1[atRule] = [rule];
                    }
                    return;
                }
                var res = _this.buildFromRule(rule, dump_1, opts);
                if (json) {
                    codeJson.push(res);
                }
                else {
                    code += res;
                }
            });
            this.sortMediaObject(atRules_1).forEach(function (item) {
                var rulesStr = '';
                var atRule = item.key;
                var mRules = item.value;
                mRules.forEach(function (rule) {
                    var ruleStr = _this.buildFromRule(rule, dump_1, opts);
                    if (rule.get('singleAtRule')) {
                        code += "".concat(atRule, "{").concat(ruleStr, "}");
                    }
                    else {
                        rulesStr += ruleStr;
                    }
                    json && codeJson.push(ruleStr);
                });
                if (rulesStr) {
                    code += "".concat(atRule, "{").concat(rulesStr, "}");
                }
            });
            // @ts-ignore
            em && clearStyles && rules.remove && rules.remove(dump_1);
        }
        return json ? codeJson.filter(function (r) { return r; }) : code;
    };
    /**
     * Get CSS from the rule model
     * @param {Model} rule
     * @return {string} CSS string
     */
    CssGenerator.prototype.buildFromRule = function (rule, dump, opts) {
        var _this = this;
        var _a;
        if (opts === void 0) { opts = {}; }
        var result = '';
        var model = this.model;
        var selectorStrNoAdd = rule.selectorsToString({ skipAdd: 1 });
        var selectorsAdd = rule.get('selectorsAdd');
        var singleAtRule = rule.get('singleAtRule');
        var found;
        // This will not render a rule if there is no its component
        (_a = rule.get('selectors')) === null || _a === void 0 ? void 0 : _a.forEach(function (selector) {
            var name = selector.getFullName();
            if (_this.compCls.indexOf(name) >= 0 || _this.ids.indexOf(name) >= 0 || opts.keepUnusedStyles) {
                found = 1;
            }
        });
        if ((selectorStrNoAdd && found) || selectorsAdd || singleAtRule || !model) {
            var block = rule.getDeclaration({ body: 1 });
            block && (opts.json ? (result = rule) : (result += block));
        }
        else {
            dump.push(rule);
        }
        return result;
    };
    /**
     * Get matched rules of a component
     * @param {Component} component
     * @param {Array<CSSRule>} rules
     * @returns {Array<CSSRule>}
     */
    CssGenerator.prototype.matchedRules = function (component, rules) {
        var _this = this;
        var el = component.getEl();
        var result = [];
        rules.forEach(function (rule) {
            try {
                if (rule
                    .selectorsToString()
                    .split(',')
                    .some(function (selector) { return el === null || el === void 0 ? void 0 : el.matches(_this.__cleanSelector(selector)); })) {
                    result.push(rule);
                }
            }
            catch (err) { }
        });
        component.components().forEach(function (component) {
            result = result.concat(_this.matchedRules(component, rules));
        });
        // Remove duplicates
        result = result.filter(function (rule, i) { return result.indexOf(rule) === i; });
        return result;
    };
    /**
     * Get the numeric length of the media query string
     * @param  {String} mediaQuery Media query string
     * @return {Number}
     */
    CssGenerator.prototype.getQueryLength = function (mediaQuery) {
        var length = /(-?\d*\.?\d+)\w{0,}/.exec(mediaQuery);
        if (!length)
            return maxValue;
        return parseFloat(length[1]);
    };
    /**
     * Return a sorted array from media query object
     * @param  {Object} items
     * @return {Array}
     */
    CssGenerator.prototype.sortMediaObject = function (items) {
        var _this = this;
        if (items === void 0) { items = {}; }
        var itemsArr = [];
        (0,index_all.each)(items, function (value, key) { return itemsArr.push({ key: key, value: value }); });
        return itemsArr.sort(function (a, b) {
            var isMobFirst = [a.key, b.key].every(function (mquery) { return mquery.indexOf('min-width') !== -1; });
            var left = isMobFirst ? a.key : b.key;
            var right = isMobFirst ? b.key : a.key;
            return _this.getQueryLength(left) - _this.getQueryLength(right);
        });
    };
    CssGenerator.prototype.sortRules = function (a, b) {
        var getKey = function (rule) { return rule.get('mediaText') || ''; };
        var isMobFirst = [getKey(a), getKey(b)].every(function (q) { return q.indexOf('min-width') !== -1; });
        var left = isMobFirst ? getKey(a) : getKey(b);
        var right = isMobFirst ? getKey(b) : getKey(a);
        return this.getQueryLength(left) - this.getQueryLength(right);
    };
    /**
     * Return passed selector without states
     * @param {String} selector
     * @returns {String}
     * @private
     */
    CssGenerator.prototype.__cleanSelector = function (selector) {
        return selector
            .split(' ')
            .map(function (item) { return item.split(':')[0]; })
            .join(' ');
    };
    return CssGenerator;
}(common/* Model */.Hn));
/* harmony default export */ const model_CssGenerator = (CssGenerator);

;// CONCATENATED MODULE: ./src/css_composer/model/CssRule.ts
var CssRule_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CssRule_assign = (undefined && undefined.__assign) || function () {
    CssRule_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return CssRule_assign.apply(this, arguments);
};
var CssRule_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};






// @ts-ignore
var CSS = ((0,mixins.hasWin)() ? window : {}).CSS;
/**
 * @typedef CssRule
 * @property {Array<Selector>} selectors Array of selectors
 * @property {Object} style Object containing style definitions
 * @property {String} [selectorsAdd=''] Additional string css selectors
 * @property {String} [atRuleType=''] Type of at-rule, eg. `media`, 'font-face'
 * @property {String} [mediaText=''] At-rule value, eg. `(max-width: 1000px)`
 * @property {Boolean} [singleAtRule=false] This property is used only on at-rules, like 'page' or 'font-face', where the block containes only style declarations
 * @property {String} [state=''] State of the rule, eg: `hover`, `focused`
 * @property {Boolean|Array<String>} [important=false] If true, sets `!important` on all properties. You can also pass an array to specify properties on which use important
 * @property {Boolean} [stylable=true] Indicates if the rule is stylable from the editor
 *
 * [Device]: device.html
 * [State]: state.html
 * [Component]: component.html
 */
var CssRule = /** @class */ (function (_super) {
    CssRule_extends(CssRule, _super);
    function CssRule(props, opt) {
        if (opt === void 0) { opt = {}; }
        var _this = _super.call(this, props) || this;
        _this.config = props || {};
        _this.opt = opt;
        _this.em = opt.em;
        _this.ensureSelectors(null, null, {});
        _this.on('change', _this.__onChange);
        return _this;
    }
    CssRule.prototype.defaults = function () {
        return {
            selectors: [],
            selectorsAdd: '',
            style: {},
            mediaText: '',
            state: '',
            stylable: true,
            atRuleType: '',
            singleAtRule: false,
            important: false,
            group: '',
            shallow: false,
            _undo: true,
        };
    };
    CssRule.prototype.__onChange = function (m, opts) {
        var em = this.em;
        var changed = this.changedAttributes();
        changed && !(0,mixins.isEmptyObj)(changed) && (em === null || em === void 0 ? void 0 : em.changesUp(opts));
    };
    CssRule.prototype.clone = function () {
        var opts = CssRule_assign({}, this.opt);
        var attr = CssRule_assign({}, this.attributes);
        attr.selectors = this.get('selectors').map(function (s) { return s.clone(); });
        // @ts-ignore
        return new this.constructor(attr, opts);
    };
    CssRule.prototype.ensureSelectors = function (m, c, opts) {
        var em = this.em;
        var sm = em === null || em === void 0 ? void 0 : em.get('SelectorManager');
        var toListen = [this, 'change:selectors', this.ensureSelectors];
        var sels = this.getSelectors();
        this.stopListening.apply(this, toListen);
        if (sels.models) {
            sels = CssRule_spreadArray([], sels.models, true);
        }
        sels = (0,index_all.isString)(sels) ? [sels] : sels;
        if (Array.isArray(sels)) {
            var res = sels.filter(function (i) { return i; }).map(function (i) { return (sm ? sm.add(i) : i); });
            sels = new model_Selectors(res);
        }
        this.set('selectors', sels, opts);
        // @ts-ignore
        this.listenTo.apply(this, toListen);
    };
    /**
     * Returns the at-rule statement when exists, eg. `@media (...)`, `@keyframes`
     * @returns {String}
     * @example
     * const cssRule = editor.Css.setRule('.class1', { color: 'red' }, {
     *  atRuleType: 'media',
     *  atRuleParams: '(min-width: 500px)'
     * });
     * cssRule.getAtRule(); // "@media (min-width: 500px)"
     */
    CssRule.prototype.getAtRule = function () {
        var type = this.get('atRuleType');
        var condition = this.get('mediaText');
        // Avoid breaks with the last condition
        var typeStr = type ? "@".concat(type) : condition ? '@media' : '';
        return typeStr + (condition && typeStr ? " ".concat(condition) : '');
    };
    /**
     * Return selectors of the rule as a string
     * @param {Object} [opts] Options
     * @param {Boolean} [opts.skipState] Skip state from the result
     * @returns {String}
     * @example
     * const cssRule = editor.Css.setRule('.class1:hover', { color: 'red' });
     * cssRule.selectorsToString(); // ".class1:hover"
     * cssRule.selectorsToString({ skipState: true }); // ".class1"
     */
    CssRule.prototype.selectorsToString = function (opts) {
        if (opts === void 0) { opts = {}; }
        var result = [];
        var state = this.get('state');
        var addSelector = this.get('selectorsAdd');
        var selOpts = {
            escape: function (str) { return (CSS && CSS.escape ? CSS.escape(str) : str); },
        };
        // @ts-ignore
        var selectors = this.get('selectors').getFullString(0, selOpts);
        var stateStr = state && !opts.skipState ? ":".concat(state) : '';
        selectors && result.push("".concat(selectors).concat(stateStr));
        addSelector && !opts.skipAdd && result.push(addSelector);
        return result.join(', ');
    };
    /**
     * Get declaration block (without the at-rule statement)
     * @param {Object} [opts={}] Options (same as in `selectorsToString`)
     * @returns {String}
     * @example
     * const cssRule = editor.Css.setRule('.class1', { color: 'red' }, {
     *  atRuleType: 'media',
     *  atRuleParams: '(min-width: 500px)'
     * });
     * cssRule.getDeclaration() // ".class1{color:red;}"
     */
    CssRule.prototype.getDeclaration = function (opts) {
        if (opts === void 0) { opts = {}; }
        var result = '';
        var important = this.attributes.important;
        var selectors = this.selectorsToString(opts);
        var style = this.styleToString(CssRule_assign({ important: important }, opts));
        var singleAtRule = this.get('singleAtRule');
        if ((selectors || singleAtRule) && (style || opts.allowEmpty)) {
            result = singleAtRule ? style : "".concat(selectors, "{").concat(style, "}");
        }
        return result;
    };
    /**
     * Get the Device the rule is related to.
     * @returns {[Device]|null}
     * @example
     * const device = rule.getDevice();
     * console.log(device?.getName());
     */
    CssRule.prototype.getDevice = function () {
        var em = this.em;
        var _a = this.attributes, atRuleType = _a.atRuleType, mediaText = _a.mediaText;
        var devices = (em === null || em === void 0 ? void 0 : em.get('DeviceManager').getDevices()) || [];
        var deviceDefault = devices.filter(function (d) { return d.getWidthMedia() === ''; })[0];
        if (atRuleType !== 'media' || !mediaText) {
            return deviceDefault || null;
        }
        return devices.filter(function (d) { return d.getWidthMedia() === getMediaLength(mediaText); })[0] || null;
    };
    /**
     * Get the State the rule is related to.
     * @returns {[State]|null}
     * @example
     * const state = rule.getState();
     * console.log(state?.getLabel());
     */
    CssRule.prototype.getState = function () {
        var em = this.em;
        var stateValue = this.get('state');
        var states = (em === null || em === void 0 ? void 0 : em.get('SelectorManager').getStates()) || [];
        return states.filter(function (s) { return s.getName() === stateValue; })[0] || null;
    };
    /**
     * Returns the related Component (valid only for component-specific rules).
     * @returns {[Component]|null}
     * @example
     * const cmp = rule.getComponent();
     * console.log(cmp?.toHTML());
     */
    CssRule.prototype.getComponent = function () {
        var _a;
        var sel = this.getSelectors();
        var sngl = sel.length == 1 && sel.at(0);
        var cmpId = sngl && sngl.isId() && sngl.get('name');
        return (cmpId && ((_a = this.em) === null || _a === void 0 ? void 0 : _a.Components.getById(cmpId))) || null;
    };
    /**
     * Return the CSS string of the rule
     * @param {Object} [opts={}] Options (same as in `getDeclaration`)
     * @return {String} CSS string
     * @example
     * const cssRule = editor.Css.setRule('.class1', { color: 'red' }, {
     *  atRuleType: 'media',
     *  atRuleParams: '(min-width: 500px)'
     * });
     * cssRule.toCSS() // "@media (min-width: 500px){.class1{color:red;}}"
     */
    CssRule.prototype.toCSS = function (opts) {
        if (opts === void 0) { opts = {}; }
        var result = '';
        var atRule = this.getAtRule();
        var block = this.getDeclaration(opts);
        if (block || opts.allowEmpty) {
            result = block;
        }
        if (atRule && result) {
            result = "".concat(atRule, "{").concat(result, "}");
        }
        return result;
    };
    CssRule.prototype.toJSON = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var obj = common/* Model */.Hn.prototype.toJSON.apply(this, args);
        if ((_a = this.em) === null || _a === void 0 ? void 0 : _a.getConfig().avoidDefaults) {
            var defaults = this.defaults();
            (0,index_all.forEach)(defaults, function (value, key) {
                if (obj[key] === value) {
                    delete obj[key];
                }
            });
            // Delete the property used for partial updates
            delete obj.style.__p;
            if ((0,index_all.isEmpty)(obj.selectors))
                delete obj.selectors;
            if ((0,index_all.isEmpty)(obj.style))
                delete obj.style;
        }
        return obj;
    };
    /**
     * Compare the actual model with parameters
     * @param {Object} selectors Collection of selectors
     * @param {String} state Css rule state
     * @param {String} width For which device this style is oriented
     * @param {Object} ruleProps Other rule props
     * @returns  {Boolean}
     * @private
     */
    CssRule.prototype.compare = function (selectors, state, width, ruleProps) {
        var _a;
        if (ruleProps === void 0) { ruleProps = {}; }
        var st = state || '';
        var wd = width || '';
        var selAdd = ruleProps.selectorsAdd || '';
        var atRule = ruleProps.atRuleType || '';
        var sel = !(0,index_all.isArray)(selectors) && !selectors.models ? [selectors] : selectors.models || selectors;
        // Fix atRuleType in case is not specified with width
        if (wd && !atRule)
            atRule = 'media';
        var a1 = sel.map(function (model) { return model.getFullName(); });
        var a2 = (_a = this.get('selectors')) === null || _a === void 0 ? void 0 : _a.map(function (model) { return model.getFullName(); });
        // Check selectors
        var a1S = a1.slice().sort();
        var a2S = a2.slice().sort();
        if (a1.length !== a2.length || !a1S.every(function (v, i) { return v === a2S[i]; })) {
            return false;
        }
        // Check other properties
        if (this.get('state') !== st ||
            this.get('mediaText') !== wd ||
            this.get('selectorsAdd') !== selAdd ||
            this.get('atRuleType') !== atRule) {
            return false;
        }
        return true;
    };
    return CssRule;
}(model_StyleableModel));
/* harmony default export */ const model_CssRule = (CssRule);

;// CONCATENATED MODULE: ./src/css_composer/model/CssRules.ts
var CssRules_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var CssRules = /** @class */ (function (_super) {
    CssRules_extends(CssRules, _super);
    function CssRules(props, opt) {
        var _this = _super.call(this, props) || this;
        // Inject editor
        _this.editor = opt === null || opt === void 0 ? void 0 : opt.em;
        // This will put the listener post CssComposer.postLoad
        setTimeout(function () {
            _this.on('remove', _this.onRemove);
            _this.on('add', _this.onAdd);
        });
        return _this;
    }
    CssRules.prototype.toJSON = function (opts) {
        var result = common/* Collection */.FE.prototype.toJSON.call(this, opts);
        return result.filter(function (rule) { return rule.style && !rule.shallow; });
    };
    CssRules.prototype.onAdd = function (model, c, o) {
        model.ensureSelectors(model, c, o); // required for undo
    };
    CssRules.prototype.onRemove = function (removed) {
        var em = this.editor;
        em.stopListening(removed);
        em.UndoManager.remove(removed);
    };
    /** @ts-ignore */
    CssRules.prototype.add = function (models, opt) {
        if (opt === void 0) { opt = {}; }
        if (typeof models === 'string') {
            models = this.editor.get('Parser').parseCss(models);
        }
        opt.em = this.editor;
        return common/* Collection */.FE.prototype.add.apply(this, [models, opt]);
    };
    return CssRules;
}(common/* Collection */.FE));
/* harmony default export */ const model_CssRules = (CssRules);
CssRules.prototype.model = model_CssRule;

;// CONCATENATED MODULE: ./src/css_composer/index.ts
/**
 * This module manages CSS rules in the canvas.
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/css_composer/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  cssComposer: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const css = editor.Css;
 * ```
 *
 * * [addRules](#addrules)
 * * [setRule](#setrule)
 * * [getRule](#getrule)
 * * [getRules](#getrules)
 * * [remove](#remove)
 * * [clear](#clear)
 *
 * [CssRule]: css_rule.html
 *
 * @module Css
 */
var css_composer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var css_composer_assign = (undefined && undefined.__assign) || function () {
    css_composer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return css_composer_assign.apply(this, arguments);
};
var css_composer_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};









var CssComposer = /** @class */ (function (_super) {
    css_composer_extends(CssComposer, _super);
    /**
     * Initializes module. Automatically called with a new instance of the editor
     * @param {Object} config Configurations
     * @private
     */
    function CssComposer(em) {
        var _this = _super.call(this, em, 'CssComposer', null, {}, css_composer_config_config) || this;
        _this.Selectors = model_Selectors;
        _this.storageKey = 'styles';
        var config = _this.config;
        var ppfx = config.pStylePrefix;
        if (ppfx)
            config.stylePrefix = ppfx + config.stylePrefix;
        // @ts-ignore
        config.rules = _this.em.config.style || config.rules || '';
        _this.rules = new model_CssRules([], config);
        return _this;
    }
    /**
     * On load callback
     * @private
     */
    CssComposer.prototype.onLoad = function () {
        this.rules.add(this.config.rules, { silent: true });
    };
    /**
     * Do stuff after load
     * @param  {Editor} em
     * @private
     */
    CssComposer.prototype.postLoad = function () {
        var _a;
        var um = (_a = this.em) === null || _a === void 0 ? void 0 : _a.get('UndoManager');
        um && um.add(this.getAll());
    };
    CssComposer.prototype.store = function () {
        return this.getProjectData();
    };
    CssComposer.prototype.load = function (data) {
        return this.loadProjectData(data, {
            // @ts-ignore Fix add() first in CssRules
            all: this.rules,
        });
    };
    /**
     * Add new rule to the collection, if not yet exists with the same selectors
     * @param {Array<Selector>} selectors Array of selectors
     * @param {String} state Css rule state
     * @param {String} width For which device this style is oriented
     * @param {Object} props Other props for the rule
     * @param {Object} opts Options for the add of new rule
     * @return {Model}
     * @private
     * @example
     * var sm = editor.SelectorManager;
     * var sel1 = sm.add('myClass1');
     * var sel2 = sm.add('myClass2');
     * var rule = cssComposer.add([sel1, sel2], 'hover');
     * rule.set('style', {
     *   width: '100px',
     *   color: '#fff',
     * });
     * */
    CssComposer.prototype.add = function (selectors, state, width, opts, addOpts) {
        if (opts === void 0) { opts = {}; }
        if (addOpts === void 0) { addOpts = {}; }
        var s = state || '';
        var w = width || '';
        var opt = css_composer_assign({}, opts);
        var rule = this.get(selectors, s, w, opt);
        // do not create rules that were found before
        // unless this is a single at-rule, for which multiple declarations
        // make sense (e.g. multiple `@font-type`s)
        if (rule && rule.config && !rule.config.singleAtRule) {
            return rule;
        }
        else {
            opt.state = s;
            opt.mediaText = w;
            opt.selectors = [];
            // #4727: Prevent updating atRuleType if already defined
            if (w && !opt.atRuleType) {
                opt.atRuleType = 'media';
            }
            rule = new model_CssRule(opt, this.config);
            // @ts-ignore
            rule.get('selectors').add(selectors, addOpts);
            this.rules.add(rule, addOpts);
            return rule;
        }
    };
    /**
     * Get the rule
     * @param {String|Array<Selector>} selectors Array of selectors or selector string, eg `.myClass1.myClass2`
     * @param {String} state Css rule state, eg. 'hover'
     * @param {String} width Media rule value, eg. '(max-width: 992px)'
     * @param {Object} ruleProps Other rule props
     * @return  {Model|null}
     * @private
     * @example
     * const sm = editor.SelectorManager;
     * const sel1 = sm.add('myClass1');
     * const sel2 = sm.add('myClass2');
     * const rule = cssComposer.get([sel1, sel2], 'hover', '(max-width: 992px)');
     * // Update the style
     * rule.set('style', {
     *   width: '300px',
     *   color: '#000',
     * });
     * */
    CssComposer.prototype.get = function (selectors, state, width, ruleProps) {
        var slc = selectors;
        if ((0,index_all.isString)(selectors)) {
            var sm = this.em.Selectors;
            var singleSel = selectors.split(',')[0].trim();
            var node = this.em.Parser.parserCss.checkNode({ selectors: singleSel })[0];
            slc = sm.get(node.selectors);
        }
        return this.rules.find(function (rule) { return rule.compare(slc, state, width, ruleProps); }) || null;
    };
    CssComposer.prototype.getAll = function () {
        return this.rules;
    };
    /**
     * Add a raw collection of rule objects
     * This method overrides styles, in case, of already defined rule
     * @param {String|Array<Object>} data CSS string or an array of rule objects, eg. [{selectors: ['class1'], style: {....}}, ..]
     * @param {Object} opts Options
     * @param {Object} props Additional properties to add on rules
     * @return {Array<Model>}
     * @private
     */
    CssComposer.prototype.addCollection = function (data, opts, props) {
        if (opts === void 0) { opts = {}; }
        if (props === void 0) { props = {}; }
        var em = this.em;
        var result = [];
        if ((0,index_all.isString)(data)) {
            data = em.Parser.parseCss(data);
        }
        var d = data instanceof Array ? data : [data];
        for (var i = 0, l = d.length; i < l; i++) {
            var rule = (d[i] || {});
            if (!rule.selectors)
                continue;
            var sm = em === null || em === void 0 ? void 0 : em.Selectors;
            if (!sm)
                console.warn('Selector Manager not found');
            var sl = rule.selectors;
            var sels = sl instanceof Array ? sl : [sl];
            var newSels = [];
            for (var j = 0, le = sels.length; j < le; j++) {
                // @ts-ignore
                var selec = sm.add(sels[j]);
                newSels.push(selec);
            }
            var modelExists = this.get(newSels, rule.state, rule.mediaText, rule);
            var model = this.add(newSels, rule.state, rule.mediaText, rule, opts);
            var updateStyle = !modelExists || !opts.avoidUpdateStyle;
            var style = rule.style || {};
            (0,mixins.isObject)(props) && model.set(props, opts);
            if (updateStyle) {
                var styleUpdate = opts.extend ? css_composer_assign(css_composer_assign({}, model.get('style')), style) : style;
                model.set('style', styleUpdate, opts);
            }
            result.push(model);
        }
        return result;
    };
    /**
     * Add CssRules via CSS string.
     * @param {String} css CSS string of rules to add.
     * @returns {Array<[CssRule]>} Array of rules
     * @example
     * const addedRules = css.addRules('.my-cls{ color: red } @media (max-width: 992px) { .my-cls{ color: darkred } }');
     * // Check rules
     * console.log(addedRules.map(rule => rule.toCSS()));
     */
    CssComposer.prototype.addRules = function (css) {
        return this.addCollection(css);
    };
    /**
     * Add/update the CssRule.
     * @param {String} selectors Selector string, eg. `.myclass`
     * @param {Object} style  Style properties and values. If the rule exists, styles will be replaced unless `addStyles` option is used.
     * @param {Object} [opts={}]  Additional properties.
     * @param {String} [opts.atRuleType='']  At-rule type, eg. `media`.
     * @param {String} [opts.atRuleParams='']  At-rule parameters, eg. `(min-width: 500px)`.
     * @param {Boolean} [opts.addStyles=false] If the rule exists already, merge passed styles instead of replacing them.
     * @returns {[CssRule]} The new/updated CssRule.
     * @example
     * // Simple class-based rule
     * const rule = css.setRule('.class1.class2', { color: 'red' });
     * console.log(rule.toCSS()) // output: .class1.class2 { color: red }
     * // With state and other mixed selector
     * const rule = css.setRule('.class1.class2:hover, div#myid', { color: 'red' });
     * // output: .class1.class2:hover, div#myid { color: red }
     * // With media
     * const rule = css.setRule('.class1:hover', { color: 'red' }, {
     *  atRuleType: 'media',
     *  atRuleParams: '(min-width: 500px)',
     * });
     * // output: `@media (min-width: 500px) { .class1:hover { color: red } }`
     *
     * // Update styles of existent rule
     * css.setRule('.class1', { color: 'red', background: 'red' });
     * css.setRule('.class1', { color: 'blue' }, { addStyles: true });
     * // output: .class1 { color: blue; background: red }
     */
    CssComposer.prototype.setRule = function (selectors, style, opts) {
        if (style === void 0) { style = {}; }
        if (opts === void 0) { opts = {}; }
        var atRuleType = opts.atRuleType, atRuleParams = opts.atRuleParams;
        var node = this.em.Parser.parserCss.checkNode({
            selectors: selectors,
            style: style,
        })[0];
        var state = node.state, selectorsAdd = node.selectorsAdd;
        var sm = this.em.Selectors;
        var selector = sm.add(node.selectors);
        var rule = this.add(selector, state, atRuleParams, {
            selectorsAdd: selectorsAdd,
            atRule: atRuleType,
        });
        if (opts.addStyles) {
            rule.addStyle(style, opts);
        }
        else {
            rule.setStyle(style, opts);
        }
        return rule;
    };
    /**
     * Get the CssRule.
     * @param {String} selectors Selector string, eg. `.myclass:hover`
     * @param {Object} [opts={}]  Additional properties
     * @param {String} [opts.atRuleType='']  At-rule type, eg. `media`
     * @param {String} [opts.atRuleParams='']  At-rule parameters, eg. '(min-width: 500px)'
     * @returns {[CssRule]}
     * @example
     * const rule = css.getRule('.myclass1:hover');
     * const rule2 = css.getRule('.myclass1:hover, div#myid');
     * const rule3 = css.getRule('.myclass1', {
     *  atRuleType: 'media',
     *  atRuleParams: '(min-width: 500px)',
     * });
     */
    CssComposer.prototype.getRule = function (selectors, opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var sm = em.Selectors;
        var node = em.Parser.parserCss.checkNode({ selectors: selectors })[0];
        // @ts-ignore
        var selector = sm.get(node.selectors);
        var state = node.state, selectorsAdd = node.selectorsAdd;
        var atRuleType = opts.atRuleType, atRuleParams = opts.atRuleParams;
        return selector
            ? this.get(selector, state, atRuleParams, {
                selectorsAdd: selectorsAdd,
                atRuleType: atRuleType,
            })
            : undefined;
    };
    /**
     * Get all rules or filtered by a matching selector.
     * @param {String} [selector=''] Selector, eg. `.myclass`
     * @returns {Array<[CssRule]>}
     * @example
     * // Take all the component specific rules
     * const id = someComponent.getId();
     * const rules = css.getRules(`#${id}`);
     * console.log(rules.map(rule => rule.toCSS()))
     * // All rules in the project
     * console.log(css.getRules())
     */
    CssComposer.prototype.getRules = function (selector) {
        var rules = this.getAll();
        if (!selector)
            return css_composer_spreadArray([], rules.models, true);
        var optRuleSel = { sort: true };
        var sels = (0,index_all.isString)(selector) ? selector.split(',').map(function (s) { return s.trim(); }) : selector;
        var result = rules.filter(function (r) { return sels.indexOf(r.getSelectors().getFullString(null, optRuleSel)) >= 0; });
        return result;
    };
    /**
     * Add/update the CSS rule with id selector
     * @param {string} name Id selector name, eg. 'my-id'
     * @param {Object} style  Style properties and values
     * @param {Object} [opts={}]  Custom options, like `state` and `mediaText`
     * @return {CssRule} The new/updated rule
     * @private
     * @example
     * const rule = css.setIdRule('myid', { color: 'red' });
     * const ruleHover = css.setIdRule('myid', { color: 'blue' }, { state: 'hover' });
     * // This will add current CSS:
     * // #myid { color: red }
     * // #myid:hover { color: blue }
     */
    CssComposer.prototype.setIdRule = function (name, style, opts) {
        if (style === void 0) { style = {}; }
        if (opts === void 0) { opts = {}; }
        var _a = opts.addOpts, addOpts = _a === void 0 ? {} : _a, mediaText = opts.mediaText;
        var state = opts.state || '';
        var media = !(0,index_all.isUndefined)(mediaText) ? mediaText : this.em.getCurrentMedia();
        var sm = this.em.Selectors;
        var selector = sm.add({ name: name, type: model_Selector.TYPE_ID }, addOpts);
        var rule = this.add(selector, state, media, {}, addOpts);
        rule.setStyle(style, css_composer_assign(css_composer_assign({}, opts), addOpts));
        return rule;
    };
    /**
     * Get the CSS rule by id selector
     * @param {string} name Id selector name, eg. 'my-id'
     * @param  {Object} [opts={}]  Custom options, like `state` and `mediaText`
     * @return {CssRule}
     * @private
     * @example
     * const rule = css.getIdRule('myid');
     * const ruleHover = css.setIdRule('myid', { state: 'hover' });
     */
    CssComposer.prototype.getIdRule = function (name, opts) {
        if (opts === void 0) { opts = {}; }
        var mediaText = opts.mediaText;
        var state = opts.state || '';
        var media = !(0,index_all.isUndefined)(mediaText) ? mediaText : this.em.getCurrentMedia();
        var selector = this.em.Selectors.get(name, model_Selector.TYPE_ID);
        return selector && this.get(selector, state, media);
    };
    /**
     * Add/update the CSS rule with class selector
     * @param {string} name Class selector name, eg. 'my-class'
     * @param {Object} style  Style properties and values
     * @param {Object} [opts={}]  Custom options, like `state` and `mediaText`
     * @return {CssRule} The new/updated rule
     * @private
     * @example
     * const rule = css.setClassRule('myclass', { color: 'red' });
     * const ruleHover = css.setClassRule('myclass', { color: 'blue' }, { state: 'hover' });
     * // This will add current CSS:
     * // .myclass { color: red }
     * // .myclass:hover { color: blue }
     */
    CssComposer.prototype.setClassRule = function (name, style, opts) {
        if (style === void 0) { style = {}; }
        if (opts === void 0) { opts = {}; }
        var state = opts.state || '';
        var media = opts.mediaText || this.em.getCurrentMedia();
        var sm = this.em.Selectors;
        var selector = sm.add({ name: name, type: model_Selector.TYPE_CLASS });
        var rule = this.add(selector, state, media);
        rule.setStyle(style, opts);
        return rule;
    };
    /**
     * Get the CSS rule by class selector
     * @param {string} name Class selector name, eg. 'my-class'
     * @param  {Object} [opts={}]  Custom options, like `state` and `mediaText`
     * @return {CssRule}
     * @private
     * @example
     * const rule = css.getClassRule('myclass');
     * const ruleHover = css.getClassRule('myclass', { state: 'hover' });
     */
    CssComposer.prototype.getClassRule = function (name, opts) {
        if (opts === void 0) { opts = {}; }
        var state = opts.state || '';
        var media = opts.mediaText || this.em.getCurrentMedia();
        var selector = this.em.Selectors.get(name, model_Selector.TYPE_CLASS);
        return selector && this.get(selector, state, media);
    };
    /**
     * Remove rule, by CssRule or matching selector (eg. the selector will match also at-rules like `@media`)
     * @param {String|[CssRule]|Array<[CssRule]>} rule CssRule or matching selector.
     * @return {Array<[CssRule]>} Removed rules
     * @example
     * // Remove by CssRule
     * const toRemove = css.getRules('.my-cls');
     * css.remove(toRemove);
     * // Remove by selector
     * css.remove('.my-cls-2');
     */
    CssComposer.prototype.remove = function (rule, opts) {
        var toRemove = (0,index_all.isString)(rule) ? this.getRules(rule) : rule;
        var result = this.getAll().remove(toRemove, opts);
        return (0,index_all.isArray)(result) ? result : [result];
    };
    /**
     * Remove all rules
     * @return {this}
     */
    CssComposer.prototype.clear = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.getAll().reset([], opts);
        return this;
    };
    CssComposer.prototype.getComponentRules = function (cmp, opts) {
        if (opts === void 0) { opts = {}; }
        var state = opts.state, mediaText = opts.mediaText, current = opts.current;
        if (current) {
            state = this.em.get('state') || '';
            mediaText = this.em.getCurrentMedia();
        }
        var id = cmp.getId();
        var rules = this.getAll().filter(function (r) {
            if (!(0,index_all.isUndefined)(state) && r.get('state') !== state)
                return false;
            if (!(0,index_all.isUndefined)(mediaText) && r.get('mediaText') !== mediaText)
                return false;
            return r.getSelectorsString() === "#".concat(id);
        });
        return rules;
    };
    /**
     * Render the block of CSS rules
     * @return {HTMLElement}
     * @private
     */
    CssComposer.prototype.render = function () {
        var _a;
        (_a = this.rulesView) === null || _a === void 0 ? void 0 : _a.remove();
        this.rulesView = new view_CssRulesView({
            collection: this.rules,
            config: this.config,
        });
        return this.rulesView.render().el;
    };
    CssComposer.prototype.checkId = function (rule, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = opts.idMap, idMap = _a === void 0 ? {} : _a;
        var changed = [];
        if (!Object.keys(idMap).length)
            return changed;
        var rules = Array.isArray(rule) ? rule : [rule];
        rules.forEach(function (rule) {
            var sel = rule.selectors;
            if (sel && sel.length == 1) {
                var sSel = sel[0];
                if ((0,index_all.isString)(sSel)) {
                    if (sSel[0] === '#') {
                        var prevId = sSel.substring(1);
                        var newId = idMap[prevId];
                        if (prevId && newId) {
                            sel[0] = "#".concat(newId);
                            changed.push(rule);
                        }
                    }
                }
                else if (sSel.name && sSel.type === model_Selector.TYPE_ID) {
                    var newId = idMap[sSel.name];
                    if (newId) {
                        sSel.name = newId;
                        changed.push(rule);
                    }
                }
            }
        });
        return changed;
    };
    CssComposer.prototype.destroy = function () {
        var _a;
        this.rules.reset();
        this.rules.stopListening();
        (_a = this.rulesView) === null || _a === void 0 ? void 0 : _a.remove();
    };
    return CssComposer;
}(ItemManagerModule));
/* harmony default export */ const css_composer = (CssComposer);

;// CONCATENATED MODULE: ./src/block_manager/config/config.ts
var block_manager_config_config_config = {
    appendTo: '',
    blocks: [],
    appendOnClick: false,
    custom: false,
};
/* harmony default export */ const block_manager_config_config = (block_manager_config_config_config);

;// CONCATENATED MODULE: ./src/block_manager/model/Block.ts
var Block_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @property {String} label Block label, eg. `My block`
 * @property {String|Object} content The content of the block. Might be an HTML string or a [Component Defintion](/modules/Components.html#component-definition)
 * @property {String} [media=''] HTML string for the media/icon of the block, eg. `<svg ...`, `<img ...`, etc.
 * @property {String} [category=''] Block category, eg. `Basic blocks`
 * @property {Boolean} [activate=false] If true, triggers the `active` event on the dropped component.
 * @property {Boolean} [select=false] If true, the dropped component will be selected.
 * @property {Boolean} [resetId=false] If true, all IDs of dropped components and their styles will be changed.
 * @property {Boolean} [disable=false] Disable the block from being interacted
 * @property {Function} [onClick] Custom behavior on click, eg. `(block, editor) => editor.getWrapper().append(block.get('content'))`
 * @property {Object} [attributes={}] Block attributes to apply in the view element
 *
 * @module docsjs.Block
 */
var Block = /** @class */ (function (_super) {
    Block_extends(Block, _super);
    function Block() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Block.prototype.defaults = function () {
        return {
            label: '',
            content: '',
            media: '',
            category: '',
            activate: false,
            select: undefined,
            resetId: false,
            disable: false,
            onClick: undefined,
            attributes: {},
        };
    };
    /**
     * Get block id
     * @returns {String}
     */
    Block.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get block label
     * @returns {String}
     */
    Block.prototype.getLabel = function () {
        return this.get('label');
    };
    /**
     * Get block media
     * @returns {String}
     */
    Block.prototype.getMedia = function () {
        return this.get('media');
    };
    /**
     * Get block content
     * @returns {Object|String|Array<Object|String>}
     */
    Block.prototype.getContent = function () {
        return this.get('content');
    };
    /**
     * Get block category label
     * @returns {String}
     */
    Block.prototype.getCategoryLabel = function () {
        var ctg = this.get('category');
        // @ts-ignore
        return (0,index_all.isFunction)(ctg === null || ctg === void 0 ? void 0 : ctg.get) ? ctg.get('label') : (ctg === null || ctg === void 0 ? void 0 : ctg.label) ? ctg === null || ctg === void 0 ? void 0 : ctg.label : ctg;
    };
    return Block;
}(common/* Model */.Hn));
/* harmony default export */ const model_Block = (Block);

;// CONCATENATED MODULE: ./src/block_manager/model/Blocks.ts
var Blocks_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Blocks = /** @class */ (function (_super) {
    Blocks_extends(Blocks, _super);
    function Blocks() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Blocks;
}(common/* Collection */.FE));
/* harmony default export */ const model_Blocks = (Blocks);
Blocks.prototype.model = model_Block;

;// CONCATENATED MODULE: ./src/block_manager/model/Category.ts
var Category_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Category = /** @class */ (function (_super) {
    Category_extends(Category, _super);
    function Category() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Category.prototype.defaults = function () {
        return {
            id: '',
            label: '',
            open: true,
            attributes: {},
        };
    };
    return Category;
}(common/* Model */.Hn));
/* harmony default export */ const model_Category = (Category);

;// CONCATENATED MODULE: ./src/block_manager/model/Categories.ts
var Categories_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var Categories = /** @class */ (function (_super) {
    Categories_extends(Categories, _super);
    function Categories() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @ts-ignore */
    Categories.prototype.add = function (model, opts) {
        var models = (0,index_all.isArray)(model) ? model : [model];
        models.forEach(function (md) { return md && (md.id = (0,mixins.normalizeKey)("".concat(md.id))); });
        return _super.prototype.add.call(this, model, opts);
    };
    Categories.prototype.get = function (id) {
        return _super.prototype.get.call(this, (0,index_all.isString)(id) ? (0,mixins.normalizeKey)(id) : id);
    };
    return Categories;
}(common/* Collection */.FE));
/* harmony default export */ const model_Categories = (Categories);
Categories.prototype.model = model_Category;

;// CONCATENATED MODULE: ./src/block_manager/types.ts
/**{START_EVENTS}*/
var BlocksEvents;
(function (BlocksEvents) {
    /**
     * @event `block:add` New block added to the collection. The [Block] is passed as an argument to the callback.
     * @example
     * editor.on('block:add', (block) => { ... });
     */
    BlocksEvents["add"] = "block:add";
    /**
     * @event `block:remove` Block removed from the collection. The [Block] is passed as an argument to the callback.
     * @example
     * editor.on('block:remove', (block) => { ... });
     */
    BlocksEvents["remove"] = "block:remove";
    /**
     * @event `block:remove:before` Event triggered before Block remove.
     * @example
     * editor.on('block:remove:before', (block, remove, opts) => { ... });
     */
    BlocksEvents["removeBefore"] = "block:remove:before";
    /**
     * @event `block:update` Block updated. The [Block] and the object containing changes are passed as arguments to the callback.
     * @example
     * editor.on('block:update', (block, updatedProps) => { ... });
     */
    BlocksEvents["update"] = "block:update";
    /**
     * @event `block:drag:start` Started dragging block. The [Block] is passed as an argument.
     * @example
     * editor.on('block:drag:start', (block) => { ... });
     */
    BlocksEvents["dragStart"] = "block:drag:start";
    /**
     * @event `block:drag` The block is dragging. The [Block] is passed as an argument.
     * @example
     * editor.on('block:drag', (block) => { ... });
     */
    BlocksEvents["drag"] = "block:drag";
    /**
     * @event `block:drag:stop` Dragging of the block is stopped. The dropped [Component] (if dropped successfully) and the [Block] are passed as arguments.
     * @example
     * editor.on('block:drag:stop', (component, block) => { ... });
     */
    BlocksEvents["dragEnd"] = "block:drag:stop";
    /**
     * @event `block:custom` Event to use in case of [custom Block Manager UI](https://grapesjs.com/docs/modules/Blocks.html#customization).
     * @example
     * editor.on('block:custom', ({ container, blocks, ... }) => { ... });
     */
    BlocksEvents["custom"] = "block:custom";
    /**
     * @event `block` Catch-all event for all the events mentioned above. An object containing all the available data about the triggered event is passed as an argument to the callback.
     * @example
     * editor.on('block', ({ event, model, ... }) => { ... });
     */
    BlocksEvents["all"] = "block";
})(BlocksEvents || (BlocksEvents = {}));
/**{END_EVENTS}*/
// need this to avoid the TS documentation generator to break
/* harmony default export */ const block_manager_types = ((/* unused pure expression or super */ null && (BlocksEvents)));

;// CONCATENATED MODULE: ./src/block_manager/view/BlockView.ts
var BlockView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var BlockView = /** @class */ (function (_super) {
    BlockView_extends(BlockView, _super);
    function BlockView(o, config) {
        if (config === void 0) { config = {}; }
        var _this = _super.call(this, o) || this;
        var model = _this.model;
        _this.em = config.em;
        _this.config = config;
        _this.endDrag = _this.endDrag.bind(_this);
        _this.ppfx = config.pStylePrefix || '';
        _this.listenTo(model, 'destroy remove', _this.remove);
        _this.listenTo(model, 'change', _this.render);
        return _this;
    }
    BlockView.prototype.events = function () {
        return {
            click: 'handleClick',
            mousedown: 'startDrag',
            dragstart: 'handleDragStart',
            drag: 'handleDrag',
            dragend: 'handleDragEnd',
        };
    };
    BlockView.prototype.__getModule = function () {
        return this.em.Blocks;
    };
    BlockView.prototype.handleClick = function (ev) {
        var _a = this, config = _a.config, model = _a.model, em = _a.em;
        var onClick = model.get('onClick') || config.appendOnClick;
        em.trigger('block:click', model, ev);
        if (!onClick) {
            return;
        }
        else if ((0,index_all.isFunction)(onClick)) {
            return onClick(model, em === null || em === void 0 ? void 0 : em.getEditor(), { event: ev });
        }
        var sorter = config.getSorter();
        var content = model.get('content');
        var selected = em.getSelected();
        sorter.setDropContent(content);
        var target, valid, insertAt;
        // If there is a selected component, try first to append
        // the block inside, otherwise, try to place it as a next sibling
        if (selected) {
            valid = sorter.validTarget(selected.getEl(), content);
            if (valid.valid) {
                target = selected;
            }
            else {
                var parent_1 = selected.parent();
                if (parent_1) {
                    valid = sorter.validTarget(parent_1.getEl(), content);
                    if (valid.valid) {
                        target = parent_1;
                        insertAt = parent_1.components().indexOf(selected) + 1;
                    }
                }
            }
        }
        // If no target found yet, try to append the block to the wrapper
        if (!target) {
            var wrapper = em.getWrapper();
            valid = sorter.validTarget(wrapper.getEl(), content);
            if (valid.valid)
                target = wrapper;
        }
        var result = target && target.append(content, { at: insertAt })[0];
        result && em.setSelected(result, { scroll: 1 });
    };
    /**
     * Start block dragging
     * @private
     */
    BlockView.prototype.startDrag = function (e) {
        var _a = this, config = _a.config, em = _a.em, model = _a.model;
        var disable = model.get('disable');
        //Right or middel click
        if (e.button !== 0 || !config.getSorter || this.el.draggable || disable)
            return;
        em.refreshCanvas();
        var sorter = config.getSorter();
        sorter.__currentBlock = model;
        sorter.setDragHelper(this.el, e);
        sorter.setDropContent(this.model.get('content'));
        sorter.startSort(this.el);
        (0,dom.on)(document, 'mouseup', this.endDrag);
    };
    BlockView.prototype.handleDragStart = function (ev) {
        this.__getModule().__startDrag(this.model, ev);
    };
    BlockView.prototype.handleDrag = function (ev) {
        this.__getModule().__drag(ev);
    };
    BlockView.prototype.handleDragEnd = function () {
        this.__getModule().__endDrag();
    };
    /**
     * Drop block
     * @private
     */
    BlockView.prototype.endDrag = function () {
        (0,dom/* off */.S1)(document, 'mouseup', this.endDrag);
        var sorter = this.config.getSorter();
        // After dropping the block in the canvas the mouseup event is not yet
        // triggerd on 'this.doc' and so clicking outside, the sorter, tries to move
        // things (throws false positives). As this method just need to drop away
        // the block helper I use the trick of 'moved = 0' to void those errors.
        sorter.moved = 0;
        sorter.endMove();
    };
    BlockView.prototype.render = function () {
        var _a;
        var _b = this, em = _b.em, el = _b.el, $el = _b.$el, ppfx = _b.ppfx, model = _b.model;
        var disable = model.get('disable');
        var attr = model.get('attributes') || {};
        var cls = attr.class || '';
        var className = "".concat(ppfx, "block");
        var label = (em && em.t("blockManager.labels.".concat(model.id))) || model.get('label');
        // @ts-ignore deprecated
        var render = model.get('render');
        var media = model.get('media');
        var clsAdd = disable ? "".concat(className, "--disable") : "".concat(ppfx, "four-color-h");
        $el.attr(attr);
        el.className = "".concat(cls, " ").concat(className, " ").concat(ppfx, "one-bg ").concat(clsAdd).trim();
        el.innerHTML = "\n      ".concat(media ? "<div class=\"".concat(className, "__media\">").concat(media, "</div>") : '', "\n      <div class=\"").concat(className, "-label\">").concat(label, "</div>\n    ");
        el.title = attr.title || ((_a = el.textContent) === null || _a === void 0 ? void 0 : _a.trim());
        el.setAttribute('draggable', "".concat((0,mixins.hasDnd)(em) && !disable ? true : false));
        // @ts-ignore
        var result = render && render({ el: el, model: model, className: className, prefix: ppfx });
        if (result)
            el.innerHTML = result;
        return this;
    };
    return BlockView;
}(common/* View */.G7));
/* harmony default export */ const view_BlockView = (BlockView);

;// CONCATENATED MODULE: ./src/block_manager/view/CategoryView.ts
var CategoryView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var CategoryView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


var CategoryView = /** @class */ (function (_super) {
    CategoryView_extends(CategoryView, _super);
    function CategoryView(o, config) {
        var _this = _super.call(this, o) || this;
        _this.config = config;
        var pfx = config.pStylePrefix || '';
        _this.em = config.em;
        _this.pfx = pfx;
        _this.caretR = 'fa fa-caret-right';
        _this.caretD = 'fa fa-caret-down';
        _this.iconClass = "".concat(pfx, "caret-icon");
        _this.activeClass = "".concat(pfx, "open");
        _this.className = "".concat(pfx, "block-category");
        _this.listenTo(_this.model, 'change:open', _this.updateVisibility);
        _this.model.view = _this;
        return _this;
    }
    CategoryView.prototype.events = function () {
        return {
            'click [data-title]': 'toggle',
        };
    };
    CategoryView.prototype.template = function (_a) {
        var pfx = _a.pfx, label = _a.label;
        return html(CategoryView_templateObject_1 || (CategoryView_templateObject_1 = CategoryView_makeTemplateObject(["\n      <div class=\"", "title\" data-title>\n        <i class=\"", "caret-icon\"></i>\n        ", "\n      </div>\n      <div class=\"", "blocks-c\"></div>\n    "], ["\n      <div class=\"", "title\" data-title>\n        <i class=\"", "caret-icon\"></i>\n        ", "\n      </div>\n      <div class=\"", "blocks-c\"></div>\n    "])), pfx, pfx, label, pfx);
    };
    /** @ts-ignore */
    CategoryView.prototype.attributes = function () {
        return this.model.get('attributes') || {};
    };
    CategoryView.prototype.updateVisibility = function () {
        if (this.model.get('open'))
            this.open();
        else
            this.close();
    };
    CategoryView.prototype.open = function () {
        this.$el.addClass(this.activeClass);
        this.getIconEl().className = "".concat(this.iconClass, " ").concat(this.caretD);
        this.getBlocksEl().style.display = '';
    };
    CategoryView.prototype.close = function () {
        this.$el.removeClass(this.activeClass);
        this.getIconEl().className = "".concat(this.iconClass, " ").concat(this.caretR);
        this.getBlocksEl().style.display = 'none';
    };
    CategoryView.prototype.toggle = function () {
        var model = this.model;
        model.set('open', !model.get('open'));
    };
    CategoryView.prototype.getIconEl = function () {
        if (!this.iconEl) {
            this.iconEl = this.el.querySelector(".".concat(this.iconClass));
        }
        return this.iconEl;
    };
    CategoryView.prototype.getBlocksEl = function () {
        if (!this.blocksEl) {
            this.blocksEl = this.el.querySelector(".".concat(this.pfx, "blocks-c"));
        }
        return this.blocksEl;
    };
    CategoryView.prototype.append = function (el) {
        this.getBlocksEl().appendChild(el);
    };
    CategoryView.prototype.render = function () {
        var _a = this, em = _a.em, el = _a.el, $el = _a.$el, model = _a.model, pfx = _a.pfx;
        var label = em.t("blockManager.categories.".concat(model.id)) || model.get('label');
        el.innerHTML = this.template({ pfx: pfx, label: label });
        $el.addClass(this.className);
        $el.css({ order: model.get('order') });
        this.updateVisibility();
        return this;
    };
    return CategoryView;
}(common/* View */.G7));
/* harmony default export */ const view_CategoryView = (CategoryView);
var CategoryView_templateObject_1;

;// CONCATENATED MODULE: ./src/block_manager/view/BlocksView.ts
var BlocksView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var BlocksView_assign = (undefined && undefined.__assign) || function () {
    BlocksView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return BlocksView_assign.apply(this, arguments);
};




var BlocksView = /** @class */ (function (_super) {
    BlocksView_extends(BlocksView, _super);
    function BlocksView(opts, config) {
        var _this = _super.call(this, opts) || this;
        _this.renderedCategories = new Map();
        (0,index_all.bindAll)(_this, 'getSorter', 'onDrag', 'onDrop', 'onMove');
        _this.config = config || {};
        _this.categories = opts.categories || '';
        var ppfx = _this.config.pStylePrefix || '';
        _this.ppfx = ppfx;
        _this.noCatClass = "".concat(ppfx, "blocks-no-cat");
        _this.blockContClass = "".concat(ppfx, "blocks-c");
        _this.catsClass = "".concat(ppfx, "block-categories");
        var coll = _this.collection;
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset', _this.render);
        _this.em = _this.config.em;
        if (_this.em) {
            _this.config.getSorter = _this.getSorter;
        }
        return _this;
    }
    BlocksView.prototype.__getModule = function () {
        return this.em.Blocks;
    };
    BlocksView.prototype.updateConfig = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.config = BlocksView_assign(BlocksView_assign({}, this.config), opts);
    };
    /**
     * Get sorter
     * @private
     */
    BlocksView.prototype.getSorter = function () {
        var em = this.em;
        if (!em)
            return;
        if (!this.sorter) {
            var utils = em.Utils;
            var canvas = em.Canvas;
            this.sorter = new utils.Sorter({
                // @ts-ignore
                container: canvas.getBody(),
                placer: canvas.getPlacerEl(),
                containerSel: '*',
                itemSel: '*',
                pfx: this.ppfx,
                onStart: this.onDrag,
                onEndMove: this.onDrop,
                onMove: this.onMove,
                document: canvas.getFrameEl().contentDocument,
                direction: 'a',
                wmargin: 1,
                nested: 1,
                em: em,
                canvasRelative: 1,
            });
        }
        return this.sorter;
    };
    BlocksView.prototype.onDrag = function (ev) {
        this.em.stopDefault();
        this.__getModule().__startDrag(this.sorter.__currentBlock, ev);
    };
    BlocksView.prototype.onMove = function (ev) {
        this.__getModule().__drag(ev);
    };
    BlocksView.prototype.onDrop = function (component) {
        this.em.runDefault();
        this.__getModule().__endDrag({ component: component });
        delete this.sorter.__currentBlock;
    };
    /**
     * Add new model to the collection
     * @param {Model} model
     * @private
     * */
    BlocksView.prototype.addTo = function (model) {
        this.add(model);
    };
    /**
     * Render new model inside the view
     * @param {Model} model
     * @param {Object} fragment Fragment collection
     * @private
     * */
    BlocksView.prototype.add = function (model, fragment) {
        var _a = this, config = _a.config, renderedCategories = _a.renderedCategories;
        var view = new view_BlockView({
            model: model,
            attributes: model.get('attributes'),
        }, config);
        var rendered = view.render().el;
        var category = model.get('category');
        // Check for categories
        if (category && this.categories && !config.ignoreCategories) {
            if ((0,index_all.isString)(category)) {
                category = { id: category, label: category };
            }
            else if ((0,index_all.isObject)(category) && !category.id) {
                category.id = category.label;
            }
            var catModel = this.categories.add(category);
            var catId = catModel.get('id');
            var categories = this.getCategoriesEl();
            var catView = renderedCategories.get(catId);
            // @ts-ignore
            model.set('category', catModel, { silent: true });
            if (!catView && categories) {
                catView = new view_CategoryView({ model: catModel }, config).render();
                renderedCategories.set(catId, catView);
                categories.appendChild(catView.el);
            }
            catView && catView.append(rendered);
            return;
        }
        fragment ? fragment.appendChild(rendered) : this.append(rendered);
    };
    BlocksView.prototype.getCategoriesEl = function () {
        if (!this.catsEl) {
            this.catsEl = this.el.querySelector(".".concat(this.catsClass));
        }
        return this.catsEl;
    };
    BlocksView.prototype.getBlocksEl = function () {
        if (!this.blocksEl) {
            this.blocksEl = this.el.querySelector(".".concat(this.noCatClass, " .").concat(this.blockContClass));
        }
        return this.blocksEl;
    };
    BlocksView.prototype.append = function (el) {
        var blocks = this.getBlocksEl();
        blocks && blocks.appendChild(el);
    };
    BlocksView.prototype.render = function () {
        var _this = this;
        var ppfx = this.ppfx;
        var frag = document.createDocumentFragment();
        delete this.catsEl;
        delete this.blocksEl;
        this.renderedCategories = new Map();
        this.el.innerHTML = "\n      <div class=\"".concat(this.catsClass, "\"></div>\n      <div class=\"").concat(this.noCatClass, "\">\n        <div class=\"").concat(this.blockContClass, "\"></div>\n      </div>\n    ");
        this.collection.each(function (model) { return _this.add(model, frag); });
        this.append(frag);
        var cls = "".concat(this.blockContClass, "s ").concat(ppfx, "one-bg ").concat(ppfx, "two-color");
        this.$el.addClass(cls);
        this.rendered = true;
        return this;
    };
    return BlocksView;
}(common/* View */.G7));
/* harmony default export */ const view_BlocksView = (BlocksView);

;// CONCATENATED MODULE: ./src/block_manager/index.ts
var block_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var block_manager_assign = (undefined && undefined.__assign) || function () {
    block_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return block_manager_assign.apply(this, arguments);
};
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/block_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  blockManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('block:add', (block) => { ... });
 *
 * // Use the API
 * const blockManager = editor.Blocks;
 * blockManager.add(...);
 * ```
 *
 * {REPLACE_EVENTS}
 *
 * [Block]: block.html
 * [Component]: component.html
 *
 * @module Blocks
 */









var BlockManager = /** @class */ (function (_super) {
    block_manager_extends(BlockManager, _super);
    function BlockManager(em) {
        var _a;
        var _this = _super.call(this, em, 'BlockManager', new model_Blocks(((_a = em.config.blockManager) === null || _a === void 0 ? void 0 : _a.blocks) || []), BlocksEvents, block_manager_config_config) || this;
        _this.events = BlocksEvents;
        _this.Block = model_Block;
        _this.Blocks = model_Blocks;
        _this.Category = model_Category;
        _this.Categories = model_Categories;
        _this.storageKey = '';
        // Global blocks collection
        _this.blocks = _this.all;
        _this.blocksVisible = new model_Blocks(_this.blocks.models);
        _this.categories = new model_Categories();
        // Setup the sync between the global and public collections
        _this.blocks.on('add', function (model) { return _this.blocksVisible.add(model); });
        _this.blocks.on('remove', function (model) { return _this.blocksVisible.remove(model); });
        _this.blocks.on('reset', function (coll) { return _this.blocksVisible.reset(coll.models); });
        _this.__onAllEvent = (0,index_all.debounce)(function () { return _this.__trgCustom(); }, 0);
        return _this;
    }
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    BlockManager.prototype.__trgCustom = function () {
        this.em.trigger(this.events.custom, this.__customData());
    };
    BlockManager.prototype.__customData = function () {
        var _this = this;
        var bhv = this.__getBehaviour();
        return {
            bm: this,
            blocks: this.getAll().models,
            container: bhv.container,
            dragStart: function (block, ev) { return _this.startDrag(block, ev); },
            drag: function (ev) { return _this.__drag(ev); },
            dragStop: function (cancel) { return _this.endDrag(cancel); },
        };
    };
    BlockManager.prototype.__startDrag = function (block, ev) {
        var _a = this, em = _a.em, events = _a.events, blocks = _a.blocks;
        var content = block.getContent ? block.getContent() : block;
        this._dragBlock = block;
        em.set({ dragResult: null, dragContent: content });
        [em, blocks].map(function (i) { return i.trigger(events.dragStart, block, ev); });
    };
    BlockManager.prototype.__drag = function (ev) {
        var _a = this, em = _a.em, events = _a.events, blocks = _a.blocks;
        var block = this._dragBlock;
        [em, blocks].map(function (i) { return i.trigger(events.drag, block, ev); });
    };
    BlockManager.prototype.__endDrag = function (opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, em = _a.em, events = _a.events, blocks = _a.blocks;
        var block = this._dragBlock;
        var cmp = opts.component || em.get('dragResult');
        delete this._dragBlock;
        if (cmp && block) {
            var oldKey = 'activeOnRender';
            var oldActive = cmp.get && cmp.get(oldKey);
            var toActive = block.get('activate') || oldActive;
            var toSelect = block.get('select');
            var first = (0,index_all.isArray)(cmp) ? cmp[0] : cmp;
            if (toSelect || (toActive && toSelect !== false)) {
                em.setSelected(first);
            }
            if (toActive) {
                first.trigger('active');
                oldActive && first.unset(oldKey);
            }
            if (block.get('resetId')) {
                first.onAll(function (cmp) { return cmp.resetId(); });
            }
        }
        em.set({ dragResult: null, dragContent: null });
        if (block) {
            [em, blocks].map(function (i) { return i.trigger(events.dragEnd, cmp, block); });
        }
    };
    BlockManager.prototype.__getFrameViews = function () {
        return this.em.Canvas.getFrames()
            .map(function (frame) { return frame.view; })
            .filter(Boolean);
    };
    BlockManager.prototype.__behaviour = function (opts) {
        if (opts === void 0) { opts = {}; }
        return (this._bhv = block_manager_assign(block_manager_assign({}, (this._bhv || {})), opts));
    };
    BlockManager.prototype.__getBehaviour = function () {
        return this._bhv || {};
    };
    BlockManager.prototype.startDrag = function (block, ev) {
        this.__startDrag(block, ev);
        this.__getFrameViews().forEach(function (fv) { var _a; return (_a = fv.droppable) === null || _a === void 0 ? void 0 : _a.startCustom(); });
    };
    BlockManager.prototype.endDrag = function (cancel) {
        this.__getFrameViews().forEach(function (fv) { var _a; return (_a = fv.droppable) === null || _a === void 0 ? void 0 : _a.endCustom(cancel); });
        this.__endDrag();
    };
    BlockManager.prototype.postRender = function () {
        var _a = this, categories = _a.categories, config = _a.config, em = _a.em;
        var collection = this.blocksVisible;
        this.blocksView = new view_BlocksView({ collection: collection, categories: categories }, block_manager_assign(block_manager_assign({}, config), { em: em }));
        this.__appendTo(collection.models);
        this.__trgCustom();
    };
    /**
     * Add new block.
     * @param {String} id Block ID
     * @param {[Block]} props Block properties
     * @returns {[Block]} Added block
     * @example
     * blockManager.add('h1-block', {
     *   label: 'Heading',
     *   content: '<h1>Put your title here</h1>',
     *   category: 'Basic',
     *   attributes: {
     *     title: 'Insert h1 block'
     *   }
     * });
     */
    BlockManager.prototype.add = function (id, props, opts) {
        if (opts === void 0) { opts = {}; }
        var prp = props || {};
        prp.id = id;
        return this.blocks.add(prp, opts);
    };
    /**
     * Get the block by id.
     * @param  {String} id Block id
     * @returns {[Block]}
     * @example
     * const block = blockManager.get('h1-block');
     * console.log(JSON.stringify(block));
     * // {label: 'Heading', content: '<h1>Put your ...', ...}
     */
    BlockManager.prototype.get = function (id) {
        return this.blocks.get(id);
    };
    /**
     * Return all blocks.
     * @returns {Collection<[Block]>}
     * @example
     * const blocks = blockManager.getAll();
     * console.log(JSON.stringify(blocks));
     * // [{label: 'Heading', content: '<h1>Put your ...'}, ...]
     */
    BlockManager.prototype.getAll = function () {
        return this.blocks;
    };
    /**
     * Return the visible collection, which containes blocks actually rendered
     * @returns {Collection<[Block]>}
     */
    BlockManager.prototype.getAllVisible = function () {
        return this.blocksVisible;
    };
    /**
     * Remove block.
     * @param {String|[Block]} block Block or block ID
     * @returns {[Block]} Removed block
     * @example
     * const removed = blockManager.remove('BLOCK_ID');
     * // or by passing the Block
     * const block = blockManager.get('BLOCK_ID');
     * blockManager.remove(block);
     */
    BlockManager.prototype.remove = function (block, opts) {
        if (opts === void 0) { opts = {}; }
        return this.__remove(block, opts);
    };
    /**
     * Get all available categories.
     * It's possible to add categories only within blocks via 'add()' method
     * @return {Array|Collection}
     */
    BlockManager.prototype.getCategories = function () {
        return this.categories;
    };
    /**
     * Return the Blocks container element
     * @return {HTMLElement}
     */
    BlockManager.prototype.getContainer = function () {
        var _a;
        return (_a = this.blocksView) === null || _a === void 0 ? void 0 : _a.el;
    };
    /**
     * Returns currently dragging block.
     * Updated when the drag starts and cleared once it's done.
     * @returns {[Block]|undefined}
     */
    BlockManager.prototype.getDragBlock = function () {
        return this._dragBlock;
    };
    /**
     * Render blocks
     * @param  {Array} blocks Blocks to render, without the argument will render all global blocks
     * @param  {Object} [opts={}] Options
     * @param  {Boolean} [opts.external] Render blocks in a new container (HTMLElement will be returned)
     * @param  {Boolean} [opts.ignoreCategories] Render blocks without categories
     * @return {HTMLElement} Rendered element
     * @example
     * // Render all blocks (inside the global collection)
     * blockManager.render();
     *
     * // Render new set of blocks
     * const blocks = blockManager.getAll();
     * const filtered = blocks.filter(block => block.get('category') == 'sections')
     *
     * blockManager.render(filtered);
     * // Or a new set from an array
     * blockManager.render([
     *  {label: 'Label text', content: '<div>Content</div>'}
     * ]);
     *
     * // Back to blocks from the global collection
     * blockManager.render();
     *
     * // You can also render your blocks outside of the main block container
     * const newBlocksEl = blockManager.render(filtered, { external: true });
     * document.getElementById('some-id').appendChild(newBlocksEl);
     */
    BlockManager.prototype.render = function (blocks, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, categories = _a.categories, config = _a.config, em = _a.em;
        var toRender = blocks || this.getAll().models;
        if (opts.external) {
            var collection = new model_Blocks(toRender);
            return new view_BlocksView({ collection: collection, categories: categories }, block_manager_assign(block_manager_assign({ em: em }, config), opts)).render().el;
        }
        if (this.blocksView) {
            this.blocksView.updateConfig(opts);
            this.blocksView.collection.reset(toRender);
            if (!this.blocksView.rendered) {
                this.blocksView.render();
                this.blocksView.rendered = true;
            }
        }
        return this.getContainer();
    };
    BlockManager.prototype.destroy = function () {
        var _a;
        var colls = [this.blocks, this.blocksVisible, this.categories];
        colls.map(function (c) { return c.stopListening(); });
        colls.map(function (c) { return c.reset(); });
        (_a = this.blocksView) === null || _a === void 0 ? void 0 : _a.remove();
    };
    return BlockManager;
}(ItemManagerModule));
/* harmony default export */ const block_manager = (BlockManager);

;// CONCATENATED MODULE: ./src/selector_manager/config/config.ts
var selector_manager_config_config_config = {
    stylePrefix: 'clm-',
    appendTo: '',
    selectors: [],
    states: [{ name: 'hover' }, { name: 'active' }, { name: 'nth-of-type(2n)' }],
    iconAdd: '<svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg>',
    iconSync: '<svg viewBox="0 0 24 24"><path d="M12 18c-3.31 0-6-2.69-6-6 0-1 .25-1.97.7-2.8L5.24 7.74A7.93 7.93 0 0 0 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4m0-11V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1-.25 1.97-.7 2.8l1.46 1.46A7.93 7.93 0 0 0 20 12c0-4.42-3.58-8-8-8z"></path></svg>',
    iconTagOn: '<svg viewBox="0 0 24 24"><path d="M19 19H5V5h10V3H5c-1.11 0-2 .89-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-8h-2m-11.09-.92L6.5 11.5 11 16 21 6l-1.41-1.42L11 13.17l-3.09-3.09z"></path></svg>',
    iconTagOff: '<svg viewBox="0 0 24 24"><path d="M19 3H5c-1.11 0-2 .89-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5a2 2 0 0 0-2-2m0 2v14H5V5h14z"></path></svg>',
    iconTagRemove: '<svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"></path></svg>',
    componentFirst: false,
    custom: false,
};
/* harmony default export */ const selector_manager_config_config = (selector_manager_config_config_config);

;// CONCATENATED MODULE: ./src/selector_manager/model/State.ts
var State_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

/**
 * @typedef State
 * @property {String} name State name, eg. `hover`, `nth-of-type(2n)`
 * @property {String} label State label, eg. `Hover`, `Even/Odd`
 */
var State = /** @class */ (function (_super) {
    State_extends(State, _super);
    function State() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    State.prototype.defaults = function () {
        return {
            name: '',
            label: '',
        };
    };
    /**
     * Get state name
     * @returns {String}
     */
    State.prototype.getName = function () {
        return this.get('name');
    };
    /**
     * Get state label. If label was not provided, the name will be returned.
     * @returns {String}
     */
    State.prototype.getLabel = function () {
        return this.get('label') || this.getName();
    };
    return State;
}(common/* Model */.Hn));
/* harmony default export */ const model_State = (State);
State.prototype.idAttribute = 'name';

;// CONCATENATED MODULE: ./src/selector_manager/view/ClassTagView.ts
var ClassTagView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ClassTagView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


var inputProp = 'contentEditable';
var ClassTagView = /** @class */ (function (_super) {
    ClassTagView_extends(ClassTagView, _super);
    function ClassTagView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        var config = o.config || {};
        _this.config = config;
        _this.module = o.module;
        _this.coll = o.coll || null;
        _this.pfx = config.stylePrefix || '';
        _this.ppfx = config.pStylePrefix || '';
        _this.em = config.em;
        _this.listenTo(_this.model, 'change:active', _this.updateStatus);
        return _this;
    }
    ClassTagView.prototype.template = function () {
        var _a = this, pfx = _a.pfx, model = _a.model, config = _a.config;
        var label = model.get('label') || '';
        return html(ClassTagView_templateObject_1 || (ClassTagView_templateObject_1 = ClassTagView_makeTemplateObject(["\n      <span id=\"", "checkbox\" class=\"", "tag-status\" data-tag-status></span>\n      <span id=\"", "tag-label\" data-tag-name>", "</span>\n      <span id=\"", "close\" class=\"", "tag-close\" data-tag-remove> $", " </span>\n    "], ["\n      <span id=\"", "checkbox\" class=\"", "tag-status\" data-tag-status></span>\n      <span id=\"", "tag-label\" data-tag-name>", "</span>\n      <span id=\"", "close\" class=\"", "tag-close\" data-tag-remove> $", " </span>\n    "])), pfx, pfx, pfx, label, pfx, pfx, config.iconTagRemove);
    };
    ClassTagView.prototype.events = function () {
        return {
            'click [data-tag-remove]': 'removeTag',
            'click [data-tag-status]': 'changeStatus',
            'dblclick [data-tag-name]': 'startEditTag',
            'focusout [data-tag-name]': 'endEditTag',
        };
    };
    /**
     * Returns the element which containes the anme of the tag
     * @return {HTMLElement}
     */
    ClassTagView.prototype.getInputEl = function () {
        if (!this.inputEl) {
            this.inputEl = this.el.querySelector('[data-tag-name]');
        }
        return this.inputEl;
    };
    /**
     * Start editing tag
     * @private
     */
    ClassTagView.prototype.startEditTag = function () {
        var em = this.em;
        var inputEl = this.getInputEl();
        inputEl[inputProp] = 'true';
        inputEl.focus();
        em === null || em === void 0 ? void 0 : em.setEditing(true);
    };
    /**
     * End editing tag. If the class typed already exists the
     * old one will be restored otherwise will be changed
     * @private
     */
    ClassTagView.prototype.endEditTag = function () {
        var _a = this, model = _a.model, em = _a.em;
        var inputEl = this.getInputEl();
        var label = inputEl.textContent || '';
        var sm = em === null || em === void 0 ? void 0 : em.Selectors;
        inputEl[inputProp] = 'false';
        em === null || em === void 0 ? void 0 : em.setEditing(false);
        if (sm && sm.rename(model, label) !== model) {
            inputEl.innerText = model.getLabel();
        }
    };
    /**
     * Update status of the tag
     * @private
     */
    ClassTagView.prototype.changeStatus = function () {
        var model = this.model;
        model.set('active', !model.getActive());
    };
    /**
     * Remove tag from the selected component
     * @param {Object} e
     * @private
     */
    ClassTagView.prototype.removeTag = function () {
        this.module.removeSelected(this.model);
    };
    /**
     * Update status of the checkbox
     * @private
     */
    ClassTagView.prototype.updateStatus = function () {
        var _a = this, model = _a.model, $el = _a.$el, config = _a.config;
        var iconTagOn = config.iconTagOn, iconTagOff = config.iconTagOff;
        var $chk = $el.find('[data-tag-status]');
        if (model.get('active')) {
            $chk.html(iconTagOn);
            $el.removeClass('opac50');
        }
        else {
            $chk.html(iconTagOff);
            $el.addClass('opac50');
        }
    };
    ClassTagView.prototype.render = function () {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx, $el = _a.$el, model = _a.model;
        var mainCls = "".concat(pfx, "tag");
        var classes = ["".concat(mainCls, " ").concat(ppfx, "three-bg")];
        model.get('protected') && classes.push("".concat(mainCls, "-protected"));
        $el.html(this.template());
        $el.attr('class', classes.join(' '));
        this.updateStatus();
        return this;
    };
    return ClassTagView;
}(common/* View */.G7));
/* harmony default export */ const view_ClassTagView = (ClassTagView);
var ClassTagView_templateObject_1;

;// CONCATENATED MODULE: ./src/selector_manager/view/ClassTagsView.ts
var ClassTagsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ClassTagsView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};




var ClassTagsView = /** @class */ (function (_super) {
    ClassTagsView_extends(ClassTagsView, _super);
    function ClassTagsView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        _this.config = o.config || {};
        _this.pfx = _this.config.stylePrefix || '';
        _this.ppfx = _this.config.pStylePrefix || '';
        _this.className = _this.pfx + 'tags';
        _this.stateInputId = _this.pfx + 'states';
        _this.stateInputC = _this.pfx + 'input-c';
        _this.states = _this.config.states || [];
        var em = _this.config.em;
        var coll = _this.collection;
        _this.target = em;
        var md = em.Selectors;
        _this.module = md;
        _this.em = em;
        _this.componentChanged = (0,index_all.debounce)(_this.componentChanged.bind(_this), 0);
        _this.checkSync = (0,index_all.debounce)(_this.checkSync.bind(_this), 0);
        var toList = 'component:toggled component:update:classes';
        var toListCls = 'component:update:classes change:state';
        _this.listenTo(em, toList, _this.componentChanged);
        _this.listenTo(em, 'styleManager:update', _this.componentChanged);
        _this.listenTo(em, toListCls, _this.__handleStateChange);
        _this.listenTo(em, 'styleable:change change:device', _this.checkSync);
        _this.listenTo(coll, 'add', _this.addNew);
        _this.listenTo(coll, 'reset', _this.renderClasses);
        _this.listenTo(coll, 'remove', _this.tagRemoved);
        _this.listenTo(md.getAll(), md.events.state, (0,index_all.debounce)(function () { return _this.renderStates(); }, 0));
        _this.delegateEvents();
        return _this;
    }
    ClassTagsView.prototype.template = function (_a) {
        var labelInfo = _a.labelInfo, labelHead = _a.labelHead, iconSync = _a.iconSync, iconAdd = _a.iconAdd, pfx = _a.pfx, ppfx = _a.ppfx;
        return html(ClassTagsView_templateObject_1 || (ClassTagsView_templateObject_1 = ClassTagsView_makeTemplateObject([" <div id=\"", "up\" class=\"", "header\">\n        <div id=\"", "label\" class=\"", "header-label\">", "</div>\n        <div id=\"", "status-c\" class=\"", "header-status\">\n          <span id=\"", "input-c\" data-states-c>\n            <div class=\"", "field ", "select\">\n              <span id=\"", "input-holder\">\n                <select id=\"", "states\" data-states></select>\n              </span>\n              <div class=\"", "sel-arrow\">\n                <div class=\"", "d-s-arrow\"></div>\n              </div>\n            </div>\n          </span>\n        </div>\n      </div>\n      <div id=\"", "tags-field\" class=\"", "field\">\n        <div id=\"", "tags-c\" data-selectors></div>\n        <input id=\"", "new\" data-input />\n        <span id=\"", "add-tag\" class=\"", "tags-btn ", "tags-btn__add\" data-add> $", " </span>\n        <span class=\"", "tags-btn ", "tags-btn__sync\" style=\"display: none\" data-sync-style> $", " </span>\n      </div>\n      <div class=\"", "sels-info\">\n        <div class=\"", "label-sel\">", ":</div>\n        <div class=\"", "sels\" data-selected></div>\n      </div>"], [" <div id=\"", "up\" class=\"", "header\">\n        <div id=\"", "label\" class=\"", "header-label\">", "</div>\n        <div id=\"", "status-c\" class=\"", "header-status\">\n          <span id=\"", "input-c\" data-states-c>\n            <div class=\"", "field ", "select\">\n              <span id=\"", "input-holder\">\n                <select id=\"", "states\" data-states></select>\n              </span>\n              <div class=\"", "sel-arrow\">\n                <div class=\"", "d-s-arrow\"></div>\n              </div>\n            </div>\n          </span>\n        </div>\n      </div>\n      <div id=\"", "tags-field\" class=\"", "field\">\n        <div id=\"", "tags-c\" data-selectors></div>\n        <input id=\"", "new\" data-input />\n        <span id=\"", "add-tag\" class=\"", "tags-btn ", "tags-btn__add\" data-add> $", " </span>\n        <span class=\"", "tags-btn ", "tags-btn__sync\" style=\"display: none\" data-sync-style> $", " </span>\n      </div>\n      <div class=\"", "sels-info\">\n        <div class=\"", "label-sel\">", ":</div>\n        <div class=\"", "sels\" data-selected></div>\n      </div>"])), pfx, pfx, pfx, pfx, labelHead, pfx, pfx, pfx, ppfx, ppfx, ppfx, pfx, ppfx, ppfx, pfx, ppfx, pfx, pfx, pfx, pfx, pfx, iconAdd, pfx, pfx, iconSync, pfx, pfx, labelInfo, pfx);
    };
    ClassTagsView.prototype.events = function () {
        return {
            'change [data-states]': 'stateChanged',
            'click [data-add]': 'startNewTag',
            'focusout [data-input]': 'endNewTag',
            'keyup [data-input]': 'onInputKeyUp',
            'click [data-sync-style]': 'syncStyle',
        };
    };
    ClassTagsView.prototype.syncStyle = function () {
        var em = this.em;
        var target = this.getTarget();
        var cssC = em.Css;
        var opts = { noDisabled: 1 };
        var selectors = this.getCommonSelectors({ opts: opts });
        var state = em.get('state');
        var mediaText = em.getCurrentMedia();
        var ruleComponents = [];
        var rule = cssC.get(selectors, state, mediaText) || cssC.add(selectors, state, mediaText);
        var style;
        this.getTargets().forEach(function (target) {
            var ruleComponent = cssC.getIdRule(target.getId(), {
                state: state,
                mediaText: mediaText,
            });
            style = ruleComponent.getStyle();
            ruleComponent.setStyle({});
            ruleComponents.push(ruleComponent);
        });
        style && rule.addStyle(style);
        em.trigger('component:toggled');
        em.trigger('component:sync-style', {
            component: target,
            selectors: selectors,
            mediaText: mediaText,
            rule: rule,
            ruleComponents: ruleComponents,
            state: state,
        });
    };
    /**
     * Triggered when a tag is removed from collection
     * @param {Object} model Removed model
     * @private
     */
    ClassTagsView.prototype.tagRemoved = function (model) {
        this.updateStateVis();
    };
    /**
     * Add new model
     * @param {Object} model
     * @private
     */
    ClassTagsView.prototype.addNew = function (model) {
        this.addToClasses(model);
    };
    /**
     * Start tag creation
     * @param {Object} e
     * @private
     */
    ClassTagsView.prototype.startNewTag = function () {
        var _a, _b;
        (_a = this.$addBtn) === null || _a === void 0 ? void 0 : _a.css({ display: 'none' });
        (_b = this.$input) === null || _b === void 0 ? void 0 : _b.show().focus();
    };
    /**
     * End tag creation
     * @param {Object} e
     * @private
     */
    ClassTagsView.prototype.endNewTag = function () {
        var _a, _b;
        (_a = this.$addBtn) === null || _a === void 0 ? void 0 : _a.css({ display: '' });
        (_b = this.$input) === null || _b === void 0 ? void 0 : _b.hide().val('');
    };
    /**
     * Checks what to do on keyup event
     * @param  {Object} e
     * @private
     */
    ClassTagsView.prototype.onInputKeyUp = function (e) {
        var _a;
        if (e.keyCode === 13) {
            e.preventDefault();
            this.addNewTag((_a = this.$input) === null || _a === void 0 ? void 0 : _a.val());
        }
        else if (e.keyCode === 27) {
            this.endNewTag();
        }
    };
    ClassTagsView.prototype.checkStates = function () {
        var state = this.em.getState();
        var statesEl = this.getStates();
        statesEl && statesEl.val(state);
    };
    /**
     * Triggered when component is changed
     * @param  {Object} e
     * @public
     */
    ClassTagsView.prototype.componentChanged = function (_a) {
        var _b = _a === void 0 ? {} : _a, targets = _b.targets;
        this.updateSelection(targets);
    };
    ClassTagsView.prototype.updateSelection = function (targets) {
        var trgs = targets || this.getTargets();
        trgs = (0,index_all.isArray)(trgs) ? trgs : [trgs];
        var selectors = [];
        if (trgs && trgs.length) {
            selectors = this.getCommonSelectors({ targets: trgs });
            //@ts-ignore TODO This parameters are not in use why do we have them?
            this.checkSync({ validSelectors: selectors });
        }
        this.collection.reset(selectors);
        this.updateStateVis(trgs);
        this.module.__trgCustom();
        return selectors;
    };
    ClassTagsView.prototype.getCommonSelectors = function (_a) {
        var _b = _a === void 0 ? {} : _a, targets = _b.targets, _c = _b.opts, opts = _c === void 0 ? {} : _c;
        var trgs = targets || this.getTargets();
        return this.module.__getCommonSelectors(trgs, opts);
    };
    ClassTagsView.prototype._commonSelectors = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this.module).__common.apply(_a, args);
    };
    ClassTagsView.prototype.checkSync = function () {
        var _a = this, $btnSyncEl = _a.$btnSyncEl, config = _a.config, collection = _a.collection;
        var target = this.getTarget();
        var hasStyle;
        if (target && config.componentFirst && collection.length) {
            var style = target.getStyle();
            hasStyle = !(0,index_all.isEmpty)(style);
        }
        $btnSyncEl && $btnSyncEl[hasStyle ? 'show' : 'hide']();
    };
    ClassTagsView.prototype.getTarget = function () {
        return this.target.getSelected();
    };
    ClassTagsView.prototype.getTargets = function () {
        return this.target.getSelectedAll();
    };
    /**
     * Update states visibility. Hides states in case there is no tags
     * inside collection
     * @private
     */
    ClassTagsView.prototype.updateStateVis = function (targets) {
        var em = this.em;
        var avoidInline = em && em.getConfig().avoidInlineStyle;
        var display = this.collection.length || avoidInline ? '' : 'none';
        this.getStatesC().css('display', display);
        this.updateSelector(targets);
    };
    ClassTagsView.prototype.__handleStateChange = function () {
        this.updateSelector(this.getTargets());
    };
    /**
     * Update selector helper
     * @return {this}
     * @private
     */
    ClassTagsView.prototype.updateSelector = function (targets) {
        var _this = this;
        var elSel = this.el.querySelector('[data-selected]');
        var result = [];
        var trgs = targets || this.getTargets();
        trgs = (0,index_all.isArray)(trgs) ? trgs : [trgs];
        trgs.forEach(function (target) { return result.push(_this.__getName(target)); });
        elSel && (elSel.innerHTML = result.join(', '));
        this.checkStates();
    };
    ClassTagsView.prototype.__getName = function (target) {
        var _a = this, pfx = _a.pfx, config = _a.config, em = _a.em;
        var selectedName = config.selectedName, componentFirst = config.componentFirst;
        var result;
        if ((0,index_all.isString)(target)) {
            result = html(templateObject_2 || (templateObject_2 = ClassTagsView_makeTemplateObject(["<span class=\"", "sel-gen\">", "</span>"], ["<span class=\"", "sel-gen\">", "</span>"])), pfx, target);
        }
        else {
            var sel = target === null || target === void 0 ? void 0 : target.getSelectors();
            if (!sel)
                return '';
            var selectors = sel.getStyleable();
            var state = em.get('state');
            var idRes = target.getId
                ? html(templateObject_3 || (templateObject_3 = ClassTagsView_makeTemplateObject(["<span class=\"", "sel-cmp\">", "</span>\n            <span class=\"", "sel-id\">#", "</span>"], ["<span class=\"", "sel-cmp\">", "</span>\n            <span class=\"", "sel-id\">#", "</span>"])), pfx, target.getName(), pfx, target.getId()) : '';
            result = this.collection.getFullString(selectors);
            result = result ? html(templateObject_4 || (templateObject_4 = ClassTagsView_makeTemplateObject(["<span class=\"", "sel-rule\">", "</span>"], ["<span class=\"", "sel-rule\">", "</span>"])), pfx, result) : target.get('selectorsAdd') || idRes;
            result = componentFirst && idRes ? idRes : result;
            result += state ? html(templateObject_5 || (templateObject_5 = ClassTagsView_makeTemplateObject(["<span class=\"", "sel-state\">:", "</span>"], ["<span class=\"", "sel-state\">:", "</span>"])), pfx, state) : '';
            result = selectedName ? selectedName({ result: result, state: state, target: target }) : result;
        }
        return result && "<span class=\"".concat(pfx, "sel\">").concat(result, "</span>");
    };
    /**
     * Triggered when the select with states is changed
     * @param  {Object} e
     * @private
     */
    ClassTagsView.prototype.stateChanged = function (ev) {
        var em = this.em;
        var value = ev.target.value;
        em.set('state', value);
    };
    /**
     * Add new tag to collection, if possible, and to the component
     * @param  {Object} e
     * @private
     */
    ClassTagsView.prototype.addNewTag = function (value) {
        var label = value.trim();
        if (!label)
            return;
        this.module.addSelected({ label: label });
        this.endNewTag();
        // this.updateStateVis(); // Check if required
    };
    /**
     * Add new object to collection
     * @param   {Object} model  Model
     * @param   {Object} fragmentEl   Fragment collection
     * @return {Object} Object created
     * @private
     * */
    ClassTagsView.prototype.addToClasses = function (model, fragmentEl) {
        var fragment = fragmentEl;
        var classes = this.getClasses();
        var rendered = new view_ClassTagView({
            model: model,
            config: this.config,
            coll: this.collection,
            module: this.module,
        }).render().el;
        fragment ? fragment.appendChild(rendered) : classes.append(rendered);
        return rendered;
    };
    /**
     * Render the collection of classes
     * @private
     */
    ClassTagsView.prototype.renderClasses = function () {
        var _this = this;
        var frag = document.createDocumentFragment();
        var classes = this.getClasses();
        classes.empty();
        this.collection.each(function (model) { return _this.addToClasses(model, frag); });
        classes.append(frag);
    };
    /**
     * Return classes element
     * @return {HTMLElement}
     * @private
     */
    ClassTagsView.prototype.getClasses = function () {
        return this.$el.find('[data-selectors]');
    };
    /**
     * Return states element
     * @return {HTMLElement}
     * @private
     */
    ClassTagsView.prototype.getStates = function () {
        if (!this.$states) {
            var el = this.$el.find('[data-states]');
            this.$states = el[0] && el;
        }
        return this.$states;
    };
    /**
     * Return states container element
     * @return {HTMLElement}
     * @private
     */
    ClassTagsView.prototype.getStatesC = function () {
        if (!this.$statesC)
            this.$statesC = this.$el.find('#' + this.stateInputC);
        return this.$statesC;
    };
    ClassTagsView.prototype.renderStates = function () {
        var _a = this, module = _a.module, em = _a.em;
        var labelStates = em.t('selectorManager.emptyState');
        var options = module
            .getStates()
            .map(function (state) {
            var label = em.t("selectorManager.states.".concat(state.id)) || state.getLabel() || state.id;
            return "<option value=\"".concat(state.id, "\">").concat(label, "</option>");
        })
            .join('');
        var statesEl = this.getStates();
        statesEl && statesEl.html("<option value=\"\">".concat(labelStates, "</option>").concat(options));
        this.checkStates();
    };
    ClassTagsView.prototype.render = function () {
        var _a = this, em = _a.em, pfx = _a.pfx, ppfx = _a.ppfx, config = _a.config, $el = _a.$el, el = _a.el;
        var render = config.render, iconSync = config.iconSync, iconAdd = config.iconAdd;
        var tmpOpts = {
            iconSync: iconSync,
            iconAdd: iconAdd,
            labelHead: em.t('selectorManager.label'),
            labelInfo: em.t('selectorManager.selected'),
            ppfx: ppfx,
            pfx: pfx,
            el: el,
        };
        $el.html(this.template(tmpOpts));
        var renderRes = render && render(tmpOpts);
        renderRes && renderRes !== el && $el.empty().append(renderRes);
        this.$input = $el.find('[data-input]');
        this.$addBtn = $el.find('[data-add]');
        this.$classes = $el.find('#' + pfx + 'tags-c');
        this.$btnSyncEl = $el.find('[data-sync-style]');
        this.$input.hide();
        this.renderStates();
        this.renderClasses();
        $el.attr('class', "".concat(this.className, " ").concat(ppfx, "one-bg ").concat(ppfx, "two-color"));
        return this;
    };
    return ClassTagsView;
}(common/* View */.G7));
/* harmony default export */ const view_ClassTagsView = (ClassTagsView);
var ClassTagsView_templateObject_1, templateObject_2, templateObject_3, templateObject_4, templateObject_5;

;// CONCATENATED MODULE: ./src/selector_manager/index.ts
/**
 * Selectors in GrapesJS are used in CSS Composer inside Rules and in Components as classes. To illustrate this concept let's take
 * a look at this code:
 *
 * ```css
 * span > #send-btn.btn{
 *  ...
 * }
 * ```
 * ```html
 * <span>
 *   <button id="send-btn" class="btn"></button>
 * </span>
 * ```
 *
 * In this scenario we get:
 * * span     -> selector of type `tag`
 * * send-btn -> selector of type `id`
 * * btn      -> selector of type `class`
 *
 * So, for example, being `btn` the same class entity it'll be easier to refactor and track things.
 *
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/selector_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  selectorManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('selector:add', (selector) => { ... });
 *
 * // Use the API
 * const sm = editor.Selectors;
 * sm.add(...);
 * ```
 *
 * ## Available Events
 * * `selector:add` - Selector added. The [Selector] is passed as an argument to the callback.
 * * `selector:remove` - Selector removed. The [Selector] is passed as an argument to the callback.
 * * `selector:update` - Selector updated. The [Selector] and the object containing changes are passed as arguments to the callback.
 * * `selector:state` - States changed. An object containing all the available data about the triggered event is passed as an argument to the callback.
 * * `selector` - Catch-all event for all the events mentioned above. An object containing all the available data about the triggered event is passed as an argument to the callback.
 *
 * ## Methods
 * * [getConfig](#getconfig)
 * * [add](#add)
 * * [get](#get)
 * * [remove](#remove)
 * * [rename](#rename)
 * * [getAll](#getall)
 * * [setState](#setstate)
 * * [getState](#getstate)
 * * [getStates](#getstates)
 * * [setStates](#setstates)
 * * [getSelected](#getselected)
 * * [addSelected](#addselected)
 * * [removeSelected](#removeselected)
 * * [getSelectedTargets](#getselectedtargets)
 * * [setComponentFirst](#setcomponentfirst)
 * * [getComponentFirst](#getcomponentfirst)
 *
 * [Selector]: selector.html
 * [State]: state.html
 * [Component]: component.html
 * [CssRule]: css_rule.html
 *
 * @module Selectors
 */
var selector_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var selector_manager_assign = (undefined && undefined.__assign) || function () {
    selector_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return selector_manager_assign.apply(this, arguments);
};
var selector_manager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};









var isId = function (str) { return (0,index_all.isString)(str) && str[0] == '#'; };
var isClass = function (str) { return (0,index_all.isString)(str) && str[0] == '.'; };
var selector_manager_evAll = 'selector';
var selector_manager_evPfx = "".concat(selector_manager_evAll, ":");
var selector_manager_evAdd = "".concat(selector_manager_evPfx, "add");
var selector_manager_evUpdate = "".concat(selector_manager_evPfx, "update");
var selector_manager_evRemove = "".concat(selector_manager_evPfx, "remove");
var selector_manager_evRemoveBefore = "".concat(selector_manager_evRemove, ":before");
var evCustom = "".concat(selector_manager_evPfx, "custom");
var evState = "".concat(selector_manager_evPfx, "state");
var selectorEvents = {
    all: selector_manager_evAll,
    update: selector_manager_evUpdate,
    add: selector_manager_evAdd,
    remove: selector_manager_evRemove,
    removeBefore: selector_manager_evRemoveBefore,
    state: evState,
    custom: evCustom,
};
var SelectorManager = /** @class */ (function (_super) {
    selector_manager_extends(SelectorManager, _super);
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    function SelectorManager(em) {
        var _this = _super.call(this, em, 'SelectorManager', new model_Selectors([]), selectorEvents, selector_manager_config_config, { skipListen: true }) || this;
        _this.Selector = model_Selector;
        _this.Selectors = model_Selectors;
        _this.storageKey = '';
        (0,index_all.bindAll)(_this, '__updateSelectedByComponents');
        var config = _this.config;
        var ppfx = config.pStylePrefix;
        if (ppfx)
            config.stylePrefix = ppfx + config.stylePrefix;
        // Global selectors container
        _this.all = new model_Selectors(config.selectors);
        _this.selected = new model_Selectors([], { em: em, config: config });
        _this.states = new common/* Collection */.FE(config.states.map(function (state) { return new model_State(state); }), { model: model_State });
        _this.model = new common/* Model */.Hn({ cFirst: config.componentFirst, _undo: true });
        _this.__update = (0,index_all.debounce)(function () { return _this.__trgCustom(); }, 0);
        _this.__initListen({
            collections: [_this.states, _this.selected],
            propagate: [{ entity: _this.states, event: _this.events.state }],
        });
        em.on('change:state', function (m, value) { return em.trigger(evState, value); });
        _this.model.on('change:cFirst', function (m, value) { return em.trigger('selector:type', value); });
        em.on('component:toggled component:update:classes', _this.__updateSelectedByComponents);
        var listenTo = 'component:toggled component:update:classes change:device styleManager:update selector:state selector:type style:target';
        _this.model.listenTo(em, listenTo, function () { return _this.__update(); });
        return _this;
    }
    SelectorManager.prototype.__trgCustom = function (opts) {
        this.em.trigger(this.events.custom, this.__customData(opts));
    };
    SelectorManager.prototype.getAll = function (opts) {
        if (opts === void 0) { opts = {}; }
        return (this.all ? (opts.array ? selector_manager_spreadArray([], this.all.models, true) : this.all) : []);
    };
    SelectorManager.prototype.__customData = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.__ctn = this.__ctn || opts.container;
        return {
            states: this.getStates(),
            selected: this.getSelected(),
            container: this.__ctn,
        };
    };
    // postLoad() {
    //   this.__postLoad();
    //   const { em, model } = this;
    //   const um = em.get('UndoManager');
    //   um && um.add(model);
    //   um && um.add(this.pages);
    // },
    SelectorManager.prototype.postRender = function () {
        this.__appendTo();
        this.__trgCustom();
    };
    SelectorManager.prototype.select = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var targets = Array.isArray(value) ? value : [value];
        var toSelect = this.em.Styles.select(targets, opts);
        this.selected.reset(this.__getCommonSelectors(toSelect));
        var selTags = this.selectorTags;
        var res = toSelect
            .filter(function (i) { return i; })
            .map(function (sel) { return ((0,mixins.isComponent)(sel) ? sel : (0,mixins.isRule)(sel) && !sel.get('selectorsAdd') ? sel : sel.getSelectorsString()); });
        selTags && selTags.componentChanged({ targets: res });
        return this;
    };
    SelectorManager.prototype.addSelector = function (name, opts, cOpts) {
        if (opts === void 0) { opts = {}; }
        if (cOpts === void 0) { cOpts = {}; }
        var props = selector_manager_assign({}, opts);
        if ((0,index_all.isObject)(name)) {
            props = name;
        }
        else {
            props.name = name;
        }
        if (isId(props.name)) {
            props.name = props.name.substr(1);
            props.type = model_Selector.TYPE_ID;
        }
        else if (isClass(props.name)) {
            props.name = props.name.substr(1);
        }
        if (props.label && !props.name) {
            props.name = this.escapeName(props.label);
        }
        var cname = props.name;
        var config = this.getConfig();
        var _a = this, all = _a.all, em = _a.em;
        var selector = cname ? this.get(cname, props.type) : all.where(props)[0];
        if (!selector) {
            var selModel = props instanceof model_Selector ? props : new model_Selector(props, selector_manager_assign(selector_manager_assign({}, cOpts), { config: config, em: em }));
            return all.add(selModel, cOpts);
        }
        return selector;
    };
    SelectorManager.prototype.getSelector = function (name, type) {
        if (type === void 0) { type = model_Selector.TYPE_CLASS; }
        if (isId(name)) {
            name = name.substr(1);
            type = model_Selector.TYPE_ID;
        }
        else if (isClass(name)) {
            name = name.substr(1);
        }
        return this.all.where({ name: name, type: type })[0];
    };
    /**
     * Add a new selector to the collection if it does not already exist.
     * You can pass selectors properties or string identifiers.
     * @param {Object|String} props Selector properties or string identifiers, eg. `{ name: 'my-class', label: 'My class' }`, `.my-cls`
     * @param {Object} [opts] Selector options
     * @return {[Selector]}
     * @example
     * const selector = selectorManager.add({ name: 'my-class', label: 'My class' });
     * console.log(selector.toString()) // `.my-class`
     * // Same as
     * const selector = selectorManager.add('.my-class');
     * console.log(selector.toString()) // `.my-class`
     * */
    SelectorManager.prototype.add = function (props, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var cOpts = (0,index_all.isString)(props) ? {} : opts;
        // Keep support for arrays but avoid it in docs
        if ((0,index_all.isArray)(props)) {
            return props.map(function (item) { return _this.addSelector(item, opts, cOpts); });
        }
        else {
            return this.addSelector(props, opts, cOpts);
        }
    };
    /**
     * Add class selectors
     * @param {Array|string} classes Array or string of classes
     * @return {Array} Array of added selectors
     * @private
     * @example
     * sm.addClass('class1');
     * sm.addClass('class1 class2');
     * sm.addClass(['class1', 'class2']);
     * // -> [SelectorObject, ...]
     */
    SelectorManager.prototype.addClass = function (classes) {
        var _this = this;
        var added = [];
        if ((0,index_all.isString)(classes)) {
            classes = classes.trim().split(' ');
        }
        classes.forEach(function (name) { return added.push(_this.addSelector(name)); });
        return added;
    };
    /**
     * Get the selector by its name/type
     * @param {String} name Selector name or string identifier
     * @returns {[Selector]|null}
     * @example
     * const selector = selectorManager.get('.my-class');
     * // Get Id
     * const selectorId = selectorManager.get('#my-id');
     * */
    SelectorManager.prototype.get = function (name, type) {
        var _this = this;
        // Keep support for arrays but avoid it in docs
        if ((0,index_all.isArray)(name)) {
            var result_1 = [];
            var selectors = name.map(function (item) { return _this.getSelector(item); }).filter(Boolean);
            selectors.forEach(function (item) { return result_1.indexOf(item) < 0 && result_1.push(item); });
            // @ts-ignore
            return result_1;
        }
        else {
            // @ts-ignore
            return this.getSelector(name, type);
        }
    };
    /**
     * Remove Selector.
     * @param {String|[Selector]} selector Selector instance or Selector string identifier
     * @returns {[Selector]} Removed Selector
     * @example
     * const removed = selectorManager.remove('.myclass');
     * // or by passing the Selector
     * selectorManager.remove(selectorManager.get('.myclass'));
     */
    SelectorManager.prototype.remove = function (selector, opts) {
        return this.__remove(selector, opts);
    };
    /**
     * Rename Selector.
     * @param {[Selector]} selector Selector to update.
     * @param {String} name New name for the selector.
     * @returns {[Selector]} Selector containing the passed name.
     * @example
     * const selector = selectorManager.get('myclass');
     * const result = selectorManager.rename(selector, 'myclass2');
     * console.log(result === selector ? 'Selector updated' : 'Selector with this name exists already');
     */
    SelectorManager.prototype.rename = function (selector, name, opts) {
        var newName = this.escapeName(name);
        var result = this.get(newName);
        return result || selector.set({ name: newName, label: name }, opts);
    };
    /**
     * Change the selector state
     * @param {String} value State value
     * @returns {this}
     * @example
     * selectorManager.setState('hover');
     */
    SelectorManager.prototype.setState = function (value) {
        this.em.setState(value);
        return this;
    };
    /**
     * Get the current selector state value
     * @returns {String}
     */
    SelectorManager.prototype.getState = function () {
        return this.em.getState();
    };
    /**
     * Get states
     * @returns {Array<[State]>}
     */
    SelectorManager.prototype.getStates = function () {
        return selector_manager_spreadArray([], this.states.models, true);
    };
    /**
     * Set a new collection of states
     * @param {Array<Object>} states Array of new states
     * @returns {Array<[State]>}
     * @example
     * const states = selectorManager.setStates([
     *   { name: 'hover', label: 'Hover' },
     *   { name: 'nth-of-type(2n)', label: 'Even/Odd' }
     * ]);
     */
    SelectorManager.prototype.setStates = function (states, opts) {
        return this.states.reset(states.map(function (state) { return new model_State(state); }), opts);
    };
    /**
     * Get commonly selected selectors, based on all selected components.
     * @returns {Array<[Selector]>}
     * @example
     * const selected = selectorManager.getSelected();
     * console.log(selected.map(s => s.toString()))
     */
    SelectorManager.prototype.getSelected = function () {
        return this.__getCommon();
    };
    /**
     * Get selected selectors.
     * @returns {Array<[Selector]>}
     * @example
     * const selected = selectorManager.getSelectedAll();
     * console.log(selected.map(s => s.toString()))
     */
    SelectorManager.prototype.getSelectedAll = function () {
        return selector_manager_spreadArray([], this.selected.models, true);
    };
    /**
     * Add new selector to all selected components.
     * @param {Object|String} props Selector properties or string identifiers, eg. `{ name: 'my-class', label: 'My class' }`, `.my-cls`
     * @example
     * selectorManager.addSelected('.new-class');
     */
    SelectorManager.prototype.addSelected = function (props) {
        var added = this.add(props);
        this.em.getSelectedAll().forEach(function (target) {
            target.getSelectors().add(added);
        });
        // TODO: update selected collection
    };
    /**
     * Remove a common selector from all selected components.
     * @param {String|[Selector]} selector Selector instance or Selector string identifier
     * @example
     * selectorManager.removeSelected('.myclass');
     */
    SelectorManager.prototype.removeSelected = function (selector) {
        this.em.getSelectedAll().forEach(function (trg) {
            !selector.get('protected') && trg && trg.getSelectors().remove(selector);
        });
    };
    SelectorManager.prototype.duplicateSelected = function (selector, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var commonSelectors = this.getSelected();
        if (commonSelectors.indexOf(selector) < 0)
            return;
        var state = this.getState();
        var media = em.getCurrentMedia();
        var rule = em.Css.get(commonSelectors, state, media);
        var styleToApply = rule === null || rule === void 0 ? void 0 : rule.getStyle();
        em.getSelectedAll().forEach(function (component) {
            var selectors = component.getSelectors();
            if (selectors.includes(selector)) {
                var suffix = opts.suffix || ' copy';
                var label = selector.getLabel();
                var newSelector = _this.addSelector("".concat(label).concat(suffix));
                var at = selectors.indexOf(selector);
                selectors.remove(selector);
                selectors.add(newSelector, { at: at });
            }
        });
        if (styleToApply) {
            var newRule = em.Css.add(this.getSelected(), state, media);
            newRule.setStyle(styleToApply);
        }
    };
    /**
     * Get the array of currently selected targets.
     * @returns {Array<[Component]|[CssRule]>}
     * @example
     * const targetsToStyle = selectorManager.getSelectedTargets();
     * console.log(targetsToStyle.map(target => target.getSelectorsString()))
     */
    SelectorManager.prototype.getSelectedTargets = function () {
        return this.em.Styles.getSelectedAll();
    };
    /**
     * Update component-first option.
     * If the component-first is enabled, all the style changes will be applied on selected components (ID rules) instead
     * of selectors (which would change styles on all components with those classes).
     * @param {Boolean} value
     */
    SelectorManager.prototype.setComponentFirst = function (value) {
        this.getConfig().componentFirst = value;
        this.model.set({ cFirst: value });
    };
    /**
     * Get the value of component-first option.
     * @return {Boolean}
     */
    SelectorManager.prototype.getComponentFirst = function () {
        return this.getConfig().componentFirst;
    };
    /**
     * Get all selectors
     * @name getAll
     * @function
     * @return {Collection<[Selector]>}
     * */
    /**
     * Return escaped selector name
     * @param {String} name Selector name to escape
     * @returns {String} Escaped name
     * @private
     */
    SelectorManager.prototype.escapeName = function (name) {
        var escapeName = this.getConfig().escapeName;
        return escapeName ? escapeName(name) : model_Selector.escapeName(name);
    };
    /**
     * Render class selectors. If an array of selectors is provided a new instance of the collection will be rendered
     * @param {Array<Object>} selectors
     * @return {HTMLElement}
     * @private
     */
    SelectorManager.prototype.render = function (selectors) {
        var selectorTags = this.selectorTags;
        var config = this.getConfig();
        var el = selectorTags === null || selectorTags === void 0 ? void 0 : selectorTags.el;
        this.selected.reset(selectors);
        this.selectorTags = new view_ClassTagsView({
            el: el,
            collection: this.selected,
            //@ts-ignore
            module: this,
            config: config,
        });
        return this.selectorTags.render().el;
    };
    SelectorManager.prototype.destroy = function () {
        var _a = this, selectorTags = _a.selectorTags, model = _a.model;
        model.stopListening();
        this.__update.cancel();
        this.__destroy();
        selectorTags === null || selectorTags === void 0 ? void 0 : selectorTags.remove();
        this.selectorTags = undefined;
    };
    /**
     * Get common selectors from the current selection.
     * @return {Array<Selector>}
     * @private
     */
    SelectorManager.prototype.__getCommon = function () {
        return this.__getCommonSelectors(this.em.getSelectedAll());
    };
    SelectorManager.prototype.__getCommonSelectors = function (components, opts) {
        if (opts === void 0) { opts = {}; }
        var selectors = components.map(function (cmp) { return cmp.getSelectors && cmp.getSelectors().getValid(opts); }).filter(Boolean);
        return this.__common.apply(this, selectors);
    };
    SelectorManager.prototype.__common = function () {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!args.length)
            return [];
        if (args.length === 1)
            return args[0];
        if (args.length === 2)
            return args[0].filter(function (item) { return args[1].indexOf(item) >= 0; });
        return (args
            .slice(1)
            //@ts-ignore
            .reduce(function (acc, item) { return _this.__common(acc, item); }, args[0]));
    };
    SelectorManager.prototype.__updateSelectedByComponents = function () {
        this.selected.reset(this.__getCommon());
    };
    return SelectorManager;
}(ItemManagerModule));
/* harmony default export */ const selector_manager = (SelectorManager);

;// CONCATENATED MODULE: ./src/parser/config/config.ts
var parser_config_config_config = {
    textTags: ['br', 'b', 'i', 'u', 'a', 'ul', 'ol'],
    parserCss: undefined,
    parserHtml: undefined,
    optionsHtml: {
        htmlType: 'text/html',
        allowScripts: false,
        allowUnsafeAttr: false,
        keepEmptyTextNodes: false,
    },
};
/* harmony default export */ const parser_config_config = (parser_config_config_config);

;// CONCATENATED MODULE: ./src/parser/model/BrowserParserCss.ts
var BrowserParserCss_a;

/** @see https://developer.mozilla.org/en-US/docs/Web/API/CSSRule/type */
var CSS_RULE_TYPES = {
    STYLE_RULE: 1,
    CHARSET_RULE: 2,
    IMPORT_RULE: 3,
    MEDIA_RULE: 4,
    FONT_FACE_RULE: 5,
    PAGE_RULE: 6,
    KEYFRAMES_RULE: 7,
    KEYFRAME_RULE: 8,
    NAMESPACE_RULE: 10,
    COUNTER_STYLE_RULE: 11,
    SUPPORTS_RULE: 12,
    DOCUMENT_RULE: 13,
    FONT_FEATURE_VALUES_RULE: 14,
    VIEWPORT_RULE: 15,
    REGION_STYLE_RULE: 16,
};
/** @see https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule  */
var AT_RULE_NAMES = (BrowserParserCss_a = {},
    BrowserParserCss_a[CSS_RULE_TYPES.MEDIA_RULE] = 'media',
    BrowserParserCss_a[CSS_RULE_TYPES.FONT_FACE_RULE] = 'font-face',
    BrowserParserCss_a[CSS_RULE_TYPES.PAGE_RULE] = 'page',
    BrowserParserCss_a[CSS_RULE_TYPES.KEYFRAMES_RULE] = 'keyframes',
    BrowserParserCss_a[CSS_RULE_TYPES.COUNTER_STYLE_RULE] = 'counter-style',
    BrowserParserCss_a[CSS_RULE_TYPES.SUPPORTS_RULE] = 'supports',
    BrowserParserCss_a[CSS_RULE_TYPES.DOCUMENT_RULE] = 'document',
    BrowserParserCss_a[CSS_RULE_TYPES.FONT_FEATURE_VALUES_RULE] = 'font-feature-values',
    BrowserParserCss_a[CSS_RULE_TYPES.VIEWPORT_RULE] = 'viewport',
    BrowserParserCss_a);
var AT_RULE_KEYS = (0,index_all.keys)(AT_RULE_NAMES);
var SINGLE_AT_RULE_TYPES = [
    CSS_RULE_TYPES.FONT_FACE_RULE,
    CSS_RULE_TYPES.PAGE_RULE,
    CSS_RULE_TYPES.COUNTER_STYLE_RULE,
    CSS_RULE_TYPES.VIEWPORT_RULE,
];
var NESTABLE_AT_RULE_NAMES = AT_RULE_KEYS.filter(function (i) { return SINGLE_AT_RULE_TYPES.indexOf(Number(i)) < 0; })
    .map(function (i) { return AT_RULE_NAMES[i]; })
    .concat(['container', 'layer']);
var SINGLE_AT_RULE_NAMES = SINGLE_AT_RULE_TYPES.map(function (n) { return AT_RULE_NAMES[n]; });
/**
 * Parse selector string to array.
 * Only classe based are valid as CSS rules inside editor, not valid
 * selectors will be dropped as additional
 * It's ok with the last part of the string as state (:hover, :active)
 * @param  {string} str Selectors string
 * @return {Object}
 * @example
 * var res = parseSelector('.test1, .test1.test2, .test2 .test3');
 * console.log(res);
 * // { result: [['test1'], ['test1', 'test2']], add: ['.test2 .test3'] }
 */
var parseSelector = function (str) {
    if (str === void 0) { str = ''; }
    var add = [];
    var result = [];
    var sels = str.split(',');
    for (var i = 0, len = sels.length; i < len; i++) {
        var sel = sels[i].trim();
        // Will accept only concatenated classes and last
        // class might be with state (eg. :hover), nothing else.
        // Can also accept SINGLE ID selectors, eg. `#myid`, `#myid:hover`
        // Composed are not valid: `#myid.some-class`, `#myid.some-class:hover`
        if (/^(\.{1}[\w\-]+)+(:{1,2}[\w\-()]+)?$/gi.test(sel) || /^(#{1}[\w\-]+){1}(:{1,2}[\w\-()]+)?$/gi.test(sel)) {
            var cls = sel.split('.').filter(Boolean);
            result.push(cls);
        }
        else {
            add.push(sel);
        }
    }
    return {
        result: result,
        add: add,
    };
};
/**
 * Parse style declarations of the node.
 * @param {CSSRule} node
 * @return {Object}
 */
var parseStyle = function (node) {
    var stl = node.style;
    var style = {};
    for (var i = 0, len = stl.length; i < len; i++) {
        var propName = stl[i];
        var propValue = stl.getPropertyValue(propName);
        var important = stl.getPropertyPriority(propName);
        style[propName] = "".concat(propValue).concat(important ? " !".concat(important) : '');
    }
    return style;
};
/**
 * Get the condition when possible
 * @param  {CSSRule} node
 * @return {string}
 */
var parseCondition = function (node) {
    // @ts-ignore
    var condition = node.conditionText || (node.media && node.media.mediaText) || node.name || node.selectorText || '';
    return condition.trim();
};
/**
 * Create node for the editor
 * @param  {Array<String>} selectors Array containing strings of classes
 * @param {Object} style Key-value object of style declarations
 * @return {Object}
 */
var createNode = function (selectors, style, opts) {
    if (style === void 0) { style = {}; }
    if (opts === void 0) { opts = {}; }
    var node = {};
    var selLen = selectors.length;
    var lastClass = selectors[selLen - 1];
    var stateArr = lastClass ? lastClass.split(/:(.+)/) : [];
    var state = stateArr[1];
    // @ts-ignore
    var atRule = opts.atRule, selectorsAdd = opts.selectorsAdd, mediaText = opts.mediaText;
    var singleAtRule = SINGLE_AT_RULE_NAMES.indexOf(atRule) >= 0;
    singleAtRule && (node.singleAtRule = true);
    atRule && (node.atRuleType = atRule);
    selectorsAdd && (node.selectorsAdd = selectorsAdd);
    mediaText && (node.mediaText = mediaText);
    // Isolate the state from selectors
    if (state) {
        selectors[selLen - 1] = stateArr[0];
        node.state = state;
        stateArr.splice(stateArr.length - 1, 1);
    }
    node.selectors = selectors;
    node.style = style;
    return node;
};
var getNestableAtRule = function (node) {
    var _a = node.cssText, cssText = _a === void 0 ? '' : _a;
    return NESTABLE_AT_RULE_NAMES.find(function (name) { return cssText.indexOf("@".concat(name)) === 0; });
};
/**
 * Fetch data from node
 * @param  {StyleSheet|CSSRule} el
 * @return {Array<Object>}
 */
var parseNode = function (el) {
    var result = [];
    var nodes = el.cssRules || [];
    for (var i = 0, len = nodes.length; i < len; i++) {
        var node = nodes[i];
        var type = node.type;
        var singleAtRule = false;
        var atRuleType = '';
        var condition = '';
        var sels = node.selectorText || node.keyText || '';
        var isSingleAtRule = SINGLE_AT_RULE_TYPES.indexOf(type) >= 0;
        // Check if the node is an at-rule
        if (isSingleAtRule) {
            singleAtRule = true;
            atRuleType = AT_RULE_NAMES[type];
            condition = parseCondition(node);
        }
        else if (AT_RULE_KEYS.indexOf("".concat(type)) >= 0 || (!type && getNestableAtRule(node))) {
            var subRules = parseNode(node);
            var subAtRuleType = AT_RULE_NAMES[type] || getNestableAtRule(node);
            condition = parseCondition(node);
            for (var s = 0, lens = subRules.length; s < lens; s++) {
                var subRule = subRules[s];
                condition && (subRule.mediaText = condition);
                subRule.atRuleType = subAtRuleType;
            }
            result = result.concat(subRules);
        }
        if (!sels && !isSingleAtRule)
            continue;
        var style = parseStyle(node);
        var selsParsed = parseSelector(sels);
        var selsAdd = selsParsed.add;
        var selsArr = selsParsed.result;
        var lastRule = void 0;
        // For each group of selectors
        for (var k = 0, len3 = selsArr.length; k < len3; k++) {
            var model = createNode(selsArr[k], style, {
                atRule: AT_RULE_NAMES[type],
            });
            result.push(model);
            lastRule = model;
        }
        // Need to push somewhere not class-based selectors, if some rule was
        // created will push them there, otherwise will create a new rule
        if (selsAdd.length) {
            var selsAddStr = selsAdd.join(', ');
            if (lastRule) {
                lastRule.selectorsAdd = selsAddStr;
            }
            else {
                var model = {
                    selectors: [],
                    selectorsAdd: selsAddStr,
                    style: style,
                };
                singleAtRule && (model.singleAtRule = singleAtRule);
                atRuleType && (model.atRuleType = atRuleType);
                condition && (model.mediaText = condition);
                result.push(model);
            }
        }
    }
    return result;
};
/**
 * Parse CSS string and return the array of objects
 * @param  {String} str CSS string
 * @return {Array<Object>} Array of objects for the definition of CSSRules
 */
/* harmony default export */ const BrowserParserCss = (function (str) {
    var el = document.createElement('style');
    el.innerHTML = str;
    // There is no .sheet before adding it to the <head>
    document.head.appendChild(el);
    var sheet = el.sheet;
    document.head.removeChild(el);
    return sheet ? parseNode(sheet) : [];
});

;// CONCATENATED MODULE: ./src/parser/model/ParserCss.ts


var ParserCss = function (em, config) {
    if (config === void 0) { config = {}; }
    return ({
        /**
         * Parse CSS string to a desired model object
         * @param  {String} input CSS string
         * @return {Array<Object>}
         */
        parse: function (input) {
            var _this = this;
            var output = [];
            var parserCss = config.parserCss;
            var editor = em === null || em === void 0 ? void 0 : em.Editor;
            var nodes = parserCss ? parserCss(input, editor) : BrowserParserCss(input);
            nodes.forEach(function (node) { return (output = output.concat(_this.checkNode(node))); });
            em === null || em === void 0 ? void 0 : em.trigger('parse:css', { input: input, output: output, nodes: nodes });
            return output;
        },
        /**
         * Check the returned node from a custom parser and transforms it to
         * a valid object for the CSS composer
         * @return {[type]}
         */
        checkNode: function (node) {
            var selectors = node.selectors, style = node.style;
            var result = [node];
            if ((0,index_all.isString)(selectors)) {
                var nodes_1 = [];
                var parsedNode = node;
                var selsParsed = parseSelector(selectors);
                var classSets = selsParsed.result;
                var selectorsAdd = selsParsed.add.join(', ');
                var opts_1 = { atRule: parsedNode.atRule, mediaText: parsedNode.params };
                if (classSets.length) {
                    classSets.forEach(function (classSet) {
                        nodes_1.push(createNode(classSet, style, opts_1));
                    });
                }
                else {
                    nodes_1.push(createNode([], style, opts_1));
                }
                if (selectorsAdd) {
                    var lastNode = nodes_1[nodes_1.length - 1];
                    lastNode.selectorsAdd = selectorsAdd;
                }
                result = nodes_1;
            }
            return result;
        },
    });
};
/* harmony default export */ const model_ParserCss = (ParserCss);

;// CONCATENATED MODULE: ./src/parser/index.ts
var parser_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/parser/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  parser: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const { Parser } = editor;
 * ```
 * ## Available Events
 * * `parse:html` - On HTML parse, an object containing the input and the output of the parser is passed as an argument
 * * `parse:css` - On CSS parse, an object containing the input and the output of the parser is passed as an argument
 *
 * ## Methods
 * * [getConfig](#getconfig)
 * * [parseHtml](#parsehtml)
 * * [parseCss](#parsecss)
 *
 * @module Parser
 */




var ParserModule = /** @class */ (function (_super) {
    parser_extends(ParserModule, _super);
    function ParserModule(em) {
        var _this = _super.call(this, em, 'Parser', parser_config_config) || this;
        var config = _this.config;
        _this.parserCss = model_ParserCss(em, config);
        _this.parserHtml = model_ParserHtml(em, config);
        return _this;
    }
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Parse HTML string and return the object containing the Component Definition
     * @param  {String} input HTML string to parse
     * @param  {Object} [options] Options
     * @param  {String} [options.htmlType] [HTML mime type](https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02) to parse
     * @param  {Boolean} [options.allowScripts=false] Allow `<script>` tags
     * @param  {Boolean} [options.allowUnsafeAttr=false] Allow unsafe HTML attributes (eg. `on*` inline event handlers)
     * @returns {Object} Object containing the result `{ html: ..., css: ... }`
     * @example
     * const resHtml = Parser.parseHtml(`<table><div>Hi</div></table>`, {
     *   htmlType: 'text/html', // default
     * });
     * // By using the `text/html`, this will fix automatically all the HTML syntax issues
     * // Indeed the final representation, in this case, will be `<div>Hi</div><table></table>`
     * const resXml = Parser.parseHtml(`<table><div>Hi</div></table>`, {
     *   htmlType: 'application/xml',
     * });
     * // This will preserve the original format as, from the XML point of view, is a valid format
     */
    ParserModule.prototype.parseHtml = function (input, options) {
        if (options === void 0) { options = {}; }
        var _a = this, em = _a.em, parserHtml = _a.parserHtml;
        parserHtml.compTypes = (em.Components.getTypes() || {});
        return parserHtml.parse(input, this.parserCss, options);
    };
    /**
     * Parse CSS string and return an array of valid definition objects for CSSRules
     * @param  {String} input CSS string to parse
     * @returns {Array<Object>} Array containing the result
     * @example
     * const res = Parser.parseCss('.cls { color: red }');
     * // [{ ... }]
     */
    ParserModule.prototype.parseCss = function (input) {
        return this.parserCss.parse(input);
    };
    ParserModule.prototype.destroy = function () { };
    return ParserModule;
}(abstract_Module));
/* harmony default export */ const src_parser = (ParserModule);

;// CONCATENATED MODULE: ./src/storage_manager/config/config.ts
var storage_manager_config_config_config = {
    id: 'gjs-',
    type: 'local',
    autosave: true,
    autoload: true,
    stepsBeforeSave: 1,
    recovery: false,
    onStore: function (data) { return data; },
    onLoad: function (data) { return data; },
    options: {
        local: {
            key: 'gjsProject',
            checkLocal: true,
        },
        remote: {
            headers: {},
            urlStore: '',
            urlLoad: '',
            contentTypeJson: true,
            fetchOptions: '',
            credentials: 'include',
            onStore: function (data) { return data; },
            onLoad: function (result) { return result; },
        },
    },
};
/* harmony default export */ const storage_manager_config_config = (storage_manager_config_config_config);

;// CONCATENATED MODULE: ./src/storage_manager/model/LocalStorage.ts
var LocalStorage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var LocalStorage_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

var LocalStorage = /** @class */ (function () {
    function LocalStorage() {
    }
    LocalStorage.prototype.store = function (data, opts) {
        if (opts === void 0) { opts = {}; }
        return LocalStorage_awaiter(this, void 0, void 0, function () {
            return LocalStorage_generator(this, function (_a) {
                if (this.hasLocal(opts, true)) {
                    localStorage.setItem(opts.key, JSON.stringify(data));
                }
                return [2 /*return*/, data];
            });
        });
    };
    LocalStorage.prototype.load = function (opts) {
        if (opts === void 0) { opts = {}; }
        return LocalStorage_awaiter(this, void 0, void 0, function () {
            var result;
            return LocalStorage_generator(this, function (_a) {
                result = {};
                if (this.hasLocal(opts, true)) {
                    result = JSON.parse(localStorage.getItem(opts.key) || '{}');
                }
                return [2 /*return*/, result];
            });
        });
    };
    LocalStorage.prototype.hasLocal = function (opts, thr) {
        if (opts === void 0) { opts = {}; }
        if (opts.checkLocal && (!(0,mixins.hasWin)() || !localStorage)) {
            if (thr)
                throw new Error('localStorage not available');
            return false;
        }
        return true;
    };
    return LocalStorage;
}());
/* harmony default export */ const model_LocalStorage = (LocalStorage);

;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/finally.js
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(function (value) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      return value;
    });
  }, function (reason) {
    // @ts-ignore
    return constructor.resolve(callback()).then(function () {
      // @ts-ignore
      return constructor.reject(reason);
    });
  });
}
/* harmony default export */ const src_finally = (finallyConstructor);
;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/allSettled.js

function allSettled(arr) {
  var P = this;
  return new P(function (resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(new TypeError(_typeof(arr) + ' ' + arr + ' is not iterable(cannot read property Symbol(Symbol.iterator))'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
        var then = val.then;
        if (typeof then === 'function') {
          then.call(val, function (val) {
            res(i, val);
          }, function (e) {
            args[i] = {
              status: 'rejected',
              reason: e
            };
            if (--remaining === 0) {
              resolve(args);
            }
          });
          return;
        }
      }
      args[i] = {
        status: 'fulfilled',
        value: val
      };
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
}
/* harmony default export */ const src_allSettled = (allSettled);
;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/any.js
/**
 * @constructor
 */
function AggregateError(errors, message) {
  this.name = 'AggregateError', this.errors = errors;
  this.message = message || '';
}
AggregateError.prototype = Error.prototype;
function any(arr) {
  var P = this;
  return new P(function (resolve, reject) {
    if (!(arr && typeof arr.length !== 'undefined')) {
      return reject(new TypeError('Promise.any accepts an array'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return reject();
    var rejectionReasons = [];
    for (var i = 0; i < args.length; i++) {
      try {
        P.resolve(args[i]).then(resolve).catch(function (error) {
          rejectionReasons.push(error);
          if (rejectionReasons.length === args.length) {
            reject(new AggregateError(rejectionReasons, 'All promises were rejected'));
          }
        });
      } catch (ex) {
        reject(ex);
      }
    }
  });
}
/* harmony default export */ const src_any = (any);
;// CONCATENATED MODULE: ./node_modules/promise-polyfill/src/index.js





// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;
function isArray(x) {
  return Boolean(x && typeof x.length !== 'undefined');
}
function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function () {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function src_Promise(fn) {
  if (!(this instanceof src_Promise)) throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];
  doResolve(fn, this);
}
function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  src_Promise._immediateFn(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}
function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
    if (newValue && (_typeof(newValue) === 'object' || typeof newValue === 'function')) {
      var then = newValue.then;
      if (newValue instanceof src_Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}
function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}
function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    src_Promise._immediateFn(function () {
      if (!self._handled) {
        src_Promise._unhandledRejectionFn(self._value);
      }
    });
  }
  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return;
      done = true;
      resolve(self, value);
    }, function (reason) {
      if (done) return;
      done = true;
      reject(self, reason);
    });
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}
src_Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};
src_Promise.prototype.then = function (onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);
  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};
src_Promise.prototype['finally'] = src_finally;
src_Promise.all = function (arr) {
  return new src_Promise(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.all accepts an array'));
    }
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      try {
        if (val && (_typeof(val) === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(val, function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};
src_Promise.any = src_any;
src_Promise.allSettled = src_allSettled;
src_Promise.resolve = function (value) {
  if (value && _typeof(value) === 'object' && value.constructor === src_Promise) {
    return value;
  }
  return new src_Promise(function (resolve) {
    resolve(value);
  });
};
src_Promise.reject = function (value) {
  return new src_Promise(function (resolve, reject) {
    reject(value);
  });
};
src_Promise.race = function (arr) {
  return new src_Promise(function (resolve, reject) {
    if (!isArray(arr)) {
      return reject(new TypeError('Promise.race accepts an array'));
    }
    for (var i = 0, len = arr.length; i < len; i++) {
      src_Promise.resolve(arr[i]).then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
src_Promise._immediateFn =
// @ts-ignore
typeof setImmediate === 'function' && function (fn) {
  // @ts-ignore
  setImmediate(fn);
} || function (fn) {
  setTimeoutFunc(fn, 0);
};
src_Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};
/* harmony default export */ const src = (src_Promise);
;// CONCATENATED MODULE: ./src/utils/fetch.ts
// @ts-ignore avoid errors during TS build


if ((0,mixins.hasWin)()) {
    window.Promise = window.Promise || src;
}
/* harmony default export */ const utils_fetch = (typeof fetch == 'function'
    ? // @ts-ignore
        fetch.bind()
    : function (url, options) {
        // @ts-ignore avoid errors during TS build
        return new src(function (res, rej) {
            var req = new XMLHttpRequest();
            req.open(options.method || 'get', url);
            req.withCredentials = options.credentials == 'include';
            for (var k in options.headers || {}) {
                req.setRequestHeader(k, options.headers[k]);
            }
            req.onload = function (e) {
                return res({
                    status: req.status,
                    statusText: req.statusText,
                    text: function () { return src.resolve(req.responseText); },
                });
            };
            req.onerror = rej;
            // Actually, fetch doesn't support onProgress feature
            if (req.upload && options.onProgress) {
                req.upload.onprogress = options.onProgress;
            }
            // Include body only if present
            options.body ? req.send(options.body) : req.send();
        });
    });

;// CONCATENATED MODULE: ./src/storage_manager/model/RemoteStorage.ts
var RemoteStorage_assign = (undefined && undefined.__assign) || function () {
    RemoteStorage_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return RemoteStorage_assign.apply(this, arguments);
};
var RemoteStorage_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var RemoteStorage_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};


var RemoteStorage = /** @class */ (function () {
    function RemoteStorage() {
    }
    RemoteStorage.prototype.store = function (data, opts) {
        if (opts === void 0) { opts = {}; }
        return RemoteStorage_awaiter(this, void 0, void 0, function () {
            return RemoteStorage_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.request(opts.urlStore, this.__props(opts, data), opts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    RemoteStorage.prototype.load = function (opts) {
        if (opts === void 0) { opts = {}; }
        return RemoteStorage_awaiter(this, void 0, void 0, function () {
            return RemoteStorage_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.request(opts.urlLoad, this.__props(opts), opts)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    RemoteStorage.prototype.request = function (url, props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        return utils_fetch(url, props)
            .then(function (res) {
            var result = res.text();
            var isOk = ((res.status / 200) | 0) === 1;
            return isOk ? result : result.then(Promise.reject);
        })
            .then(function (text) {
            var parsable = text && (0,index_all.isString)(text);
            return opts.contentTypeJson && parsable ? JSON.parse(text) : text;
        });
    };
    RemoteStorage.prototype.__props = function (opts, data) {
        if (opts === void 0) { opts = {}; }
        var typeJson = opts.contentTypeJson;
        var headers = opts.headers || {};
        var fetchOpts = opts.fetchOptions || {};
        var reqHead = 'X-Requested-With';
        var typeHead = 'Content-Type';
        var body;
        if ((0,index_all.isUndefined)(headers[reqHead])) {
            headers[reqHead] = 'XMLHttpRequest';
        }
        if ((0,index_all.isUndefined)(headers[typeHead]) && typeJson) {
            headers[typeHead] = 'application/json; charset=utf-8';
        }
        if (data) {
            if (typeJson) {
                body = JSON.stringify(data);
            }
            else {
                body = new FormData();
                for (var key in data) {
                    body.append(key, data[key]);
                }
            }
        }
        var result = {
            method: body ? 'POST' : 'GET',
            credentials: opts.credentials,
            headers: headers,
            body: body,
        };
        return RemoteStorage_assign(RemoteStorage_assign({}, result), ((0,index_all.isFunction)(fetchOpts) ? fetchOpts(result) : fetchOpts));
    };
    return RemoteStorage;
}());
/* harmony default export */ const model_RemoteStorage = (RemoteStorage);

;// CONCATENATED MODULE: ./src/storage_manager/types.ts
/**{START_EVENTS}*/
var StorageEvents;
(function (StorageEvents) {
    /**
     * @event `storage:start` Storage request start.
     * @example
     * editor.on('storage:start', (type) => {
     *  console.log('Storage start');
     * });
     */
    StorageEvents["start"] = "storage:start";
    /**
     * @event `storage:start:store` Storage store request start.
     * The project JSON object to store is passed as an argument (which you can edit).
     * @example
     * editor.on('storage:start:store', (data) => {
     *  console.log('Storage start store');
     * });
     */
    StorageEvents["startStore"] = "storage:start:store";
    /**
     * @event `storage:start:load` Storage load request start.
     * @example
     * editor.on('storage:start:load', () => {
     *  console.log('Storage start load');
     * });
     */
    StorageEvents["startLoad"] = "storage:start:load";
    /**
     * @event `storage:load` Storage loaded the project.
     * The loaded project is passed as an argument.
     * @example
     * editor.on('storage:load', (data, res) => {
     *  console.log('Storage loaded the project');
     * });
     */
    StorageEvents["load"] = "storage:load";
    /**
     * @event `storage:store` Storage stored the project.
     * The stored project is passed as an argument.
     * @example
     * editor.on('storage:store', (data, res) => {
     *  console.log('Storage stored the project');
     * });
     */
    StorageEvents["store"] = "storage:store";
    /**
     * @event `storage:after` Storage request completed.
     * Triggered right after `storage:load`/`storage:store`.
     * @example
     * editor.on('storage:after', (type) => {
     *  console.log('Storage request completed');
     * });
     */
    StorageEvents["after"] = "storage:after";
    StorageEvents["afterStore"] = "storage:after:store";
    StorageEvents["afterLoad"] = "storage:after:load";
    /**
     * @event `storage:end` Storage request ended.
     * This event triggers also in case of errors.
     * @example
     * editor.on('storage:end', (type) => {
     *  console.log('Storage request ended');
     * });
     */
    StorageEvents["end"] = "storage:end";
    /**
     * @event `storage:end:store` Storage store request ended.
     * This event triggers also in case of errors.
     * @example
     * editor.on('storage:end:store', () => {
     *  console.log('Storage store request ended');
     * });
     */
    StorageEvents["endStore"] = "storage:end:store";
    /**
     * @event `storage:end:load` Storage load request ended.
     * This event triggers also in case of errors.
     * @example
     * editor.on('storage:end:load', () => {
     *  console.log('Storage load request ended');
     * });
     */
    StorageEvents["endLoad"] = "storage:end:load";
    /**
     * @event `storage:error` Error on storage request.
     * @example
     * editor.on('storage:error', (err, type) => {
     *  console.log('Storage error');
     * });
     */
    StorageEvents["error"] = "storage:error";
    /**
     * @event `storage:error:store` Error on store request.
     * @example
     * editor.on('storage:error:store', (err) => {
     *  console.log('Error on store');
     * });
     */
    StorageEvents["errorStore"] = "storage:error:store";
    /**
     * @event `storage:error:load` Error on load request.
     * @example
     * editor.on('storage:error:load', (err) => {
     *  console.log('Error on load');
     * });
     */
    StorageEvents["errorLoad"] = "storage:error:load";
})(StorageEvents || (StorageEvents = {}));
/**{END_EVENTS}*/
// need this to avoid the TS documentation generator to break
/* harmony default export */ const storage_manager_types = (StorageEvents);

;// CONCATENATED MODULE: ./src/storage_manager/index.ts
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/storage_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  storageManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('storage:start', () => { ... });
 *
 * // Use the API
 * const storageManager = editor.Storage;
 * storageManager.add(...);
 * ```
 *
 * {REPLACE_EVENTS}
 *
 * ## Methods
 * * [getConfig](#getconfig)
 * * [isAutosave](#isautosave)
 * * [setAutosave](#setautosave)
 * * [getStepsBeforeSave](#getstepsbeforesave)
 * * [setStepsBeforeSave](#setstepsbeforesave)
 * * [getStorages](#getstorages)
 * * [getCurrent](#getcurrent)
 * * [getCurrentStorage](#getcurrentstorage)
 * * [setCurrent](#setcurrent)
 * * [getStorageOptions](#getstorageoptions)
 * * [add](#add)
 * * [get](#get)
 * * [store](#store)
 * * [load](#load)
 *
 * @module Storage
 */
var storage_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var storage_manager_assign = (undefined && undefined.__assign) || function () {
    storage_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return storage_manager_assign.apply(this, arguments);
};
var storage_manager_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var storage_manager_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};






var STORAGE_LOCAL = 'local';
var STORAGE_REMOTE = 'remote';
var StorageManager = /** @class */ (function (_super) {
    storage_manager_extends(StorageManager, _super);
    function StorageManager(em) {
        var _this = _super.call(this, em, 'StorageManager', storage_manager_config_config) || this;
        _this.storages = {};
        _this.events = storage_manager_types;
        var config = _this.config;
        if (config._disable)
            config.type = undefined;
        _this.storages = {};
        _this.add(STORAGE_LOCAL, new model_LocalStorage());
        _this.add(STORAGE_REMOTE, new model_RemoteStorage());
        _this.setCurrent(config.type);
        return _this;
    }
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Check if autosave is enabled.
     * @returns {Boolean}
     * */
    StorageManager.prototype.isAutosave = function () {
        return !!this.config.autosave;
    };
    /**
     * Set autosave value.
     * @param  {Boolean} value
     * */
    StorageManager.prototype.setAutosave = function (value) {
        this.config.autosave = !!value;
        return this;
    };
    /**
     * Returns number of steps required before trigger autosave.
     * @returns {Number}
     * */
    StorageManager.prototype.getStepsBeforeSave = function () {
        return this.config.stepsBeforeSave;
    };
    /**
     * Set steps required before trigger autosave.
     * @param {Number} value
     * */
    StorageManager.prototype.setStepsBeforeSave = function (value) {
        this.config.stepsBeforeSave = value;
        return this;
    };
    /**
     * Add new storage.
     * @param {String} type Storage type
     * @param {Object} storage Storage definition
     * @param {Function} storage.load Load method
     * @param  {Function} storage.store Store method
     * @example
     * storageManager.add('local2', {
     *   async load(storageOptions) {
     *     // ...
     *   },
     *   async store(data, storageOptions) {
     *     // ...
     *   },
     * });
     * */
    StorageManager.prototype.add = function (type, storage) {
        this.storages[type] = storage;
        return this;
    };
    /**
     * Return storage by type.
     * @param {String} type Storage type
     * @returns {Object|null}
     * */
    StorageManager.prototype.get = function (type) {
        return this.storages[type];
    };
    /**
     * Get all storages.
     * @returns {Object}
     * */
    StorageManager.prototype.getStorages = function () {
        return this.storages;
    };
    /**
     * Get current storage type.
     * @returns {String}
     * */
    StorageManager.prototype.getCurrent = function () {
        return this.config.currentStorage;
    };
    /**
     * Set current storage type.
     * @param {String} type Storage type
     * */
    StorageManager.prototype.setCurrent = function (type) {
        this.getConfig().currentStorage = type;
        return this;
    };
    StorageManager.prototype.getCurrentStorage = function () {
        return this.get(this.getCurrent());
    };
    /**
     * Get storage options by type.
     * @param {String} type Storage type
     * @returns {Object}
     * */
    StorageManager.prototype.getStorageOptions = function (type) {
        return this.getCurrentOptions(type);
    };
    /**
     * Store data in the current storage.
     * @param {Object} data Project data.
     * @param {Object} [options] Storage options.
     * @returns {Object} Stored data.
     * @example
     * const data = editor.getProjectData();
     * await storageManager.store(data);
     * */
    StorageManager.prototype.store = function (data, options) {
        if (options === void 0) { options = {}; }
        return storage_manager_awaiter(this, void 0, void 0, function () {
            var st, opts, recovery, recoveryOpts, _a, error_1;
            return storage_manager_generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        st = this.getCurrentStorage();
                        opts = storage_manager_assign(storage_manager_assign({}, this.getCurrentOptions()), options);
                        recovery = this.getRecoveryStorage();
                        recoveryOpts = this.getCurrentOptions(STORAGE_LOCAL);
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 5, , 9]);
                        return [4 /*yield*/, this.__exec(st, opts, data)];
                    case 2:
                        _b.sent();
                        _a = recovery;
                        if (!_a) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.__exec(recovery, recoveryOpts, {})];
                    case 3:
                        _a = (_b.sent());
                        _b.label = 4;
                    case 4:
                        _a;
                        return [3 /*break*/, 9];
                    case 5:
                        error_1 = _b.sent();
                        if (!recovery) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.__exec(recovery, recoveryOpts, data)];
                    case 6:
                        _b.sent();
                        return [3 /*break*/, 8];
                    case 7: throw error_1;
                    case 8: return [3 /*break*/, 9];
                    case 9: return [2 /*return*/, data];
                }
            });
        });
    };
    /**
     * Load resource from the current storage by keys
     * @param {Object} [options] Storage options.
     * @returns {Object} Loaded data.
     * @example
     * const data = await storageManager.load();
     * editor.loadProjectData(data);
     * */
    StorageManager.prototype.load = function (options) {
        if (options === void 0) { options = {}; }
        return storage_manager_awaiter(this, void 0, void 0, function () {
            var st, opts, recoveryStorage, result, recoveryData, error_2;
            return storage_manager_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        st = this.getCurrentStorage();
                        opts = storage_manager_assign(storage_manager_assign({}, this.getCurrentOptions()), options);
                        recoveryStorage = this.getRecoveryStorage();
                        if (!recoveryStorage) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.__exec(recoveryStorage, this.getCurrentOptions(STORAGE_LOCAL))];
                    case 1:
                        recoveryData = _a.sent();
                        if (!!(0,index_all.isEmpty)(recoveryData)) return [3 /*break*/, 5];
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, this.__askRecovery()];
                    case 3:
                        _a.sent();
                        result = recoveryData;
                        return [3 /*break*/, 5];
                    case 4:
                        error_2 = _a.sent();
                        return [3 /*break*/, 5];
                    case 5:
                        if (!!result) return [3 /*break*/, 7];
                        return [4 /*yield*/, this.__exec(st, opts)];
                    case 6:
                        result = _a.sent();
                        _a.label = 7;
                    case 7: return [2 /*return*/, result || {}];
                }
            });
        });
    };
    StorageManager.prototype.__askRecovery = function () {
        var em = this.em;
        var recovery = this.getRecovery();
        return new Promise(function (res, rej) {
            if ((0,index_all.isFunction)(recovery)) {
                recovery(res, rej, em === null || em === void 0 ? void 0 : em.getEditor());
            }
            else {
                confirm(em === null || em === void 0 ? void 0 : em.t('storageManager.recover')) ? res(null) : rej();
            }
        });
    };
    StorageManager.prototype.getRecovery = function () {
        return this.config.recovery;
    };
    StorageManager.prototype.getRecoveryStorage = function () {
        var recovery = this.getRecovery();
        return recovery && this.getCurrent() === STORAGE_REMOTE && this.get(STORAGE_LOCAL);
    };
    StorageManager.prototype.__exec = function (storage, opts, data) {
        var _a;
        return storage_manager_awaiter(this, void 0, void 0, function () {
            var ev, _b, onStore, onLoad, result, editor, response, toStore, _c, _d, _e, _f, error_3;
            return storage_manager_generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        ev = data ? 'store' : 'load';
                        _b = this.getConfig(), onStore = _b.onStore, onLoad = _b.onLoad;
                        this.onStart(ev, data);
                        if (!storage) {
                            return [2 /*return*/, data || {}];
                        }
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 14, , 15]);
                        editor = (_a = this.em) === null || _a === void 0 ? void 0 : _a.getEditor();
                        response = void 0;
                        if (!data) return [3 /*break*/, 7];
                        _c = onStore;
                        if (!_c) return [3 /*break*/, 3];
                        return [4 /*yield*/, onStore(data, editor)];
                    case 2:
                        _c = (_g.sent());
                        _g.label = 3;
                    case 3:
                        toStore = (_c) || data;
                        _d = opts.onStore;
                        if (!_d) return [3 /*break*/, 5];
                        return [4 /*yield*/, opts.onStore(toStore, editor)];
                    case 4:
                        _d = (_g.sent());
                        _g.label = 5;
                    case 5:
                        toStore = (_d) || toStore;
                        return [4 /*yield*/, storage.store(toStore, opts)];
                    case 6:
                        response = _g.sent();
                        result = data;
                        return [3 /*break*/, 13];
                    case 7: return [4 /*yield*/, storage.load(opts)];
                    case 8:
                        response = _g.sent();
                        result = this.__clearKeys(response);
                        _e = opts.onLoad;
                        if (!_e) return [3 /*break*/, 10];
                        return [4 /*yield*/, opts.onLoad(result, editor)];
                    case 9:
                        _e = (_g.sent());
                        _g.label = 10;
                    case 10:
                        result = (_e) || result;
                        _f = onLoad;
                        if (!_f) return [3 /*break*/, 12];
                        return [4 /*yield*/, onLoad(result, editor)];
                    case 11:
                        _f = (_g.sent());
                        _g.label = 12;
                    case 12:
                        result = (_f) || result;
                        _g.label = 13;
                    case 13:
                        this.onAfter(ev, result, response);
                        this.onEnd(ev, result, response);
                        return [3 /*break*/, 15];
                    case 14:
                        error_3 = _g.sent();
                        this.onError(ev, error_3);
                        throw error_3;
                    case 15: return [2 /*return*/, result];
                }
            });
        });
    };
    StorageManager.prototype.__clearKeys = function (data) {
        if (data === void 0) { data = {}; }
        var config = this.getConfig();
        var reg = new RegExp("^".concat(config.id));
        var result = {};
        for (var itemKey in data) {
            var itemKeyR = itemKey.replace(reg, '');
            result[itemKeyR] = data[itemKey];
        }
        return result;
    };
    StorageManager.prototype.getCurrentOptions = function (type) {
        var config = this.getConfig();
        var current = type || this.getCurrent();
        return config.options[current] || {};
    };
    /**
     * On start callback
     * @private
     */
    StorageManager.prototype.onStart = function (type, data) {
        var em = this.em;
        if (em) {
            var ev = type === 'load' ? storage_manager_types.startLoad : storage_manager_types.startStore;
            em.trigger(storage_manager_types.start, type, data);
            em.trigger(ev, data);
        }
    };
    /**
     * On after callback (before passing data to the callback)
     * @private
     */
    StorageManager.prototype.onAfter = function (type, data, response) {
        var em = this.em;
        if (em) {
            var evAfter = type === 'load' ? storage_manager_types.afterLoad : storage_manager_types.afterStore;
            em.trigger(storage_manager_types.after);
            em.trigger(evAfter, data, response);
            var ev = type === 'load' ? storage_manager_types.load : storage_manager_types.store;
            em.trigger(ev, data, response);
        }
    };
    /**
     * On end callback
     * @private
     */
    StorageManager.prototype.onEnd = function (type, data, response) {
        var em = this.em;
        if (em) {
            var ev = type === 'load' ? storage_manager_types.endLoad : storage_manager_types.endStore;
            em.trigger(storage_manager_types.end, type, data, response);
            em.trigger(ev, data, response);
        }
    };
    /**
     * On error callback
     * @private
     */
    StorageManager.prototype.onError = function (type, error) {
        var em = this.em;
        if (em) {
            var ev = type === 'load' ? storage_manager_types.errorLoad : storage_manager_types.errorStore;
            em.trigger(storage_manager_types.error, error, type);
            em.trigger(ev, error);
            this.onEnd(type, error);
        }
    };
    /**
     * Check if autoload is possible
     * @return {Boolean}
     * @private
     * */
    StorageManager.prototype.canAutoload = function () {
        var storage = this.getCurrentStorage();
        return !!storage && !!this.config.autoload;
    };
    StorageManager.prototype.destroy = function () {
        this.storages = {};
    };
    return StorageManager;
}(abstract_Module));
/* harmony default export */ const storage_manager = (StorageManager);

;// CONCATENATED MODULE: ./src/trait_manager/config/config.ts
var trait_manager_config_config_config = {
    stylePrefix: 'trt-',
    appendTo: '',
    optionsTarget: [{ value: false }, { value: '_blank' }],
    custom: false,
};
/* harmony default export */ const trait_manager_config_config = (trait_manager_config_config_config);

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitView.ts
var view_TraitView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var view_TraitView_assign = (undefined && undefined.__assign) || function () {
    view_TraitView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return view_TraitView_assign.apply(this, arguments);
};



var TraitView_TraitView = /** @class */ (function (_super) {
    view_TraitView_extends(TraitView, _super);
    function TraitView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        _this.events = {};
        _this.appendInput = true;
        var _a = o.config, config = _a === void 0 ? {} : _a;
        var _b = _this, model = _b.model, eventCapture = _b.eventCapture;
        var target = model.target;
        var type = model.attributes.type;
        _this.config = config;
        _this.em = config.em;
        _this.ppfx = config.pStylePrefix || '';
        _this.pfx = _this.ppfx + config.stylePrefix || '';
        _this.target = target;
        var ppfx = _this.ppfx;
        _this.clsField = "".concat(ppfx, "field ").concat(ppfx, "field-").concat(type);
        var evToListen = [
            ['change:value', _this.onValueChange],
            ['remove', _this.removeView],
        ];
        evToListen.forEach(function (_a) {
            var event = _a[0], clb = _a[1];
            model.off(event, clb);
            _this.listenTo(model, event, clb);
        });
        model.view = _this;
        _this.listenTo(model, 'change:label', _this.render);
        _this.listenTo(model, 'change:placeholder', _this.rerender);
        _this.events = {};
        eventCapture.forEach(function (event) { return (_this.events[event] = 'onChange'); });
        _this.delegateEvents();
        _this.init();
        return _this;
    }
    /** @ts-ignore */
    TraitView.prototype.attributes = function () {
        return this.model.get('attributes') || {};
    };
    TraitView.prototype.templateLabel = function (cmp) {
        var ppfx = this.ppfx;
        var label = this.getLabel();
        return "<div class=\"".concat(ppfx, "label\" title=\"").concat(label, "\">").concat(label, "</div>");
    };
    TraitView.prototype.templateInput = function (data) {
        var clsField = this.clsField;
        return "<div class=\"".concat(clsField, "\" data-input></div>");
    };
    TraitView.prototype.getClbOpts = function () {
        return {
            component: this.target,
            trait: this.model,
            elInput: this.getInputElem(),
        };
    };
    TraitView.prototype.removeView = function () {
        this.remove();
        this.removed();
    };
    TraitView.prototype.init = function () { };
    TraitView.prototype.removed = function () { };
    TraitView.prototype.onRender = function (props) { };
    TraitView.prototype.onUpdate = function (props) { };
    TraitView.prototype.onEvent = function (props) { };
    /**
     * Fires when the input is changed
     * @private
     */
    TraitView.prototype.onChange = function (event) {
        var el = this.getInputElem();
        if (el && !(0,index_all.isUndefined)(el.value)) {
            this.model.set('value', el.value);
        }
        this.onEvent(view_TraitView_assign(view_TraitView_assign({}, this.getClbOpts()), { event: event }));
    };
    TraitView.prototype.getValueForTarget = function () {
        return this.model.get('value');
    };
    TraitView.prototype.setInputValue = function (value) {
        var el = this.getInputElem();
        el && (el.value = value);
    };
    /**
     * On change callback
     * @private
     */
    TraitView.prototype.onValueChange = function (model, value, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.fromTarget) {
            this.setInputValue(model.get('value'));
            this.postUpdate();
        }
        else {
            var val = this.getValueForTarget();
            model.setTargetValue(val, opts);
        }
    };
    /**
     * Render label
     * @private
     */
    TraitView.prototype.renderLabel = function () {
        var _a = this, $el = _a.$el, target = _a.target;
        var label = this.getLabel();
        var tpl = this.templateLabel(target);
        if (this.createLabel) {
            tpl =
                this.createLabel({
                    label: label,
                    component: target,
                    trait: this,
                }) || '';
        }
        $el.find('[data-label]').append(tpl);
    };
    /**
     * Returns label for the input
     * @return {string}
     * @private
     */
    TraitView.prototype.getLabel = function () {
        var em = this.em;
        var _a = this.model.attributes, label = _a.label, name = _a.name;
        return em.t("traitManager.traits.labels.".concat(name)) || (0,mixins.capitalize)(label || name).replace(/-/g, ' ');
    };
    /**
     * Returns current target component
     */
    TraitView.prototype.getComponent = function () {
        return this.target;
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitView.prototype.getInputEl = function () {
        if (!this.$input) {
            var _a = this, em = _a.em, model = _a.model;
            var md = model;
            var name_1 = model.attributes.name;
            var placeholder = md.get('placeholder') || md.get('default') || '';
            var type = md.get('type') || 'text';
            var min = md.get('min');
            var max = md.get('max');
            var value = this.getModelValue();
            var input = (0,cash_dom["default"])("<input type=\"".concat(type, "\">"));
            var i18nAttr = em.t("traitManager.traits.attributes.".concat(name_1)) || {};
            input.attr(view_TraitView_assign({ placeholder: placeholder }, i18nAttr));
            if (!(0,index_all.isUndefined)(value)) {
                md.set({ value: value }, { silent: true });
                input.prop('value', value);
            }
            if (min) {
                input.prop('min', min);
            }
            if (max) {
                input.prop('max', max);
            }
            this.$input = input;
        }
        return this.$input.get(0);
    };
    TraitView.prototype.getInputElem = function () {
        var _a = this, input = _a.input, $input = _a.$input;
        return input || ($input && $input.get && $input.get(0)) || this.getElInput();
    };
    TraitView.prototype.getModelValue = function () {
        var value;
        var model = this.model;
        var target = this.target;
        var name = model.getName();
        if (model.get('changeProp')) {
            value = target.get(name);
        }
        else {
            var attrs = target.get('attributes');
            value = model.get('value') || attrs[name];
        }
        return !(0,index_all.isUndefined)(value) ? value : '';
    };
    TraitView.prototype.getElInput = function () {
        return this.elInput;
    };
    /**
     * Renders input
     * @private
     * */
    TraitView.prototype.renderField = function () {
        var _a = this, $el = _a.$el, appendInput = _a.appendInput, model = _a.model;
        var inputs = $el.find('[data-input]');
        var el = inputs[inputs.length - 1];
        var tpl = model.el;
        if (!tpl) {
            tpl = this.createInput ? this.createInput(this.getClbOpts()) : this.getInputEl();
        }
        if ((0,index_all.isString)(tpl)) {
            el.innerHTML = tpl;
            this.elInput = el.firstChild;
        }
        else {
            appendInput ? el.appendChild(tpl) : el.insertBefore(tpl, el.firstChild);
            this.elInput = tpl;
        }
        model.el = this.elInput;
    };
    TraitView.prototype.hasLabel = function () {
        var label = this.model.attributes.label;
        return !this.noLabel && label !== false;
    };
    TraitView.prototype.rerender = function () {
        delete this.model.el;
        this.render();
    };
    TraitView.prototype.postUpdate = function () {
        this.onUpdate(this.getClbOpts());
    };
    TraitView.prototype.render = function () {
        var _a = this, $el = _a.$el, pfx = _a.pfx, ppfx = _a.ppfx, model = _a.model;
        var _b = model.attributes, type = _b.type, id = _b.id;
        var hasLabel = this.hasLabel && this.hasLabel();
        var cls = "".concat(pfx, "trait");
        delete this.$input;
        var tmpl = "<div class=\"".concat(cls, " ").concat(cls, "--").concat(type, "\">\n      ").concat(hasLabel ? "<div class=\"".concat(ppfx, "label-wrp\" data-label></div>") : '', "\n      <div class=\"").concat(ppfx, "field-wrp ").concat(ppfx, "field-wrp--").concat(type, "\" data-input>\n        ").concat(this.templateInput
            ? (0,index_all.isFunction)(this.templateInput)
                ? this.templateInput(this.getClbOpts())
                : this.templateInput
            : '', "\n      </div>\n    </div>");
        $el.empty().append(tmpl);
        hasLabel && this.renderLabel();
        this.renderField();
        this.el.className = "".concat(cls, "__wrp ").concat(cls, "__wrp-").concat(id);
        this.postUpdate();
        this.onRender(this.getClbOpts());
        return this;
    };
    return TraitView;
}(common/* View */.G7));
/* harmony default export */ const trait_manager_view_TraitView = (TraitView_TraitView);
TraitView_TraitView.prototype.eventCapture = ['change'];

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitSelectView.ts
var view_TraitSelectView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var TraitSelectView_TraitSelectView = /** @class */ (function (_super) {
    view_TraitSelectView_extends(TraitSelectView, _super);
    function TraitSelectView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        _this.listenTo(_this.model, 'change:options', _this.rerender);
        return _this;
    }
    TraitSelectView.prototype.templateInput = function () {
        var _a = this, ppfx = _a.ppfx, clsField = _a.clsField;
        return "<div class=\"".concat(clsField, "\">\n      <div data-input></div>\n      <div class=\"").concat(ppfx, "sel-arrow\">\n        <div class=\"").concat(ppfx, "d-s-arrow\"></div>\n      </div>\n    </div>");
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitSelectView.prototype.getInputEl = function () {
        if (!this.$input) {
            var _a = this, model = _a.model, em_1 = _a.em;
            var propName_1 = model.get('name');
            var opts = model.get('options') || [];
            var values_1 = [];
            var input_1 = '<select>';
            opts.forEach(function (el) {
                var attrs = '';
                var name, value, style;
                if ((0,index_all.isString)(el)) {
                    name = el;
                    value = el;
                }
                else {
                    name = el.name || el.label || el.value;
                    value = "".concat((0,index_all.isUndefined)(el.value) ? el.id : el.value).replace(/"/g, '&quot;');
                    style = el.style ? el.style.replace(/"/g, '&quot;') : '';
                    attrs += style ? " style=\"".concat(style, "\"") : '';
                }
                var resultName = em_1.t("traitManager.traits.options.".concat(propName_1, ".").concat(value)) || name;
                input_1 += "<option value=\"".concat(value, "\"").concat(attrs, ">").concat(resultName, "</option>");
                values_1.push(value);
            });
            input_1 += '</select>';
            this.$input = (0,cash_dom["default"])(input_1);
            var val = model.getTargetValue();
            var valResult = values_1.indexOf(val) >= 0 ? val : model.get('default');
            !(0,index_all.isUndefined)(valResult) && this.$input.val(valResult);
        }
        return this.$input.get(0);
    };
    return TraitSelectView;
}(trait_manager_view_TraitView));
/* harmony default export */ const trait_manager_view_TraitSelectView = (TraitSelectView_TraitSelectView);

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitCheckboxView.ts
var view_TraitCheckboxView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TraitCheckboxView_TraitCheckboxView = /** @class */ (function (_super) {
    view_TraitCheckboxView_extends(TraitCheckboxView, _super);
    function TraitCheckboxView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.appendInput = false;
        return _this;
    }
    TraitCheckboxView.prototype.templateInput = function () {
        var _a = this, ppfx = _a.ppfx, clsField = _a.clsField;
        return "<label class=\"".concat(clsField, "\" data-input>\n    <i class=\"").concat(ppfx, "chk-icon\"></i>\n  </label>");
    };
    /**
     * Fires when the input is changed
     * @private
     */
    TraitCheckboxView.prototype.onChange = function () {
        this.model.set('value', this.getInputElem().checked);
    };
    TraitCheckboxView.prototype.setInputValue = function (value) {
        var el = this.getInputElem();
        el && (el.checked = !!value);
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitCheckboxView.prototype.getInputEl = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var toInit = !this.$input;
        var el = trait_manager_view_TraitView.prototype.getInputEl.apply(this, args);
        if (toInit) {
            var checked = void 0, targetValue = void 0;
            var _a = this, model = _a.model, target = _a.target;
            var valueFalse = model.attributes.valueFalse;
            var name_1 = model.getName();
            if (model.get('changeProp')) {
                checked = target.get(name_1);
                targetValue = checked;
            }
            else {
                targetValue = target.get('attributes')[name_1];
                checked = targetValue || targetValue === '' ? !0 : !1;
            }
            if (!(0,index_all.isUndefined)(valueFalse) && targetValue === valueFalse) {
                checked = !1;
            }
            el.checked = checked;
        }
        return el;
    };
    return TraitCheckboxView;
}(trait_manager_view_TraitView));
/* harmony default export */ const trait_manager_view_TraitCheckboxView = (TraitCheckboxView_TraitCheckboxView);

;// CONCATENATED MODULE: ./src/domain_abstract/ui/Input.ts
var Input_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Input = /** @class */ (function (_super) {
    Input_extends(Input, _super);
    function Input(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, opts) || this;
        var ppfx = opts.ppfx || '';
        _this.opts = opts;
        _this.ppfx = ppfx;
        _this.em = opts.target || {};
        !opts.onChange && _this.listenTo(_this.model, 'change:value', _this.handleModelChange);
        return _this;
    }
    Input.prototype.template = function () {
        return "<span class=\"".concat(this.holderClass(), "\"></span>");
    };
    Input.prototype.inputClass = function () {
        return "".concat(this.ppfx, "field");
    };
    Input.prototype.holderClass = function () {
        return "".concat(this.ppfx, "input-holder");
    };
    /**
     * Fired when the element of the property is updated
     */
    Input.prototype.elementUpdated = function () {
        this.model.trigger('el:change');
    };
    /**
     * Set value to the input element
     * @param {string} value
     */
    Input.prototype.setValue = function (value, opts) {
        var model = this.model;
        var val = value || model.get('defaults');
        var input = this.getInputEl();
        input && (input.value = val);
    };
    /**
     * Updates the view when the model is changed
     * */
    Input.prototype.handleModelChange = function (model, value, opts) {
        this.setValue(value, opts);
    };
    /**
     * Handled when the view is changed
     */
    Input.prototype.handleChange = function (e) {
        e.stopPropagation();
        var value = this.getInputEl().value;
        this.__onInputChange(value);
        this.elementUpdated();
    };
    Input.prototype.__onInputChange = function (value) {
        this.model.set({ value: value }, { fromInput: 1 });
    };
    /**
     * Get the input element
     * @return {HTMLElement}
     */
    Input.prototype.getInputEl = function () {
        if (!this.inputEl) {
            var _a = this, model = _a.model, opts = _a.opts;
            var type = opts.type || 'text';
            var plh = model.get('placeholder') || model.get('defaults') || model.get('default') || '';
            this.inputEl = (0,cash_dom["default"])("<input type=\"".concat(type, "\" placeholder=\"").concat(plh, "\">"));
        }
        return this.inputEl.get(0);
    };
    Input.prototype.render = function () {
        this.inputEl = null;
        var el = this.$el;
        el.addClass(this.inputClass());
        el.html(this.template());
        el.find(".".concat(this.holderClass())).append(this.getInputEl());
        return this;
    };
    return Input;
}(common/* View */.G7));
/* harmony default export */ const ui_Input = (Input);
Input.prototype.events = {
    // @ts-ignore
    change: 'handleChange',
};

;// CONCATENATED MODULE: ./src/domain_abstract/ui/InputNumber.ts
var InputNumber_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var InputNumber = /** @class */ (function (_super) {
    InputNumber_extends(InputNumber, _super);
    function InputNumber(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, opts) || this;
        (0,index_all.bindAll)(_this, 'moveIncrement', 'upIncrement');
        _this.doc = document;
        _this.listenTo(_this.model, 'change:unit', _this.handleModelChange);
        return _this;
    }
    InputNumber.prototype.template = function () {
        var ppfx = this.ppfx;
        return "\n      <span class=\"".concat(ppfx, "input-holder\"></span>\n      <span class=\"").concat(ppfx, "field-units\"></span>\n      <div class=\"").concat(ppfx, "field-arrows\" data-arrows>\n        <div class=\"").concat(ppfx, "field-arrow-u\" data-arrow-up></div>\n        <div class=\"").concat(ppfx, "field-arrow-d\" data-arrow-down></div>\n      </div>\n    ");
    };
    InputNumber.prototype.inputClass = function () {
        var ppfx = this.ppfx;
        return this.opts.contClass || "".concat(ppfx, "field ").concat(ppfx, "field-integer");
    };
    /**
     * Set value to the model
     * @param {string} value
     * @param {Object} opts
     */
    InputNumber.prototype.setValue = function (value, opts) {
        var opt = opts || {};
        var valid = this.validateInputValue(value, { deepCheck: 1 });
        var validObj = { value: valid.value, unit: '' };
        // If found some unit value
        if (valid.unit || valid.force) {
            validObj.unit = valid.unit;
        }
        this.model.set(validObj, opt);
        // Generally I get silent when I need to reflect data to view without
        // reupdating the target
        if (opt.silent) {
            this.handleModelChange();
        }
    };
    /**
     * Handled when the view is changed
     */
    InputNumber.prototype.handleChange = function (e) {
        e.stopPropagation();
        this.setValue(this.getInputEl().value);
        this.elementUpdated();
    };
    /**
     * Handled when the view is changed
     */
    InputNumber.prototype.handleUnitChange = function (e) {
        e.stopPropagation();
        var value = this.getUnitEl().value;
        this.model.set('unit', value);
        this.elementUpdated();
    };
    /**
     * Handled when user uses keyboard
     */
    InputNumber.prototype.handleKeyDown = function (e) {
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            this.upArrowClick();
        }
        if (e.key === 'ArrowDown') {
            e.preventDefault();
            this.downArrowClick();
        }
    };
    /**
     * Fired when the element of the property is updated
     */
    InputNumber.prototype.elementUpdated = function () {
        this.model.trigger('el:change');
    };
    /**
     * Updates the view when the model is changed
     * */
    InputNumber.prototype.handleModelChange = function () {
        var model = this.model;
        this.getInputEl().value = model.get('value');
        var unitEl = this.getUnitEl();
        unitEl && (unitEl.value = model.get('unit') || '');
    };
    /**
     * Get the unit element
     * @return {HTMLElement}
     */
    InputNumber.prototype.getUnitEl = function () {
        if (!this.unitEl) {
            var model_1 = this.model;
            var units = model_1.get('units') || [];
            if (units.length) {
                var options_1 = ['<option value="" disabled hidden>-</option>'];
                units.forEach(function (unit) {
                    var selected = unit == model_1.get('unit') ? 'selected' : '';
                    options_1.push("<option ".concat(selected, ">").concat(unit, "</option>"));
                });
                var temp = document.createElement('div');
                temp.innerHTML = "<select class=\"".concat(this.ppfx, "input-unit\">").concat(options_1.join(''), "</select>");
                this.unitEl = temp.firstChild;
            }
        }
        return this.unitEl;
    };
    /**
     * Invoked when the up arrow is clicked
     * */
    InputNumber.prototype.upArrowClick = function () {
        var model = this.model;
        var step = model.get('step');
        var value = parseFloat(model.get('value'));
        this.setValue(this.normalizeValue(value + step));
        this.elementUpdated();
    };
    /**
     * Invoked when the down arrow is clicked
     * */
    InputNumber.prototype.downArrowClick = function () {
        var model = this.model;
        var step = model.get('step');
        var value = parseFloat(model.get('value'));
        this.setValue(this.normalizeValue(value - step));
        this.elementUpdated();
    };
    /**
     * Change easily integer input value with click&drag method
     * @param Event
     *
     * @return void
     * */
    InputNumber.prototype.downIncrement = function (e) {
        e.preventDefault();
        this.moved = false;
        var value = this.model.get('value') || 0;
        value = this.normalizeValue(value);
        this.current = { y: e.pageY, val: value };
        (0,dom.on)(this.doc, 'mousemove', this.moveIncrement);
        (0,dom.on)(this.doc, 'mouseup', this.upIncrement);
    };
    /** While the increment is clicked, moving the mouse will update input value
     * @param Object
     *
     * @return bool
     * */
    InputNumber.prototype.moveIncrement = function (ev) {
        this.moved = true;
        var model = this.model;
        var step = model.get('step');
        var data = this.current;
        var pos = this.normalizeValue(data.val + (data.y - ev.pageY) * step);
        var _a = this.validateInputValue(pos), value = _a.value, unit = _a.unit;
        this.prValue = value;
        model.set({ value: value, unit: unit }, { avoidStore: 1 });
        return false;
    };
    /**
     * Stop moveIncrement method
     * */
    InputNumber.prototype.upIncrement = function () {
        var model = this.model;
        var step = model.get('step');
        (0,dom/* off */.S1)(this.doc, 'mouseup', this.upIncrement);
        (0,dom/* off */.S1)(this.doc, 'mousemove', this.moveIncrement);
        if (this.prValue && this.moved) {
            var value = this.prValue - step;
            // @ts-ignore
            model.set('value', value, { avoidStore: 1 }).set('value', value + step);
            this.elementUpdated();
        }
    };
    InputNumber.prototype.normalizeValue = function (value, defValue) {
        if (defValue === void 0) { defValue = 0; }
        var model = this.model;
        var step = model.get('step');
        var stepDecimals = 0;
        if (isNaN(value)) {
            return defValue;
        }
        value = parseFloat(value);
        if (Math.floor(value) !== value) {
            var side = step.toString().split('.')[1];
            stepDecimals = side ? side.length : 0;
        }
        return stepDecimals ? parseFloat(value.toFixed(stepDecimals)) : value;
    };
    /**
     * Validate input value
     * @param {String} value Raw value
     * @param {Object} opts Options
     * @return {Object} Validated string
     */
    InputNumber.prototype.validateInputValue = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var force = 0;
        var opt = opts || {};
        var model = this.model;
        var defValue = ''; //model.get('defaults');
        var val = !(0,index_all.isUndefined)(value) ? value : defValue;
        var units = opts.units || model.get('units') || [];
        var unit = model.get('unit') || (units.length && units[0]) || '';
        var max = !(0,index_all.isUndefined)(opts.max) ? opts.max : model.get('max');
        var min = !(0,index_all.isUndefined)(opts.min) ? opts.min : model.get('min');
        var limitlessMax = !!model.get('limitlessMax');
        var limitlessMin = !!model.get('limitlessMin');
        if (opt.deepCheck) {
            var fixed = model.get('fixedValues') || [];
            if (val === '')
                unit = '';
            if (val) {
                // If the value is one of the fixed values I leave it as it is
                var regFixed = new RegExp('^' + fixed.join('|'), 'g');
                if (fixed.length && regFixed.test(val)) {
                    val = val.match(regFixed)[0];
                    unit = '';
                    force = 1;
                }
                else {
                    var valCopy = val + '';
                    val += ''; // Make it suitable for replace
                    val = parseFloat(val.replace(',', '.'));
                    val = !isNaN(val) ? val : defValue;
                    var uN = valCopy.replace(val, '');
                    // Check if exists as unit
                    if ((0,index_all.indexOf)(units, uN) >= 0)
                        unit = uN;
                }
            }
        }
        if (!limitlessMax && !(0,index_all.isUndefined)(max) && max !== '')
            val = val > max ? max : val;
        if (!limitlessMin && !(0,index_all.isUndefined)(min) && min !== '')
            val = val < min ? min : val;
        return {
            force: force,
            value: val,
            unit: unit,
        };
    };
    InputNumber.prototype.render = function () {
        ui_Input.prototype.render.call(this);
        this.unitEl = null;
        var unit = this.getUnitEl();
        unit && this.$el.find(".".concat(this.ppfx, "field-units")).get(0).appendChild(unit);
        return this;
    };
    return InputNumber;
}(ui_Input));
/* harmony default export */ const ui_InputNumber = (InputNumber);
InputNumber.prototype.events = {
    // @ts-ignore
    'change input': 'handleChange',
    'change select': 'handleUnitChange',
    'click [data-arrow-up]': 'upArrowClick',
    'click [data-arrow-down]': 'downArrowClick',
    'mousedown [data-arrows]': 'downIncrement',
    keydown: 'handleKeyDown',
};

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitNumberView.ts
var view_TraitNumberView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var TraitNumberView_TraitNumberView = /** @class */ (function (_super) {
    view_TraitNumberView_extends(TraitNumberView, _super);
    function TraitNumberView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TraitNumberView.prototype.getValueForTarget = function () {
        var model = this.model;
        var _a = model.attributes, value = _a.value, unit = _a.unit;
        return !(0,index_all.isUndefined)(value) && value !== '' ? value + unit : model.get('default');
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitNumberView.prototype.getInputEl = function () {
        if (!this.input) {
            var _a = this, ppfx = _a.ppfx, model = _a.model;
            var value = this.getModelValue();
            var inputNumber = new ui_InputNumber({
                contClass: "".concat(ppfx, "field-int"),
                type: 'number',
                model: model,
                ppfx: ppfx,
            });
            inputNumber.render();
            this.$input = inputNumber.inputEl;
            this.$unit = inputNumber.unitEl;
            // @ts-ignore
            model.set('value', value, { fromTarget: true });
            this.$input.val(value);
            this.input = inputNumber.el;
        }
        return this.input;
    };
    return TraitNumberView;
}(trait_manager_view_TraitView));
/* harmony default export */ const view_TraitNumberView = (TraitNumberView_TraitNumberView);

;// CONCATENATED MODULE: ./src/domain_abstract/ui/InputColor.ts
var InputColor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var InputColor_assign = (undefined && undefined.__assign) || function () {
    InputColor_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return InputColor_assign.apply(this, arguments);
};




cash_dom["default"] && ColorPicker(cash_dom["default"]);
var InputColor_getColor = function (color) {
    var name = color.getFormat() === 'name' && color.toName();
    var cl = color.getAlpha() == 1 ? color.toHexString() : color.toRgbString();
    return name || cl.replace(/ /g, '');
};
var InputColor = /** @class */ (function (_super) {
    InputColor_extends(InputColor, _super);
    function InputColor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InputColor.prototype.template = function () {
        var ppfx = this.ppfx;
        return "\n      <div class=\"".concat(this.holderClass(), "\"></div>\n      <div class=\"").concat(ppfx, "field-colorp\">\n        <div class=\"").concat(ppfx, "field-colorp-c\" data-colorp-c>\n          <div class=\"").concat(ppfx, "checker-bg\"></div>\n        </div>\n      </div>\n    ");
    };
    InputColor.prototype.inputClass = function () {
        var ppfx = this.ppfx;
        return "".concat(ppfx, "field ").concat(ppfx, "field-color");
    };
    InputColor.prototype.holderClass = function () {
        return "".concat(this.ppfx, "input-holder");
    };
    InputColor.prototype.remove = function () {
        _super.prototype.remove.call(this);
        this.colorEl.spectrum('destroy');
        return this;
    };
    InputColor.prototype.handleChange = function (e) {
        e.stopPropagation();
        var value = e.target.value;
        if ((0,index_all.isUndefined)(value))
            return;
        this.__onInputChange(value);
    };
    InputColor.prototype.__onInputChange = function (val) {
        var _a = this, model = _a.model, opts = _a.opts;
        var onChange = opts.onChange;
        var value = val;
        var colorEl = this.getColorEl();
        // Check the color by using the ColorPicker's parser
        if (colorEl) {
            colorEl.spectrum('set', value);
            var tc = colorEl.spectrum('get');
            var color = value && InputColor_getColor(tc);
            color && (value = color);
        }
        onChange ? onChange(value) : model.set({ value: value }, { fromInput: 1 });
    };
    /**
     * Set value to the model
     * @param {string} val
     * @param {Object} opts
     */
    InputColor.prototype.setValue = function (val, opts) {
        if (opts === void 0) { opts = {}; }
        var model = this.model;
        var def = !(0,index_all.isUndefined)(opts.def) ? opts.def : model.get('defaults');
        var value = !(0,index_all.isUndefined)(val) ? val : !(0,index_all.isUndefined)(def) ? def : '';
        var inputEl = this.getInputEl();
        var colorEl = this.getColorEl();
        var valueClr = value != 'none' ? value : '';
        inputEl.value = value;
        colorEl.get(0).style.backgroundColor = valueClr;
        // This prevents from adding multiple thumbs in spectrum
        if (opts.fromTarget || (opts.fromInput && !opts.avoidStore)) {
            colorEl.spectrum('set', valueClr);
            this.noneColor = value == 'none';
            this.movedColor = valueClr;
        }
    };
    /**
     * Get the color input element
     * @return {HTMLElement}
     */
    InputColor.prototype.getColorEl = function () {
        var _this = this;
        if (!this.colorEl) {
            var _a = this, em = _a.em, model_1 = _a.model, opts = _a.opts;
            var ppfx = this.ppfx;
            var onChange_1 = opts.onChange;
            var colorEl = (0,cash_dom["default"])("<div class=\"".concat(this.ppfx, "field-color-picker\"></div>"));
            var cpStyle = colorEl.get(0).style;
            var elToAppend = em && em.config ? em.config.el : '';
            var colorPickerConfig = (em && em.getConfig && em.getConfig().colorPicker) || {};
            this.movedColor = '';
            var changed_1 = false;
            var previousColor_1;
            this.$el.find('[data-colorp-c]').append(colorEl);
            var handleChange_1 = function (value, complete) {
                if (complete === void 0) { complete = true; }
                if (onChange_1) {
                    onChange_1(value, !complete);
                }
                else {
                    complete && model_1.setValueFromInput(0, false); // for UndoManager
                    model_1.setValueFromInput(value, complete);
                }
            };
            // @ts-ignore
            colorEl.spectrum(InputColor_assign(InputColor_assign(InputColor_assign({ color: model_1.getValue() || false, containerClassName: "".concat(ppfx, "one-bg ").concat(ppfx, "two-color"), appendTo: elToAppend || 'body', maxSelectionSize: 8, showPalette: true, showAlpha: true, chooseText: 'Ok', cancelText: '⨯', palette: [] }, colorPickerConfig), (model_1.get('colorPicker') || {})), { move: function (color) {
                    var cl = InputColor_getColor(color);
                    _this.movedColor = cl;
                    cpStyle.backgroundColor = cl;
                    handleChange_1(cl, false);
                }, change: function (color) {
                    changed_1 = true;
                    var cl = InputColor_getColor(color);
                    cpStyle.backgroundColor = cl;
                    handleChange_1(cl);
                    _this.noneColor = false;
                }, show: function (color) {
                    changed_1 = false;
                    _this.movedColor = '';
                    previousColor_1 = onChange_1 ? model_1.getValue({ noDefault: true }) : InputColor_getColor(color);
                }, hide: function () {
                    if (!changed_1 && (previousColor_1 || onChange_1)) {
                        if (_this.noneColor) {
                            previousColor_1 = '';
                        }
                        cpStyle.backgroundColor = previousColor_1;
                        // @ts-ignore
                        colorEl.spectrum('set', previousColor_1);
                        handleChange_1(previousColor_1, false);
                    }
                } }));
            if (em && em.on) {
                this.listenTo(em, 'component:selected', function () {
                    _this.movedColor && handleChange_1(_this.movedColor);
                    changed_1 = true;
                    _this.movedColor = '';
                    // @ts-ignore
                    colorEl.spectrum('hide');
                });
            }
            this.colorEl = colorEl;
        }
        return this.colorEl;
    };
    InputColor.prototype.render = function () {
        ui_Input.prototype.render.call(this);
        // This will make the color input available on render
        this.getColorEl();
        return this;
    };
    return InputColor;
}(ui_Input));
/* harmony default export */ const ui_InputColor = (InputColor);

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitColorView.ts
var view_TraitColorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TraitColorView_TraitColorView = /** @class */ (function (_super) {
    view_TraitColorView_extends(TraitColorView, _super);
    function TraitColorView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TraitColorView.prototype.templateInput = function () {
        return '';
    };
    /**
     * Returns input element
     * @return {HTMLElement}
     * @private
     */
    TraitColorView.prototype.getInputEl = function () {
        if (!this.input) {
            var model = this.model;
            var value = this.getModelValue();
            var inputColor = new ui_InputColor({
                model: model,
                target: this.config.em,
                contClass: this.ppfx + 'field-color',
                ppfx: this.ppfx,
            });
            var input = inputColor.render();
            input.setValue(value, { fromTarget: 1 });
            this.input = input.el;
        }
        return this.input;
    };
    return TraitColorView;
}(trait_manager_view_TraitView));
/* harmony default export */ const trait_manager_view_TraitColorView = (TraitColorView_TraitColorView);

;// CONCATENATED MODULE: ./src/trait_manager/view/TraitButtonView.ts
var view_TraitButtonView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var TraitButtonView_TraitButtonView = /** @class */ (function (_super) {
    view_TraitButtonView_extends(TraitButtonView, _super);
    function TraitButtonView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TraitButtonView.prototype.templateInput = function () {
        return '';
    };
    TraitButtonView.prototype.onChange = function () {
        this.handleClick();
    };
    TraitButtonView.prototype.handleClick = function () {
        var _a = this, model = _a.model, em = _a.em;
        var command = model.get('command');
        if (command) {
            if ((0,index_all.isString)(command)) {
                em.Commands.run(command);
            }
            else {
                command(em.Editor, model);
            }
        }
    };
    TraitButtonView.prototype.renderLabel = function () {
        if (this.model.get('label')) {
            trait_manager_view_TraitView.prototype.renderLabel.apply(this);
        }
    };
    TraitButtonView.prototype.getInputEl = function () {
        var _a = this, model = _a.model, ppfx = _a.ppfx;
        var _b = model.props(), labelButton = _b.labelButton, text = _b.text, full = _b.full;
        var label = labelButton || text;
        var className = "".concat(ppfx, "btn");
        var input = "<button type=\"button\" class=\"".concat(className, "-prim").concat(full ? " ".concat(className, "--full") : '', "\">").concat(label, "</button>");
        return input;
    };
    return TraitButtonView;
}(trait_manager_view_TraitView));
/* harmony default export */ const trait_manager_view_TraitButtonView = (TraitButtonView_TraitButtonView);
// Fix #4388
TraitButtonView_TraitButtonView.prototype.eventCapture = ['click button'];

;// CONCATENATED MODULE: ./src/trait_manager/index.ts
var trait_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();











var trait_manager_evAll = 'trait';
var trait_manager_evPfx = "".concat(trait_manager_evAll, ":");
var trait_manager_evCustom = "".concat(trait_manager_evPfx, "custom");
var typesDef = {
    text: trait_manager_view_TraitView,
    number: view_TraitNumberView,
    select: trait_manager_view_TraitSelectView,
    checkbox: trait_manager_view_TraitCheckboxView,
    color: trait_manager_view_TraitColorView,
    button: trait_manager_view_TraitButtonView,
};
var TraitManager = /** @class */ (function (_super) {
    trait_manager_extends(TraitManager, _super);
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Initialize module
     * @private
     */
    function TraitManager(em) {
        var _this = _super.call(this, em, 'TraitManager', trait_manager_config_config) || this;
        _this.TraitsView = view_TraitsView;
        _this.events = {
            all: trait_manager_evAll,
            custom: trait_manager_evCustom,
        };
        var model = new common/* Model */.Hn();
        _this.model = model;
        _this.types = typesDef;
        var upAll = (0,index_all.debounce)(function () { return _this.__upSel(); }, 0);
        model.listenTo(em, 'component:toggled', upAll);
        var update = (0,index_all.debounce)(function () { return _this.__onUp(); }, 0);
        model.listenTo(em, 'trait:update', update);
        return _this;
    }
    TraitManager.prototype.__upSel = function () {
        this.select(this.em.getSelected());
    };
    TraitManager.prototype.__onUp = function () {
        this.select(this.getSelected());
    };
    TraitManager.prototype.select = function (component) {
        this.model.set({ component: component });
        this.render();
        this.__trgCustom();
    };
    TraitManager.prototype.getSelected = function () {
        return this.model.get('component');
    };
    /**
     * Get traits from the currently selected component.
     */
    TraitManager.prototype.getCurrent = function () {
        var _a;
        return ((_a = this.getSelected()) === null || _a === void 0 ? void 0 : _a.traits) || [];
    };
    TraitManager.prototype.__trgCustom = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.__ctn = this.__ctn || opts.container;
        this.em.trigger(this.events.custom, { container: this.__ctn });
    };
    TraitManager.prototype.postRender = function () {
        this.__appendTo();
    };
    /**
     *
     * Get Traits viewer
     * @private
     */
    TraitManager.prototype.getTraitsViewer = function () {
        return this.view;
    };
    /**
     * Add new trait type
     * @param {string} name Type name
     * @param {Object} methods Object representing the trait
     */
    TraitManager.prototype.addType = function (name, trait) {
        var baseView = this.getType('text');
        //@ts-ignore
        this.types[name] = baseView.extend(trait);
    };
    /**
     * Get trait type
     * @param {string} name Type name
     * @return {Object}
     */
    TraitManager.prototype.getType = function (name) {
        return this.getTypes()[name];
    };
    /**
     * Get all trait types
     * @returns {Object}
     */
    TraitManager.prototype.getTypes = function () {
        return this.types;
    };
    TraitManager.prototype.render = function () {
        var _a = this, view = _a.view, em = _a.em;
        var el = view === null || view === void 0 ? void 0 : view.el;
        var traits = this.getCurrent(); //.map(trait => InputFactory.buildView(trait as any, em, trait.opts as any));
        console.log(traits);
        this.view = new view_TraitsView(em, { el: el, traits: traits }).render();
        return this.view.el;
    };
    TraitManager.prototype.destroy = function () {
        this.model.stopListening();
        this.model.clear();
    };
    return TraitManager;
}(abstract_Module));
/* harmony default export */ const trait_manager = (TraitManager);

;// CONCATENATED MODULE: ./src/navigator/config/config.ts
var navigator_config_config_config = {
    stylePrefix: '',
    appendTo: '',
    sortable: true,
    hidable: true,
    hideTextnode: true,
    root: '',
    showWrapper: true,
    showHover: true,
    scrollCanvas: { behavior: 'smooth', block: 'nearest' },
    scrollLayers: { behavior: 'auto', block: 'nearest' },
    highlightHover: true,
    custom: false,
    onInit: function () { },
    onRender: function () { },
    extend: {},
};
/* harmony default export */ const navigator_config_config = (navigator_config_config_config);

;// CONCATENATED MODULE: ./src/navigator/view/ItemsView.ts
var ItemsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var ItemsView = /** @class */ (function (_super) {
    ItemsView_extends(ItemsView, _super);
    function ItemsView(opt) {
        if (opt === void 0) { opt = {}; }
        var _this = _super.call(this, opt) || this;
        _this.items = [];
        _this.opt = opt;
        var config = opt.config || {};
        _this.config = config;
        _this.parentView = opt.parentView;
        var pfx = config.stylePrefix || '';
        var ppfx = config.pStylePrefix || '';
        var coll = _this.collection;
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset resetNavigator', _this.render);
        _this.listenTo(coll, 'remove', _this.removeChildren);
        _this.className = "".concat(pfx, "layers");
        var em = config.em;
        if (config.sortable && !_this.opt.sorter) {
            var utils = em.Utils;
            _this.opt.sorter = new utils.Sorter({
                // @ts-ignore
                container: config.sortContainer || _this.el,
                containerSel: ".".concat(_this.className),
                itemSel: ".".concat(pfx, "layer"),
                ignoreViewChildren: 1,
                avoidSelectOnEnd: 1,
                nested: 1,
                ppfx: ppfx,
                pfx: pfx,
                em: em,
            });
        }
        // For the sorter
        _this.$el.data('collection', coll);
        opt.parent && _this.$el.data('model', opt.parent);
        return _this;
    }
    ItemsView.prototype.removeChildren = function (removed) {
        // @ts-ignore
        var view = removed.viewLayer;
        if (!view)
            return;
        view.remove();
        // @ts-ignore
        delete removed.viewLayer;
    };
    /**
     * Add to collection
     * @param Object Model
     *
     * @return Object
     * */
    ItemsView.prototype.addTo = function (model) {
        var i = this.collection.indexOf(model);
        this.addToCollection(model, null, i);
    };
    /**
     * Add new object to collection
     * @param  Object  Model
     * @param  Object   Fragment collection
     * @param  integer  Index of append
     *
     * @return Object Object created
     * */
    ItemsView.prototype.addToCollection = function (model, fragmentEl, index) {
        var _a = this, parentView = _a.parentView, opt = _a.opt, config = _a.config;
        var ItemView = opt.ItemView, opened = opt.opened, module = opt.module, level = opt.level, sorter = opt.sorter;
        var fragment = fragmentEl || null;
        var item = new ItemView({
            ItemView: ItemView,
            level: level,
            model: model,
            parentView: parentView,
            config: config,
            sorter: sorter,
            opened: opened,
            module: module,
        });
        var rendered = item.render().el;
        if (fragment) {
            fragment.appendChild(rendered);
        }
        else {
            if (typeof index !== 'undefined') {
                var method = 'before';
                // If the added model is the last of collection
                // need to change the logic of append
                if (this.$el.children().length == index) {
                    index--;
                    method = 'after';
                }
                // In case the added is new in the collection index will be -1
                if (index < 0) {
                    this.$el.append(rendered);
                }
                else {
                    // @ts-ignore
                    this.$el.children().eq(index)[method](rendered);
                }
            }
            else
                this.$el.append(rendered);
        }
        this.items.push(item);
        return rendered;
    };
    ItemsView.prototype.remove = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        common/* View */.G7.prototype.remove.apply(this, args);
        this.items.map(function (i) { return i.remove(); });
        return this;
    };
    ItemsView.prototype.render = function () {
        var _this = this;
        var frag = document.createDocumentFragment();
        var el = this.el;
        el.innerHTML = '';
        this.collection.each(function (model) { return _this.addToCollection(model, frag); });
        el.appendChild(frag);
        el.className = this.className;
        return this;
    };
    return ItemsView;
}(common/* View */.G7));
/* harmony default export */ const view_ItemsView = (ItemsView);

// EXTERNAL MODULE: ./src/commands/view/CommandAbstract.ts
<<<<<<< HEAD
var CommandAbstract = __webpack_require__(458);
=======
var CommandAbstract = __webpack_require__(790);
>>>>>>> script-module
;// CONCATENATED MODULE: ./src/commands/config/config.ts
var commands_config_config_config = {
    stylePrefix: 'com-',
    defaults: {},
    strict: true,
};
/* harmony default export */ const commands_config_config = (commands_config_config_config);

;// CONCATENATED MODULE: ./src/commands/index.ts
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/commands/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  commands: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('run', () => { ... });
 *
 * // Use the API
 * const commands = editor.Commands;
 * commands.add(...);
 * ```
 *
 ** ## Available Events
 * * `run:{commandName}` - Triggered when some command is called to run (eg. editor.runCommand('preview'))
 * * `stop:{commandName}` - Triggered when some command is called to stop (eg. editor.stopCommand('preview'))
 * * `run:{commandName}:before` - Triggered before the command is called
 * * `stop:{commandName}:before` - Triggered before the command is called to stop
 * * `abort:{commandName}` - Triggered when the command execution is aborted (`editor.on(`run:preview:before`, opts => opts.abort = 1);`)
 * * `run` - Triggered on run of any command. The id and the result are passed as arguments to the callback
 * * `stop` - Triggered on stop of any command. The id and the result are passed as arguments to the callback
 *
 * ## Methods
 * * [add](#add)
 * * [get](#get)
 * * [getAll](#getall)
 * * [extend](#extend)
 * * [has](#has)
 * * [run](#run)
 * * [stop](#stop)
 * * [isActive](#isactive)
 * * [getActive](#getactive)
 *
 * @module Commands
 */
var commands_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var commands_assign = (undefined && undefined.__assign) || function () {
    commands_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return commands_assign.apply(this, arguments);
};
var commands_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};





var commandsDef = [
    ['preview', 'Preview', 'preview'],
    ['resize', 'Resize', 'resize'],
    ['fullscreen', 'Fullscreen', 'fullscreen'],
    ['copy', 'CopyComponent'],
    ['paste', 'PasteComponent'],
    ['canvas-move', 'CanvasMove'],
    ['canvas-clear', 'CanvasClear'],
    ['open-code', 'ExportTemplate', 'export-template'],
    ['open-layers', 'OpenLayers', 'open-layers'],
    ['open-styles', 'OpenStyleManager', 'open-sm'],
    ['open-traits', 'OpenTraitManager', 'open-tm'],
    ['open-blocks', 'OpenBlocks', 'open-blocks'],
    ['open-assets', 'OpenAssets', 'open-assets'],
<<<<<<< HEAD
    ['open-pages', 'OpenPages', 'open-pages'],
=======
>>>>>>> script-module
    ['component-select', 'SelectComponent', 'select-comp'],
    ['component-outline', 'SwitchVisibility', 'sw-visibility'],
    ['component-offset', 'ShowOffset', 'show-offset'],
    ['component-move', 'MoveComponent', 'move-comp'],
    ['component-next', 'ComponentNext'],
    ['component-prev', 'ComponentPrev'],
    ['component-enter', 'ComponentEnter'],
    ['component-exit', 'ComponentExit', 'select-parent'],
    ['component-delete', 'ComponentDelete'],
    ['component-style-clear', 'ComponentStyleClear'],
    ['component-drag', 'ComponentDrag'],
];
var defComOptions = { preserveSelected: 1 };
var getOnComponentDragStart = function (em) { return function (data) { return em.trigger("".concat(eventDrag, ":start"), data); }; };
var getOnComponentDrag = function (em) { return function (data) { return em.trigger(eventDrag, data); }; };
var getOnComponentDragEnd = function (em, targets, opts) {
    if (opts === void 0) { opts = {}; }
    return function (a, b, data) {
        targets.forEach(function (trg) { return trg.set('status', trg.get('selectable') ? 'selected' : ''); });
        em.setSelected(targets);
        targets[0].emitUpdate();
        em.trigger("".concat(eventDrag, ":end"), data);
        // Defer selectComponent in order to prevent canvas "freeze" #2692
        setTimeout(function () { return em.runDefault(defComOptions); });
        // Dirty patch to prevent parent selection on drop
        (opts.altMode || data.cancelled) && em.set('_cmpDrag', 1);
    };
};
var CommandsModule = /** @class */ (function (_super) {
    commands_extends(CommandsModule, _super);
    /**
     * @private
     */
    function CommandsModule(em) {
        var _this = _super.call(this, em, 'Commands', commands_config_config) || this;
        _this.CommandAbstract = CommandAbstract["default"];
        _this.defaultCommands = {};
        _this.commands = {};
        _this.active = {};
        var config = _this.config;
        var ppfx = config.pStylePrefix;
        var defaultCommands = _this.defaultCommands;
        if (ppfx) {
            config.stylePrefix = ppfx + config.stylePrefix;
        }
        // Load commands passed via configuration
        Object.keys(config.defaults).forEach(function (k) {
            var obj = config.defaults[k];
            if (obj.id)
                _this.add(obj.id, obj);
        });
        defaultCommands['tlb-delete'] = {
            run: function (ed) {
                return ed.runCommand('core:component-delete');
            },
        };
        defaultCommands['tlb-clone'] = {
            run: function (ed) {
                ed.runCommand('core:copy');
                ed.runCommand('core:paste', { action: 'clone-component' });
            },
        };
        defaultCommands['tlb-move'] = {
            run: function (ed, s, opts) {
                var _a;
                if (opts === void 0) { opts = {}; }
                var dragger;
                var em = ed.getModel();
                var event = opts.event;
                var trg = opts.target;
                var trgs = trg ? [trg] : commands_spreadArray([], ed.getSelectedAll(), true);
                var targets = trgs.map(function (trg) { var _a, _b; return ((_b = (_a = trg.delegate) === null || _a === void 0 ? void 0 : _a.move) === null || _b === void 0 ? void 0 : _b.call(_a, trg)) || trg; }).filter(Boolean);
                var target = targets[0];
                var nativeDrag = (event === null || event === void 0 ? void 0 : event.type) === 'dragstart';
                var modes = ['absolute', 'translate'];
                if (!(target === null || target === void 0 ? void 0 : target.get('draggable'))) {
                    return em.logWarning('The element is not draggable');
                }
                var mode = target.get('dmode') || em.get('dmode');
                var hideTlb = function () { return em.stopDefault(defComOptions); };
                var altMode = (0,index_all.includes)(modes, mode);
                targets.forEach(function (trg) { return trg.trigger('disable', { fromMove: true }); });
                // Without setTimeout the ghost image disappears
                nativeDrag ? setTimeout(hideTlb, 0) : hideTlb();
                var onStart = getOnComponentDragStart(em);
                var onDrag = getOnComponentDrag(em);
                var onEnd = getOnComponentDragEnd(em, targets, { altMode: altMode });
                if (altMode) {
                    // TODO move grabbing func in editor/canvas from the Sorter
                    dragger = ed.runCommand('core:component-drag', {
                        guidesInfo: 1,
                        mode: mode,
                        target: target,
                        onStart: onStart,
                        onDrag: onDrag,
                        onEnd: onEnd,
                        event: event,
                    });
                }
                else {
                    if (nativeDrag) {
                        event.dataTransfer.setDragImage((_a = target.view) === null || _a === void 0 ? void 0 : _a.el, 0, 0);
                        //sel.set('status', 'freezed');
                    }
                    var cmdMove = ed.Commands.get('move-comp');
                    cmdMove.onStart = onStart;
                    cmdMove.onDrag = onDrag;
                    cmdMove.onEndMoveFromModel = onEnd;
                    // @ts-ignore
                    cmdMove.initSorterFromModels(targets);
                }
                targets.filter(function (sel) { return sel.get('selectable'); }).forEach(function (sel) { return sel.set('status', 'freezed-selected'); });
            },
        };
        // Core commands
        defaultCommands['core:undo'] = function (e) { return e.UndoManager.undo(); };
        defaultCommands['core:redo'] = function (e) { return e.UndoManager.redo(); };
        commandsDef.forEach(function (item) {
            var oldCmd = item[2];
            var cmd = __webpack_require__(828)("./".concat(item[1])).default;
            var cmdName = "core:".concat(item[0]);
            defaultCommands[cmdName] = cmd;
            if (oldCmd) {
                defaultCommands[oldCmd] = cmd;
                // Propogate old commands (can be removed once we stop to call old commands)
                ['run', 'stop'].forEach(function (name) {
                    em.on("".concat(name, ":").concat(oldCmd), function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        return em.trigger.apply(em, commands_spreadArray(["".concat(name, ":").concat(cmdName)], args, false));
                    });
                });
            }
        });
        // @ts-ignore TODO check where it's used
        config.model = em.Canvas;
        for (var id in defaultCommands) {
            _this.add(id, defaultCommands[id]);
        }
        return _this;
    }
    /**
     * Add new command to the collection
     * @param	{string} id Command's ID
     * @param	{Object|Function} command Object representing your command,
     *  By passing just a function it's intended as a stateless command
     *  (just like passing an object with only `run` method).
     * @return {this}
     * @example
     * commands.add('myCommand', {
     * 	run(editor, sender) {
     * 		alert('Hello world!');
     * 	},
     * 	stop(editor, sender) {
     * 	},
     * });
     * // As a function
     * commands.add('myCommand2', editor => { ... });
     * */
    CommandsModule.prototype.add = function (id, command) {
        var result = (0,index_all.isFunction)(command) ? { run: command } : command;
        if (!result.stop) {
            result.noStop = true;
        }
        delete result.initialize;
        result.id = id;
        this.commands[id] = CommandAbstract["default"].extend(result);
        return this;
    };
    /**
     * Get command by ID
     * @param	{string}	id Command's ID
     * @return {Object} Object representing the command
     * @example
     * var myCommand = commands.get('myCommand');
     * myCommand.run();
     * */
    CommandsModule.prototype.get = function (id) {
        var command = this.commands[id];
        if ((0,index_all.isFunction)(command)) {
            command = new command(this.config);
            this.commands[id] = command;
        }
        else if (!command) {
            this.em.logWarning("'".concat(id, "' command not found"));
        }
        return command;
    };
    /**
     * Extend the command. The command to extend should be defined as an object
     * @param	{string}	id Command's ID
     * @param {Object} Object with the new command functions
     * @returns {this}
     * @example
     * commands.extend('old-command', {
     *  someInnerFunction() {
     *  // ...
     *  }
     * });
     * */
    CommandsModule.prototype.extend = function (id, cmd) {
        if (cmd === void 0) { cmd = {}; }
        var command = this.get(id);
        if (command) {
            var cmdObj = commands_assign(commands_assign({}, command.constructor.prototype), cmd);
            this.add(id, cmdObj);
            // Extend also old name commands if exist
            var oldCmd = commandsDef.filter(function (cmd) { return "core:".concat(cmd[0]) === id && cmd[2]; })[0];
            oldCmd && this.add(oldCmd[2], cmdObj);
        }
        return this;
    };
    /**
     * Check if command exists
     * @param	{string}	id Command's ID
     * @return {Boolean}
     * */
    CommandsModule.prototype.has = function (id) {
        return !!this.commands[id];
    };
    /**
     * Get an object containing all the commands
     * @return {Object}
     */
    CommandsModule.prototype.getAll = function () {
        return this.commands;
    };
    /**
     * Execute the command
     * @param {String} id Command ID
     * @param {Object} [options={}] Options
     * @return {*} The return is defined by the command
     * @example
     * commands.run('myCommand', { someOption: 1 });
     */
    CommandsModule.prototype.run = function (id, options) {
        if (options === void 0) { options = {}; }
        return this.runCommand(this.get(id), options);
    };
    /**
     * Stop the command
     * @param {String} id Command ID
     * @param {Object} [options={}] Options
     * @return {*} The return is defined by the command
     * @example
     * commands.stop('myCommand', { someOption: 1 });
     */
    CommandsModule.prototype.stop = function (id, options) {
        if (options === void 0) { options = {}; }
        return this.stopCommand(this.get(id), options);
    };
    /**
     * Check if the command is active. You activate commands with `run`
     * and disable them with `stop`. If the command was created without `stop`
     * method it can't be registered as active
     * @param  {String}  id Command id
     * @return {Boolean}
     * @example
     * const cId = 'some-command';
     * commands.run(cId);
     * commands.isActive(cId);
     * // -> true
     * commands.stop(cId);
     * commands.isActive(cId);
     * // -> false
     */
    CommandsModule.prototype.isActive = function (id) {
        return this.getActive().hasOwnProperty(id);
    };
    /**
     * Get all active commands
     * @return {Object}
     * @example
     * console.log(commands.getActive());
     * // -> { someCommand: itsLastReturn, anotherOne: ... };
     */
    CommandsModule.prototype.getActive = function () {
        return this.active;
    };
    /**
     * Run command via its object
     * @param  {Object} command
     * @param {Object} options
     * @return {*} Result of the command
     * @private
     */
    CommandsModule.prototype.runCommand = function (command, options) {
        if (options === void 0) { options = {}; }
        var result;
        if (command && command.run) {
            var _a = this, em = _a.em, config = _a.config;
            var id = command.id;
            var editor = em.Editor;
            if (!this.isActive(id) || options.force || !config.strict) {
                // @ts-ignore
                result = editor && command.callRun(editor, options);
                if (id && command.stop && !command.noStop && !options.abort) {
                    this.active[id] = result;
                }
            }
        }
        return result;
    };
    /**
     * Stop the command
     * @param  {Object} command
     * @param {Object} options
     * @return {*} Result of the command
     * @private
     */
    CommandsModule.prototype.stopCommand = function (command, options) {
        if (options === void 0) { options = {}; }
        var result;
        if (command && command.run) {
            var _a = this, em = _a.em, config = _a.config;
            var id = command.id;
            var editor = em.Editor;
            if (this.isActive(id) || options.force || !config.strict) {
                if (id)
                    delete this.active[id];
                // @ts-ignore
                result = command.callStop(editor, options);
            }
        }
        return result;
    };
    /**
     * Create anonymous Command instance
     * @param {Object} command Command object
     * @return {Command}
     * @private
     * */
    CommandsModule.prototype.create = function (command) {
        if (!command.stop)
            command.noStop = true;
        var cmd = CommandAbstract["default"].extend(command);
        return new cmd(this.config);
    };
    CommandsModule.prototype.destroy = function () {
        this.defaultCommands = {};
        this.commands = {};
        this.active = {};
    };
    return CommandsModule;
}(abstract_Module));
/* harmony default export */ const commands = (CommandsModule);

;// CONCATENATED MODULE: ./src/navigator/view/ItemView.ts
var ItemView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();







var ItemView_inputProp = 'contentEditable';
var ItemView = /** @class */ (function (_super) {
    ItemView_extends(ItemView, _super);
    function ItemView(opt) {
        var _this = _super.call(this, opt) || this;
        (0,index_all.bindAll)(_this, '__render');
        _this.opt = opt;
        _this.module = opt.module;
        _this.config = opt.config || {};
        _this.sorter = opt.sorter || '';
        _this.parentView = opt.parentView;
        var _a = _this, model = _a.model, pfx = _a.pfx, ppfx = _a.ppfx;
        var type = model.get('type') || 'default';
        _this.className = "".concat(pfx, "layer ").concat(pfx, "layer__t-").concat(type, " no-select ").concat(ppfx, "two-color");
        _this.inputNameCls = "".concat(ppfx, "layer-name");
        _this.clsTitleC = "".concat(pfx, "layer-title-c");
        _this.clsTitle = "".concat(pfx, "layer-title");
        _this.clsCaret = "".concat(pfx, "layer-caret");
        _this.clsCount = "".concat(pfx, "layer-count");
        _this.clsMove = "".concat(pfx, "layer-move");
        _this.clsChildren = "".concat(pfx, "layer-children");
        _this.clsNoChild = "".concat(pfx, "layer-no-chld");
        _this.clsEdit = "".concat(_this.inputNameCls, "--edit");
        _this.clsNoEdit = "".concat(_this.inputNameCls, "--no-edit");
        _this.initComponent();
        return _this;
    }
    ItemView.prototype.events = function () {
        return {
            'mousedown [data-toggle-move]': 'startSort',
            'touchstart [data-toggle-move]': 'startSort',
            'click [data-toggle-visible]': 'toggleVisibility',
            'click [data-toggle-open]': 'toggleOpening',
            'click [data-toggle-select]': 'handleSelect',
            'mouseover [data-toggle-select]': 'handleHover',
            'mouseout [data-toggle-select]': 'handleHoverOut',
            'dblclick [data-name]': 'handleEdit',
            'keydown [data-name]': 'handleEditKey',
            'focusout [data-name]': 'handleEditEnd',
        };
    };
    ItemView.prototype.template = function (model) {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx, config = _a.config, clsNoEdit = _a.clsNoEdit, module = _a.module, opt = _a.opt, em = _a.em;
        var hidable = config.hidable;
        var count = module.getComponents(model).length;
        var addClass = !count ? this.clsNoChild : '';
        var clsTitle = "".concat(this.clsTitle, " ").concat(addClass);
        var clsTitleC = "".concat(this.clsTitleC);
        var clsInput = "".concat(this.inputNameCls, " ").concat(clsNoEdit, " ").concat(ppfx, "no-app");
        var level = opt.level || 0;
        var gut = "".concat(level * 10, "px");
        var name = model.getName();
        var icon = model.getIcon();
        var clsBase = "".concat(pfx, "layer");
        var icons = (em === null || em === void 0 ? void 0 : em.getConfig()).icons;
        var _b = icons, move = _b.move, eye = _b.eye, eyeOff = _b.eyeOff, chevron = _b.chevron;
        return "\n      <div class=\"".concat(pfx, "layer-item ").concat(ppfx, "one-bg\" data-toggle-select>\n        <div class=\"").concat(pfx, "layer-item-left\">\n          ").concat(hidable
            ? "<i class=\"".concat(pfx, "layer-vis\" data-toggle-visible>\n                <i class=\"").concat(pfx, "layer-vis-on\">").concat(eye, "</i>\n                <i class=\"").concat(pfx, "layer-vis-off\">").concat(eyeOff, "</i>\n              </i>")
            : '', "\n          <div class=\"").concat(clsTitleC, "\">\n            <div class=\"").concat(clsTitle, "\" style=\"padding-left: ").concat(gut, "\">\n              <div class=\"").concat(pfx, "layer-title-inn\" title=\"").concat(name, "\">\n                <i class=\"").concat(this.clsCaret, "\" data-toggle-open>").concat(chevron, "</i>\n                  ").concat(icon ? "<span class=\"".concat(clsBase, "__icon\">").concat(icon, "</span>") : '', "\n                <span class=\"").concat(clsInput, "\" data-name>").concat(name, "</span>\n              </div>\n            </div>\n          </div>\n        </div>\n        <div class=\"").concat(pfx, "layer-item-right\">\n          ").concat(count ? "<div class=\"".concat(this.clsCount, "\" data-count>").concat(count || '', "</div>") : '', "\n          <div class=\"").concat(this.clsMove, "\" data-toggle-move>").concat(move || '', "</div>\n        </div>\n      </div>\n      <div class=\"").concat(this.clsChildren, "\"></div>\n    ");
    };
    Object.defineProperty(ItemView.prototype, "em", {
        get: function () {
            return this.module.em;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ItemView.prototype, "ppfx", {
        get: function () {
            return this.em.getConfig().stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ItemView.prototype, "pfx", {
        get: function () {
            return this.config.stylePrefix;
        },
        enumerable: false,
        configurable: true
    });
    ItemView.prototype.initComponent = function () {
        var _this = this;
        var _a = this, model = _a.model, config = _a.config;
        var onInit = config.onInit;
        var components = model.components();
        this.listenTo(components, 'remove add reset', this.checkChildren);
        [
            ['change:status', this.updateStatus],
            ['change:open', this.updateOpening],
            ['change:layerable', this.updateLayerable],
            ['change:style:display', this.updateVisibility],
            ['rerender:layer', this.render],
            ['change:name change:custom-name', this.updateName],
            // @ts-ignore
        ].forEach(function (item) { return _this.listenTo(model, item[0], item[1]); });
        this.$el.data('model', model);
        this.$el.data('collection', components);
        // @ts-ignore
        model.viewLayer = this;
        onInit.bind(this)({
            component: model,
            render: this.__render,
            listenTo: this.listenTo,
        });
    };
    ItemView.prototype.updateName = function () {
        this.getInputName().innerText = this.model.getName();
    };
    ItemView.prototype.getVisibilityEl = function () {
        if (!this.eyeEl) {
            this.eyeEl = this.$el.children('[data-toggle-select]').find('[data-toggle-visible]');
        }
        return this.eyeEl;
    };
    ItemView.prototype.updateVisibility = function () {
        var _a = this, pfx = _a.pfx, model = _a.model, module = _a.module;
        var hClass = "".concat(pfx, "layer-hidden");
        var hidden = !module.isVisible(model);
        var method = hidden ? 'addClass' : 'removeClass';
        this.$el[method](hClass);
        this.getVisibilityEl()[method]("".concat(pfx, "layer-off"));
    };
    /**
     * Toggle visibility
     * @param	Event
     *
     * @return 	void
     * */
    ItemView.prototype.toggleVisibility = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopImmediatePropagation();
        var _a = this, module = _a.module, model = _a.model;
        module.setVisible(model, !module.isVisible(model));
    };
    /**
     * Handle the edit of the component name
     */
    ItemView.prototype.handleEdit = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
        var _a = this, em = _a.em, $el = _a.$el, clsNoEdit = _a.clsNoEdit, clsEdit = _a.clsEdit;
        var inputEl = this.getInputName();
        inputEl[ItemView_inputProp] = 'true';
        inputEl.focus();
        document.execCommand('selectAll', false);
        em.setEditing(true);
        $el.find(".".concat(this.inputNameCls)).removeClass(clsNoEdit).addClass(clsEdit);
    };
    ItemView.prototype.handleEditKey = function (ev) {
        ev.stopPropagation();
        ((0,dom/* isEscKey */.kl)(ev) || (0,dom/* isEnterKey */.r$)(ev)) && this.handleEditEnd(ev);
    };
    /**
     * Handle with the end of editing of the component name
     */
    ItemView.prototype.handleEditEnd = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
        var _a = this, em = _a.em, $el = _a.$el, clsNoEdit = _a.clsNoEdit, clsEdit = _a.clsEdit;
        var inputEl = this.getInputName();
        var name = inputEl.textContent;
        inputEl.scrollLeft = 0;
        inputEl[ItemView_inputProp] = 'false';
        this.setName(name, { component: this.model, propName: 'custom-name' });
        em.setEditing(false);
        $el.find(".".concat(this.inputNameCls)).addClass(clsNoEdit).removeClass(clsEdit);
        // Ensure to always update the layer name #4544
        this.updateName();
    };
    ItemView.prototype.setName = function (name, _a) {
        var propName = _a.propName;
        this.model.set(propName, name);
    };
    /**
     * Get the input containing the name of the component
     * @return {HTMLElement}
     */
    ItemView.prototype.getInputName = function () {
        if (!this.inputName) {
            this.inputName = this.el.querySelector(".".concat(this.inputNameCls));
        }
        return this.inputName;
    };
    /**
     * Update item opening
     *
     * @return void
     * */
    ItemView.prototype.updateOpening = function () {
        var _a = this, $el = _a.$el, model = _a.model, pfx = _a.pfx;
        var clsOpen = 'open';
        var clsChvOpen = "".concat(pfx, "layer-open");
        var caret = this.getCaret();
        if (this.module.isOpen(model)) {
            $el.addClass(clsOpen);
            caret.addClass(clsChvOpen);
        }
        else {
            $el.removeClass(clsOpen);
            caret.removeClass(clsChvOpen);
        }
    };
    /**
     * Toggle item opening
     * @param {Object}	e
     *
     * @return void
     * */
    ItemView.prototype.toggleOpening = function (ev) {
        var _a = this, model = _a.model, module = _a.module;
        ev === null || ev === void 0 ? void 0 : ev.stopImmediatePropagation();
        if (!model.get('components').length)
            return;
        module.setOpen(model, !module.isOpen(model));
    };
    /**
     * Handle component selection
     */
    ItemView.prototype.handleSelect = function (event) {
        event === null || event === void 0 ? void 0 : event.stopPropagation();
        var _a = this, module = _a.module, model = _a.model;
        module.setLayerData(model, { selected: true }, { event: event });
    };
    /**
     * Handle component selection
     */
    ItemView.prototype.handleHover = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
        var _a = this, module = _a.module, model = _a.model;
        module.setLayerData(model, { hovered: true });
    };
    ItemView.prototype.handleHoverOut = function (ev) {
        ev === null || ev === void 0 ? void 0 : ev.stopPropagation();
        var _a = this, module = _a.module, model = _a.model;
        module.setLayerData(model, { hovered: false });
    };
    /**
     * Delegate to sorter
     * @param	Event
     * */
    ItemView.prototype.startSort = function (ev) {
        var _a, _b, _c;
        ev.stopPropagation();
        var _d = this, em = _d.em, sorter = _d.sorter, model = _d.model;
        // Right or middel click
        if (ev.button && ev.button !== 0)
            return;
        if (sorter) {
            var toMove = ((_b = (_a = model.delegate) === null || _a === void 0 ? void 0 : _a.move) === null || _b === void 0 ? void 0 : _b.call(_a, model)) || model;
            sorter.onStart = getOnComponentDragStart(em);
            sorter.onMoveClb = getOnComponentDrag(em);
            sorter.onEndMove = getOnComponentDragEnd(em, [toMove]);
            var itemEl = ((_c = toMove.viewLayer) === null || _c === void 0 ? void 0 : _c.el) || ev.target;
            sorter.startSort(itemEl);
        }
    };
    /**
     * Update item on status change
     * @param	Event
     * */
    ItemView.prototype.updateStatus = function () {
        // @ts-ignore
        view_ComponentView.prototype.updateStatus.apply(this, [
            {
                avoidHover: !this.config.highlightHover,
                noExtHl: true,
            },
        ]);
    };
    /**
     * Update item aspect after children changes
     *
     * @return void
     * */
    ItemView.prototype.checkChildren = function () {
        var _a = this, model = _a.model, clsNoChild = _a.clsNoChild, $el = _a.$el, module = _a.module;
        var count = module.getComponents(model).length;
        var title = $el.children(".".concat(this.clsTitleC)).children(".".concat(this.clsTitle));
        var cnt = this.cnt;
        if (!cnt) {
            cnt = $el.children('[data-count]').get(0);
            this.cnt = cnt;
        }
        title[count ? 'removeClass' : 'addClass'](clsNoChild);
        if (cnt)
            cnt.innerHTML = count || '';
        !count && module.setOpen(model, false);
    };
    ItemView.prototype.getCaret = function () {
        if (!this.caret || !this.caret.length) {
            this.caret = this.$el.children(".".concat(this.clsTitleC)).find(".".concat(this.clsCaret));
        }
        return this.caret;
    };
    ItemView.prototype.setRoot = function (el) {
        var _a;
        el = (0,index_all.isString)(el) ? (_a = this.em.getWrapper()) === null || _a === void 0 ? void 0 : _a.find(el)[0] : el;
        var model = (0,mixins.getModel)(el);
        if (!model)
            return;
        this.stopListening();
        this.model = model;
        this.initComponent();
        this._rendered && this.render();
    };
    ItemView.prototype.updateLayerable = function () {
        var parentView = this.parentView;
        var toRerender = parentView || this;
        toRerender.render();
    };
    ItemView.prototype.__clearItems = function () {
        var _a;
        (_a = this.items) === null || _a === void 0 ? void 0 : _a.remove();
    };
    ItemView.prototype.remove = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        common/* View */.G7.prototype.remove.apply(this, args);
        this.__clearItems();
        return this;
    };
    ItemView.prototype.render = function () {
        var _a = this, model = _a.model, config = _a.config, pfx = _a.pfx, ppfx = _a.ppfx, opt = _a.opt, sorter = _a.sorter;
        this.__clearItems();
        var opened = opt.opened, module = opt.module, ItemView = opt.ItemView;
        var hidden = !module.__isLayerable(model);
        var el = this.$el.empty();
        var level = opt.level + 1;
        delete this.inputName;
        this.items = new view_ItemsView({
            ItemView: ItemView,
            collection: model.get('components'),
            config: config,
            sorter: sorter,
            opened: opened,
            parentView: this,
            parent: model,
            level: level,
            module: module,
        });
        var children = this.items.render().$el;
        if (!config.showWrapper && level === 1) {
            el.append(children);
        }
        else {
            el.html(this.template(model));
            el.find(".".concat(this.clsChildren)).append(children);
        }
        if (!model.get('draggable') || !config.sortable) {
            el.children(".".concat(this.clsMove)).remove();
        }
        !module.isVisible(model) && (this.className += " ".concat(pfx, "hide"));
        hidden && (this.className += " ".concat(ppfx, "hidden"));
        el.attr('class', this.className);
        this.updateStatus();
        this.updateOpening();
        this.updateVisibility();
        this.__render();
        this._rendered = true;
        return this;
    };
    ItemView.prototype.__render = function () {
        var _a = this, model = _a.model, config = _a.config, el = _a.el;
        var onRender = config.onRender;
        var opt = { component: model, el: el };
        onRender.bind(this)(opt);
        this.em.trigger('layer:render', opt);
    };
    return ItemView;
}(common/* View */.G7));
/* harmony default export */ const view_ItemView = (ItemView);

;// CONCATENATED MODULE: ./src/navigator/index.ts
/**
 * You can customize the initial state of the module from the editor initialization
 * ```js
 * const editor = grapesjs.init({
 *  // ...
 *  layerManager: {
 *    // ...
 *  },
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const layers = editor.Layers;
 * ```
 *
 * ## Available Events
 * * `layer:root` - Root layer changed. The new root component is passed as an argument to the callback.
 * * `layer:component` - Component layer is updated. The updated component is passed as an argument to the callback.
 *
 * ## Methods
 * * [setRoot](#setroot)
 * * [getRoot](#getroot)
 * * [getComponents](#getcomponents)
 * * [setOpen](#setopen)
 * * [isOpen](#isopen)
 * * [setVisible](#setvisible)
 * * [isVisible](#isvisible)
 * * [setlocked](#setlocked)
 * * [isLocked](#islocked)
 * * [setName](#setname)
 * * [getName](#getname)
 * * [getLayerData](#getlayerdata)
 *
 * [Page]: page.html
 * [Component]: component.html
 *
 * @module Layers
 */
var navigator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var navigator_assign = (undefined && undefined.__assign) || function () {
    navigator_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return navigator_assign.apply(this, arguments);
};






var navigator_evAll = 'layer';
var navigator_evPfx = "".concat(navigator_evAll, ":");
var evRoot = "".concat(navigator_evPfx, "root");
var evComponent = "".concat(navigator_evPfx, "component");
var navigator_evCustom = "".concat(navigator_evPfx, "custom");
var events = {
    all: navigator_evAll,
    root: evRoot,
    component: evComponent,
    custom: navigator_evCustom,
};
var styleOpts = { mediaText: '' };
var propsToListen = ['open', 'status', 'locked', 'custom-name', 'components', 'classes']
    .map(function (p) { return "component:update:".concat(p); })
    .join(' ');
var isStyleHidden = function (style) {
    if (style === void 0) { style = {}; }
    return (style.display || '').trim().indexOf('none') === 0;
};
var LayerManager = /** @class */ (function (_super) {
    navigator_extends(LayerManager, _super);
    function LayerManager(em) {
        var _this = _super.call(this, em, 'LayerManager', navigator_config_config) || this;
        _this.events = events;
        (0,index_all.bindAll)(_this, 'componentChanged', '__onRootChange', '__onComponent');
        _this.model = new ModuleModel/* default */.Z(_this, { opened: {} });
        // @ts-ignore
        _this.config.stylePrefix = _this.config.pStylePrefix;
        return _this;
    }
    LayerManager.prototype.onLoad = function () {
        var _this = this;
        var _a = this, em = _a.em, config = _a.config, model = _a.model;
        model.listenTo(em, 'component:selected', this.componentChanged);
        model.on('change:root', this.__onRootChange);
        model.listenTo(em, propsToListen, this.__onComponent);
        this.componentChanged();
        model.listenToOnce(em, 'load', function () {
            _this.setRoot(config.root);
            _this.__appendTo();
        });
    };
    /**
     * Update the root layer with another component.
     * @param {[Component]|String} component Component to be set as root
     * @return {[Component]}
     * @example
     * const component = editor.getSelected();
     * layers.setRoot(component);
     */
    LayerManager.prototype.setRoot = function (component) {
        var wrapper = this.em.getWrapper();
        var root = (0,mixins.isComponent)(component) ? component : wrapper;
        if (component && (0,index_all.isString)(component) && (0,mixins.hasWin)()) {
            root = wrapper.find(component)[0] || wrapper;
        }
        this.model.set('root', root);
        return root;
    };
    /**
     * Get the current root layer.
     * @return {[Component]}
     * @example
     * const layerRoot = layers.getRoot();
     */
    LayerManager.prototype.getRoot = function () {
        return this.model.get('root'); // || this.em.getWrapper();
    };
    /**
     * Get valid layer child components (eg. excludes non layerable components).
     * @param {[Component]} component Component from which you want to get child components
     * @returns {Array<[Component]>}
     * @example
     * const component = editor.getSelected();
     * const components = layers.getComponents(component);
     * console.log(components);
     */
    LayerManager.prototype.getComponents = function (component) {
        var _this = this;
        return component.components().filter(function (cmp) { return _this.__isLayerable(cmp); });
    };
    /**
     * Update the layer open state of the component.
     * @param {[Component]} component Component to update
     * @param {Boolean} value
     */
    LayerManager.prototype.setOpen = function (component, value) {
        component.set('open', value);
    };
    /**
     * Check the layer open state of the component.
     * @param {[Component]} component
     * @returns {Boolean}
     */
    LayerManager.prototype.isOpen = function (component) {
        return !!component.get('open');
    };
    /**
     * Update the layer visibility state of the component.
     * @param {[Component]} component Component to update
     * @param {Boolean} value
     */
    LayerManager.prototype.setVisible = function (component, value) {
        var prevDspKey = '__prev-display';
        var style = component.getStyle(styleOpts);
        var display = style.display;
        if (value) {
            var prevDisplay = component.get(prevDspKey);
            delete style.display;
            if (prevDisplay) {
                style.display = prevDisplay;
                component.unset(prevDspKey);
            }
        }
        else {
            display && component.set(prevDspKey, display);
            style.display = 'none';
        }
        component.setStyle(style, styleOpts);
        this.updateLayer(component);
        this.em.trigger('component:toggled'); // Updates Style Manager #2938
    };
    /**
     * Check the layer visibility state of the component.
     * @param {[Component]} component
     * @returns {Boolean}
     */
    LayerManager.prototype.isVisible = function (component) {
        return !isStyleHidden(component.getStyle(styleOpts));
    };
    /**
     * Update the layer locked state of the component.
     * @param {[Component]} component Component to update
     * @param {Boolean} value
     */
    LayerManager.prototype.setLocked = function (component, value) {
        component.set('locked', value);
    };
    /**
     * Check the layer locked state of the component.
     * @param {[Component]} component
     * @returns {Boolean}
     */
    LayerManager.prototype.isLocked = function (component) {
        return !!component.get('locked');
    };
    /**
     * Update the layer name of the component.
     * @param {[Component]} component Component to update
     * @param {String} value New name
     */
    LayerManager.prototype.setName = function (component, value) {
        component.set('custom-name', value);
    };
    /**
     * Get the layer name of the component.
     * @param {[Component]} component
     * @returns {String} Component layer name
     */
    LayerManager.prototype.getName = function (component) {
        return component.getName();
    };
    /**
     * Get layer data from a component.
     * @param {[Component]} component Component from which you want to read layer data.
     * @returns {Object} Object containing the layer data.
     * @example
     * const component = editor.getSelected();
     * const layerData = layers.getLayerData(component);
     * console.log(layerData);
     */
    LayerManager.prototype.getLayerData = function (component) {
        var status = component.get('status');
        return {
            name: component.getName(),
            open: this.isOpen(component),
            selected: status === 'selected',
            hovered: status === 'hovered', // || this.em.getHovered() === component,
            visible: this.isVisible(component),
            locked: this.isLocked(component),
            components: this.getComponents(component),
        };
    };
    LayerManager.prototype.setLayerData = function (component, data, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = this, em = _b.em, config = _b.config;
        var open = data.open, selected = data.selected, hovered = data.hovered, visible = data.visible, locked = data.locked, name = data.name;
        var cmpOpts = navigator_assign({ fromLayers: true }, opts);
        if ((0,mixins.isDef)(open)) {
            this.setOpen(component, open);
        }
        if ((0,mixins.isDef)(selected)) {
            if (selected) {
                em.setSelected(component, cmpOpts);
                var scroll_1 = config.scrollCanvas;
                scroll_1 && ((_a = component.views) === null || _a === void 0 ? void 0 : _a.forEach(function (view) { return view.scrollIntoView(scroll_1); }));
            }
            else {
                em.removeSelected(component, cmpOpts);
            }
        }
        if ((0,mixins.isDef)(hovered) && config.showHover) {
            hovered ? em.setHovered(component, cmpOpts) : em.setHovered(null, cmpOpts);
        }
        if ((0,mixins.isDef)(visible)) {
            visible !== this.isVisible(component) && this.setVisible(component, visible);
        }
        if ((0,mixins.isDef)(locked)) {
            this.setLocked(component, locked);
        }
        if ((0,mixins.isDef)(name)) {
            this.setName(component, name);
        }
    };
    /**
     * Triggered when the selected component is changed
     * @private
     */
    LayerManager.prototype.componentChanged = function (sel, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        if (opts.fromLayers)
            return;
        var _b = this, em = _b.em, config = _b.config;
        var scrollLayers = config.scrollLayers;
        var opened = this.model.get('opened');
        var selected = em.getSelected();
        var parent = selected === null || selected === void 0 ? void 0 : selected.parent();
        for (var cid in opened) {
            opened[cid].set('open', false);
            delete opened[cid];
        }
        while (parent) {
            parent.set('open', true);
            opened[parent.cid] = parent;
            parent = parent.parent();
        }
        if (selected && scrollLayers) {
            // @ts-ignore
            var el = (_a = selected.viewLayer) === null || _a === void 0 ? void 0 : _a.el;
            el === null || el === void 0 ? void 0 : el.scrollIntoView(scrollLayers);
        }
    };
    LayerManager.prototype.getAll = function () {
        return this.view;
    };
    LayerManager.prototype.render = function () {
        var _a, _b;
        var _c = this, config = _c.config, model = _c.model;
        var ItemView = view_ItemView.extend(config.extend);
        this.view = new ItemView({
            el: (_a = this.view) === null || _a === void 0 ? void 0 : _a.el,
            ItemView: ItemView,
            level: 0,
            config: config,
            opened: model.get('opened'),
            model: this.getRoot(),
            module: this,
        });
        return (_b = this.view) === null || _b === void 0 ? void 0 : _b.render().el;
    };
    LayerManager.prototype.destroy = function () {
        var _a;
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.remove();
    };
    LayerManager.prototype.__onRootChange = function () {
        var _a;
        var root = this.getRoot();
        (_a = this.view) === null || _a === void 0 ? void 0 : _a.setRoot(root);
        this.em.trigger(evRoot, root);
        this.__trgCustom();
    };
    LayerManager.prototype.__onComponent = function (component) {
        this.updateLayer(component);
    };
    LayerManager.prototype.__isLayerable = function (cmp) {
        var tag = cmp.get('tagName');
        var hideText = this.config.hideTextnode;
        var isValid = !hideText || (!cmp.is('textnode') && tag !== 'br');
        return isValid && cmp.get('layerable');
    };
    LayerManager.prototype.__trgCustom = function (opts) {
        var _a = this, __ctn = _a.__ctn, em = _a.em, events = _a.events;
        this.__ctn = __ctn || (opts === null || opts === void 0 ? void 0 : opts.container);
        em.trigger(events.custom, {
            container: this.__ctn,
            root: this.getRoot(),
        });
    };
    LayerManager.prototype.updateLayer = function (component, opts) {
        this.em.trigger(evComponent, component, opts);
    };
    return LayerManager;
}(abstract_Module));
/* harmony default export */ const src_navigator = (LayerManager);

;// CONCATENATED MODULE: ./src/asset_manager/config/config.ts
var asset_manager_config_config_config = {
    assets: [],
    noAssets: '',
    stylePrefix: 'am-',
    upload: '',
    uploadName: 'files',
    headers: {},
    params: {},
    credentials: 'include',
    multiUpload: true,
    autoAdd: true,
    customFetch: undefined,
    uploadFile: undefined,
    embedAsBase64: true,
    handleAdd: undefined,
    beforeUpload: undefined,
    showUrlInput: true,
    custom: false,
    dropzone: false,
    openAssetsOnDrop: true,
    dropzoneContent: '',
};
/* harmony default export */ const asset_manager_config_config = (asset_manager_config_config_config);

;// CONCATENATED MODULE: ./src/asset_manager/model/Asset.ts
var Asset_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * @property {String} type Asset type, eg. `'image'`.
 * @property {String} src Asset URL, eg. `'https://.../image.png'`.
 *
 * @module docsjs.Asset
 */
var Asset = /** @class */ (function (_super) {
    Asset_extends(Asset, _super);
    function Asset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Asset.getDefaults = function () {
        return (0,index_all.result)(this.prototype, 'defaults');
    };
    Asset.prototype.defaults = function () {
        return {
            type: '',
            src: '',
        };
    };
    /**
     * Get asset type.
     * @returns {String}
     * @example
     * // Asset: { src: 'https://.../image.png', type: 'image' }
     * asset.getType(); // -> 'image'
     * */
    Asset.prototype.getType = function () {
        return this.get('type');
    };
    /**
     * Get asset URL.
     * @returns {String}
     * @example
     * // Asset: { src: 'https://.../image.png'  }
     * asset.getSrc(); // -> 'https://.../image.png'
     * */
    Asset.prototype.getSrc = function () {
        return this.get('src');
    };
    /**
     * Get filename of the asset (based on `src`).
     * @returns {String}
     * @example
     * // Asset: { src: 'https://.../image.png' }
     * asset.getFilename(); // -> 'image.png'
     * // Asset: { src: 'https://.../image' }
     * asset.getFilename(); // -> 'image'
     * */
    Asset.prototype.getFilename = function () {
        return this.get('src').split('/').pop().split('?').shift();
    };
    /**
     * Get extension of the asset (based on `src`).
     * @returns {String}
     * @example
     * // Asset: { src: 'https://.../image.png' }
     * asset.getExtension(); // -> 'png'
     * // Asset: { src: 'https://.../image' }
     * asset.getExtension(); // -> ''
     * */
    Asset.prototype.getExtension = function () {
        return this.getFilename().split('.').pop();
    };
    return Asset;
}(common/* Model */.Hn));
/* harmony default export */ const model_Asset = (Asset);
Asset.prototype.idAttribute = 'src';

;// CONCATENATED MODULE: ./src/asset_manager/model/AssetImage.ts
var AssetImage_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AssetImage_assign = (undefined && undefined.__assign) || function () {
    AssetImage_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return AssetImage_assign.apply(this, arguments);
};

var AssetImage = /** @class */ (function (_super) {
    AssetImage_extends(AssetImage, _super);
    function AssetImage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AssetImage.prototype.defaults = function () {
        return AssetImage_assign(AssetImage_assign({}, model_Asset.getDefaults()), { type: 'image', unitDim: 'px', height: 0, width: 0 });
    };
    return AssetImage;
}(model_Asset));
/* harmony default export */ const model_AssetImage = (AssetImage);

;// CONCATENATED MODULE: ./src/asset_manager/view/AssetView.ts
var AssetView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var AssetView = /** @class */ (function (_super) {
    AssetView_extends(AssetView, _super);
    function AssetView(opt) {
        var _this = _super.call(this, opt) || this;
        _this.options = opt;
        _this.collection = opt.collection;
        var config = opt.config || {};
        _this.config = config;
        _this.pfx = config.stylePrefix || '';
        // @ts-ignore
        _this.ppfx = config.pStylePrefix || '';
        // @ts-ignore
        _this.em = config.em;
        _this.className = _this.pfx + 'asset';
        _this.listenTo(_this.model, 'destroy remove', _this.remove);
        // @ts-ignore
        _this.model.view = _this;
        var init = _this.init && _this.init.bind(_this);
        init && init(opt);
        return _this;
    }
    AssetView.prototype.__getBhv = function () {
        var em = this.em;
        var am = em === null || em === void 0 ? void 0 : em.Assets;
        return (am === null || am === void 0 ? void 0 : am.__getBehaviour()) || {};
    };
    AssetView.prototype.template = function (view, asset) {
        var pfx = this.pfx;
        return "\n      <div class=\"".concat(pfx, "preview-cont\">\n        ").concat(this.getPreview(), "\n      </div>\n      <div class=\"").concat(pfx, "meta\">\n        ").concat(this.getInfo(), "\n      </div>\n      <div class=\"").concat(pfx, "close\" data-toggle=\"asset-remove\">\n        &Cross;\n      </div>\n    ");
    };
    /**
     * Update target if exists
     * @param {Model} target
     * @private
     * */
    AssetView.prototype.updateTarget = function (target) {
        if (target && target.set) {
            target.set('attributes', (0,index_all.clone)(target.get('attributes')));
            target.set('src', this.model.get('src'));
        }
    };
    AssetView.prototype.getPreview = function () {
        return '';
    };
    AssetView.prototype.getInfo = function () {
        return '';
    };
    AssetView.prototype.render = function () {
        var el = this.el;
        el.innerHTML = this.template(this, this.model);
        el.className = this.className;
        return this;
    };
    return AssetView;
}(common/* View */.G7));
/* harmony default export */ const view_AssetView = (AssetView);

;// CONCATENATED MODULE: ./src/asset_manager/view/AssetImageView.ts
var AssetImageView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var AssetImageView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};



var AssetImageView = /** @class */ (function (_super) {
    AssetImageView_extends(AssetImageView, _super);
    function AssetImageView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AssetImageView.prototype.getPreview = function () {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx, model = _a.model;
        var src = model.get('src');
        return html(AssetImageView_templateObject_1 || (AssetImageView_templateObject_1 = AssetImageView_makeTemplateObject(["\n      <div class=\"", "preview\" style=\"background-image: url('", "');\"></div>\n      <div class=\"", "preview-bg ", "checker-bg\"></div>\n    "], ["\n      <div class=\"", "preview\" style=\"background-image: url('", "');\"></div>\n      <div class=\"", "preview-bg ", "checker-bg\"></div>\n    "])), pfx, src, pfx, ppfx);
    };
    AssetImageView.prototype.getInfo = function () {
        var _a = this, pfx = _a.pfx, model = _a.model;
        var name = model.get('name');
        var width = model.get('width');
        var height = model.get('height');
        var unit = model.get('unitDim');
        var dim = width && height ? "".concat(width, "x").concat(height).concat(unit) : '';
        name = name || model.getFilename();
        return html(AssetImageView_templateObject_2 || (AssetImageView_templateObject_2 = AssetImageView_makeTemplateObject(["\n      <div class=\"", "name\">", "</div>\n      <div class=\"", "dimensions\">", "</div>\n    "], ["\n      <div class=\"", "name\">", "</div>\n      <div class=\"", "dimensions\">", "</div>\n    "])), pfx, name, pfx, dim);
    };
    // @ts-ignore
    AssetImageView.prototype.init = function (o) {
        var pfx = this.pfx;
        this.className += " ".concat(pfx, "asset-image");
    };
    /**
     * Triggered when the asset is clicked
     * @private
     * */
    AssetImageView.prototype.onClick = function () {
        var _a = this, model = _a.model, pfx = _a.pfx;
        var select = this.__getBhv().select;
        // @ts-ignore
        var onClick = this.config.onClick;
        var coll = this.collection;
        coll.trigger('deselectAll');
        this.$el.addClass(pfx + 'highlight');
        if ((0,index_all.isFunction)(select)) {
            select(model, false);
        }
        else if ((0,index_all.isFunction)(onClick)) {
            onClick(model);
        }
        else {
            // @ts-ignore
            this.updateTarget(coll.target);
        }
    };
    /**
     * Triggered when the asset is double clicked
     * @private
     * */
    AssetImageView.prototype.onDblClick = function () {
        var _a = this, em = _a.em, model = _a.model;
        var select = this.__getBhv().select;
        // @ts-ignore
        var onDblClick = this.config.onDblClick;
        // @ts-ignore
        var _b = this.collection, target = _b.target, onSelect = _b.onSelect;
        if ((0,index_all.isFunction)(select)) {
            select(model, true);
        }
        else if ((0,index_all.isFunction)(onDblClick)) {
            onDblClick(model);
        }
        else {
            this.updateTarget(target);
            em === null || em === void 0 ? void 0 : em.Modal.close();
        }
        (0,index_all.isFunction)(onSelect) && onSelect(model);
    };
    /**
     * Remove asset from collection
     * @private
     * */
    AssetImageView.prototype.onRemove = function (e) {
        e.stopImmediatePropagation();
        this.model.collection.remove(this.model);
    };
    return AssetImageView;
}(view_AssetView));
/* harmony default export */ const view_AssetImageView = (AssetImageView);
AssetImageView.prototype.events = {
    // @ts-ignore
    'click [data-toggle=asset-remove]': 'onRemove',
    click: 'onClick',
    dblclick: 'onDblClick',
};
var AssetImageView_templateObject_1, AssetImageView_templateObject_2;

;// CONCATENATED MODULE: ./src/domain_abstract/model/TypeableCollection.ts
var TypeableCollection_assign = (undefined && undefined.__assign) || function () {
    TypeableCollection_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return TypeableCollection_assign.apply(this, arguments);
};
// @ts-nocheck TODO extend View


var TypeableCollection = {
    types: [],
    initialize: function (models, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = opts.em;
        this.em = em;
        this.opts = opts;
        this.model = function (attrs, options) {
            if (attrs === void 0) { attrs = {}; }
            if (options === void 0) { options = {}; }
            var Model, View, type;
            if (attrs && attrs.type) {
                var baseType = _this.getBaseType();
                type = _this.getType(attrs.type);
                Model = type ? type.model : baseType.model;
                View = type ? type.view : baseType.view;
            }
            else {
                var typeFound = _this.recognizeType(attrs);
                type = typeFound.type;
                Model = type.model;
                View = type.view;
                attrs = typeFound.attributes;
            }
            var model = new Model(attrs, TypeableCollection_assign(TypeableCollection_assign({}, options), { em: em }));
            model.typeView = View;
            return model;
        };
        var init = this.init && this.init.bind(this);
        init && init();
    },
    /**
     * Recognize type by any value
     * @param  {mixed} value
     * @return {Object} Found type
     */
    recognizeType: function (value) {
        var types = this.getTypes();
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            var typeFound = type.isType(value);
            typeFound = typeof typeFound == 'boolean' && typeFound ? { type: type.id } : typeFound;
            if (typeFound) {
                return {
                    type: type,
                    attributes: typeFound,
                };
            }
        }
        // If, for any reason, the type is not found it'll return the base one
        return {
            type: this.getBaseType(),
            attributes: value,
        };
    },
    /**
     * Returns the base type (last object in the stack)
     * @return {Object}
     */
    getBaseType: function () {
        var types = this.getTypes();
        return types[types.length - 1];
    },
    /**
     * Get types
     * @return {Array}
     */
    getTypes: function () {
        return this.types;
    },
    /**
     * Get type
     * @param {string} id Type ID
     * @return {Object} Type definition
     */
    getType: function (id) {
        var types = this.getTypes();
        for (var i = 0; i < types.length; i++) {
            var type = types[i];
            if (type.id === id) {
                return type;
            }
        }
    },
    /**
     * Add new type
     * @param {string} id Type ID
     * @param {Object} definition Definition of the type. Each definition contains
     *                            `model` (business logic), `view` (presentation logic)
     *                            and `isType` function which recognize the type of the
     *                            passed entity
     * addType('my-type', {
     *  model: {},
     *  view: {},
     *  isType: (value) => {},
     * })
     */
    addType: function (id, definition) {
        var type = this.getType(id);
        var baseType = this.getBaseType();
        var ModelInst = type ? type.model : baseType.model;
        var ViewInst = type ? type.view : baseType.view;
        var model = definition.model, view = definition.view, isType = definition.isType;
        model = model instanceof common/* Model */.Hn || (0,index_all.isFunction)(model) ? model : ModelInst.extend(model || {});
        view = view instanceof common/* View */.G7 || (0,index_all.isFunction)(view) ? view : ViewInst.extend(view || {});
        // New API
        if (this.extendViewApi && !definition.model && !definition.view) {
            view = view.extend(definition);
        }
        if (type) {
            type.model = model;
            type.view = view;
            type.isType = isType || type.isType;
        }
        else {
            definition.id = id;
            definition.model = model;
            definition.view = view;
            definition.isType =
                isType ||
                    function (value) {
                        if (value && value.type == id) {
                            return true;
                        }
                    };
            this.getTypes().unshift(definition);
        }
    },
};
/* harmony default export */ const model_TypeableCollection = (TypeableCollection);

;// CONCATENATED MODULE: ./src/asset_manager/model/Assets.ts
var Assets_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var TypeableCollectionExt = common/* Collection */.FE.extend(model_TypeableCollection);
var Assets = /** @class */ (function (_super) {
    Assets_extends(Assets, _super);
    function Assets() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Assets;
}(TypeableCollectionExt));
/* harmony default export */ const model_Assets = (Assets);
Assets.prototype.types = [
    {
        id: 'image',
        model: model_AssetImage,
        view: view_AssetImageView,
        isType: function (value) {
            if (typeof value == 'string') {
                return {
                    type: 'image',
                    src: value,
                };
            }
            return value;
        },
    },
];

;// CONCATENATED MODULE: ./src/asset_manager/view/AssetsView.ts
var AssetsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var AssetsView = /** @class */ (function (_super) {
    AssetsView_extends(AssetsView, _super);
    function AssetsView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        _this.options = o;
        _this.config = o.config;
        _this.pfx = _this.config.stylePrefix || '';
        // @ts-ignore
        _this.ppfx = _this.config.pStylePrefix || '';
        // @ts-ignore
        _this.em = _this.config.em;
        var coll = _this.collection;
        _this.listenTo(coll, 'reset', _this.renderAssets);
        _this.listenTo(coll, 'add', _this.addToAsset);
        _this.listenTo(coll, 'remove', _this.removedAsset);
        _this.listenTo(coll, 'deselectAll', _this.deselectAll);
        return _this;
    }
    AssetsView.prototype.template = function (_a) {
        var pfx = _a.pfx, ppfx = _a.ppfx, em = _a.em;
        var form = '';
        if (this.config.showUrlInput) {
            form = "\n          <form class=\"".concat(pfx, "add-asset\">\n            <div class=\"").concat(ppfx, "field ").concat(pfx, "add-field\">\n              <input placeholder=\"").concat(em === null || em === void 0 ? void 0 : em.t('assetManager.inputPlh'), "\"/>\n            </div>\n            <button class=\"").concat(ppfx, "btn-prim\">").concat(em === null || em === void 0 ? void 0 : em.t('assetManager.addButton'), "</button>\n            <div style=\"clear:both\"></div>\n          </form>\n      ");
        }
        return "\n    <div class=\"".concat(pfx, "assets-cont\">\n      <div class=\"").concat(pfx, "assets-header\">\n        ").concat(form, "\n      </div>\n      <div class=\"").concat(pfx, "assets\" data-el=\"assets\"></div>\n      <div style=\"clear:both\"></div>\n    </div>\n    ");
    };
    /**
     * Add new asset to the collection via string
     * @param {Event} e Event object
     * @return {this}
     * @private
     */
    AssetsView.prototype.handleSubmit = function (ev) {
        ev.preventDefault();
        var input = this.getAddInput();
        var url = input && input.value.trim();
        var handleAdd = this.config.handleAdd;
        if (!url) {
            return;
        }
        input.value = '';
        var assetsEl = this.getAssetsEl();
        if (assetsEl) {
            assetsEl.scrollTop = 0;
        }
        if (handleAdd) {
            handleAdd.bind(this)(url);
        }
        else {
            this.options.globalCollection.add(url, { at: 0 });
        }
    };
    /**
     * Returns assets element
     * @return {HTMLElement}
     * @private
     */
    AssetsView.prototype.getAssetsEl = function () {
        //if(!this.assets) // Not able to cache as after the rerender it losses the ref
        return this.el.querySelector(".".concat(this.pfx, "assets"));
    };
    /**
     * Returns input url element
     * @return {HTMLElement}
     * @private
     */
    AssetsView.prototype.getAddInput = function () {
        if (!this.inputUrl || !this.inputUrl.value) {
            this.inputUrl = this.el.querySelector(".".concat(this.pfx, "add-asset input"));
        }
        return this.inputUrl;
    };
    /**
     * Triggered when an asset is removed
     * @param {Asset} model Removed asset
     * @private
     */
    AssetsView.prototype.removedAsset = function (model) {
        if (!this.collection.length) {
            this.toggleNoAssets();
        }
    };
    /**
     * Add asset to collection
     * @private
     * */
    AssetsView.prototype.addToAsset = function (model) {
        if (this.collection.length == 1) {
            this.toggleNoAssets(true);
        }
        this.addAsset(model);
    };
    /**
     * Add new asset to collection
     * @param Object Model
     * @param Object Fragment collection
     * @return Object Object created
     * @private
     * */
    AssetsView.prototype.addAsset = function (model, fragmentEl) {
        if (fragmentEl === void 0) { fragmentEl = null; }
        var fragment = fragmentEl;
        var collection = this.collection;
        var config = this.config;
        // @ts-ignore
        var rendered = new model.typeView({
            model: model,
            collection: collection,
            config: config,
        }).render().el;
        if (fragment) {
            fragment.appendChild(rendered);
        }
        else {
            var assetsEl = this.getAssetsEl();
            if (assetsEl) {
                assetsEl.insertBefore(rendered, assetsEl.firstChild);
            }
        }
        return rendered;
    };
    /**
     * Checks if to show noAssets
     * @param {Boolean} hide
     * @private
     */
    AssetsView.prototype.toggleNoAssets = function (hide) {
        if (hide === void 0) { hide = false; }
        var assetsEl = this.$el.find(".".concat(this.pfx, "assets"));
        if (hide) {
            assetsEl.empty();
        }
        else {
            var noAssets = this.config.noAssets;
            noAssets && assetsEl.append(noAssets);
        }
    };
    /**
     * Deselect all assets
     * @private
     * */
    AssetsView.prototype.deselectAll = function () {
        var pfx = this.pfx;
        this.$el.find(".".concat(pfx, "highlight")).removeClass("".concat(pfx, "highlight"));
    };
    AssetsView.prototype.renderAssets = function () {
        var _this = this;
        var fragment = document.createDocumentFragment();
        var assets = this.$el.find(".".concat(this.pfx, "assets"));
        assets.empty();
        this.toggleNoAssets(!!this.collection.length);
        this.collection.each(function (model) { return _this.addAsset(model, fragment); });
        assets.append(fragment);
    };
    AssetsView.prototype.render = function () {
        var fuRendered = this.options.fu.render().el;
        this.$el.empty();
        this.$el.append(fuRendered).append(this.template(this));
        this.el.className = "".concat(this.ppfx, "asset-manager");
        this.renderAssets();
        return this;
    };
    return AssetsView;
}(common/* View */.G7));
/* harmony default export */ const view_AssetsView = (AssetsView);
AssetsView.prototype.events = {
    // @ts-ignore
    submit: 'handleSubmit',
};

;// CONCATENATED MODULE: ./src/asset_manager/view/FileUploader.ts
var FileUploader_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FileUploader_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};



var FileUploaderView = /** @class */ (function (_super) {
    FileUploader_extends(FileUploaderView, _super);
    function FileUploaderView(opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, opts) || this;
        _this.options = opts;
        var c = opts.config || {};
        _this.module = opts.module;
        _this.config = c;
        // @ts-ignore
        _this.em = _this.config.em;
        _this.pfx = c.stylePrefix || '';
        _this.ppfx = c.pStylePrefix || '';
        _this.target = _this.options.globalCollection || {};
        _this.uploadId = _this.pfx + 'uploadFile';
        _this.disabled = c.disableUpload !== undefined ? c.disableUpload : !c.upload && !c.embedAsBase64;
        _this.multiUpload = c.multiUpload !== undefined ? c.multiUpload : true;
        var uploadFile = c.uploadFile;
        if (uploadFile) {
            _this.uploadFile = uploadFile.bind(_this);
        }
        else if (!c.upload && c.embedAsBase64) {
            _this.uploadFile = FileUploaderView.embedAsBase64;
        }
        _this.delegateEvents();
        return _this;
    }
    FileUploaderView.prototype.template = function (_a) {
        var pfx = _a.pfx, title = _a.title, uploadId = _a.uploadId, disabled = _a.disabled, multiUpload = _a.multiUpload;
        return html(FileUploader_templateObject_1 || (FileUploader_templateObject_1 = FileUploader_makeTemplateObject(["\n      <form>\n        <div id=\"", "title\">", "</div>\n        <input\n          data-input\n          type=\"file\"\n          id=\"", "\"\n          name=\"file\"\n          accept=\"*/*\"\n          ", "\n          ", "\n        />\n        <div style=\"clear:both;\"></div>\n      </form>\n    "], ["\n      <form>\n        <div id=\"", "title\">", "</div>\n        <input\n          data-input\n          type=\"file\"\n          id=\"", "\"\n          name=\"file\"\n          accept=\"*/*\"\n          ", "\n          ", "\n        />\n        <div style=\"clear:both;\"></div>\n      </form>\n    "])), pfx, title, uploadId, disabled ? 'disabled' : '', multiUpload ? 'multiple' : '');
    };
    FileUploaderView.prototype.events = function () {
        return {
            'change [data-input]': 'uploadFile',
        };
    };
    /**
     * Triggered before the upload is started
     * @private
     */
    FileUploaderView.prototype.onUploadStart = function () {
        var module = this.module;
        module && module.__propEv('asset:upload:start');
    };
    /**
     * Triggered after the upload is ended
     * @param  {Object|string} res End result
     * @private
     */
    FileUploaderView.prototype.onUploadEnd = function (res) {
        var _a = this, $el = _a.$el, module = _a.module;
        module && module.__propEv('asset:upload:end', res);
        var input = $el.find('input');
        input && input.val('');
    };
    /**
     * Triggered on upload error
     * @param  {Object} err Error
     * @private
     */
    FileUploaderView.prototype.onUploadError = function (err) {
        var module = this.module;
        console.error(err);
        this.onUploadEnd(err);
        module && module.__propEv('asset:upload:error', err);
    };
    /**
     * Triggered on upload response
     * @param  {string} text Response text
     * @private
     */
    FileUploaderView.prototype.onUploadResponse = function (text, clb) {
        var _a = this, module = _a.module, config = _a.config, target = _a.target;
        var json;
        try {
            json = typeof text === 'string' ? JSON.parse(text) : text;
        }
        catch (e) {
            json = text;
        }
        module && module.__propEv('asset:upload:response', json);
        if (config.autoAdd && target) {
            target.add(json.data, { at: 0 });
        }
        this.onUploadEnd(text);
        clb === null || clb === void 0 ? void 0 : clb(json);
    };
    /**
     * Upload files
     * @param  {Object}  e Event
     * @return {Promise}
     * @private
     * */
    FileUploaderView.prototype.uploadFile = function (e, clb) {
        var _this = this;
        // @ts-ignore
        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        var config = this.config;
        var beforeUpload = config.beforeUpload;
        var beforeUploadResponse = beforeUpload && beforeUpload(files);
        if (beforeUploadResponse === false)
            return;
        var body = new FormData();
        var params = config.params, customFetch = config.customFetch, fetchOptions = config.fetchOptions;
        for (var param in params) {
            body.append(param, params[param]);
        }
        if (this.multiUpload) {
            for (var i = 0; i < files.length; i++) {
                body.append("".concat(config.uploadName, "[]"), files[i]);
            }
        }
        else if (files.length) {
            body.append(config.uploadName, files[0]);
        }
        var url = config.upload;
        var headers = config.headers;
        var reqHead = 'X-Requested-With';
        if (typeof headers[reqHead] == 'undefined') {
            headers[reqHead] = 'XMLHttpRequest';
        }
        if (url) {
            this.onUploadStart();
            var fetchOpts = {
                method: 'post',
                credentials: config.credentials || 'include',
                headers: headers,
                body: body,
            };
            var fetchOptsResult = (fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions(fetchOpts)) || fetchOpts;
            var fetchResult = customFetch
                ? customFetch(url, fetchOptsResult)
                : utils_fetch(url, fetchOptsResult).then(function (res) {
                    return ((res.status / 200) | 0) == 1 ? res.text() : res.text().then(function (text) { return Promise.reject(text); });
                });
            return fetchResult
                .then(function (text) { return _this.onUploadResponse(text, clb); })
                .catch(function (err) { return _this.onUploadError(err); });
        }
    };
    /**
     * Make input file droppable
     * @private
     * */
    FileUploaderView.prototype.initDrop = function () {
        var that = this;
        if (!this.uploadForm) {
            this.uploadForm = this.$el.find('form').get(0);
            var formEl_1 = this.uploadForm;
            if ('draggable' in formEl_1) {
                this.uploadForm.ondragover = function () {
                    formEl_1.className = that.pfx + 'hover';
                    return false;
                };
                this.uploadForm.ondragleave = function () {
                    formEl_1.className = '';
                    return false;
                };
                this.uploadForm.ondrop = function (ev) {
                    formEl_1.className = '';
                    ev.preventDefault();
                    that.uploadFile(ev);
                    return;
                };
            }
        }
    };
    FileUploaderView.prototype.initDropzone = function (ev) {
        var _this = this;
        var addedCls = 0;
        var c = this.config;
        var em = ev.model;
        var edEl = ev.el;
        var editor = em.Editor;
        var frameEl = em.Canvas.getBody();
        var ppfx = this.ppfx;
        var updatedCls = "".concat(ppfx, "dropzone-active");
        var dropzoneCls = "".concat(ppfx, "dropzone");
        var cleanEditorElCls = function () {
            edEl.className = edEl.className.replace(updatedCls, '').trim();
            addedCls = 0;
        };
        var onDragOver = function () {
            if (!addedCls) {
                edEl.className += " ".concat(updatedCls);
                addedCls = 1;
            }
            return false;
        };
        var onDragLeave = function () {
            cleanEditorElCls();
            return false;
        };
        var onDrop = function (e) {
            cleanEditorElCls();
            e.preventDefault();
            e.stopPropagation();
            _this.uploadFile(e);
            if (c.openAssetsOnDrop && editor) {
                var target = editor.getSelected();
                editor.runCommand('open-assets', {
                    target: target,
                    onSelect: function () {
                        editor.Modal.close();
                        editor.AssetManager.setTarget(null);
                    },
                });
            }
            return false;
        };
        ev.$el.append("<div class=\"".concat(dropzoneCls, "\">").concat(c.dropzoneContent, "</div>"));
        cleanEditorElCls();
        if ('draggable' in edEl) {
            [edEl, frameEl].forEach(function (item) {
                item.ondragover = onDragOver;
                item.ondragleave = onDragLeave;
                item.ondrop = onDrop;
            });
        }
    };
    FileUploaderView.prototype.render = function () {
        var _a = this, $el = _a.$el, pfx = _a.pfx, em = _a.em;
        $el.html(this.template({
            title: em && em.t('assetManager.uploadTitle'),
            uploadId: this.uploadId,
            disabled: this.disabled,
            multiUpload: this.multiUpload,
            pfx: pfx,
        }));
        this.initDrop();
        $el.attr('class', pfx + 'file-uploader');
        return this;
    };
    FileUploaderView.embedAsBase64 = function (e, clb) {
        var _this = this;
        // List files dropped
        // @ts-ignore
        var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
        var response = { data: [] };
        // Unlikely, widely supported now
        if (!FileReader) {
            // @ts-ignore
            this.onUploadError(new Error('Unsupported platform, FileReader is not defined'));
            return;
        }
        var promises = [];
        var mimeTypeMatcher = /^(.+)\/(.+)$/;
        var _loop_1 = function (file) {
            // For each file a reader (to read the base64 URL)
            // and a promise (to track and merge results and errors)
            var promise = new Promise(function (resolve, reject) {
                var reader = new FileReader();
                reader.addEventListener('load', function (event) {
                    var type;
                    var name = file.name;
                    // Try to find the MIME type of the file.
                    var match = mimeTypeMatcher.exec(file.type);
                    if (match) {
                        type = match[1]; // The first part in the MIME, "image" in image/png
                    }
                    else {
                        type = file.type;
                    }
                    /*
                  // Show local video files, http://jsfiddle.net/dsbonev/cCCZ2/embedded/result,js,html,css/
                  var URL = window.URL || window.webkitURL
                  var file = this.files[0]
                  var type = file.type
                  var videoNode = document.createElement('video');
                  var canPlay = videoNode.canPlayType(type) // can use also for 'audio' types
                  if (canPlay === '') canPlay = 'no'
                  var message = 'Can play type "' + type + '": ' + canPlay
                  var isError = canPlay === 'no'
                  displayMessage(message, isError)
          
                  if (isError) {
                    return
                  }
          
                  var fileURL = URL.createObjectURL(file)
                  videoNode.src = fileURL
                   */
                    // If it's an image, try to find its size
                    if (type === 'image') {
                        var data_1 = {
                            src: reader.result,
                            name: name,
                            type: type,
                            height: 0,
                            width: 0,
                        };
                        var image_1 = new Image();
                        image_1.addEventListener('error', function (error) {
                            reject(error);
                        });
                        image_1.addEventListener('load', function () {
                            data_1.height = image_1.height;
                            data_1.width = image_1.width;
                            resolve(data_1);
                        });
                        // @ts-ignore
                        image_1.src = data_1.src;
                    }
                    else if (type) {
                        // Not an image, but has a type
                        resolve({
                            src: reader.result,
                            name: name,
                            type: type,
                        });
                    }
                    else {
                        // No type found, resolve with the URL only
                        resolve(reader.result);
                    }
                });
                reader.addEventListener('error', function (error) {
                    reject(error);
                });
                reader.addEventListener('abort', function (error) {
                    reject('Aborted');
                });
                reader.readAsDataURL(file);
            });
            promises.push(promise);
        };
        for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
            var file = files_1[_i];
            _loop_1(file);
        }
        return Promise.all(promises).then(function (data) {
            response.data = data;
            // @ts-ignore
            _this.onUploadResponse(response, clb);
        }, function (error) {
            // @ts-ignore
            _this.onUploadError(error);
        });
    };
    return FileUploaderView;
}(common/* View */.G7));
/* harmony default export */ const FileUploader = (FileUploaderView);
var FileUploader_templateObject_1;

;// CONCATENATED MODULE: ./src/asset_manager/index.ts
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/asset_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  assetManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const assetManager = editor.AssetManager;
 * ```
 *
 * ## Available Events
 * * `asset:open` - Asset Manager opened.
 * * `asset:close` - Asset Manager closed.
 * * `asset:add` - Asset added. The [Asset] is passed as an argument to the callback.
 * * `asset:remove` - Asset removed. The [Asset] is passed as an argument to the callback.
 * * `asset:update` - Asset updated. The updated [Asset] and the object containing changes are passed as arguments to the callback.
 * * `asset:upload:start` - Before the upload is started.
 * * `asset:upload:end` - After the upload is ended.
 * * `asset:upload:error` - On any error in upload, passes the error as an argument.
 * * `asset:upload:response` - On upload response, passes the result as an argument.
 * * `asset` - Catch-all event for all the events mentioned above. An object containing all the available data about the triggered event is passed as an argument to the callback.
 * * `asset:custom` - Event for handling custom Asset Manager UI.
 *
 * ## Methods
 * * [open](#open)
 * * [close](#close)
 * * [isOpen](#isopen)
 * * [add](#add)
 * * [get](#get)
 * * [getAll](#getall)
 * * [getAllVisible](#getallvisible)
 * * [remove](#remove)
 * * [getContainer](#getcontainer)
 *
 * [Asset]: asset.html
 *
 * @module Assets
 */
var asset_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var asset_manager_assign = (undefined && undefined.__assign) || function () {
    asset_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return asset_manager_assign.apply(this, arguments);
};
var asset_manager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};







var asset_manager_evAll = 'asset';
var asset_manager_evPfx = "".concat(asset_manager_evAll, ":");
var asset_manager_evSelect = "".concat(asset_manager_evPfx, "select");
var asset_manager_evUpdate = "".concat(asset_manager_evPfx, "update");
var asset_manager_evAdd = "".concat(asset_manager_evPfx, "add");
var asset_manager_evRemove = "".concat(asset_manager_evPfx, "remove");
var asset_manager_evRemoveBefore = "".concat(asset_manager_evRemove, ":before");
var asset_manager_evCustom = "".concat(asset_manager_evPfx, "custom");
var evOpen = "".concat(asset_manager_evPfx, "open");
var evClose = "".concat(asset_manager_evPfx, "close");
var evUpload = "".concat(asset_manager_evPfx, "upload");
var evUploadStart = "".concat(evUpload, ":start");
var evUploadEnd = "".concat(evUpload, ":end");
var evUploadError = "".concat(evUpload, ":error");
var evUploadRes = "".concat(evUpload, ":response");
var assetCmd = 'open-assets';
var assetEvents = {
    all: asset_manager_evAll,
    select: asset_manager_evSelect,
    update: asset_manager_evUpdate,
    add: asset_manager_evAdd,
    remove: asset_manager_evRemove,
    removeBefore: asset_manager_evRemoveBefore,
    custom: asset_manager_evCustom,
    open: evOpen,
    close: evClose,
    uploadStart: evUploadStart,
    uploadEnd: evUploadEnd,
    uploadError: evUploadError,
    uploadResponse: evUploadRes,
};
var AssetManager = /** @class */ (function (_super) {
    asset_manager_extends(AssetManager, _super);
    /**
     * Initialize module
     * @param {Object} config Configurations
     * @private
     */
    function AssetManager(em) {
        // @ts-ignore
        var _this = _super.call(this, em, 'AssetManager', new model_Assets([], em), assetEvents, asset_manager_config_config) || this;
        _this.storageKey = 'assets';
        _this.Asset = model_Asset;
        _this.Assets = model_Assets;
        var _a = _this, all = _a.all, config = _a.config;
        // @ts-ignore
        _this.assetsVis = new model_Assets([]);
        // @ts-ignore
        var ppfx = config.pStylePrefix;
        if (ppfx) {
            config.stylePrefix = "".concat(ppfx).concat(config.stylePrefix);
        }
        // Setup the sync between the global and public collections
        all.on('add', function (model) { return _this.getAllVisible().add(model); });
        all.on('remove', function (model) { return _this.getAllVisible().remove(model); });
        _this.__onAllEvent = (0,index_all.debounce)(function () { return _this.__trgCustom(); }, 0);
        return _this;
    }
    AssetManager.prototype.__propEv = function (ev) {
        var _a, _b;
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        (_a = this.em).trigger.apply(_a, asset_manager_spreadArray([ev], data, false));
        (_b = this.getAll()).trigger.apply(_b, asset_manager_spreadArray([ev], data, false));
    };
    AssetManager.prototype.__trgCustom = function () {
        var bhv = this.__getBehaviour();
        var custom = this.getConfig().custom;
        if (!bhv.container && !custom.open) {
            return;
        }
        this.em.trigger(this.events.custom, this.__customData());
    };
    AssetManager.prototype.__customData = function () {
        var _this = this;
        var bhv = this.__getBehaviour();
        return {
            am: this,
            open: this.isOpen(),
            assets: this.getAll().models,
            types: bhv.types || [],
            container: bhv.container,
            close: function () { return _this.close(); },
            remove: function (asset, opts) { return _this.remove(asset, opts); },
            select: function (asset, complete) {
                var res = _this.add(asset);
                (0,index_all.isFunction)(bhv.select) && bhv.select(res, complete);
            },
            // extra
            options: bhv.options || {},
        };
    };
    /**
     * Open the asset manager.
     * @param {Object} [options] Options for the asset manager.
     * @param {Array<String>} [options.types=['image']] Types of assets to show.
     * @param {Function} [options.select] Type of operation to perform on asset selection. If not specified, nothing will happen.
     * @example
     * assetManager.open({
     *  select(asset, complete) {
     *    const selected = editor.getSelected();
     *    if (selected && selected.is('image')) {
     *      selected.addAttributes({ src: asset.getSrc() });
     *      // The default AssetManager UI will trigger `select(asset, false)` on asset click
     *      // and `select(asset, true)` on double-click
     *      complete && assetManager.close();
     *    }
     *  }
     * });
     * // with your custom types (you should have assets with those types declared)
     * assetManager.open({ types: ['doc'], ... });
     */
    AssetManager.prototype.open = function (options) {
        if (options === void 0) { options = {}; }
        var cmd = this.em.Commands;
        cmd.run(assetCmd, asset_manager_assign({ types: ['image'], select: function () { } }, options));
    };
    /**
     * Close the asset manager.
     * @example
     * assetManager.close();
     */
    AssetManager.prototype.close = function () {
        var cmd = this.em.Commands;
        cmd.stop(assetCmd);
    };
    /**
     * Checks if the asset manager is open
     * @returns {Boolean}
     * @example
     * assetManager.isOpen(); // true | false
     */
    AssetManager.prototype.isOpen = function () {
        var cmd = this.em.Commands;
        return !!(cmd === null || cmd === void 0 ? void 0 : cmd.isActive(assetCmd));
    };
    /**
     * Add new asset/s to the collection. URLs are supposed to be unique
     * @param {String|Object|Array<String>|Array<Object>} asset URL strings or an objects representing the resource.
     * @param {Object} [opts] Options
     * @returns {[Asset]}
     * @example
     * // As strings
     * assetManager.add('http://img.jpg');
     * assetManager.add(['http://img.jpg', './path/to/img.png']);
     *
     * // Using objects you can indicate the type and other meta informations
     * assetManager.add({
     *  // type: 'image',	// image is default
     * 	src: 'http://img.jpg',
     * 	height: 300,
     *	width: 200,
     * });
     * assetManager.add([{ src: 'img2.jpg' }, { src: 'img2.png' }]);
     */
    AssetManager.prototype.add = function (asset, opts) {
        if (opts === void 0) { opts = {}; }
        // Put the model at the beginning
        if (typeof opts.at == 'undefined') {
            opts.at = 0;
        }
        return this.all.add(asset, opts);
    };
    /**
     * Return asset by URL
     * @param  {String} src URL of the asset
     * @returns {[Asset]|null}
     * @example
     * const asset = assetManager.get('http://img.jpg');
     */
    AssetManager.prototype.get = function (src) {
        return this.all.where({ src: src })[0] || null;
    };
    /**
     * Return the global collection, containing all the assets
     * @returns {Collection<[Asset]>}
     */
    AssetManager.prototype.getAll = function () {
        return this.all;
    };
    /**
     * Return the visible collection, which contains assets actually rendered
     * @returns {Collection<[Asset]>}
     */
    AssetManager.prototype.getAllVisible = function () {
        return this.assetsVis;
    };
    /**
     * Remove asset
     * @param {String|[Asset]} asset Asset or asset URL
     * @returns {[Asset]} Removed asset
     * @example
     * const removed = assetManager.remove('http://img.jpg');
     * // or by passing the Asset
     * const asset = assetManager.get('http://img.jpg');
     * assetManager.remove(asset);
     */
    AssetManager.prototype.remove = function (asset, opts) {
        return this.__remove(asset, opts);
    };
    AssetManager.prototype.store = function () {
        return this.getProjectData();
    };
    AssetManager.prototype.load = function (data) {
        return this.loadProjectData(data);
    };
    /**
     * Return the Asset Manager Container
     * @returns {HTMLElement}
     */
    AssetManager.prototype.getContainer = function () {
        var _a;
        var bhv = this.__getBehaviour();
        return bhv.container || ((_a = this.am) === null || _a === void 0 ? void 0 : _a.el);
    };
    /**
     *  Get assets element container
     * @returns {HTMLElement}
     * @private
     */
    AssetManager.prototype.getAssetsEl = function () {
        var _a;
        return (_a = this.am) === null || _a === void 0 ? void 0 : _a.el.querySelector('[data-el=assets]');
    };
    /**
     * Render assets
     * @param  {array} assets Assets to render, without the argument will render all global assets
     * @returns {HTMLElement}
     * @private
     * @example
     * // Render all assets
     * assetManager.render();
     *
     * // Render some of the assets
     * const assets = assetManager.getAll();
     * assetManager.render(assets.filter(
     *  asset => asset.get('category') == 'cats'
     * ));
     */
    AssetManager.prototype.render = function (assts) {
        if (this.getConfig().custom)
            return;
        var toRender = assts || this.getAll().models;
        if (!this.am) {
            var obj = this.__viewParams();
            obj.fu = this.FileUploader();
            this.am = new view_AssetsView(asset_manager_assign({}, obj));
            this.am.render();
        }
        this.assetsVis.reset(toRender);
        return this.getContainer();
    };
    AssetManager.prototype.__viewParams = function () {
        return {
            collection: this.assetsVis, // Collection visible in asset manager
            globalCollection: this.all,
            config: this.config,
            module: this,
            fu: undefined,
        };
    };
    /**
     * Add new type. If you want to get more about type definition we suggest to read the [module's page](/modules/Assets.html)
     * @param {string} id Type ID
     * @param {Object} definition Definition of the type. Each definition contains
     *                            `model` (business logic), `view` (presentation logic)
     *                            and `isType` function which recognize the type of the
     *                            passed entity
     * @private
     * @example
     * assetManager.addType('my-type', {
     *  model: {},
     *  view: {},
     *  isType: (value) => {},
     * })
     */
    AssetManager.prototype.addType = function (id, definition) {
        this.getAll().addType(id, definition);
    };
    /**
     * Get type
     * @param {string} id Type ID
     * @returns {Object} Type definition
     * @private
     */
    AssetManager.prototype.getType = function (id) {
        return this.getAll().getType(id);
    };
    /**
     * Get types
     * @returns {Array}
     * @private
     */
    AssetManager.prototype.getTypes = function () {
        return this.getAll().getTypes();
    };
    //-------
    AssetManager.prototype.AssetsView = function () {
        return this.am;
    };
    AssetManager.prototype.FileUploader = function () {
        if (!this.fu) {
            this.fu = new FileUploader(this.__viewParams());
        }
        return this.fu;
    };
    AssetManager.prototype.onLoad = function () {
        var _this = this;
        this.getAll().reset(this.config.assets);
        var _a = this, em = _a.em, events = _a.events;
        em.on("run:".concat(assetCmd), function () { return _this.__propEv(events.open); });
        em.on("stop:".concat(assetCmd), function () { return _this.__propEv(events.close); });
    };
    AssetManager.prototype.postRender = function (editorView) {
        var _a;
        this.config.dropzone && ((_a = this.fu) === null || _a === void 0 ? void 0 : _a.initDropzone(editorView));
    };
    /**
     * Set new target
     * @param	{Object}	m Model
     * @private
     * */
    AssetManager.prototype.setTarget = function (m) {
        this.assetsVis.target = m;
    };
    /**
     * Set callback after asset was selected
     * @param	{Object}	f Callback function
     * @private
     * */
    AssetManager.prototype.onSelect = function (f) {
        this.assetsVis.onSelect = f;
    };
    /**
     * Set callback to fire when the asset is clicked
     * @param {function} func
     * @private
     */
    AssetManager.prototype.onClick = function (func) {
        // @ts-ignore
        this.config.onClick = func;
    };
    /**
     * Set callback to fire when the asset is double clicked
     * @param {function} func
     * @private
     */
    AssetManager.prototype.onDblClick = function (func) {
        // @ts-ignore
        this.config.onDblClick = func;
    };
    AssetManager.prototype.__behaviour = function (opts) {
        if (opts === void 0) { opts = {}; }
        return (this._bhv = asset_manager_assign(asset_manager_assign({}, (this._bhv || {})), opts));
    };
    AssetManager.prototype.__getBehaviour = function (opts) {
        if (opts === void 0) { opts = {}; }
        return this._bhv || {};
    };
    AssetManager.prototype.destroy = function () {
        var _a, _b;
        this.all.stopListening();
        this.all.reset();
        this.assetsVis.stopListening();
        this.assetsVis.reset();
        (_a = this.fu) === null || _a === void 0 ? void 0 : _a.remove();
        (_b = this.am) === null || _b === void 0 ? void 0 : _b.remove();
        this._bhv = {};
    };
    return AssetManager;
}(ItemManagerModule));
/* harmony default export */ const asset_manager = (AssetManager);

;// CONCATENATED MODULE: ./src/i18n/locale/en.js
var traitInputAttr = {
  placeholder: 'eg. Text here'
};
/* harmony default export */ const en = ({
  assetManager: {
    addButton: 'Add image',
    inputPlh: 'http://path/to/the/image.jpg',
    modalTitle: 'Select Image',
    uploadTitle: 'Drop files here or click to upload'
  },
  // Here just as a reference, GrapesJS core doesn't contain any block,
  // so this should be omitted from other local files
  blockManager: {
    labels: {
      // 'block-id': 'Block Label',
    },
    categories: {
      // 'category-id': 'Category Label',
    }
  },
  domComponents: {
    names: {
      '': 'Box',
      wrapper: 'Body',
      text: 'Text',
      comment: 'Comment',
      image: 'Image',
      video: 'Video',
      label: 'Label',
      link: 'Link',
      map: 'Map',
      tfoot: 'Table foot',
      tbody: 'Table body',
      thead: 'Table head',
      table: 'Table',
      row: 'Table row',
      cell: 'Table cell'
    }
  },
  deviceManager: {
    device: 'Device',
    devices: {
      desktop: 'Desktop',
      tablet: 'Tablet',
      mobileLandscape: 'Mobile Landscape',
      mobilePortrait: 'Mobile Portrait'
    }
  },
  panels: {
    buttons: {
      titles: {
        preview: 'Preview',
        fullscreen: 'Fullscreen',
        'sw-visibility': 'View components',
        'export-template': 'View code',
        'open-sm': 'Open Style Manager',
        'open-tm': 'Settings',
        'open-layers': 'Open Layer Manager',
        'open-blocks': 'Open Blocks'
      }
    }
  },
  selectorManager: {
    label: 'Classes',
    selected: 'Selected',
    emptyState: '- State -',
    states: {
      hover: 'Hover',
      active: 'Click',
      'nth-of-type(2n)': 'Even/Odd'
    }
  },
  styleManager: {
    empty: 'Select an element before using Style Manager',
    layer: 'Layer',
    fileButton: 'Images',
    sectors: {
      general: 'General',
      layout: 'Layout',
      typography: 'Typography',
      decorations: 'Decorations',
      extra: 'Extra',
      flex: 'Flex',
      dimension: 'Dimension'
    },
    // Default names for sub properties in Composite and Stack types.
    // Other labels are generated directly from their property names (eg. 'font-size' will be 'Font size').
    properties: {
      'text-shadow-h': 'X',
      'text-shadow-v': 'Y',
      'text-shadow-blur': 'Blur',
      'text-shadow-color': 'Color',
      'box-shadow-h': 'X',
      'box-shadow-v': 'Y',
      'box-shadow-blur': 'Blur',
      'box-shadow-spread': 'Spread',
      'box-shadow-color': 'Color',
      'box-shadow-type': 'Type',
      'margin-top-sub': 'Top',
      'margin-right-sub': 'Right',
      'margin-bottom-sub': 'Bottom',
      'margin-left-sub': 'Left',
      'padding-top-sub': 'Top',
      'padding-right-sub': 'Right',
      'padding-bottom-sub': 'Bottom',
      'padding-left-sub': 'Left',
      'border-width-sub': 'Width',
      'border-style-sub': 'Style',
      'border-color-sub': 'Color',
      'border-top-left-radius-sub': 'Top Left',
      'border-top-right-radius-sub': 'Top Right',
      'border-bottom-right-radius-sub': 'Bottom Right',
      'border-bottom-left-radius-sub': 'Bottom Left',
      'transform-rotate-x': 'Rotate X',
      'transform-rotate-y': 'Rotate Y',
      'transform-rotate-z': 'Rotate Z',
      'transform-scale-x': 'Scale X',
      'transform-scale-y': 'Scale Y',
      'transform-scale-z': 'Scale Z',
      'transition-property-sub': 'Property',
      'transition-duration-sub': 'Duration',
      'transition-timing-function-sub': 'Timing',
      'background-image-sub': 'Image',
      'background-repeat-sub': 'Repeat',
      'background-position-sub': 'Position',
      'background-attachment-sub': 'Attachment',
      'background-size-sub': 'Size'
    }
    // Translate options in style properties
    // options: {
    //   float: { // Id of the property
    //     ...
    //     left: 'Left', // {option id}: {Option label}
    //   }
    // }
  },
  traitManager: {
    empty: 'Select an element before using Trait Manager',
    label: 'Component settings',
    traits: {
      // The core library generates the name by their `name` property
      labels: {
        // id: 'Id',
        // alt: 'Alt',
        // title: 'Title',
        // href: 'Href',
      },
      // In a simple trait, like text input, these are used on input attributes
      attributes: {
        id: traitInputAttr,
        alt: traitInputAttr,
        title: traitInputAttr,
        href: {
          placeholder: 'eg. https://google.com'
        }
      },
      // In a trait like select, these are used to translate option names
      options: {
        target: {
          false: 'This window',
          _blank: 'New window'
        }
      }
    }
  },
  storageManager: {
    recover: 'Do you want to recover unsaved changes?'
  }
});
;// CONCATENATED MODULE: ./src/i18n/config.ts

var i18n_config_config = {
    locale: 'en',
    localeFallback: 'en',
    detectLocale: true,
    debug: false,
    messages: { en: en },
    messagesAdd: undefined,
};
/* harmony default export */ const i18n_config = (i18n_config_config);

;// CONCATENATED MODULE: ./src/i18n/index.ts
var i18n_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/i18n/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  i18n: {
 *    locale: 'en',
 *    localeFallback: 'en',
 *    messages: {
 *      it: { hello: 'Ciao', ... },
 *      ...
 *    }
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const i18n = editor.I18n;
 * ```
 *
 * ### Events
 * * `i18n:add` - New set of messages is added
 * * `i18n:update` - The set of messages is updated
 * * `i18n:locale` - Locale changed
 *
 * @module I18n
 */




var I18nModule = /** @class */ (function (_super) {
    i18n_extends(I18nModule, _super);
    /**
     * Initialize module
     * @param {Object} config Configurations
     * @private
     */
    function I18nModule(em) {
        var _this = _super.call(this, em, 'I18n', i18n_config) || this;
        var add = _this.config.messagesAdd;
        add && _this.addMessages(add);
        if (_this.config.detectLocale) {
            _this.config.locale = _this._localLang();
        }
        return _this;
    }
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Update current locale
     * @param {String} locale Locale value
     * @returns {this}
     * @example
     * i18n.setLocale('it');
     */
    I18nModule.prototype.setLocale = function (locale) {
        var _a = this, em = _a.em, config = _a.config;
        var evObj = { value: locale, valuePrev: config.locale };
        em && em.trigger('i18n:locale', evObj);
        config.locale = locale;
        return this;
    };
    /**
     * Get current locale
     * @returns {String} Current locale value
     */
    I18nModule.prototype.getLocale = function () {
        return this.config.locale;
    };
    /**
     * Get all messages
     * @param {String} [lang] Specify the language of messages to return
     * @param {Object} [opts] Options
     * @param {Boolean} [opts.debug] Show warnings in case of missing language
     * @returns {Object}
     * @example
     * i18n.getMessages();
     * // -> { en: { hello: '...' }, ... }
     * i18n.getMessages('en');
     * // -> { hello: '...' }
     */
    I18nModule.prototype.getMessages = function (lang, opts) {
        if (opts === void 0) { opts = {}; }
        var messages = this.config.messages;
        lang && !messages[lang] && this._debug("'".concat(lang, "' i18n lang not found"), opts);
        return lang ? messages[lang] : messages;
    };
    /**
     * Set new set of messages
     * @param {Object} msg Set of messages
     * @returns {this}
     * @example
     * i18n.getMessages();
     * // -> { en: { msg1: 'Msg 1', msg2: 'Msg 2', } }
     * i18n.setMessages({ en: { msg2: 'Msg 2 up', msg3: 'Msg 3', } });
     * // Set replaced
     * i18n.getMessages();
     * // -> { en: { msg2: 'Msg 2 up', msg3: 'Msg 3', } }
     */
    I18nModule.prototype.setMessages = function (msg) {
        var _a = this, em = _a.em, config = _a.config;
        config.messages = msg;
        em && em.trigger('i18n:update', msg);
        return this;
    };
    /**
     * Update messages
     * @param {Object} msg Set of messages to add
     * @returns {this}
     * @example
     * i18n.getMessages();
     * // -> { en: { msg1: 'Msg 1', msg2: 'Msg 2', } }
     * i18n.addMessages({ en: { msg2: 'Msg 2 up', msg3: 'Msg 3', } });
     * // Set updated
     * i18n.getMessages();
     * // -> { en: { msg1: 'Msg 1', msg2: 'Msg 2 up', msg3: 'Msg 3', } }
     */
    I18nModule.prototype.addMessages = function (msg) {
        var em = this.em;
        var messages = this.config.messages;
        em && em.trigger('i18n:add', msg);
        this.setMessages((0,mixins.deepMerge)(messages, msg));
        return this;
    };
    /**
     * Translate the locale message
     * @param {String} key Label to translate
     * @param {Object} [opts] Options for the translation
     * @param {Object} [opts.params] Params for the translation
     * @param {Boolean} [opts.debug] Show warnings in case of missing resources
     * @returns {String}
     * @example
     * obj.setMessages({
     *  en: { msg: 'Msg', msg2: 'Msg {test}'},
     *  it: { msg2: 'Msg {test} it'},
     * });
     * obj.t('msg');
     * // -> outputs `Msg`
     * obj.t('msg2', { params: { test: 'hello' } });  // use params
     * // -> outputs `Msg hello`
     * obj.t('msg2', { l: 'it', params: { test: 'hello' } });  // custom local
     * // -> outputs `Msg hello it`
     */
    I18nModule.prototype.t = function (key, opts) {
        if (opts === void 0) { opts = {}; }
        var config = this.config;
        var param = opts.params || {};
        var locale = opts.l || this.getLocale();
        var localeFlb = opts.lFlb || config.localeFallback;
        var result = this._getMsg(key, locale, opts);
        // Try with fallback
        if (!result)
            result = this._getMsg(key, localeFlb, opts);
        !result && this._debug("'".concat(key, "' i18n key not found in '").concat(locale, "' lang"), opts);
        result = result && (0,index_all.isString)(result) ? this._addParams(result, param) : result;
        return result;
    };
    I18nModule.prototype._localLang = function () {
        var nav = ((0,mixins.hasWin)() && window.navigator) || {};
        // @ts-ignore
        var lang = nav.language || nav.userLanguage;
        return lang ? lang.split('-')[0] : 'en';
    };
    I18nModule.prototype._addParams = function (str, params) {
        var reg = new RegExp('{([\\w\\d-]*)}', 'g');
        return str.replace(reg, function (m, val) { return params[val] || ''; }).trim();
    };
    I18nModule.prototype._getMsg = function (key, locale, opts) {
        if (opts === void 0) { opts = {}; }
        var msgSet = this.getMessages(locale, opts);
        // Lang set is missing
        if (!msgSet)
            return;
        var result = msgSet[key];
        // Check for nested getter
        if (!result && key.indexOf('.') > 0) {
            result = key.split('.').reduce(function (lang, key) {
                if ((0,index_all.isUndefined)(lang))
                    return;
                return lang[key];
            }, msgSet);
        }
        return result;
    };
    I18nModule.prototype._debug = function (str, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, em = _a.em, config = _a.config;
        (opts.debug || config.debug) && em && em.logWarning(str);
    };
    I18nModule.prototype.destroy = function () { };
    return I18nModule;
}(abstract_Module));
/* harmony default export */ const i18n = (I18nModule);

;// CONCATENATED MODULE: ./src/utils/Sorter.ts
var Sorter_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Sorter_assign = (undefined && undefined.__assign) || function () {
    Sorter_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Sorter_assign.apply(this, arguments);
};





var Sorter_noop = function () { };
var targetSpotType = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Target;
var spotTarget = {
    id: 'sorter-target',
    type: targetSpotType,
};
var Sorter = /** @class */ (function (_super) {
    Sorter_extends(Sorter, _super);
    function Sorter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @ts-ignore */
    Sorter.prototype.initialize = function (opt) {
        if (opt === void 0) { opt = {}; }
        this.opt = opt || {};
        (0,index_all.bindAll)(this, 'startSort', 'onMove', 'endMove', 'rollback', 'updateOffset', 'moveDragHelper');
        var o = opt || {};
        this.elT = 0;
        this.elL = 0;
        this.borderOffset = o.borderOffset || 10;
        var el = o.container;
        this.el = typeof el === 'string' ? document.querySelector(el) : el;
        this.$el = (0,cash_dom["default"])(this.el); // TODO check if necessary
        this.containerSel = o.containerSel || 'div';
        this.itemSel = o.itemSel || 'div';
        this.draggable = o.draggable || true;
        this.nested = !!o.nested;
        this.pfx = o.pfx || '';
        this.ppfx = o.ppfx || '';
        this.freezeClass = o.freezeClass || this.pfx + 'freezed';
        this.onStart = o.onStart || Sorter_noop;
        this.onEndMove = o.onEndMove;
        this.customTarget = o.customTarget;
        this.onEnd = o.onEnd;
        this.direction = o.direction || 'v'; // v (vertical), h (horizontal), a (auto)
        this.onMoveClb = o.onMove;
        this.relative = o.relative || false;
        this.ignoreViewChildren = !!o.ignoreViewChildren;
        this.plh = o.placer;
        // Frame offset
        this.wmargin = o.wmargin || 0;
        this.offTop = o.offsetTop || 0;
        this.offLeft = o.offsetLeft || 0;
        this.document = o.document || document;
        this.em = o.em;
        this.canvasRelative = !!o.canvasRelative;
        this.selectOnEnd = !o.avoidSelectOnEnd;
        this.scale = o.scale;
        if (this.em && this.em.on) {
            this.em.on('change:canvasOffset', this.updateOffset);
            this.updateOffset();
        }
    };
    Sorter.prototype.getScale = function () {
        return (0,index_all.result)(this, 'scale') || 1;
    };
    Sorter.prototype.getContainerEl = function (elem) {
        if (elem)
            this.el = elem;
        if (!this.el) {
            var el = this.opt.container;
            this.el = typeof el === 'string' ? document.querySelector(el) : el;
            this.$el = (0,cash_dom["default"])(this.el); // TODO check if necessary
        }
        return this.el;
    };
    Sorter.prototype.getDocuments = function (el) {
        var em = this.em;
        var elDoc = el ? el.ownerDocument : em === null || em === void 0 ? void 0 : em.Canvas.getBody().ownerDocument;
        var docs = [document];
        elDoc && docs.push(elDoc);
        return docs;
    };
    /**
     * Triggered when the offset of the editro is changed
     */
    Sorter.prototype.updateOffset = function () {
        var _a;
        var offset = ((_a = this.em) === null || _a === void 0 ? void 0 : _a.get('canvasOffset')) || {};
        this.offTop = offset.top;
        this.offLeft = offset.left;
    };
    /**
     * Set content to drop
     * @param {String|Object} content
     */
    Sorter.prototype.setDropContent = function (content) {
        delete this.dropModel;
        this.dropContent = content;
    };
    Sorter.prototype.updateTextViewCursorPosition = function (e) {
        var em = this.em;
        if (!em)
            return;
        var Canvas = em.Canvas;
        var targetDoc = Canvas.getDocument();
        var range = null;
        if (targetDoc.caretRangeFromPoint) {
            // Chrome
            var poiner = (0,dom/* getPointerEvent */.VB)(e);
            range = targetDoc.caretRangeFromPoint(poiner.clientX, poiner.clientY);
        }
        else if (e.rangeParent) {
            // Firefox
            range = targetDoc.createRange();
            range.setStart(e.rangeParent, e.rangeOffset);
        }
        var sel = Canvas.getWindow().getSelection();
        Canvas.getFrameEl().focus();
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        range && (sel === null || sel === void 0 ? void 0 : sel.addRange(range));
        this.setContentEditable(this.activeTextModel, true);
    };
    Sorter.prototype.setContentEditable = function (model, mode) {
        if (model) {
            // @ts-ignore
            var el = model.getEl();
            if (el.contentEditable != mode)
                el.contentEditable = mode;
        }
    };
    /**
     * Toggle cursor while sorting
     * @param {Boolean} active
     */
    Sorter.prototype.toggleSortCursor = function (active) {
        var em = this.em;
        var cv = em === null || em === void 0 ? void 0 : em.Canvas;
        // Avoid updating body className as it causes a huge repaint
        // Noticeable with "fast" drag of blocks
        cv && (active ? cv.startAutoscroll() : cv.stopAutoscroll());
    };
    /**
     * Set drag helper
     * @param {HTMLElement} el
     * @param {Event} event
     */
    Sorter.prototype.setDragHelper = function (el, event) {
        var ev = event || '';
        var clonedEl = el.cloneNode(true);
        var rect = el.getBoundingClientRect();
        var computed = getComputedStyle(el);
        var style = '';
        for (var i = 0; i < computed.length; i++) {
            var prop = computed[i];
            style += "".concat(prop, ":").concat(computed.getPropertyValue(prop), ";");
        }
        document.body.appendChild(clonedEl);
        clonedEl.className += " ".concat(this.pfx, "bdrag");
        clonedEl.setAttribute('style', style);
        this.dragHelper = clonedEl;
        clonedEl.style.width = "".concat(rect.width, "px");
        clonedEl.style.height = "".concat(rect.height, "px");
        ev && this.moveDragHelper(ev);
        // Listen mouse move events
        if (this.em) {
            var $doc = (0,cash_dom["default"])(this.em.Canvas.getBody().ownerDocument);
            $doc.off('mousemove', this.moveDragHelper).on('mousemove', this.moveDragHelper);
        }
        (0,cash_dom["default"])(document).off('mousemove', this.moveDragHelper).on('mousemove', this.moveDragHelper);
    };
    /**
     * Update the position of the helper
     * @param  {Event} e
     */
    Sorter.prototype.moveDragHelper = function (e) {
        var doc = e.target.ownerDocument;
        if (!this.dragHelper || !doc) {
            return;
        }
        var posY = e.pageY;
        var posX = e.pageX;
        var addTop = 0;
        var addLeft = 0;
        // @ts-ignore
        var window = doc.defaultView || doc.parentWindow;
        var frame = window.frameElement;
        var dragHelperStyle = this.dragHelper.style;
        // If frame is present that means mouse has moved over the editor's canvas,
        // which is rendered inside the iframe and the mouse move event comes from
        // the iframe, not the parent window. Mouse position relative to the frame's
        // parent window needs to account for the frame's position relative to the
        // parent window.
        if (frame) {
            var frameRect = frame.getBoundingClientRect();
            addTop = frameRect.top + document.documentElement.scrollTop;
            addLeft = frameRect.left + document.documentElement.scrollLeft;
            posY = e.clientY;
            posX = e.clientX;
        }
        dragHelperStyle.top = posY + addTop + 'px';
        dragHelperStyle.left = posX + addLeft + 'px';
    };
    /**
     * Returns true if the element matches with selector
     * @param {Element} el
     * @param {String} selector
     * @return {Boolean}
     */
    Sorter.prototype.matches = function (el, selector) {
        return mixins.matches.call(el, selector);
    };
    /**
     * Closest parent
     * @param {Element} el
     * @param {String} selector
     * @return {Element|null}
     */
    Sorter.prototype.closest = function (el, selector) {
        if (!el)
            return;
        var elem = el.parentNode;
        while (elem && elem.nodeType === 1) {
            if (this.matches(elem, selector))
                return elem;
            elem = elem.parentNode;
        }
    };
    /**
     * Get the offset of the element
     * @param  {HTMLElement} el
     * @return {Object}
     */
    Sorter.prototype.offset = function (el) {
        var rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft,
        };
    };
    /**
     * Create placeholder
     * @return {HTMLElement}
     */
    Sorter.prototype.createPlaceholder = function () {
        var pfx = this.pfx;
        var el = document.createElement('div');
        var ins = document.createElement('div');
        el.className = pfx + 'placeholder';
        el.style.display = 'none';
        el.style.pointerEvents = 'none';
        ins.className = pfx + 'placeholder-int';
        el.appendChild(ins);
        return el;
    };
    /**
     * Picking component to move
     * @param {HTMLElement} src
     * */
    Sorter.prototype.startSort = function (src, opts) {
        var _a, _b;
        if (opts === void 0) { opts = {}; }
        var _c = this, em = _c.em, itemSel = _c.itemSel, containerSel = _c.containerSel, plh = _c.plh;
        var container = this.getContainerEl(opts.container);
        var docs = this.getDocuments(src);
        var srcModel;
        delete this.dropModel;
        delete this.target;
        delete this.prevTarget;
        this.moved = false;
        // Check if the start element is a valid one, if not, try the closest valid one
        if (src && !this.matches(src, "".concat(itemSel, ", ").concat(containerSel))) {
            src = this.closest(src, itemSel);
        }
        this.sourceEl = src;
        // Create placeholder if doesn't exist yet
        if (!plh) {
            this.plh = this.createPlaceholder();
            container.appendChild(this.plh);
        }
        if (src) {
            srcModel = this.getSourceModel(src);
            (srcModel === null || srcModel === void 0 ? void 0 : srcModel.set) && srcModel.set('status', 'freezed');
            this.srcModel = srcModel;
        }
        (0,dom.on)(container, 'mousemove dragover', this.onMove);
        (0,dom.on)(docs, 'mouseup dragend touchend', this.endMove);
        (0,dom.on)(docs, 'keydown', this.rollback);
        this.onStart({
            sorter: this,
            target: srcModel,
            // @ts-ignore
            parent: srcModel && ((_a = srcModel.parent) === null || _a === void 0 ? void 0 : _a.call(srcModel)),
            // @ts-ignore
            index: srcModel && ((_b = srcModel.index) === null || _b === void 0 ? void 0 : _b.call(srcModel)),
        });
        // Avoid strange effects on dragging
        em === null || em === void 0 ? void 0 : em.clearSelection();
        this.toggleSortCursor(true);
        em === null || em === void 0 ? void 0 : em.trigger('sorter:drag:start', src, srcModel);
    };
    /**
     * Get the model from HTMLElement target
     * @return {Model|null}
     */
    Sorter.prototype.getTargetModel = function (el) {
        var elem = el || this.target;
        return (0,cash_dom["default"])(elem).data('model');
    };
    /**
     * Get the model of the current source element (element to drag)
     * @return {Model}
     */
    Sorter.prototype.getSourceModel = function (source, _a) {
        var _this = this;
        var _b = _a === void 0 ? {} : _a, target = _b.target, _c = _b.avoidChildren, avoidChildren = _c === void 0 ? 1 : _c;
        var _d = this, em = _d.em, sourceEl = _d.sourceEl;
        var src = source || sourceEl;
        var _e = this, dropModel = _e.dropModel, dropContent = _e.dropContent;
        var isTextable = function (src) {
            return src && target && src.opt && src.opt.avoidChildren && _this.isTextableActive(src, target);
        };
        if (dropContent && em) {
            if (isTextable(dropModel)) {
                dropModel = undefined;
            }
            if (!dropModel) {
                var comps = em.Components.getComponents();
                var opts = {
                    avoidChildren: avoidChildren,
                    avoidStore: 1,
                    avoidUpdateStyle: 1,
                };
                var tempModel = comps.add(dropContent, Sorter_assign(Sorter_assign({}, opts), { temporary: true }));
                // @ts-ignore
                dropModel = comps.remove(tempModel, opts);
                dropModel = dropModel instanceof Array ? dropModel[0] : dropModel;
                this.dropModel = dropModel;
                if (isTextable(dropModel)) {
                    return this.getSourceModel(src, { target: target, avoidChildren: 0 });
                }
            }
            return dropModel;
        }
        return src && (0,cash_dom["default"])(src).data('model');
    };
    /**
     * Highlight target
     * @param  {Model|null} model
     */
    Sorter.prototype.selectTargetModel = function (model, source) {
        if (model instanceof common/* Collection */.FE) {
            return;
        }
        // Prevents loops in Firefox
        // https://github.com/GrapesJS/grapesjs/issues/2911
        if (source && source === model)
            return;
        var targetModel = this.targetModel;
        // Reset the previous model but not if it's the same as the source
        // https://github.com/GrapesJS/grapesjs/issues/2478#issuecomment-570314736
        if (targetModel && targetModel !== this.srcModel) {
            targetModel.set('status', '');
        }
        if (model === null || model === void 0 ? void 0 : model.set) {
            var cv_1 = this.em.Canvas;
            var Select = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Select, Hover = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Hover, Spacing = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Spacing;
            [Select, Hover, Spacing].forEach(function (type) { return cv_1.removeSpots({ type: type }); });
            cv_1.addSpot(Sorter_assign(Sorter_assign({}, spotTarget), { component: model }));
            model.set('status', 'selected-parent');
            this.targetModel = model;
        }
    };
    /**
     * During move
     * @param {Event} e
     * */
    Sorter.prototype.onMove = function (e) {
        var ev = e;
        var _a = this, em = _a.em, onMoveClb = _a.onMoveClb, plh = _a.plh, customTarget = _a.customTarget;
        this.moved = true;
        // Turn placeholder visibile
        var dsp = plh.style.display;
        if (!dsp || dsp === 'none')
            plh.style.display = 'block';
        // Cache all necessary positions
        var eO = this.offset(this.el);
        this.elT = this.wmargin ? Math.abs(eO.top) : eO.top;
        this.elL = this.wmargin ? Math.abs(eO.left) : eO.left;
        var rY = e.pageY - this.elT + this.el.scrollTop;
        var rX = e.pageX - this.elL + this.el.scrollLeft;
        if (this.canvasRelative && em) {
            var mousePos = em.Canvas.getMouseRelativeCanvas(e, { noScroll: 1 });
            rX = mousePos.x;
            rY = mousePos.y;
        }
        this.rX = rX;
        this.rY = rY;
        this.eventMove = e;
        //var targetNew = this.getTargetFromEl(e.target);
        var sourceModel = this.getSourceModel();
        var targetEl = customTarget ? customTarget({ sorter: this, event: e }) : e.target;
        var dims = this.dimsFromTarget(targetEl, rX, rY);
        var target = this.target;
        var targetModel = target && this.getTargetModel(target);
        this.selectTargetModel(targetModel, sourceModel);
        if (!targetModel)
            plh.style.display = 'none';
        if (!target)
            return;
        this.lastDims = dims;
        var pos = this.findPosition(dims, rX, rY);
        if (this.isTextableActive(sourceModel, targetModel)) {
            this.activeTextModel = targetModel;
            plh.style.display = 'none';
            this.lastPos = pos;
            this.updateTextViewCursorPosition(ev);
        }
        else {
            this.disableTextable();
            delete this.activeTextModel;
            // If there is a significant changes with the pointer
            if (!this.lastPos || this.lastPos.index != pos.index || this.lastPos.method != pos.method) {
                this.movePlaceholder(this.plh, dims, pos, this.prevTargetDim);
                if (!this.$plh)
                    this.$plh = (0,cash_dom["default"])(this.plh);
                // With canvasRelative the offset is calculated automatically for
                // each element
                if (!this.canvasRelative) {
                    if (this.offTop)
                        this.$plh.css('top', '+=' + this.offTop + 'px');
                    if (this.offLeft)
                        this.$plh.css('left', '+=' + this.offLeft + 'px');
                }
                this.lastPos = pos;
            }
        }
        (0,index_all.isFunction)(onMoveClb) &&
            onMoveClb({
                event: e,
                target: sourceModel,
                parent: targetModel,
                index: pos.index + (pos.method == 'after' ? 1 : 0),
            });
        em &&
            em.trigger('sorter:drag', {
                target: target,
                targetModel: targetModel,
                sourceModel: sourceModel,
                dims: dims,
                pos: pos,
                x: rX,
                y: rY,
            });
    };
    Sorter.prototype.isTextableActive = function (src, trg) {
        var _a;
        return ((_a = src === null || src === void 0 ? void 0 : src.get) === null || _a === void 0 ? void 0 : _a.call(src, 'textable')) && (trg === null || trg === void 0 ? void 0 : trg.isInstanceOf('text'));
    };
    Sorter.prototype.disableTextable = function () {
        var activeTextModel = this.activeTextModel;
        // @ts-ignore
        activeTextModel === null || activeTextModel === void 0 ? void 0 : activeTextModel.getView().disableEditing();
        this.setContentEditable(activeTextModel, false);
    };
    /**
     * Returns true if the elements is in flow, so is not in flow where
     * for example the component is with float:left
     * @param  {HTMLElement} el
     * @param  {HTMLElement} parent
     * @return {Boolean}
     * @private
     * */
    Sorter.prototype.isInFlow = function (el, parent) {
        if (!el)
            return false;
        parent = parent || document.body;
        var ch = -1, h;
        var elem = el;
        h = elem.offsetHeight;
        if ( /*h < ch || */!this.styleInFlow(elem, parent))
            return false;
        else
            return true;
    };
    /**
     * Check if el has style to be in flow
     * @param  {HTMLElement} el
     * @param  {HTMLElement} parent
     * @return {Boolean}
     * @private
     */
    Sorter.prototype.styleInFlow = function (el, parent) {
        if ((0,dom/* isTextNode */.BM)(el))
            return;
        var style = el.style || {};
        var $el = (0,cash_dom["default"])(el);
        var $parent = parent && (0,cash_dom["default"])(parent);
        if (style.overflow && style.overflow !== 'visible')
            return;
        var propFloat = $el.css('float');
        if (propFloat && propFloat !== 'none')
            return;
        if ($parent && $parent.css('display') == 'flex' && $parent.css('flex-direction') !== 'column')
            return;
        switch (style.position) {
            case 'static':
            case 'relative':
            case '':
                break;
            default:
                return;
        }
        switch (el.tagName) {
            case 'TR':
            case 'TBODY':
            case 'THEAD':
            case 'TFOOT':
                return true;
        }
        switch ($el.css('display')) {
            case 'block':
            case 'list-item':
            case 'table':
            case 'flex':
            case 'grid':
                return true;
        }
        return;
    };
    /**
     * Check if the target is valid with the actual source
     * @param  {HTMLElement} trg
     * @return {Boolean}
     */
    Sorter.prototype.validTarget = function (trg, src) {
        var trgModel = this.getTargetModel(trg);
        var srcModel = this.getSourceModel(src, { target: trgModel });
        // @ts-ignore
        src = srcModel && srcModel.view && srcModel.view.el;
        trg = trgModel && trgModel.view && trgModel.view.el;
        var result = {
            valid: true,
            src: src,
            srcModel: srcModel,
            trg: trg,
            trgModel: trgModel,
            draggable: false,
            droppable: false,
            dragInfo: '',
            dropInfo: '',
        };
        if (!src || !trg) {
            result.valid = false;
            return result;
        }
        // Check if the source is draggable in target
        var draggable = srcModel.get('draggable');
        if ((0,index_all.isFunction)(draggable)) {
            var res = draggable(srcModel, trgModel);
            result.dragInfo = res;
            result.draggable = res;
            draggable = res;
        }
        else {
            draggable = draggable instanceof Array ? draggable.join(', ') : draggable;
            result.dragInfo = draggable;
            draggable = (0,index_all.isString)(draggable) ? this.matches(trg, draggable) : draggable;
            result.draggable = draggable;
        }
        // Check if the target could accept the source
        var droppable = trgModel.get('droppable');
        if ((0,index_all.isFunction)(droppable)) {
            var res = droppable(srcModel, trgModel);
            result.droppable = res;
            result.dropInfo = res;
            droppable = res;
        }
        else {
            droppable = droppable instanceof common/* Collection */.FE ? 1 : droppable;
            droppable = droppable instanceof Array ? droppable.join(', ') : droppable;
            result.dropInfo = droppable;
            droppable = (0,index_all.isString)(droppable) ? this.matches(src, droppable) : droppable;
            droppable = draggable && this.isTextableActive(srcModel, trgModel) ? 1 : droppable;
            result.droppable = droppable;
        }
        if (!droppable || !draggable) {
            result.valid = false;
        }
        return result;
    };
    /**
     * Get dimensions of nodes relative to the coordinates
     * @param  {HTMLElement} target
     * @param {number} rX Relative X position
     * @param {number} rY Relative Y position
     * @return {Array<Array>}
     */
    Sorter.prototype.dimsFromTarget = function (target, rX, rY) {
        if (rX === void 0) { rX = 0; }
        if (rY === void 0) { rY = 0; }
        var em = this.em;
        var dims = [];
        if (!target) {
            return dims;
        }
        // Select the first valuable target
        if (!this.matches(target, "".concat(this.itemSel, ", ").concat(this.containerSel))) {
            target = this.closest(target, this.itemSel);
        }
        // If draggable is an array the target will be one of those
        if (this.draggable instanceof Array) {
            target = this.closest(target, this.draggable.join(','));
        }
        if (!target) {
            return dims;
        }
        // Check if the target is different from the previous one
        if (this.prevTarget && this.prevTarget != target) {
            delete this.prevTarget;
        }
        // New target found
        if (!this.prevTarget) {
            this.targetP = this.closest(target, this.containerSel);
            // Check if the source is valid with the target
            var validResult = this.validTarget(target);
            em && em.trigger('sorter:drag:validation', validResult);
            if (!validResult.valid && this.targetP) {
                return this.dimsFromTarget(this.targetP, rX, rY);
            }
            this.prevTarget = target;
            this.prevTargetDim = this.getDim(target);
            this.cacheDimsP = this.getChildrenDim(this.targetP);
            this.cacheDims = this.getChildrenDim(target);
        }
        // If the target is the previous one will return the cached dims
        if (this.prevTarget == target)
            dims = this.cacheDims;
        // Target when I will drop element to sort
        this.target = this.prevTarget;
        // Generally, on any new target the poiner enters inside its area and
        // triggers nearBorders(), so have to take care of this
        if (this.nearBorders(this.prevTargetDim, rX, rY) || (!this.nested && !this.cacheDims.length)) {
            var targetParent = this.targetP;
            if (targetParent && this.validTarget(targetParent).valid) {
                dims = this.cacheDimsP;
                this.target = targetParent;
            }
        }
        delete this.lastPos;
        return dims;
    };
    /**
     * Get valid target from element
     * This method should replace dimsFromTarget()
     * @param  {HTMLElement} el
     * @return {HTMLElement}
     */
    Sorter.prototype.getTargetFromEl = function (el) {
        var target = el;
        var targetParent;
        var targetPrev = this.targetPrev;
        var em = this.em;
        var containerSel = this.containerSel;
        var itemSel = this.itemSel;
        // Select the first valuable target
        if (!this.matches(target, "".concat(itemSel, ", ").concat(containerSel))) {
            target = this.closest(target, itemSel);
        }
        // If draggable is an array the target will be one of those
        // TODO check if this options is used somewhere
        if (this.draggable instanceof Array) {
            target = this.closest(target, this.draggable.join(','));
        }
        // Check if the target is different from the previous one
        if (targetPrev && targetPrev != target) {
            delete this.targetPrev;
        }
        // New target found
        if (!this.targetPrev) {
            targetParent = this.closest(target, containerSel);
            // If the current target is not valid (src/trg reasons) try with
            // the parent one (if exists)
            var validResult = this.validTarget(target);
            em && em.trigger('sorter:drag:validation', validResult);
            if (!validResult.valid && targetParent) {
                return this.getTargetFromEl(targetParent);
            }
            this.targetPrev = target;
        }
        // Generally, on any new target the poiner enters inside its area and
        // triggers nearBorders(), so have to take care of this
        if (this.nearElBorders(target)) {
            targetParent = this.closest(target, containerSel);
            if (targetParent && this.validTarget(targetParent).valid) {
                target = targetParent;
            }
        }
        return target;
    };
    /**
     * Check if the current pointer is neare to element borders
     * @return {Boolen}
     */
    Sorter.prototype.nearElBorders = function (el) {
        var off = 10;
        var rect = el.getBoundingClientRect();
        var body = el.ownerDocument.body;
        var _a = this.getCurrentPos(), x = _a.x, y = _a.y;
        var top = rect.top + body.scrollTop;
        var left = rect.left + body.scrollLeft;
        var width = rect.width;
        var height = rect.height;
        if (y < top + off || // near top edge
            y > top + height - off || // near bottom edge
            x < left + off || // near left edge
            x > left + width - off // near right edge
        ) {
            return 1;
        }
    };
    Sorter.prototype.getCurrentPos = function () {
        var ev = this.eventMove;
        var x = (ev === null || ev === void 0 ? void 0 : ev.pageX) || 0;
        var y = (ev === null || ev === void 0 ? void 0 : ev.pageY) || 0;
        return { x: x, y: y };
    };
    /**
     * Returns dimensions and positions about the element
     * @param {HTMLElement} el
     * @return {Array<number>}
     */
    Sorter.prototype.getDim = function (el) {
        var _a = this, em = _a.em, canvasRelative = _a.canvasRelative;
        var canvas = em === null || em === void 0 ? void 0 : em.Canvas;
        var offsets = canvas ? canvas.getElementOffsets(el) : {};
        var top, left, height, width;
        if (canvasRelative && em) {
            var pos = canvas.getElementPos(el, { noScroll: 1 });
            top = pos.top; // - offsets.marginTop;
            left = pos.left; // - offsets.marginLeft;
            height = pos.height; // + offsets.marginTop + offsets.marginBottom;
            width = pos.width; // + offsets.marginLeft + offsets.marginRight;
        }
        else {
            var o = this.offset(el);
            top = this.relative ? el.offsetTop : o.top - (this.wmargin ? -1 : 1) * this.elT;
            left = this.relative ? el.offsetLeft : o.left - (this.wmargin ? -1 : 1) * this.elL;
            height = el.offsetHeight;
            width = el.offsetWidth;
        }
        return { top: top, left: left, height: height, width: width, offsets: offsets };
    };
    /**
     * Get children dimensions
     * @param {HTMLELement} el Element root
     * @return {Array}
     * */
    Sorter.prototype.getChildrenDim = function (trg) {
        var _this = this;
        var dims = [];
        if (!trg)
            return dims;
        // Get children based on getChildrenContainer
        var trgModel = this.getTargetModel(trg);
        if (trgModel && trgModel.view && !this.ignoreViewChildren) {
            var view = trgModel.getCurrentView ? trgModel.getCurrentView() : trgModel.view;
            trg = view.getChildrenContainer();
        }
        (0,index_all.each)(trg.children, function (ele, i) {
            var el = ele;
            var model = (0,mixins.getModel)(el, cash_dom["default"]);
            var elIndex = model && model.index ? model.index() : i;
            if (!(0,dom/* isTextNode */.BM)(el) && !_this.matches(el, _this.itemSel)) {
                return;
            }
            var dim = _this.getDim(el);
            var dir = _this.direction;
            var dirValue;
            if (dir == 'v')
                dirValue = true;
            else if (dir == 'h')
                dirValue = false;
            else
                dirValue = _this.isInFlow(el, trg);
            dim.dir = dirValue;
            dim.el = el;
            dim.indexEl = elIndex;
            dims.push(dim);
        });
        return dims;
    };
    /**
     * Check if the coordinates are near to the borders
     * @param {Array<number>} dim
     * @param {number} rX Relative X position
     * @param {number} rY Relative Y position
     * @return {Boolean}
     * */
    Sorter.prototype.nearBorders = function (dim, rX, rY) {
        var result = false;
        var off = this.borderOffset;
        var x = rX || 0;
        var y = rY || 0;
        var t = dim.top;
        var l = dim.left;
        var h = dim.height;
        var w = dim.width;
        if (t + off > y || y > t + h - off || l + off > x || x > l + w - off)
            result = true;
        return result;
    };
    /**
     * Find the position based on passed dimensions and coordinates
     * @param {Array<Array>} dims Dimensions of nodes to parse
     * @param {number} posX X coordindate
     * @param {number} posY Y coordindate
     * @return {Object}
     * */
    Sorter.prototype.findPosition = function (dims, posX, posY) {
        var result = { index: 0, indexEl: 0, method: 'before' };
        var leftLimit = 0;
        var xLimit = 0;
        var dimRight = 0;
        var yLimit = 0;
        var xCenter = 0;
        var yCenter = 0;
        var dimDown = 0;
        var dim;
        // Each dim is: Top, Left, Height, Width
        for (var i = 0, len = dims.length; i < len; i++) {
            dim = dims[i];
            var top_1 = dim.top, left = dim.left, height = dim.height, width = dim.width;
            // Right position of the element. Left + Width
            dimRight = left + width;
            // Bottom position of the element. Top + Height
            dimDown = top_1 + height;
            // X center position of the element. Left + (Width / 2)
            xCenter = left + width / 2;
            // Y center position of the element. Top + (Height / 2)
            yCenter = top_1 + height / 2;
            // Skip if over the limits
            if ((xLimit && left > xLimit) ||
                (yLimit && yCenter >= yLimit) || // >= avoid issue with clearfixes
                (leftLimit && dimRight < leftLimit))
                continue;
            result.index = i;
            result.indexEl = dim.indexEl;
            // If it's not in flow (like 'float' element)
            if (!dim.dir) {
                if (posY < dimDown)
                    yLimit = dimDown;
                //If x lefter than center
                if (posX < xCenter) {
                    xLimit = xCenter;
                    result.method = 'before';
                }
                else {
                    leftLimit = xCenter;
                    result.method = 'after';
                }
            }
            else {
                // If y upper than center
                if (posY < yCenter) {
                    result.method = 'before';
                    break;
                }
                else
                    result.method = 'after'; // After last element
            }
        }
        return result;
    };
    /**
     * Updates the position of the placeholder
     * @param {HTMLElement} phl
     * @param {Array<Array>} dims
     * @param {Object} pos Position object
     * @param {Array<number>} trgDim target dimensions ([top, left, height, width])
     * */
    Sorter.prototype.movePlaceholder = function (plh, dims, pos, trgDim) {
        var marg = 0;
        var t = 0;
        var l = 0;
        var w = '';
        var h = '';
        var un = 'px';
        var margI = 5;
        var method = pos.method;
        var elDim = dims[pos.index];
        // Placeholder orientation
        plh.classList.remove('vertical');
        plh.classList.add('horizontal');
        if (elDim) {
            // If it's not in flow (like 'float' element)
            var top_2 = elDim.top, left = elDim.left, height = elDim.height, width = elDim.width;
            if (!elDim.dir) {
                w = 'auto';
                h = height - marg * 2 + un;
                t = top_2 + marg;
                l = method == 'before' ? left - marg : left + width - marg;
                plh.classList.remove('horizontal');
                plh.classList.add('vertical');
            }
            else {
                w = width + un;
                h = 'auto';
                t = method == 'before' ? top_2 - marg : top_2 + height - marg;
                l = left;
            }
        }
        else {
            // Placeholder inside the component
            if (!this.nested) {
                plh.style.display = 'none';
                return;
            }
            if (trgDim) {
                var offset = trgDim.offsets || {};
                var pT = offset.paddingTop || margI;
                var pL = offset.paddingLeft || margI;
                t = trgDim.top + pT;
                l = trgDim.left + pL;
                w = parseInt("".concat(trgDim.width)) - pL * 2 + un;
                h = 'auto';
            }
        }
        plh.style.top = t + un;
        plh.style.left = l + un;
        if (w)
            plh.style.width = w;
        if (h)
            plh.style.height = h;
    };
    /**
     * Build an array of all the parents, including the component itself
     * @return {Model|null}
     */
    Sorter.prototype.parents = function (model) {
        return model ? [model].concat(this.parents(model.parent())) : [];
    };
    /**
     * Sort according to the position in the dom
     * @param {Object} obj1 contains {model, parents}
     * @param {Object} obj2 contains {model, parents}
     */
    Sorter.prototype.sort = function (obj1, obj2) {
        // common ancesters
        var ancesters = obj1.parents.filter(function (p) { return obj2.parents.includes(p); });
        var ancester = ancesters[0];
        if (!ancester) {
            // this is never supposed to happen
            return obj2.model.index() - obj1.model.index();
        }
        // find siblings in the common ancester
        // the sibling is the element inside the ancester
        var s1 = obj1.parents[obj1.parents.indexOf(ancester) - 1];
        var s2 = obj2.parents[obj2.parents.indexOf(ancester) - 1];
        // order according to the position in the DOM
        return s2.index() - s1.index();
    };
    /**
     * Leave item
     * @param event
     *
     * @return void
     * */
    Sorter.prototype.endMove = function () {
        var _this = this;
        var _a;
        var src = this.sourceEl;
        var moved = [];
        var docs = this.getDocuments();
        var container = this.getContainerEl();
        var onEndMove = this.onEndMove;
        var onEnd = this.onEnd;
        var _b = this, target = _b.target, lastPos = _b.lastPos;
        var srcModel;
        (0,dom/* off */.S1)(container, 'mousemove dragover', this.onMove);
        (0,dom/* off */.S1)(docs, 'mouseup dragend touchend', this.endMove);
        (0,dom/* off */.S1)(docs, 'keydown', this.rollback);
        this.plh.style.display = 'none';
        if (src) {
            srcModel = this.getSourceModel();
        }
        if (this.moved && target) {
            var toMove = this.toMove;
            var toMoveArr = (0,index_all.isArray)(toMove) ? toMove : toMove ? [toMove] : [src];
            var domPositionOffset_1 = 0;
            if (toMoveArr.length === 1) {
                // do not sort the array in this case
                // there are cases for the sorter where toMoveArr is [undefined]
                // which allows the drop from blocks, native D&D and sort of layers in Style Manager
                moved.push(this.move(target, toMoveArr[0], lastPos));
            }
            else {
                toMoveArr
                    // add the model's parents
                    .map(function (model) { return ({
                    model: model,
                    parents: _this.parents(model),
                }); })
                    // sort based on elements positions in the dom
                    .sort(this.sort)
                    // move each component to the new parent and position
                    .forEach(function (_a) {
                    var model = _a.model;
                    // @ts-ignore store state before move
                    var index = model.index();
                    // @ts-ignore
                    var parent = model.parent().getEl();
                    // move the component to the desired position
                    moved.push(_this.move(target, model, Sorter_assign(Sorter_assign({}, lastPos), { indexEl: lastPos.indexEl - domPositionOffset_1, index: lastPos.index - domPositionOffset_1 })));
                    // when the element is dragged to the same parent and after its position
                    //  it will be removed from the children list
                    //  in that case we need to adjust the following elements target position
                    if (parent === target && index <= lastPos.index) {
                        // the next elements will be inserted 1 element before this one
                        domPositionOffset_1++;
                    }
                });
            }
        }
        if (this.plh)
            this.plh.style.display = 'none';
        var dragHelper = this.dragHelper;
        if (dragHelper) {
            dragHelper.parentNode.removeChild(dragHelper);
            delete this.dragHelper;
        }
        this.disableTextable();
        this.selectTargetModel();
        this.toggleSortCursor();
        (_a = this.em) === null || _a === void 0 ? void 0 : _a.Canvas.removeSpots(spotTarget);
        delete this.toMove;
        delete this.eventMove;
        delete this.dropModel;
        if ((0,index_all.isFunction)(onEndMove)) {
            var data_1 = {
                target: srcModel,
                // @ts-ignore
                parent: srcModel && srcModel.parent(),
                // @ts-ignore
                index: srcModel && srcModel.index(),
            };
            moved.length ? moved.forEach(function (m) { return onEndMove(m, _this, data_1); }) : onEndMove(null, this, Sorter_assign(Sorter_assign({}, data_1), { cancelled: 1 }));
        }
        (0,index_all.isFunction)(onEnd) && onEnd({ sorter: this });
    };
    /**
     * Move component to new position
     * @param {HTMLElement} dst Destination target
     * @param {HTMLElement} src Element to move
     * @param {Object} pos Object with position coordinates
     * */
    Sorter.prototype.move = function (dst, src, pos) {
        var _a = this, em = _a.em, dropContent = _a.dropContent;
        var srcEl = (0,mixins.getElement)(src);
        var warns = [];
        var index = pos.method === 'after' ? pos.indexEl + 1 : pos.indexEl;
        var validResult = this.validTarget(dst, srcEl);
        var targetCollection = (0,cash_dom["default"])(dst).data('collection');
        var trgModel = validResult.trgModel, srcModel = validResult.srcModel, draggable = validResult.draggable;
        var droppable = trgModel instanceof common/* Collection */.FE ? 1 : validResult.droppable;
        var modelToDrop, created;
        if (targetCollection && droppable && draggable) {
            var opts = { at: index, action: 'move-component' };
            var isTextable = this.isTextableActive(srcModel, trgModel);
            if (!dropContent) {
                var srcIndex = srcModel.collection.indexOf(srcModel);
                var sameCollection = targetCollection === srcModel.collection;
                var sameIndex = srcIndex === index || srcIndex === index - 1;
                var canRemove = !sameCollection || !sameIndex || isTextable;
                if (canRemove) {
                    modelToDrop = srcModel.collection.remove(srcModel, {
                        temporary: true,
                    });
                    if (sameCollection && index > srcIndex) {
                        opts.at = index - 1;
                    }
                }
            }
            else {
                // @ts-ignore
                modelToDrop = (0,index_all.isFunction)(dropContent) ? dropContent() : dropContent;
                opts.avoidUpdateStyle = true;
                opts.action = 'add-component';
            }
            if (modelToDrop) {
                if (isTextable) {
                    delete opts.at;
                    created = trgModel.getView().insertComponent(modelToDrop, opts);
                }
                else {
                    created = targetCollection.add(modelToDrop, opts);
                }
            }
            delete this.dropContent;
            delete this.prevTarget; // This will recalculate children dimensions
        }
        else if (em) {
            var dropInfo = validResult.dropInfo || (trgModel === null || trgModel === void 0 ? void 0 : trgModel.get('droppable'));
            var dragInfo = validResult.dragInfo || (srcModel === null || srcModel === void 0 ? void 0 : srcModel.get('draggable'));
            !targetCollection && warns.push('Target collection not found');
            !droppable && dropInfo && warns.push("Target is not droppable, accepts [".concat(dropInfo, "]"));
            !draggable && dragInfo && warns.push("Component not draggable, acceptable by [".concat(dragInfo, "]"));
            em.logWarning('Invalid target position', {
                errors: warns,
                model: srcModel,
                context: 'sorter',
                target: trgModel,
            });
        }
        em === null || em === void 0 ? void 0 : em.trigger('sorter:drag:end', {
            targetCollection: targetCollection,
            modelToDrop: modelToDrop,
            warns: warns,
            validResult: validResult,
            dst: dst,
            srcEl: srcEl,
        });
        return created;
    };
    /**
     * Rollback to previous situation
     * @param {Event}
     * @param {Bool} Indicates if rollback in anycase
     * */
    Sorter.prototype.rollback = function (e) {
        (0,dom/* off */.S1)(this.getDocuments(), 'keydown', this.rollback);
        var key = e.which || e.keyCode;
        if (key == 27) {
            this.moved = false;
            this.endMove();
        }
    };
    return Sorter;
}(common/* View */.G7));
/* harmony default export */ const utils_Sorter = (Sorter);

;// CONCATENATED MODULE: ./src/utils/Resizer.ts
var Resizer_assign = (undefined && undefined.__assign) || function () {
    Resizer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Resizer_assign.apply(this, arguments);
};



var createHandler = function (name, opts) {
    if (opts === void 0) { opts = {}; }
    var pfx = opts.prefix || '';
    var el = document.createElement('i');
    el.className = pfx + 'resizer-h ' + pfx + 'resizer-h-' + name;
    el.setAttribute('data-' + pfx + 'handler', name);
    return el;
};
var getBoundingRect = function (el, win) {
    var w = win || window;
    var rect = el.getBoundingClientRect();
    return {
        left: rect.left + w.pageXOffset,
        top: rect.top + w.pageYOffset,
        width: rect.width,
        height: rect.height,
    };
};
var Resizer = /** @class */ (function () {
    /**
     * Init the Resizer with options
     * @param  {Object} options
     */
    function Resizer(opts) {
        if (opts === void 0) { opts = {}; }
        this.defOpts = {
            ratioDefault: false,
            onUpdateContainer: function () { },
            step: 1,
            minDim: 10,
            maxDim: Infinity,
            unitHeight: 'px',
            unitWidth: 'px',
            keyHeight: 'height',
            keyWidth: 'width',
            currentUnit: true,
            silentFrames: false,
            avoidContainerUpdate: false,
            keepAutoHeight: false,
            keepAutoWidth: false,
            autoHeight: false,
            autoWidth: false,
            tl: true,
            tc: true,
            tr: true,
            cl: true,
            cr: true,
            bl: true,
            bc: true,
            br: true,
        };
        this.opts = Resizer_assign({}, this.defOpts);
        this.setOptions(opts);
        (0,index_all.bindAll)(this, 'handleKeyDown', 'handleMouseDown', 'move', 'stop');
    }
    /**
     * Get current connfiguration options
     * @return {Object}
     */
    Resizer.prototype.getConfig = function () {
        return this.opts;
    };
    /**
     * Setup options
     * @param {Object} options
     */
    Resizer.prototype.setOptions = function (options, reset) {
        if (options === void 0) { options = {}; }
        this.opts = Resizer_assign(Resizer_assign({}, (reset ? this.defOpts : this.opts)), options);
        this.setup();
    };
    /**
     * Setup resizer
     */
    Resizer.prototype.setup = function () {
        var opts = this.opts;
        var pfx = opts.prefix || '';
        var appendTo = opts.appendTo || document.body;
        var container = this.container;
        // Create container if not yet exist
        if (!container) {
            container = document.createElement('div');
            container.className = "".concat(pfx, "resizer-c");
            appendTo.appendChild(container);
            this.container = container;
        }
        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }
        // Create handlers
        var handlers = {};
        ['tl', 'tc', 'tr', 'cl', 'cr', 'bl', 'bc', 'br'].forEach(
        // @ts-ignore
        function (hdl) { return (handlers[hdl] = opts[hdl] ? createHandler(hdl, opts) : null); });
        for (var n in handlers) {
            var handler = handlers[n];
            handler && container.appendChild(handler);
        }
        this.handlers = handlers;
        this.mousePosFetcher = opts.mousePosFetcher;
        this.updateTarget = opts.updateTarget;
        this.posFetcher = opts.posFetcher;
        this.onStart = opts.onStart;
        this.onMove = opts.onMove;
        this.onEnd = opts.onEnd;
        this.onUpdateContainer = opts.onUpdateContainer;
    };
    /**
     * Toggle iframes pointer event
     * @param {Boolean} silent If true, iframes will be silented
     */
    Resizer.prototype.toggleFrames = function (silent) {
        if (this.opts.silentFrames) {
            var frames_1 = document.querySelectorAll('iframe');
            (0,index_all.each)(frames_1, function (frame) { return (frame.style.pointerEvents = silent ? 'none' : ''); });
        }
    };
    /**
     * Detects if the passed element is a resize handler
     * @param  {HTMLElement} el
     * @return {Boolean}
     */
    Resizer.prototype.isHandler = function (el) {
        var handlers = this.handlers;
        for (var n in handlers) {
            if (handlers[n] === el)
                return true;
        }
        return false;
    };
    /**
     * Returns the focused element
     * @return {HTMLElement}
     */
    Resizer.prototype.getFocusedEl = function () {
        return this.el;
    };
    /**
     * Returns the parent of the focused element
     * @return {HTMLElement}
     */
    Resizer.prototype.getParentEl = function () {
        var _a;
        return (_a = this.el) === null || _a === void 0 ? void 0 : _a.parentElement;
    };
    /**
     * Returns documents
     */
    Resizer.prototype.getDocumentEl = function () {
        return [this.el.ownerDocument, document];
    };
    /**
     * Return element position
     * @param  {HTMLElement} el
     * @param  {Object} opts Custom options
     * @return {Object}
     */
    Resizer.prototype.getElementPos = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var posFetcher = this.posFetcher;
        return posFetcher ? posFetcher(el, opts) : getBoundingRect(el);
    };
    /**
     * Focus resizer on the element, attaches handlers to it
     * @param {HTMLElement} el
     */
    Resizer.prototype.focus = function (el) {
        // Avoid focusing on already focused element
        if (el && el === this.el) {
            return;
        }
        this.el = el;
        this.updateContainer({ forceShow: true });
        (0,dom.on)(this.getDocumentEl(), 'pointerdown', this.handleMouseDown);
    };
    /**
     * Blur from element
     */
    Resizer.prototype.blur = function () {
        this.container.style.display = 'none';
        if (this.el) {
            (0,dom/* off */.S1)(this.getDocumentEl(), 'pointerdown', this.handleMouseDown);
            delete this.el;
        }
    };
    /**
     * Start resizing
     * @param  {Event} e
     */
    Resizer.prototype.start = function (ev) {
        var e = ev;
        // @ts-ignore Right or middel click
        if (e.button !== 0)
            return;
        e.preventDefault();
        e.stopPropagation();
        var el = this.el;
        var parentEl = this.getParentEl();
        var resizer = this;
        var config = this.opts || {};
        var mouseFetch = this.mousePosFetcher;
        var attrName = 'data-' + config.prefix + 'handler';
        var rect = this.getElementPos(el, { avoidFrameZoom: true, avoidFrameOffset: true });
        var parentRect = this.getElementPos(parentEl);
        var target = e.target;
        this.handlerAttr = target.getAttribute(attrName);
        this.clickedHandler = target;
        this.startDim = {
            t: rect.top,
            l: rect.left,
            w: rect.width,
            h: rect.height,
        };
        this.rectDim = {
            t: rect.top,
            l: rect.left,
            w: rect.width,
            h: rect.height,
        };
        this.startPos = mouseFetch
            ? mouseFetch(e)
            : {
                x: e.clientX,
                y: e.clientY,
            };
        this.parentDim = {
            t: parentRect.top,
            l: parentRect.left,
            w: parentRect.width,
            h: parentRect.height,
        };
        // Listen events
        var docs = this.getDocumentEl();
        this.docs = docs;
        (0,dom.on)(docs, 'pointermove', this.move);
        (0,dom.on)(docs, 'keydown', this.handleKeyDown);
        (0,dom.on)(docs, 'pointerup', this.stop);
        (0,index_all.isFunction)(this.onStart) && this.onStart(e, { docs: docs, config: config, el: el, resizer: resizer });
        this.toggleFrames(true);
        this.move(e);
    };
    /**
     * While resizing
     * @param  {Event} e
     */
    Resizer.prototype.move = function (ev) {
        var e = ev;
        var onMove = this.onMove;
        var mouseFetch = this.mousePosFetcher;
        var currentPos = mouseFetch
            ? mouseFetch(e)
            : {
                x: e.clientX,
                y: e.clientY,
            };
        this.currentPos = currentPos;
        this.delta = {
            x: currentPos.x - this.startPos.x,
            y: currentPos.y - this.startPos.y,
        };
        this.keys = {
            shift: e.shiftKey,
            ctrl: e.ctrlKey,
            alt: e.altKey,
        };
        this.rectDim = this.calc(this);
        this.updateRect(false);
        // Move callback
        onMove && onMove(e);
    };
    /**
     * Stop resizing
     * @param  {Event} e
     */
    Resizer.prototype.stop = function (e) {
        var el = this.el;
        var config = this.opts;
        var docs = this.docs || this.getDocumentEl();
        (0,dom/* off */.S1)(docs, 'pointermove', this.move);
        (0,dom/* off */.S1)(docs, 'keydown', this.handleKeyDown);
        (0,dom/* off */.S1)(docs, 'pointerup', this.stop);
        this.updateRect(true);
        this.toggleFrames();
        (0,index_all.isFunction)(this.onEnd) && this.onEnd(e, { docs: docs, config: config, el: el, resizer: this });
        delete this.docs;
    };
    /**
     * Update rect
     */
    Resizer.prototype.updateRect = function (store) {
        var el = this.el;
        var resizer = this;
        var config = this.opts;
        var rect = this.rectDim;
        var updateTarget = this.updateTarget;
        var selectedHandler = this.getSelectedHandler();
        var unitHeight = config.unitHeight, unitWidth = config.unitWidth, keyWidth = config.keyWidth, keyHeight = config.keyHeight;
        // Use custom updating strategy if requested
        if ((0,index_all.isFunction)(updateTarget)) {
            updateTarget(el, rect, {
                store: store,
                selectedHandler: selectedHandler,
                resizer: resizer,
                config: config,
            });
        }
        else {
            var elStyle = el.style;
            elStyle[keyWidth] = rect.w + unitWidth;
            elStyle[keyHeight] = rect.h + unitHeight;
        }
        this.updateContainer();
    };
    Resizer.prototype.updateContainer = function (opt) {
        var _a;
        if (opt === void 0) { opt = {}; }
        var _b = this, opts = _b.opts, container = _b.container, el = _b.el;
        var style = container.style;
        if (!opts.avoidContainerUpdate && el) {
            // On component resize container fits the tool,
            // to check if this update is required somewhere else point
            // const toUpdate = ['left', 'top', 'width', 'height'];
            // const rectEl = this.getElementPos(el, { target: 'container' });
            // toUpdate.forEach(pos => (style[pos] = `${rectEl[pos]}px`));
            if (opt.forceShow)
                style.display = 'block';
        }
        (_a = this.onUpdateContainer) === null || _a === void 0 ? void 0 : _a.call(this, {
            el: container,
            resizer: this,
            opts: Resizer_assign(Resizer_assign({}, opts), opt),
        });
    };
    /**
     * Get selected handler name
     * @return {string}
     */
    Resizer.prototype.getSelectedHandler = function () {
        var handlers = this.handlers;
        if (!this.selectedHandler) {
            return;
        }
        for (var n in handlers) {
            if (handlers[n] === this.selectedHandler)
                return n;
        }
    };
    /**
     * Handle ESC key
     * @param  {Event} e
     */
    Resizer.prototype.handleKeyDown = function (e) {
        // @ts-ignore
        if (e.keyCode === 27) {
            // Rollback to initial dimensions
            this.rectDim = this.startDim;
            this.stop(e);
        }
    };
    /**
     * Handle mousedown to check if it's possible to start resizing
     * @param  {Event} e
     */
    Resizer.prototype.handleMouseDown = function (e) {
        var el = e.target;
        if (this.isHandler(el)) {
            this.selectedHandler = el;
            this.start(e);
        }
        else if (el !== this.el) {
            delete this.selectedHandler;
            this.blur();
        }
    };
    /**
     * All positioning logic
     * @return {Object}
     */
    Resizer.prototype.calc = function (data) {
        var value;
        var opts = this.opts || {};
        var step = opts.step;
        var startDim = this.startDim;
        var minDim = opts.minDim;
        var maxDim = opts.maxDim;
        var deltaX = data.delta.x;
        var deltaY = data.delta.y;
        var parentW = this.parentDim.w;
        var parentH = this.parentDim.h;
        var unitWidth = this.opts.unitWidth;
        var unitHeight = this.opts.unitHeight;
        var startW = unitWidth === '%' ? (startDim.w / 100) * parentW : startDim.w;
        var startH = unitHeight === '%' ? (startDim.h / 100) * parentH : startDim.h;
        var box = {
            t: startDim.t,
            l: startDim.l,
            w: startW,
            h: startH,
        };
        if (!data)
            return;
        var attr = data.handlerAttr;
        if (~attr.indexOf('r')) {
            value =
                unitWidth === '%'
                    ? (0,mixins.normalizeFloat)(((startW + deltaX * step) / parentW) * 100, 0.01)
                    : (0,mixins.normalizeFloat)(startW + deltaX * step, step);
            value = Math.max(minDim, value);
            maxDim && (value = Math.min(maxDim, value));
            box.w = value;
        }
        if (~attr.indexOf('b')) {
            value =
                unitHeight === '%'
                    ? (0,mixins.normalizeFloat)(((startH + deltaY * step) / parentH) * 100, 0.01)
                    : (0,mixins.normalizeFloat)(startH + deltaY * step, step);
            value = Math.max(minDim, value);
            maxDim && (value = Math.min(maxDim, value));
            box.h = value;
        }
        if (~attr.indexOf('l')) {
            value =
                unitWidth === '%'
                    ? (0,mixins.normalizeFloat)(((startW - deltaX * step) / parentW) * 100, 0.01)
                    : (0,mixins.normalizeFloat)(startW - deltaX * step, step);
            value = Math.max(minDim, value);
            maxDim && (value = Math.min(maxDim, value));
            box.w = value;
        }
        if (~attr.indexOf('t')) {
            value =
                unitHeight === '%'
                    ? (0,mixins.normalizeFloat)(((startH - deltaY * step) / parentH) * 100, 0.01)
                    : (0,mixins.normalizeFloat)(startH - deltaY * step, step);
            value = Math.max(minDim, value);
            maxDim && (value = Math.min(maxDim, value));
            box.h = value;
        }
        // Enforce aspect ratio (unless shift key is being held)
        var ratioActive = opts.ratioDefault ? !data.keys.shift : data.keys.shift;
        if (attr.indexOf('c') < 0 && ratioActive) {
            var ratio = startDim.w / startDim.h;
            if (box.w / box.h > ratio) {
                box.h = Math.round(box.w / ratio);
            }
            else {
                box.w = Math.round(box.h * ratio);
            }
        }
        if (~attr.indexOf('l')) {
            box.l += startDim.w - box.w;
        }
        if (~attr.indexOf('t')) {
            box.t += startDim.h - box.h;
        }
        for (var key in box) {
            var i = key;
            box[i] = parseInt("".concat(box[i]), 10);
        }
        return box;
    };
    return Resizer;
}());
/* harmony default export */ const utils_Resizer = (Resizer);

;// CONCATENATED MODULE: ./src/utils/index.ts
var utils_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var utils_assign = (undefined && undefined.__assign) || function () {
    utils_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return utils_assign.apply(this, arguments);
};





var UtilsModule = /** @class */ (function (_super) {
    utils_extends(UtilsModule, _super);
    function UtilsModule(em) {
        var _this = _super.call(this, em, 'Utils') || this;
        _this.Sorter = utils_Sorter;
        _this.Resizer = utils_Resizer;
        _this.Dragger = Dragger/* default */.Z;
        _this.helpers = utils_assign({}, mixins);
        return _this;
    }
    UtilsModule.prototype.destroy = function () { };
    return UtilsModule;
}(abstract_Module));
/* harmony default export */ const utils = (UtilsModule);

;// CONCATENATED MODULE: ./src/utils/keymaster.ts
// @ts-nocheck
// The initial version of this library was borrowed from https://github.com/madrobby/keymaster
// and adapted to the GrapesJS's need
var k, _handlers = {}, _mods = {
    16: false,
    18: false,
    17: false,
    91: false,
}, _scope = 'all', 
// modifier keys
_MODIFIERS = {
    '⇧': 16,
    shift: 16,
    '⌥': 18,
    alt: 18,
    option: 18,
    '⌃': 17,
    ctrl: 17,
    control: 17,
    '⌘': 91,
    command: 91,
}, 
// special keys
_MAP = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    ',': 188,
    '.': 190,
    '/': 191,
    '`': 192,
    '-': 189,
    '=': 187,
    ';': 186,
    "'": 222,
    '[': 219,
    ']': 221,
    '\\': 220,
}, keymaster_code = function (x) {
    return _MAP[x] || x.toUpperCase().charCodeAt(0);
}, _downKeys = [];
for (k = 1; k < 20; k++)
    _MAP['f' + k] = 111 + k;
// IE doesn't support Array#indexOf, so have a simple replacement
function index(array, item) {
    var i = array.length;
    while (i--)
        if (array[i] === item)
            return i;
    return -1;
}
// for comparing mods before unassignment
function keymaster_compareArray(a1, a2) {
    if (a1.length != a2.length)
        return false;
    for (var i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i])
            return false;
    }
    return true;
}
var modifierMap = {
    16: 'shiftKey',
    18: 'altKey',
    17: 'ctrlKey',
    91: 'metaKey',
};
function updateModifierKey(event) {
    for (k in _mods)
        _mods[k] = event[modifierMap[k]];
}
// handle keydown event
function dispatch(event) {
    var key, handler, k, i, modifiersMatch, scope;
    key = event.keyCode;
    if (index(_downKeys, key) == -1) {
        _downKeys.push(key);
    }
    // if a modifier key, set the key.<modifierkeyname> property to true and return
    if (key == 93 || key == 224)
        key = 91; // right command on webkit, command on Gecko
    if (key in _mods) {
        _mods[key] = true;
        // 'assignKey' from inside this closure is exported to window.key
        for (k in _MODIFIERS)
            if (_MODIFIERS[k] == key)
                assignKey[k] = true;
        return;
    }
    updateModifierKey(event);
    // see if we need to ignore the keypress (filter() can can be overridden)
    // by default ignore key presses if a select, textarea, or input is focused
    if (!assignKey.filter.call(this, event))
        return;
    // abort if no potentially matching shortcuts found
    if (!(key in _handlers))
        return;
    scope = keymaster_getScope();
    // for each potential shortcut
    for (i = 0; i < _handlers[key].length; i++) {
        handler = _handlers[key][i];
        // see if it's in the current scope
        if (handler.scope == scope || handler.scope == 'all') {
            // check if modifiers match if any
            modifiersMatch = handler.mods.length > 0;
            for (k in _mods)
                if ((!_mods[k] && index(handler.mods, +k) > -1) || (_mods[k] && index(handler.mods, +k) == -1))
                    modifiersMatch = false;
            // call the handler and stop the event if neccessary
            if ((handler.mods.length == 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91]) || modifiersMatch) {
                if (handler.method(event, handler) === false) {
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                    if (event.stopPropagation)
                        event.stopPropagation();
                    if (event.cancelBubble)
                        event.cancelBubble = true;
                }
            }
        }
    }
}
// unset modifier keys on keyup
function clearModifier(event) {
    var key = event.keyCode, k, i = index(_downKeys, key);
    // remove key from _downKeys
    if (i >= 0) {
        _downKeys.splice(i, 1);
    }
    if (key == 93 || key == 224)
        key = 91;
    if (key in _mods) {
        _mods[key] = false;
        for (k in _MODIFIERS)
            if (_MODIFIERS[k] == key)
                assignKey[k] = false;
    }
}
function resetModifiers() {
    for (k in _mods)
        _mods[k] = false;
    for (k in _MODIFIERS)
        assignKey[k] = false;
}
// parse and assign shortcut
function assignKey(key, scope, method) {
    var keys, mods;
    keys = getKeys(key);
    if (method === undefined) {
        method = scope;
        scope = 'all';
    }
    // for each shortcut
    for (var i = 0; i < keys.length; i++) {
        // set modifier keys if any
        mods = [];
        key = keys[i].split('+');
        if (key.length > 1) {
            mods = getMods(key);
            key = [key[key.length - 1]];
        }
        // convert to keycode and...
        key = key[0];
        key = keymaster_code(key);
        // ...store handler
        if (!(key in _handlers))
            _handlers[key] = [];
        _handlers[key].push({
            shortcut: keys[i],
            scope: scope,
            method: method,
            key: keys[i],
            mods: mods,
        });
    }
}
// unbind all handlers for given key in current scope
function unbindKey(key, scope) {
    var multipleKeys, keys, mods = [], i, j, obj;
    multipleKeys = getKeys(key);
    for (j = 0; j < multipleKeys.length; j++) {
        keys = multipleKeys[j].split('+');
        if (keys.length > 1) {
            mods = getMods(keys);
        }
        key = keys[keys.length - 1];
        key = keymaster_code(key);
        if (scope === undefined) {
            scope = keymaster_getScope();
        }
        if (!_handlers[key]) {
            return;
        }
        for (i = 0; i < _handlers[key].length; i++) {
            obj = _handlers[key][i];
            // only clear handlers if correct scope and mods match
            if (obj.scope === scope && keymaster_compareArray(obj.mods, mods)) {
                _handlers[key][i] = {};
            }
        }
    }
}
// Returns true if the key with code 'keyCode' is currently down
// Converts strings into key codes.
function isPressed(keyCode) {
    if (typeof keyCode == 'string') {
        keyCode = keymaster_code(keyCode);
    }
    return index(_downKeys, keyCode) != -1;
}
function getPressedKeyCodes() {
    return _downKeys.slice(0);
}
function filter(event) {
    var tagName = (event.target || event.srcElement).tagName;
    // ignore keypressed in any elements that support keyboard data input
    return !(tagName == 'INPUT' || tagName == 'SELECT' || tagName == 'TEXTAREA');
}
// initialize key.<modifier> to false
for (k in _MODIFIERS)
    assignKey[k] = false;
// set current scope (default 'all')
function setScope(scope) {
    _scope = scope || 'all';
}
function keymaster_getScope() {
    return _scope || 'all';
}
// delete all handlers for a given scope
function deleteScope(scope) {
    var key, handlers, i;
    for (key in _handlers) {
        handlers = _handlers[key];
        for (i = 0; i < handlers.length;) {
            if (handlers[i].scope === scope)
                handlers.splice(i, 1);
            else
                i++;
        }
    }
}
// abstract key logic for assign and unassign
function getKeys(key) {
    var keys;
    key = key.replace(/\s/g, '');
    keys = key.split(',');
    if (keys[keys.length - 1] == '') {
        keys[keys.length - 2] += ',';
    }
    return keys;
}
// abstract mods logic for assign and unassign
function getMods(key) {
    var mods = key.slice(0, key.length - 1);
    for (var mi = 0; mi < mods.length; mi++)
        mods[mi] = _MODIFIERS[mods[mi]];
    return mods;
}
// cross-browser events
function addEvent(object, event, method) {
    if (object.addEventListener)
        object.addEventListener(event, method, false);
    else if (object.attachEvent)
        object.attachEvent('on' + event, function () {
            method(window.event);
        });
}
// set window.key and window.key.set/get/deleteScope, and the default filter
assignKey.setScope = setScope;
assignKey.getScope = keymaster_getScope;
assignKey.deleteScope = deleteScope;
assignKey.filter = filter;
assignKey.isPressed = isPressed;
assignKey.getPressedKeyCodes = getPressedKeyCodes;
assignKey.unbind = unbindKey;
assignKey.handlers = _handlers;
assignKey.init = function (win) {
    // set the handlers globally on document
    // Passing _scope to a callback to ensure it remains the same by execution. Fixes #48
    addEvent(win.document, 'keydown', function (event) {
        dispatch(event);
    });
    addEvent(win.document, 'keyup', clearModifier);
    addEvent(win, 'focus', resetModifiers);
};
/* harmony default export */ const keymaster = (assignKey);

;// CONCATENATED MODULE: ./src/keymaps/config.ts
var keymaps_config_config = {
    defaults: {
        'core:undo': {
            keys: '⌘+z, ctrl+z',
            handler: 'core:undo',
            opts: { prevent: true },
        },
        'core:redo': {
            keys: '⌘+shift+z, ctrl+shift+z',
            handler: 'core:redo',
            opts: { prevent: true },
        },
        'core:copy': {
            keys: '⌘+c, ctrl+c',
            handler: 'core:copy',
        },
        'core:paste': {
            keys: '⌘+v, ctrl+v',
            handler: 'core:paste',
        },
        'core:component-next': {
            keys: 's',
            handler: 'core:component-next',
        },
        'core:component-prev': {
            keys: 'w',
            handler: 'core:component-prev',
        },
        'core:component-enter': {
            keys: 'd',
            handler: 'core:component-enter',
        },
        'core:component-exit': {
            keys: 'a',
            handler: 'core:component-exit',
        },
        'core:component-delete': {
            keys: 'backspace, delete',
            handler: 'core:component-delete',
            opts: { prevent: true },
        },
    },
};
/* harmony default export */ const keymaps_config = (keymaps_config_config);

;// CONCATENATED MODULE: ./src/keymaps/index.ts
/**
 * You can customize the initial state of the module from the editor initialization
 * ```js
 * const editor = grapesjs.init({
 *  keymaps: {
 *     // Object of keymaps
 *    defaults: {
 *      'your-namespace:keymap-name' {
 *        keys: '⌘+z, ctrl+z',
 *        handler: 'some-command-id'
 *      },
 *      ...
 *    }
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('keymap:add', () => { ... });
 *
 * // Use the API
 * const keymaps = editor.Keymaps;
 * keymaps.add(...);
 * ```
 *
 * ## Available Events
 * * `keymap:add` - New keymap added. The new keyamp object is passed as an argument
 * * `keymap:remove` - Keymap removed. The removed keyamp object is passed as an argument
 * * `keymap:emit` - Some keymap emitted, in arguments you get keymapId, shortcutUsed, Event
 * * `keymap:emit:{keymapId}` - `keymapId` emitted, in arguments you get keymapId, shortcutUsed, Event
 *
 * ## Methods
 * * [getConfig](#getconfig)
 * * [add](#add)
 * * [get](#get)
 * * [getAll](#getAll)
 * * [remove](#remove)
 * * [removeAll](#removeall)
 *
 * @module Keymaps
 */
var keymaps_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var keymaps_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};





(0,mixins.hasWin)() && keymaster.init(window);
var KeymapsModule = /** @class */ (function (_super) {
    keymaps_extends(KeymapsModule, _super);
    function KeymapsModule(em) {
        var _this = _super.call(this, em, 'Keymaps', keymaps_config) || this;
        _this.keymaster = keymaster;
        _this.keymaps = {};
        return _this;
    }
    KeymapsModule.prototype.onLoad = function () {
        var defKeys = this.config.defaults;
        for (var id in defKeys) {
            var value = defKeys[id];
            this.add(id, value.keys, value.handler, value.opts || {});
        }
    };
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Add new keymap
     * @param {string} id Keymap id
     * @param {string} keys Keymap keys, eg. `ctrl+a`, `⌘+z, ctrl+z`
     * @param {Function|string} handler Keymap handler, might be a function
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.force=false] Force the handler to be executed.
     * @param {Boolean} [opts.prevent=false] Prevent default of the original triggered event.
     * @returns {Object} Added keymap
     * @example
     * // 'ns' is just a custom namespace
     * keymaps.add('ns:my-keymap', '⌘+j, ⌘+u, ctrl+j, alt+u', editor => {
     *  console.log('do stuff');
     * });
     * // or
     * keymaps.add('ns:my-keymap', '⌘+s, ctrl+s', 'some-gjs-command', {
     *  // Prevent the default browser action
     *  prevent: true,
     * });
     *
     * // listen to events
     * editor.on('keymap:emit', (id, shortcut, event) => {
     *  // ...
     * })
     */
    KeymapsModule.prototype.add = function (id, keys, handler, opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var cmd = em.Commands;
        var editor = em.getEditor();
        var canvas = em.Canvas;
        var keymap = { id: id, keys: keys, handler: handler };
        var pk = this.keymaps[id];
        pk && this.remove(id);
        this.keymaps[id] = keymap;
        keymaster(keys, function (e, h) {
            // It's safer putting handlers resolution inside the callback
            var opt = { event: e, h: h };
            var handlerRes = (0,index_all.isString)(handler) ? cmd.get(handler) : handler;
            var ableTorun = !em.isEditing() && !editor.Canvas.isInputFocused();
            if (ableTorun || opts.force) {
                opts.prevent && canvas.getCanvasView().preventDefault(e);
                (0,index_all.isFunction)(handlerRes) ? handlerRes(editor, 0, opt) : cmd.runCommand(handlerRes, opt);
                var args = [id, h.shortcut, e];
                em.trigger.apply(em, keymaps_spreadArray(['keymap:emit'], args, false));
                em.trigger.apply(em, keymaps_spreadArray(["keymap:emit:".concat(id)], args, false));
            }
        }, undefined);
        em.trigger('keymap:add', keymap);
        return keymap;
    };
    /**
     * Get the keymap by id
     * @param {string} id Keymap id
     * @return {Object} Keymap object
     * @example
     * keymaps.get('ns:my-keymap');
     * // -> {keys, handler};
     */
    KeymapsModule.prototype.get = function (id) {
        return this.keymaps[id];
    };
    /**
     * Get all keymaps
     * @return {Object}
     * @example
     * keymaps.getAll();
     * // -> {id1: {}, id2: {}};
     */
    KeymapsModule.prototype.getAll = function () {
        return this.keymaps;
    };
    /**
     * Remove the keymap by id
     * @param {string} id Keymap id
     * @return {Object} Removed keymap
     * @example
     * keymaps.remove('ns:my-keymap');
     * // -> {keys, handler};
     */
    KeymapsModule.prototype.remove = function (id) {
        var em = this.em;
        var keymap = this.get(id);
        if (keymap) {
            delete this.keymaps[id];
            keymap.keys.split(', ').forEach(function (k) {
                // @ts-ignore
                keymaster.unbind(k.trim());
            });
            em === null || em === void 0 ? void 0 : em.trigger('keymap:remove', keymap);
            return keymap;
        }
    };
    /**
     * Remove all binded keymaps
     * @return {this}
     */
    KeymapsModule.prototype.removeAll = function () {
        var _this = this;
        Object.keys(this.keymaps).forEach(function (keymap) { return _this.remove(keymap); });
        keymaster.handlers = {};
        return this;
    };
    KeymapsModule.prototype.destroy = function () {
        this.removeAll();
        this.keymaps = {};
    };
    return KeymapsModule;
}(abstract_Module));
/* harmony default export */ const keymaps = (KeymapsModule);

;// CONCATENATED MODULE: ./src/modal_dialog/config/config.ts
var modal_dialog_config_config_config = {
    stylePrefix: 'mdl-',
    title: '',
    content: '',
    backdrop: true,
    custom: false,
    extend: {},
};
/* harmony default export */ const modal_dialog_config_config = (modal_dialog_config_config_config);

;// CONCATENATED MODULE: ./src/modal_dialog/model/Modal.ts
var Modal_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var Modal = /** @class */ (function (_super) {
    Modal_extends(Modal, _super);
    function Modal() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Modal.prototype.defaults = function () {
        return {
            title: '',
            content: '',
            attributes: {},
            open: false,
        };
    };
    Modal.prototype.open = function () {
        this.set('open', true);
    };
    Modal.prototype.close = function () {
        this.set('open', false);
    };
    return Modal;
}(ModuleModel/* default */.Z));
/* harmony default export */ const model_Modal = (Modal);

;// CONCATENATED MODULE: ./src/modal_dialog/view/ModalView.ts
var ModalView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ModalView_assign = (undefined && undefined.__assign) || function () {
    ModalView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ModalView_assign.apply(this, arguments);
};

var ModalView = /** @class */ (function (_super) {
    ModalView_extends(ModalView, _super);
    function ModalView(o) {
        var _this = _super.call(this, o) || this;
        var model = _this.model;
        _this.listenTo(model, 'change:open', _this.updateOpen);
        _this.listenTo(model, 'change:title', _this.updateTitle);
        _this.listenTo(model, 'change:content', _this.updateContent);
        return _this;
    }
    ModalView.prototype.template = function (_a) {
        var pfx = _a.pfx, ppfx = _a.ppfx, content = _a.content, title = _a.title;
        return "<div class=\"".concat(pfx, "dialog ").concat(ppfx, "one-bg ").concat(ppfx, "two-color\">\n      <div class=\"").concat(pfx, "header\">\n        <div class=\"").concat(pfx, "title\">").concat(title, "</div>\n        <div class=\"").concat(pfx, "btn-close\" data-close-modal>&Cross;</div>\n      </div>\n      <div class=\"").concat(pfx, "content\">\n        <div id=\"").concat(pfx, "c\">").concat(content, "</div>\n        <div style=\"clear:both\"></div>\n      </div>\n    </div>\n    <div class=\"").concat(pfx, "collector\" style=\"display: none\"></div>");
    };
    ModalView.prototype.events = function () {
        return {
            click: 'onClick',
            'click [data-close-modal]': 'hide',
        };
    };
    ModalView.prototype.onClick = function (e) {
        var bkd = this.config.backdrop;
        bkd && e.target === this.el && this.hide();
    };
    /**
     * Returns collector element
     * @return {HTMLElement}
     * @private
     */
    ModalView.prototype.getCollector = function () {
        if (!this.$collector)
            this.$collector = this.$el.find('.' + this.pfx + 'collector');
        return this.$collector;
    };
    /**
     * Returns content element
     * @return {HTMLElement}
     */
    ModalView.prototype.getContent = function () {
        var pfx = this.pfx;
        if (!this.$content) {
            this.$content = this.$el.find(".".concat(pfx, "content #").concat(pfx, "c"));
        }
        return this.$content;
    };
    /**
     * Returns title element
     * @return {HTMLElement}
     * @private
     */
    ModalView.prototype.getTitle = function (opts) {
        if (opts === void 0) { opts = {}; }
        if (!this.$title)
            this.$title = this.$el.find('.' + this.pfx + 'title');
        return opts.$ ? this.$title : this.$title.get(0);
    };
    /**
     * Update content
     * @private
     * */
    ModalView.prototype.updateContent = function () {
        var content = this.getContent();
        var children = content.children();
        var coll = this.getCollector();
        var body = this.model.get('content');
        children.length && coll.append(children);
        content.empty().append(body);
    };
    /**
     * Update title
     * @private
     * */
    ModalView.prototype.updateTitle = function () {
        var title = this.getTitle({ $: true });
        //@ts-ignore
        title && title.empty().append(this.model.get('title'));
    };
    /**
     * Update open
     * @private
     * */
    ModalView.prototype.updateOpen = function () {
        this.el.style.display = this.model.get('open') ? '' : 'none';
    };
    /**
     * Hide modal
     * @private
     * */
    ModalView.prototype.hide = function () {
        this.model.close();
    };
    /**
     * Show modal
     * @private
     * */
    ModalView.prototype.show = function () {
        this.model.open();
    };
    ModalView.prototype.updateAttr = function (attr) {
        var _a = this, pfx = _a.pfx, $el = _a.$el, el = _a.el;
        //@ts-ignore
        var currAttr = [].slice.call(el.attributes).map(function (i) { return i.name; });
        $el.removeAttr(currAttr.join(' '));
        $el.attr(ModalView_assign(ModalView_assign({}, (attr || {})), { class: "".concat(pfx, "container ").concat((attr && attr.class) || '').trim() }));
    };
    ModalView.prototype.render = function () {
        var el = this.$el;
        var obj = this.model.toJSON();
        obj.pfx = this.pfx;
        obj.ppfx = this.ppfx;
        el.html(this.template(obj));
        this.updateAttr();
        this.updateOpen();
        return this;
    };
    return ModalView;
}(abstract_ModuleView));
/* harmony default export */ const view_ModalView = (ModalView);

;// CONCATENATED MODULE: ./src/modal_dialog/index.ts
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/modal_dialog/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  modal: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const modal = editor.Modal;
 * ```
 *
 * ## Available Events
 * * `modal:open` - Modal is opened
 * * `modal:close` - Modal is closed
 * * `modal` - Event triggered on any change related to the modal. An object containing all the available data about the triggered event is passed as an argument to the callback.
 *
 * ## Methods
 * * [open](#open)
 * * [close](#close)
 * * [isOpen](#isopen)
 * * [setTitle](#settitle)
 * * [getTitle](#gettitle)
 * * [setContent](#setcontent)
 * * [getContent](#getcontent)
 * * [onceClose](#onceclose)
 * * [onceOpen](#onceopen)
 *
 * @module Modal
 */
var modal_dialog_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();






var ModalModule = /** @class */ (function (_super) {
    modal_dialog_extends(ModalModule, _super);
    /**
     * Initialize module. Automatically called with a new instance of the editor
     * @param {Object} config Configurations
     * @private
     */
    function ModalModule(em) {
        var _this = _super.call(this, em, 'Modal', modal_dialog_config_config) || this;
        _this.model = new model_Modal(_this);
        _this.model.on('change:open', function (m, enable) {
            em.trigger("modal:".concat(enable ? 'open' : 'close'));
        });
        _this.model.on('change', (0,index_all.debounce)(function () {
            var data = _this._evData();
            var custom = _this.config.custom;
            //@ts-ignore
            (0,index_all.isFunction)(custom) && custom(data);
            em.trigger('modal', data);
        }, 0));
        return _this;
    }
    ModalModule.prototype._evData = function () {
        var _this = this;
        var titl = this.getTitle();
        var cnt = this.getContent();
        var _a = this.model.attributes, open = _a.open, attributes = _a.attributes;
        return {
            open: open,
            attributes: attributes,
            title: (0,index_all.isString)(titl) ? (0,dom/* createText */.rw)(titl) : titl,
            //@ts-ignore
            content: (0,index_all.isString)(cnt) ? (0,dom/* createText */.rw)(cnt) : cnt.get ? cnt.get(0) : cnt,
            close: function () {
                _this.close();
            },
        };
    };
    ModalModule.prototype.postRender = function (view) {
        var el = view.model.config.el || view.el;
        var res = this.render();
        res && (el === null || el === void 0 ? void 0 : el.appendChild(res));
    };
    /**
     * Open the modal window
     * @param {Object} [opts={}] Options
     * @param {String|HTMLElement} [opts.title] Title to set for the modal
     * @param {String|HTMLElement} [opts.content] Content to set for the modal
     * @param {Object} [opts.attributes] Updates the modal wrapper with custom attributes
     * @returns {this}
     * @example
     * modal.open({
     *   title: 'My title',
     *   content: 'My content',
     *   attributes: { class: 'my-class' },
     * });
     */
    ModalModule.prototype.open = function (opts) {
        if (opts === void 0) { opts = {}; }
        var attr = opts.attributes || {};
        opts.title && this.setTitle(opts.title);
        opts.content && this.setContent(opts.content);
        this.model.set('attributes', attr);
        this.model.open();
        this.modal && this.modal.updateAttr(attr);
        return this;
    };
    /**
     * Close the modal window
     * @returns {this}
     * @example
     * modal.close();
     */
    ModalModule.prototype.close = function () {
        this.model.close();
        return this;
    };
    /**
     * Execute callback when the modal will be closed.
     * The callback will be called one only time
     * @param {Function} clb Callback to call
     * @returns {this}
     * @example
     * modal.onceClose(() => {
     *  console.log('The modal is closed');
     * });
     */
    ModalModule.prototype.onceClose = function (clb) {
        this.em.once('modal:close', clb);
        return this;
    };
    /**
     * Execute callback when the modal will be opened.
     * The callback will be called one only time
     * @param {Function} clb Callback to call
     * @returns {this}
     * @example
     * modal.onceOpen(() => {
     *  console.log('The modal is opened');
     * });
     */
    ModalModule.prototype.onceOpen = function (clb) {
        this.em.once('modal:open', clb);
        return this;
    };
    /**
     * Checks if the modal window is open
     * @returns {Boolean}
     * @example
     * modal.isOpen(); // true | false
     */
    ModalModule.prototype.isOpen = function () {
        return !!this.model.get('open');
    };
    /**
     * Set the title to the modal window
     * @param {string | HTMLElement} title Title
     * @returns {this}
     * @example
     * // pass a string
     * modal.setTitle('Some title');
     * // or an HTMLElement
     * const el = document.createElement('div');
     * el.innerText =  'New title';
     * modal.setTitle(el);
     */
    ModalModule.prototype.setTitle = function (title) {
        this.model.set('title', title);
        return this;
    };
    /**
     * Returns the title of the modal window
     * @returns {string | HTMLElement}
     * @example
     * modal.getTitle();
     */
    ModalModule.prototype.getTitle = function () {
        return this.model.get('title');
    };
    /**
     * Set the content of the modal window
     * @param {string | HTMLElement} content Content
     * @returns {this}
     * @example
     * // pass a string
     * modal.setContent('Some content');
     * // or an HTMLElement
     * const el = document.createElement('div');
     * el.innerText =  'New content';
     * modal.setContent(el);
     */
    ModalModule.prototype.setContent = function (content) {
        this.model.set('content', ' ');
        this.model.set('content', content);
        return this;
    };
    /**
     * Get the content of the modal window
     * @returns {string | HTMLElement}
     * @example
     * modal.getContent();
     */
    ModalModule.prototype.getContent = function () {
        return this.model.get('content');
    };
    /**
     * Returns content element
     * @return {HTMLElement}
     * @private
     */
    ModalModule.prototype.getContentEl = function () {
        var _a;
        return (_a = this.modal) === null || _a === void 0 ? void 0 : _a.getContent().get(0);
    };
    /**
     * Returns modal model
     * @return {Model}
     * @private
     */
    ModalModule.prototype.getModel = function () {
        return this.model;
    };
    /**
     * Render the modal window
     * @return {HTMLElement}
     * @private
     */
    ModalModule.prototype.render = function () {
        var _a;
        if (this.config.custom)
            return;
        var View = view_ModalView.extend(this.config.extend);
        var el = this.modal && this.modal.el;
        this.modal = new View({
            el: el,
            model: this.model,
            config: this.config,
        });
        return (_a = this.modal) === null || _a === void 0 ? void 0 : _a.render().el;
    };
    ModalModule.prototype.destroy = function () {
        var _a;
        (_a = this.modal) === null || _a === void 0 ? void 0 : _a.remove();
    };
    return ModalModule;
}(abstract_Module));
/* harmony default export */ const modal_dialog = (ModalModule);

;// CONCATENATED MODULE: ./src/panels/config/config.ts
var swv = 'sw-visibility';
var expt = 'export-template';
var osm = 'open-sm';
var otm = 'open-tm';
var ola = 'open-layers';
var obl = 'open-blocks';
var opa = 'open-pages';
var ful = 'fullscreen';
var prv = 'preview';
var panels_config_config_config = {
    stylePrefix: 'pn-',
    defaults: [
        {
            id: 'commands',
            buttons: [{}],
        },
        {
            id: 'options',
            buttons: [
                {
                    active: true,
                    id: swv,
                    className: 'fa fa-square-o',
                    command: 'core:component-outline',
                    context: swv,
                    attributes: { title: 'View components' },
                },
                {
                    id: prv,
                    className: 'fa fa-eye',
                    command: prv,
                    context: prv,
                    attributes: { title: 'Preview' },
                },
                {
                    id: ful,
                    className: 'fa fa-arrows-alt',
                    command: ful,
                    context: ful,
                    attributes: { title: 'Fullscreen' },
                },
                {
                    id: expt,
                    className: 'fa fa-code',
                    command: expt,
                    attributes: { title: 'View code' },
                },
            ],
        },
        {
            id: 'views',
            buttons: [
                {
                    id: osm,
                    className: 'fa fa-paint-brush',
                    command: osm,
                    active: true,
                    togglable: false,
                    attributes: { title: 'Open Style Manager' },
                },
                {
                    id: otm,
                    className: 'fa fa-cog',
                    command: otm,
                    togglable: false,
                    attributes: { title: 'Settings' },
                },
                {
                    id: ola,
                    className: 'fa fa-bars',
                    command: ola,
                    togglable: false,
                    attributes: { title: 'Open Layer Manager' },
                },
                {
                    id: obl,
                    className: 'fa fa-th-large',
                    command: obl,
                    togglable: false,
                    attributes: { title: 'Open Blocks' },
                },
                {
                    id: opa,
                    className: 'fa fa-th-large',
                    command: opa,
                    togglable: false,
                    attributes: { title: 'Open Pages' },
                },
            ],
        },
    ],
};
/* harmony default export */ const panels_config_config = (panels_config_config_config);

;// CONCATENATED MODULE: ./src/panels/model/Button.ts
var Button_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Button = /** @class */ (function (_super) {
    Button_extends(Button, _super);
    function Button(module, options) {
        var _this = _super.call(this, module, options) || this;
        if (_this.get('buttons').length) {
            _this.set('buttons', new model_Buttons(_this.module, _this.get('buttons')));
        }
        return _this;
    }
    Button.prototype.defaults = function () {
        return {
            id: '',
            label: '',
            tagName: 'span',
            className: '',
            command: '',
            context: '',
            buttons: [],
            attributes: {},
            options: {},
            active: false,
            dragDrop: false,
            togglable: true,
            runDefaultCommand: true,
            stopDefaultCommand: false,
            disable: false,
        };
    };
    Object.defineProperty(Button.prototype, "className", {
        get: function () {
            return this.get('className');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "command", {
        get: function () {
            return this.get('command');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "active", {
        get: function () {
            return this.get('active');
        },
        set: function (isActive) {
            this.set('active', isActive);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "togglable", {
        get: function () {
            return this.get('togglable');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "runDefaultCommand", {
        get: function () {
            return this.get('runDefaultCommand');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "stopDefaultCommand", {
        get: function () {
            return this.get('stopDefaultCommand');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Button.prototype, "disable", {
        get: function () {
            return this.get('disable');
        },
        enumerable: false,
        configurable: true
    });
    return Button;
}(ModuleModel/* default */.Z));
/* harmony default export */ const model_Button = (Button);

;// CONCATENATED MODULE: ./src/panels/model/Buttons.ts
var Buttons_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Buttons = /** @class */ (function (_super) {
    Buttons_extends(Buttons, _super);
    function Buttons(module, models) {
        return _super.call(this, module, models, model_Button) || this;
    }
    /**
     * Deactivate all buttons, except one passed
     * @param  {Object}  except  Model to ignore
     * @param  {Boolean}  r     Recursive flag
     *
     * @return  void
     * */
    Buttons.prototype.deactivateAllExceptOne = function (except, r) {
        this.forEach(function (model, index) {
            if (model !== except) {
                model.set('active', false);
                if (r && model.get('buttons').length)
                    model.get('buttons').deactivateAllExceptOne(except, r);
            }
        });
    };
    /**
     * Deactivate all buttons
     * @param  {String}  ctx Context string
     *
     * @return  void
     * */
    Buttons.prototype.deactivateAll = function (ctx, sender) {
        var context = ctx || '';
        this.forEach(function (model) {
            if (model.get('context') == context && model !== sender) {
                //@ts-ignore
                model.set('active', false, { fromCollection: true });
            }
        });
    };
    /**
     * Disables all buttons
     * @param  {String}  ctx Context string
     *
     * @return  void
     * */
    Buttons.prototype.disableAllButtons = function (ctx) {
        var context = ctx || '';
        this.forEach(function (model, index) {
            if (model.get('context') == context) {
                model.set('disable', true);
            }
        });
    };
    /**
     * Disables all buttons, except one passed
     * @param  {Object}  except  Model to ignore
     * @param  {Boolean}  r     Recursive flag
     *
     * @return  void
     * */
    Buttons.prototype.disableAllButtonsExceptOne = function (except, r) {
        this.forEach(function (model, index) {
            if (model !== except) {
                model.set('disable', true);
                if (r && model.get('buttons').length)
                    model.get('buttons').disableAllButtonsExceptOne(except, r);
            }
        });
    };
    return Buttons;
}(abstract_ModuleCollection));
/* harmony default export */ const model_Buttons = (Buttons);
Buttons.prototype.model = model_Button;

;// CONCATENATED MODULE: ./src/panels/model/Panel.ts
var Panel_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Panel = /** @class */ (function (_super) {
    Panel_extends(Panel, _super);
    function Panel(module, options) {
        var _this = _super.call(this, module, options) || this;
        var btn = _this.get('buttons') || [];
        _this.buttons = new model_Buttons(module, btn);
        return _this;
    }
    Panel.prototype.defaults = function () {
        return {
            id: '',
            content: '',
            visible: true,
            buttons: [],
            attributes: {},
        };
    };
    Object.defineProperty(Panel.prototype, "buttons", {
        get: function () {
            return this.get('buttons');
        },
        set: function (buttons) {
            this.set('buttons', buttons);
        },
        enumerable: false,
        configurable: true
    });
    return Panel;
}(ModuleModel/* default */.Z));
/* harmony default export */ const model_Panel = (Panel);

;// CONCATENATED MODULE: ./src/panels/model/Panels.ts
var Panels_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Panels = /** @class */ (function (_super) {
    Panels_extends(Panels, _super);
    function Panels(module, models) {
        return _super.call(this, module, models, model_Panel) || this;
    }
    return Panels;
}(abstract_ModuleCollection));
/* harmony default export */ const model_Panels = (Panels);
Panels.prototype.model = model_Panel;

;// CONCATENATED MODULE: ./src/panels/view/ButtonView.ts
var ButtonView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var ButtonView_assign = (undefined && undefined.__assign) || function () {
    ButtonView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return ButtonView_assign.apply(this, arguments);
};


var ButtonView = /** @class */ (function (_super) {
    ButtonView_extends(ButtonView, _super);
    function ButtonView(o) {
        var _this = _super.call(this, o) || this;
        var _a = _this, model = _a.model, em = _a.em, pfx = _a.pfx, ppfx = _a.ppfx;
        var cls = model.className;
        var _b = model.attributes, command = _b.command, listen = _b.listen;
        _this.id = pfx + model.get('id');
        _this.activeCls = "".concat(pfx, "active ").concat(ppfx, "four-color");
        _this.disableCls = "".concat(ppfx, "disabled");
        _this.btnsVisCls = "".concat(pfx, "visible");
        _this.className = pfx + 'btn' + (cls ? ' ' + cls : '');
        _this.listenTo(model, 'change', _this.render);
        _this.listenTo(model, 'change:active updateActive', _this.updateActive);
        _this.listenTo(model, 'checkActive', _this.checkActive);
        _this.listenTo(model, 'change:bntsVis', _this.updateBtnsVis);
        _this.listenTo(model, 'change:attributes', _this.updateAttributes);
        _this.listenTo(model, 'change:className', _this.updateClassName);
        _this.listenTo(model, 'change:disable', _this.updateDisable);
        if (em && (0,index_all.isString)(command) && listen) {
            var chnOpt_1 = { fromListen: true };
            _this.listenTo(em, "run:".concat(command), function () { return model.set('active', true, chnOpt_1); });
            _this.listenTo(em, "stop:".concat(command), function () { return model.set('active', false, chnOpt_1); });
        }
        if (em && em.get)
            _this.commands = em.get('Commands');
        return _this;
    }
    //@ts-ignore
    ButtonView.prototype.tagName = function () {
        return this.model.get('tagName');
    };
    ButtonView.prototype.events = function () {
        return {
            click: 'clicked',
        };
    };
    /**
     * Updates class name of the button
     *
     * @return   void
     * */
    ButtonView.prototype.updateClassName = function () {
        var _a = this, model = _a.model, pfx = _a.pfx;
        var cls = model.className;
        var attrCls = model.get('attributes').class;
        var classStr = "".concat(attrCls ? attrCls : '', " ").concat(pfx, "btn ").concat(cls ? cls : '');
        this.$el.attr('class', classStr.trim());
    };
    /**
     * Updates attributes of the button
     *
     * @return   void
     * */
    ButtonView.prototype.updateAttributes = function () {
        var _a = this, em = _a.em, model = _a.model, $el = _a.$el;
        var attr = model.get('attributes') || {};
        var title = em && em.t && em.t("panels.buttons.titles.".concat(model.id));
        $el.attr(attr);
        title && $el.attr({ title: title });
        this.updateClassName();
    };
    /**
     * Updates visibility of children buttons
     *
     * @return  void
     * */
    ButtonView.prototype.updateBtnsVis = function () {
        if (!this.$buttons)
            return;
        if (this.model.get('bntsVis'))
            this.$buttons.addClass(this.btnsVisCls);
        else
            this.$buttons.removeClass(this.btnsVisCls);
    };
    /**
     * Update active status of the button
     *
     * @return   void
     * */
    ButtonView.prototype.updateActive = function (m, v, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = this, model = _b.model, commands = _b.commands, $el = _b.$el, activeCls = _b.activeCls;
        var fromCollection = opts.fromCollection, fromListen = opts.fromListen;
        var context = model.get('context');
        var options = model.get('options');
        var commandName = model.command;
        var command = {};
        if (!commandName)
            return;
        if (commands && (0,index_all.isString)(commandName)) {
            command = commands.get(commandName) || {};
        }
        else if ((0,index_all.isFunction)(commandName)) {
            command = commands.create({ run: commandName });
        }
        else if (commandName !== null && (0,index_all.isObject)(commandName)) {
            command = commands.create(commandName);
        }
        if (model.active) {
            !fromCollection && ((_a = model.collection) === null || _a === void 0 ? void 0 : _a.deactivateAll(context, model));
            model.set('active', true, { silent: true }).trigger('checkActive');
            !fromListen && commands.runCommand(command, ButtonView_assign(ButtonView_assign({}, options), { sender: model }));
            // Disable button if the command has no stop method
            //@ts-ignore
            command.noStop && model.set('active', false);
        }
        else {
            $el.removeClass(activeCls);
            !fromListen && commands.stopCommand(command, ButtonView_assign(ButtonView_assign({}, options), { sender: model, force: 1 }));
        }
    };
    ButtonView.prototype.updateDisable = function () {
        var _a = this, disableCls = _a.disableCls, model = _a.model;
        var disable = model.disable;
        this.$el[disable ? 'addClass' : 'removeClass'](disableCls);
    };
    /**
     * Update active style status
     *
     * @return   void
     * */
    ButtonView.prototype.checkActive = function () {
        var _a = this, model = _a.model, $el = _a.$el, activeCls = _a.activeCls;
        model.active ? $el.addClass(activeCls) : $el.removeClass(activeCls);
    };
    /**
     * Triggered when button is clicked
     * @return   void
     * */
    ButtonView.prototype.clicked = function () {
        var model = this.model;
        if (model.get('bntsVis') || model.disable || !model.command)
            return;
        this.toggleActive();
    };
    ButtonView.prototype.toggleActive = function () {
        var _a = this, model = _a.model, em = _a.em;
        var active = model.active, togglable = model.togglable;
        if (active && !togglable)
            return;
        model.active = !active;
        // If the stop is requested
        if (active) {
            if (model.runDefaultCommand)
                em.runDefault();
        }
        else {
            if (model.stopDefaultCommand)
                em.stopDefault();
        }
    };
    ButtonView.prototype.render = function () {
        var model = this.model;
        var label = model.get('label');
        var $el = this.$el;
        !model.get('el') && $el.empty();
        this.updateAttributes();
        label && $el.append(label);
        this.checkActive();
        this.updateDisable();
        return this;
    };
    return ButtonView;
}(abstract_ModuleView));
/* harmony default export */ const view_ButtonView = (ButtonView);

;// CONCATENATED MODULE: ./src/panels/view/ButtonsView.ts
var ButtonsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var ButtonsView = /** @class */ (function (_super) {
    ButtonsView_extends(ButtonsView, _super);
    function ButtonsView(collection) {
        var _this = _super.call(this, { collection: collection }) || this;
        _this.listenTo(_this.collection, 'add', _this.addTo);
        _this.listenTo(_this.collection, 'reset remove', _this.render);
        _this.className = _this.pfx + 'buttons';
        return _this;
    }
    /**
     * Add to collection
     * @param Object Model
     *
     * @return Object
     * */
    ButtonsView.prototype.addTo = function (model) {
        this.addToCollection(model);
    };
    /**
     * Add new object to collection
     * @param  Object  Model
     * @param  Object   Fragment collection
     *
     * @return Object Object created
     * */
    ButtonsView.prototype.addToCollection = function (model, fragmentEl) {
        var fragment = fragmentEl || null;
        var el = model.get('el');
        var view = new view_ButtonView({
            el: el,
            model: model,
        });
        var rendered = view.render().el;
        if (fragment) {
            fragment.appendChild(rendered);
        }
        else {
            this.$el.append(rendered);
        }
        return rendered;
    };
    ButtonsView.prototype.render = function () {
        var _this = this;
        var fragment = document.createDocumentFragment();
        this.$el.empty();
        this.collection.each(function (model) { return _this.addToCollection(model, fragment); });
        this.$el.append(fragment);
        this.$el.attr('class', (0,index_all.result)(this, 'className'));
        return this;
    };
    return ButtonsView;
}(abstract_ModuleView));
/* harmony default export */ const view_ButtonsView = (ButtonsView);

;// CONCATENATED MODULE: ./src/panels/view/PanelView.ts
var PanelView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PanelView_assign = (undefined && undefined.__assign) || function () {
    PanelView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PanelView_assign.apply(this, arguments);
};


var PanelView = /** @class */ (function (_super) {
    PanelView_extends(PanelView, _super);
    function PanelView(model) {
        var _this = _super.call(this, { model: model, el: model.get('el') }) || this;
        _this.className = _this.pfx + 'panel';
        _this.id = _this.pfx + model.get('id');
        _this.listenTo(model, 'change:appendContent', _this.appendContent);
        _this.listenTo(model, 'change:content', _this.updateContent);
        _this.listenTo(model, 'change:visible', _this.toggleVisible);
        model.view = _this;
        return _this;
    }
    /**
     * Append content of the panel
     * */
    PanelView.prototype.appendContent = function () {
        this.$el.append(this.model.get('appendContent'));
    };
    /**
     * Update content
     * */
    PanelView.prototype.updateContent = function () {
        this.$el.html(this.model.get('content'));
    };
    PanelView.prototype.toggleVisible = function () {
        if (!this.model.get('visible')) {
            this.$el.addClass("".concat(this.ppfx, "hidden"));
            return;
        }
        this.$el.removeClass("".concat(this.ppfx, "hidden"));
    };
    //@ts-ignore
    PanelView.prototype.attributes = function () {
        return this.model.get('attributes');
    };
    PanelView.prototype.initResize = function () {
        var em = this.em;
        var editor = em === null || em === void 0 ? void 0 : em.Editor;
        var resizable = this.model.get('resizable');
        if (editor && resizable) {
            var resz = resizable === true ? [true, true, true, true] : resizable;
            var resLen = resz.length;
            var tc = void 0, cr = void 0, bc = void 0, cl = false;
            // Choose which sides of the panel are resizable
            if (resLen == 2) {
                var resBools = resz;
                tc = resBools[0];
                bc = resBools[0];
                cr = resBools[1];
                cl = resBools[1];
            }
            else if (resLen == 4) {
                var resBools = resz;
                tc = resBools[0];
                cr = resBools[1];
                bc = resBools[2];
                cl = resBools[3];
            }
            var resizer_1 = new editor.Utils.Resizer(PanelView_assign({ tc: tc, cr: cr, bc: bc, cl: cl, tl: false, tr: false, bl: false, br: false, appendTo: this.el, silentFrames: true, avoidContainerUpdate: true, prefix: editor.getConfig().stylePrefix, onEnd: function () {
                    em && em.trigger('change:canvasOffset');
                }, posFetcher: function (el, _a) {
                    var target = _a.target;
                    var style = el.style;
                    var config = resizer_1.getConfig();
                    var keyWidth = config.keyWidth;
                    var keyHeight = config.keyHeight;
                    var rect = el.getBoundingClientRect();
                    var forContainer = target == 'container';
                    var styleWidth = style[keyWidth];
                    var styleHeight = style[keyHeight];
                    var width = styleWidth && !forContainer ? parseFloat(styleWidth) : rect.width;
                    var height = styleHeight && !forContainer ? parseFloat(styleHeight) : rect.height;
                    return {
                        left: 0,
                        top: 0,
                        width: width,
                        height: height,
                    };
                } }, (resizable && typeof resizable !== 'boolean' ? resizable : {})));
            resizer_1.blur = function () { };
            resizer_1.focus(this.el);
        }
    };
    PanelView.prototype.render = function () {
        var buttons = this.model.buttons;
        var $el = this.$el;
        var ppfx = this.ppfx;
        var cls = "".concat(this.className, " ").concat(this.id, " ").concat(ppfx, "one-bg ").concat(ppfx, "two-color");
        $el.addClass(cls);
        this.toggleVisible();
        if (buttons.length) {
            var buttonsView = new view_ButtonsView(buttons);
            $el.append(buttonsView.render().el);
        }
        $el.append(this.model.get('content'));
        return this;
    };
    return PanelView;
}(abstract_ModuleView));
/* harmony default export */ const view_PanelView = (PanelView);

;// CONCATENATED MODULE: ./src/panels/view/PanelsView.ts
var PanelsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PanelsView = /** @class */ (function (_super) {
    PanelsView_extends(PanelsView, _super);
    function PanelsView(target) {
        var _this = _super.call(this, { collection: target }) || this;
        _this.listenTo(target, 'add', _this.addTo);
        _this.listenTo(target, 'reset', _this.render);
        _this.listenTo(target, 'remove', _this.onRemove);
        _this.className = _this.pfx + 'panels';
        return _this;
    }
    PanelsView.prototype.onRemove = function (model) {
        var view = model.view;
        view && view.remove();
    };
    /**
     * Add to collection
     * @param Object Model
     *
     * @return Object
     * @private
     * */
    PanelsView.prototype.addTo = function (model) {
        this.addToCollection(model);
    };
    /**
     * Add new object to collection
     * @param  Object  Model
     * @param  Object   Fragment collection
     * @param  integer  Index of append
     *
     * @return Object Object created
     * @private
     * */
    PanelsView.prototype.addToCollection = function (model, fragmentEl) {
        var fragment = fragmentEl || null;
        var el = model.get('el');
        var view = new view_PanelView(model);
        var rendered = view.render().el;
        var appendTo = model.get('appendTo');
        // Do nothing if the panel was requested to be another element
        if (el) {
        }
        else if (appendTo) {
            var appendEl = document.querySelector(appendTo);
            appendEl === null || appendEl === void 0 ? void 0 : appendEl.appendChild(rendered);
        }
        else {
            if (fragment) {
                fragment.appendChild(rendered);
            }
            else {
                this.$el.append(rendered);
            }
        }
        view.initResize();
        return rendered;
    };
    PanelsView.prototype.render = function () {
        var _this = this;
        var $el = this.$el;
        var frag = document.createDocumentFragment();
        $el.empty();
        this.collection.each(function (model) { return _this.addToCollection(model, frag); });
        $el.append(frag);
        $el.attr('class', this.className);
        return this;
    };
    return PanelsView;
}(abstract_ModuleView));
/* harmony default export */ const view_PanelsView = (PanelsView);

;// CONCATENATED MODULE: ./src/panels/index.ts
var panels_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/panels/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  panels: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const panelManager = editor.Panels;
 * ```
 *
 * * [addPanel](#addpanel)
 * * [addButton](#addbutton)
 * * [getButton](#getbutton)
 * * [getPanel](#getpanel)
 * * [getPanels](#getpanels)
 * * [getPanelsEl](#getpanelsel)
 * * [removePanel](#removepanel)
 * * [removeButton](#removebutton)
 *
 * @module Panels
 */




var PanelManager = /** @class */ (function (_super) {
    panels_extends(PanelManager, _super);
    /**
     * Initialize module. Automatically called with a new instance of the editor
     * @param {Object} config Configurations
     * @private
     */
    function PanelManager(em) {
        var _this = _super.call(this, em, 'Panels', panels_config_config) || this;
        _this.panels = new model_Panels(_this, _this.config.defaults);
        for (var name in panels_config_config) {
            //@ts-ignore
            if (!(name in _this.config))
                _this.config[name] = panels_config_config[name];
        }
        return _this;
    }
    /**
     * Returns the collection of panels
     * @return {Collection} Collection of panel
     */
    PanelManager.prototype.getPanels = function () {
        return this.panels;
    };
    /**
     * Returns panels element
     * @return {HTMLElement}
     */
    PanelManager.prototype.getPanelsEl = function () {
        var _a;
        return (_a = this.PanelsViewObj) === null || _a === void 0 ? void 0 : _a.el;
    };
    /**
     * Add new panel to the collection
     * @param {Object|Panel} panel Object with right properties or an instance of Panel
     * @return {Panel} Added panel. Useful in case passed argument was an Object
     * @example
     * const newPanel = panelManager.addPanel({
     *  id: 'myNewPanel',
     *  visible: true,
     *  buttons: [...],
     * });
     */
    PanelManager.prototype.addPanel = function (panel) {
        return this.panels.add(panel);
    };
    /**
     * Remove a panel from the collection
     * @param {Panel|String} panel Panel instance or panel id
     * @return {Panel} Removed panel
     * @example
     * const somePanel = panelManager.getPanel('somePanel');
     * const removedPanel = panelManager.removePanel(somePanel);
     *
     * // or by id
     * const removedPanel = panelManager.removePanel('myNewPanel');
     *
     */
    PanelManager.prototype.removePanel = function (panel) {
        return this.panels.remove(panel);
    };
    /**
     * Get panel by ID
     * @param  {string} id Id string
     * @return {Panel|null}
     * @example
     * const myPanel = panelManager.getPanel('myPanel');
     */
    PanelManager.prototype.getPanel = function (id) {
        var res = this.panels.where({ id: id });
        return res.length ? res[0] : null;
    };
    /**
     * Add button to the panel
     * @param {string} panelId Panel's ID
     * @param {Object|Button} button Button object or instance of Button
     * @return {Button|null} Added button. Useful in case passed button was an Object
     * @example
     * const newButton = panelManager.addButton('myNewPanel',{
     *   id: 'myNewButton',
     *   className: 'someClass',
     *   command: 'someCommand',
     *   attributes: { title: 'Some title'},
     *   active: false,
     * });
     * // It's also possible to pass the command as an object
     * // with .run and .stop methods
     * ...
     * command: {
     *   run: function(editor) {
     *     ...
     *   },
     *   stop: function(editor) {
     *     ...
     *   }
     * },
     * // Or simply like a function which will be evaluated as a single .run command
     * ...
     * command: function(editor) {
     *   ...
     * }
     */
    PanelManager.prototype.addButton = function (panelId, button) {
        var pn = this.getPanel(panelId);
        return pn ? pn.buttons.add(button) : null;
    };
    /**
     * Remove button from the panel
     * @param {String} panelId Panel's ID
     * @param {String} buttonId Button's ID
     * @return {Button|null} Removed button.
     * @example
     * const removedButton = panelManager.addButton('myNewPanel',{
     *   id: 'myNewButton',
     *   className: 'someClass',
     *   command: 'someCommand',
     *   attributes: { title: 'Some title'},
     *   active: false,
     * });
     *
     * const removedButton = panelManager.removeButton('myNewPanel', 'myNewButton');
     *
     */
    PanelManager.prototype.removeButton = function (panelId, button) {
        var pn = this.getPanel(panelId);
        return pn && pn.buttons.remove(button);
    };
    /**
     * Get button from the panel
     * @param {string} panelId Panel's ID
     * @param {string} id Button's ID
     * @return {Button|null}
     * @example
     * const button = panelManager.getButton('myPanel', 'myButton');
     */
    PanelManager.prototype.getButton = function (panelId, id) {
        var pn = this.getPanel(panelId);
        if (pn) {
            var res = pn.buttons.where({ id: id });
            return res.length ? res[0] : null;
        }
        return null;
    };
    /**
     * Render panels and buttons
     * @return {HTMLElement}
     * @private
     */
    PanelManager.prototype.render = function () {
        var _a;
        (_a = this.PanelsViewObj) === null || _a === void 0 ? void 0 : _a.remove();
        this.PanelsViewObj = new view_PanelsView(this.panels);
        return this.PanelsViewObj.render().el;
    };
    /**
     * Active activable buttons
     * @private
     */
    PanelManager.prototype.active = function () {
        this.getPanels().each(function (p) {
            p.buttons.each(function (btn) {
                btn.get('active') && btn.trigger('updateActive');
            });
        });
    };
    /**
     * Disable buttons flagged as disabled
     * @private
     */
    PanelManager.prototype.disableButtons = function () {
        this.getPanels().each(function (p) {
            p.buttons.each(function (btn) {
                if (btn.get('disable'))
                    btn.trigger('change:disable');
            });
        });
    };
    PanelManager.prototype.destroy = function () {
        this.panels.reset();
        this.panels.stopListening();
        this.PanelsViewObj && this.PanelsViewObj.remove();
    };
    return PanelManager;
}(abstract_Module));
/* harmony default export */ const src_panels = (PanelManager);

;// CONCATENATED MODULE: ./src/code_manager/config/config.ts
var code_manager_config_config_config = {
    stylePrefix: 'cm-',
    optsCodeViewer: {},
};
/* harmony default export */ const code_manager_config_config = (code_manager_config_config_config);

;// CONCATENATED MODULE: ./src/code_manager/model/HtmlGenerator.ts
var HtmlGenerator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var HtmlGenerator_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};

var HTMLGenerator = /** @class */ (function (_super) {
    HtmlGenerator_extends(HTMLGenerator, _super);
    function HTMLGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HTMLGenerator.prototype.build = function (model, opts) {
        if (opts === void 0) { opts = {}; }
        var em = opts.em, restOpts = HtmlGenerator_rest(opts, ["em"]);
        var htmlOpts = restOpts;
        // Remove unnecessary IDs
        if (opts.cleanId && em) {
            var rules = em.Css.getAll();
            var idRules_1 = rules
                .toJSON()
                .map(function (rule) {
                var sels = rule.selectors;
                var sel = sels && sels.length === 1 && sels.models[0];
                return sel && sel.isId() && sel.get('name');
            })
                .filter(Boolean);
            if (!htmlOpts.attributes) {
                htmlOpts.attributes = function (mod, attrs) {
                    var id = attrs.id;
                    if (id &&
                        id[0] === 'i' && // all autogenerated IDs start with 'i'
                        !mod.get('script') && // if the component has script, we have to leave the ID
                        !mod.get('attributes').id && // id is not intentionally in attributes
                        idRules_1.indexOf(id) < 0 // we shouldn't have any rule with this ID
                    ) {
                        delete attrs.id;
                    }
                    return attrs;
                };
            }
        }
        return model.toHTML(htmlOpts);
    };
    return HTMLGenerator;
}(common/* Model */.Hn));
/* harmony default export */ const HtmlGenerator = (HTMLGenerator);

;// CONCATENATED MODULE: ./src/code_manager/model/JsonGenerator.ts
var JsonGenerator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var JsonGenerator = /** @class */ (function (_super) {
    JsonGenerator_extends(JsonGenerator, _super);
    function JsonGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonGenerator.prototype.build = function (model) {
        var _this = this;
        // @ts-ignore
        var json = model.toJSON();
        this.beforeEach(json);
        (0,index_all.each)(json, function (v, attr) {
            var obj = json[attr];
            if (obj instanceof common/* Model */.Hn) {
                // @ts-ignore
                json[attr] = _this.build(obj);
            }
            else if (obj instanceof common/* Collection */.FE) {
                var coll = obj;
                json[attr] = [];
                if (coll.length) {
                    coll.forEach(function (el, index) {
                        json[attr][index] = _this.build(el);
                    });
                }
            }
        });
        return json;
    };
    /**
     * Execute on each object
     * @param {Object} obj
     */
    JsonGenerator.prototype.beforeEach = function (obj) {
        delete obj.status;
    };
    return JsonGenerator;
}(common/* Model */.Hn));
/* harmony default export */ const model_JsonGenerator = (JsonGenerator);

;// CONCATENATED MODULE: ./src/code_manager/model/JsGenerator.ts
var JsGenerator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


function isFunctionEmpty(fn) {
    var _a;
    var content = ((_a = fn.toString().match(/\{([\s\S]*)\}/m)) === null || _a === void 0 ? void 0 : _a[1]) || ''; // content between first and last { }
    return content.replace(/^\s*\/\/.*$/gm, '').trim().length === 0; // remove comments
}
var JsGenerator = /** @class */ (function (_super) {
    JsGenerator_extends(JsGenerator, _super);
    function JsGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsGenerator.prototype.mapModel = function (model) {
        var _a;
        var _this = this;
        var code = '';
        var script = model.get('script-export') || model.get('script');
        var type = model.get('type');
        var comps = model.get('components');
        var id = model.getId();
        if (script) {
            // If the component has scripts we need to expose his ID
            var attr = model.get('attributes');
            attr = (0,index_all.extend)({}, attr, { id: id });
            model.set('attributes', attr, { silent: true });
            // @ts-ignore
            var scrStr = model.getScriptString(script);
            var scrProps = model.get('script-props');
            // If the script was updated, I'll put its code in a separate container
            if (model.get('scriptUpdated') && !scrProps) {
                this.mapJs[type + '-' + id] = { ids: [id], code: scrStr };
            }
            else {
                var props = void 0;
                var mapType = this.mapJs[type];
                if (scrProps) {
                    props = model.__getScriptProps();
                }
                if (mapType) {
                    mapType.ids.push(id);
                    if (props)
                        mapType.props[id] = props;
                }
                else {
                    var res = { ids: [id], code: scrStr };
                    if (props)
                        res.props = (_a = {}, _a[id] = props, _a);
                    this.mapJs[type] = res;
                }
            }
        }
        comps.forEach(function (model) {
            code += _this.mapModel(model);
        });
        return code;
    };
    JsGenerator.prototype.build = function (model) {
        this.mapJs = {};
        this.mapModel(model);
        var code = '';
        for (var type in this.mapJs) {
            var mapType = this.mapJs[type];
            if (!mapType.code) {
                continue;
            }
            if (mapType.props) {
                if (isFunctionEmpty(mapType.code)) {
                    continue;
                }
                code += "\n          var props = ".concat(JSON.stringify(mapType.props), ";\n          var ids = Object.keys(props).map(function(id) { return '#'+id }).join(',');\n          var els = document.querySelectorAll(ids);\n          for (var i = 0, len = els.length; i < len; i++) {\n            var el = els[i];\n            (").concat(mapType.code, ".bind(el))(props[el.id]);\n          }");
            }
            else {
                // Deprecated
                var ids = '#' + mapType.ids.join(', #');
                code += "\n          var items = document.querySelectorAll('".concat(ids, "');\n          for (var i = 0, len = items.length; i < len; i++) {\n            (function(){\n").concat(mapType.code, "\n}.bind(items[i]))();\n          }");
            }
        }
        return code;
    };
    return JsGenerator;
}(common/* Model */.Hn));
/* harmony default export */ const model_JsGenerator = (JsGenerator);

;// CONCATENATED MODULE: ./src/code_manager/view/EditorView.ts
var EditorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var EditorView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


var CodeEditorView = /** @class */ (function (_super) {
    EditorView_extends(CodeEditorView, _super);
    function CodeEditorView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CodeEditorView.prototype.template = function (_a) {
        var pfx = _a.pfx, codeName = _a.codeName, label = _a.label;
        return html(EditorView_templateObject_1 || (EditorView_templateObject_1 = EditorView_makeTemplateObject(["\n      <div class=\"", "editor\" id=\"", "", "\">\n        <div id=\"", "title\">", "</div>\n        <div id=\"", "code\"></div>\n      </div>\n    "], ["\n      <div class=\"", "editor\" id=\"", "", "\">\n        <div id=\"", "title\">", "</div>\n        <div id=\"", "code\"></div>\n      </div>\n    "])), pfx, pfx, codeName, pfx, label, pfx);
    };
    CodeEditorView.prototype.initialize = function (o) {
        this.config = o.config || {};
        this.pfx = this.config.stylePrefix;
    };
    CodeEditorView.prototype.render = function () {
        var _a, _b;
        var _c = this, model = _c.model, pfx = _c.pfx, $el = _c.$el;
        var obj = model.toJSON();
        var toAppend = model.get('input') || ((_b = (_a = model).getElement) === null || _b === void 0 ? void 0 : _b.call(_a));
        obj.pfx = pfx;
        $el.html(this.template(obj));
        $el.attr('class', "".concat(pfx, "editor-c"));
        $el.find("#".concat(pfx, "code")).append(toAppend);
        return this;
    };
    return CodeEditorView;
}(common/* View */.G7));
/* harmony default export */ const view_EditorView = (CodeEditorView);
var EditorView_templateObject_1;

;// CONCATENATED MODULE: ./src/code_manager/index.ts
var code_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var code_manager_assign = (undefined && undefined.__assign) || function () {
    code_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return code_manager_assign.apply(this, arguments);
};
/**
 * - [addGenerator](#addgenerator)
 * - [getGenerator](#getgenerator)
 * - [getGenerators](#getgenerators)
 * - [addViewer](#addviewer)
 * - [getViewer](#getviewer)
 * - [getViewers](#getviewers)
 * - [updateViewer](#updateviewer)
 * - [getCode](#getcode)
 *
 *
 * Before using methods you should get first the module from the editor instance, in this way:
 *
 * ```js
 * var codeManager = editor.CodeManager;
 * ```
 *
 * @module CodeManager
 */









var defaultViewer = 'CodeMirror';
var CodeManagerModule = /** @class */ (function (_super) {
    code_manager_extends(CodeManagerModule, _super);
    function CodeManagerModule(em) {
        var _this = _super.call(this, em, 'CodeManager', code_manager_config_config) || this;
        _this.EditorView = view_EditorView;
        var config = _this.config;
        var ppfx = config.pStylePrefix;
        if (ppfx)
            config.stylePrefix = ppfx + config.stylePrefix;
        _this.generators = {};
        _this.viewers = {};
        _this.defGenerators = {
            html: new HtmlGenerator(),
            css: new model_CssGenerator(),
            json: new model_JsonGenerator(),
            js: new model_JsGenerator(),
        };
        _this.defViewers = { CodeMirror: new model_CodeMirrorEditor() };
        _this.loadDefaultGenerators().loadDefaultViewers();
        return _this;
    }
    /**
     * Add new code generator to the collection
     * @param  {string} id Code generator ID
     * @param  {Object} generator Code generator wrapper
     * @param {Function} generator.build Function that builds the code
     * @return {this}
     * @example
     * codeManager.addGenerator('html7',{
     *   build: function(model){
     *    return 'myCode';
     *   }
     * });
     * */
    CodeManagerModule.prototype.addGenerator = function (id, generator) {
        this.generators[id] = generator;
        return this;
    };
    /**
     * Get code generator by id
     * @param  {string} id Code generator ID
     * @return {Object|null}
     * @example
     * var generator = codeManager.getGenerator('html7');
     * generator.build = function(model){
     *   //extend
     * };
     * */
    CodeManagerModule.prototype.getGenerator = function (id) {
        return this.generators[id];
    };
    /**
     * Returns all code generators
     * @return {Array<Object>}
     * */
    CodeManagerModule.prototype.getGenerators = function () {
        return this.generators;
    };
    /**
     * Add new code viewer
     * @param  {string} id Code viewer ID
     * @param  {Object} viewer Code viewer wrapper
     * @param {Function} viewer.init Set element on which viewer will be displayed
     * @param {Function} viewer.setContent Set content to the viewer
     * @return {this}
     * @example
     * codeManager.addViewer('ace',{
     *   init: function(el){
     *     var ace = require('ace-editor');
     *     this.editor  = ace.edit(el.id);
     *   },
     *   setContent: function(code){
     *    this.editor.setValue(code);
     *   }
     * });
     * */
    CodeManagerModule.prototype.addViewer = function (id, viewer) {
        this.viewers[id] = viewer;
        return this;
    };
    /**
     * Get code viewer by id
     * @param  {string} id Code viewer ID
     * @return {Object|null}
     * @example
     * var viewer = codeManager.getViewer('ace');
     * */
    CodeManagerModule.prototype.getViewer = function (id) {
        return this.viewers[id];
    };
    /**
     * Returns all code viewers
     * @return {Array<Object>}
     * */
    CodeManagerModule.prototype.getViewers = function () {
        return this.viewers;
    };
    CodeManagerModule.prototype.createViewer = function (opts) {
        if (opts === void 0) { opts = {}; }
        var type = !(0,index_all.isUndefined)(opts.type) ? opts.type : defaultViewer;
        var viewer = this.getViewer(type) && this.getViewer(type).clone();
        var cont = document.createElement('div');
        var txtarea = document.createElement('textarea');
        cont.appendChild(txtarea);
        viewer.set(code_manager_assign(code_manager_assign({}, this.config.optsCodeViewer), opts));
        viewer.init(txtarea);
        viewer.setElement(cont);
        return viewer;
    };
    /**
     * Update code viewer content
     * @param  {Object} viewer Viewer instance
     * @param  {string} code  Code string
     * @example
     * var AceViewer = codeManager.getViewer('ace');
     * // ...
     * var viewer = AceViewer.init(el);
     * // ...
     * codeManager.updateViewer(AceViewer, 'code');
     * */
    CodeManagerModule.prototype.updateViewer = function (viewer, code) {
        viewer.setContent(code);
    };
    /**
     * Get code from model
     * @param  {Object} model Any kind of model that will be passed to the build method of generator
     * @param  {string} genId Code generator id
     * @param  {Object} [opt] Options
     * @return {string}
     * @example
     * var codeStr = codeManager.getCode(model, 'html');
     * */
    CodeManagerModule.prototype.getCode = function (model, genId, opt) {
        if (opt === void 0) { opt = {}; }
        opt.em = this.em;
        var generator = this.getGenerator(genId);
        return generator ? generator.build(model, opt) : '';
    };
    /**
     * Load default code generators
     * @return {this}
     * @private
     * */
    CodeManagerModule.prototype.loadDefaultGenerators = function () {
        for (var id in this.defGenerators) {
            this.addGenerator(id, this.defGenerators[id]);
        }
        return this;
    };
    /**
     * Load default code viewers
     * @return {this}
     * @private
     * */
    CodeManagerModule.prototype.loadDefaultViewers = function () {
        for (var id in this.defViewers) {
            this.addViewer(id, this.defViewers[id]);
        }
        return this;
    };
    CodeManagerModule.prototype.destroy = function () { };
    return CodeManagerModule;
}(abstract_Module));
/* harmony default export */ const code_manager = (CodeManagerModule);

// EXTERNAL MODULE: ./node_modules/backbone-undo/Backbone.Undo.js
var Backbone_Undo = __webpack_require__(410);
var Backbone_Undo_default = /*#__PURE__*/__webpack_require__.n(Backbone_Undo);
;// CONCATENATED MODULE: ./src/undo_manager/config.ts
var undo_manager_config_config = {
    maximumStackLength: 500,
    trackSelection: true,
};
/* harmony default export */ const undo_manager_config = (undo_manager_config_config);

;// CONCATENATED MODULE: ./src/undo_manager/index.ts
var undo_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var undo_manager_assign = (undefined && undefined.__assign) || function () {
    undo_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return undo_manager_assign.apply(this, arguments);
};
var undo_manager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
/**
 * This module allows to manage the stack of changes applied in canvas.
 * Once the editor is instantiated you can use its API. Before using these methods you should get the module from the instance
 *
 * ```js
 * const um = editor.UndoManager;
 * ```
 *
 * * [getConfig](#getconfig)
 * * [add](#add)
 * * [remove](#remove)
 * * [removeAll](#removeall)
 * * [start](#start)
 * * [stop](#stop)
 * * [undo](#undo)
 * * [undoAll](#undoall)
 * * [redo](#redo)
 * * [redoAll](#redoall)
 * * [hasUndo](#hasundo)
 * * [hasRedo](#hasredo)
 * * [getStack](#getstack)
 * * [clear](#clear)
 *
 * @module UndoManager
 */
// @ts-ignore




var hasSkip = function (opts) { return opts.avoidStore || opts.noUndo; };
var getChanged = function (obj) { return Object.keys(obj.changedAttributes()); };
var UndoManagerModule = /** @class */ (function (_super) {
    undo_manager_extends(UndoManagerModule, _super);
    function UndoManagerModule(em) {
        var _this = _super.call(this, em, 'UndoManager', undo_manager_config) || this;
        if (_this.config._disable) {
            _this.config.maximumStackLength = 0;
        }
        var fromUndo = true;
        _this.um = new (Backbone_Undo_default())(undo_manager_assign({ track: true, register: [] }, _this.config));
        _this.um.changeUndoType('change', {
            condition: function (object) {
                var hasUndo = object.get('_undo');
                if (hasUndo) {
                    var undoExc_1 = object.get('_undoexc');
                    if ((0,index_all.isArray)(undoExc_1)) {
                        if (getChanged(object).some(function (chn) { return undoExc_1.indexOf(chn) >= 0; }))
                            return false;
                    }
                    if ((0,index_all.isBoolean)(hasUndo))
                        return true;
                    if ((0,index_all.isArray)(hasUndo)) {
                        if (getChanged(object).some(function (chn) { return hasUndo.indexOf(chn) >= 0; }))
                            return true;
                    }
                }
                return false;
            },
            on: function (object, v, opts) {
                var _this = this;
                !this.beforeCache && (this.beforeCache = object.previousAttributes());
                var opt = opts || v || {};
                opt.noUndo &&
                    setTimeout(function () {
                        _this.beforeCache = null;
                    });
                if (hasSkip(opt)) {
                    return;
                }
                else {
                    var after = object.toJSON({ fromUndo: fromUndo });
                    var result = {
                        object: object,
                        before: this.beforeCache,
                        after: after,
                    };
                    this.beforeCache = null;
                    // Skip undo in case of empty changes
                    if ((0,index_all.isEmpty)(after))
                        return;
                    return result;
                }
            },
        });
        _this.um.changeUndoType('add', {
            on: function (model, collection, options) {
                if (options === void 0) { options = {}; }
                if (hasSkip(options) || !_this.isRegistered(collection))
                    return;
                return {
                    object: collection,
                    before: undefined,
                    after: model,
                    options: undo_manager_assign(undo_manager_assign({}, options), { fromUndo: fromUndo }),
                };
            },
        });
        _this.um.changeUndoType('remove', {
            on: function (model, collection, options) {
                if (options === void 0) { options = {}; }
                if (hasSkip(options) || !_this.isRegistered(collection))
                    return;
                return {
                    object: collection,
                    before: model,
                    after: undefined,
                    options: undo_manager_assign(undo_manager_assign({}, options), { fromUndo: fromUndo }),
                };
            },
        });
        _this.um.changeUndoType('reset', {
            undo: function (collection, before) {
                collection.reset(before, { fromUndo: fromUndo });
            },
            redo: function (collection, b, after) {
                collection.reset(after, { fromUndo: fromUndo });
            },
            on: function (collection, options) {
                if (options === void 0) { options = {}; }
                if (hasSkip(options) || !_this.isRegistered(collection))
                    return;
                return {
                    object: collection,
                    before: options.previousModels,
                    after: undo_manager_spreadArray([], collection.models, true),
                    options: undo_manager_assign(undo_manager_assign({}, options), { fromUndo: fromUndo }),
                };
            },
        });
        _this.um.on('undo redo', function () {
            em.trigger('change:canvasOffset');
            em.getSelectedAll().map(function (c) { return c.trigger('rerender:layer'); });
        });
        ['undo', 'redo'].forEach(function (ev) { return _this.um.on(ev, function () { return em.trigger(ev); }); });
        return _this;
    }
    UndoManagerModule.prototype.postLoad = function () {
        var _a = this, config = _a.config, em = _a.em;
        config.trackSelection && em && this.add(em.get('selected'));
    };
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Add an entity (Model/Collection) to track
     * Note: New Components and CSSRules will be added automatically
     * @param {Model|Collection} entity Entity to track
     * @return {this}
     * @example
     * um.add(someModelOrCollection);
     */
    UndoManagerModule.prototype.add = function (entity) {
        this.um.register(entity);
        return this;
    };
    /**
     * Remove and stop tracking the entity (Model/Collection)
     * @param {Model|Collection} entity Entity to remove
     * @return {this}
     * @example
     * um.remove(someModelOrCollection);
     */
    UndoManagerModule.prototype.remove = function (entity) {
        this.um.unregister(entity);
        return this;
    };
    /**
     * Remove all entities
     * @return {this}
     * @example
     * um.removeAll();
     */
    UndoManagerModule.prototype.removeAll = function () {
        this.um.unregisterAll();
        return this;
    };
    /**
     * Start/resume tracking changes
     * @return {this}
     * @example
     * um.start();
     */
    UndoManagerModule.prototype.start = function () {
        this.um.startTracking();
        return this;
    };
    /**
     * Stop tracking changes
     * @return {this}
     * @example
     * um.stop();
     */
    UndoManagerModule.prototype.stop = function () {
        this.um.stopTracking();
        return this;
    };
    /**
     * Undo last change
     * @return {this}
     * @example
     * um.undo();
     */
    UndoManagerModule.prototype.undo = function (all) {
        if (all === void 0) { all = true; }
        var _a = this, em = _a.em, um = _a.um;
        !em.isEditing() && um.undo(all);
        return this;
    };
    /**
     * Undo all changes
     * @return {this}
     * @example
     * um.undoAll();
     */
    UndoManagerModule.prototype.undoAll = function () {
        this.um.undoAll();
        return this;
    };
    /**
     * Redo last change
     * @return {this}
     * @example
     * um.redo();
     */
    UndoManagerModule.prototype.redo = function (all) {
        if (all === void 0) { all = true; }
        var _a = this, em = _a.em, um = _a.um;
        !em.isEditing() && um.redo(all);
        return this;
    };
    /**
     * Redo all changes
     * @return {this}
     * @example
     * um.redoAll();
     */
    UndoManagerModule.prototype.redoAll = function () {
        this.um.redoAll();
        return this;
    };
    /**
     * Checks if exists an available undo
     * @return {Boolean}
     * @example
     * um.hasUndo();
     */
    UndoManagerModule.prototype.hasUndo = function () {
        return !!this.um.isAvailable('undo');
    };
    /**
     * Checks if exists an available redo
     * @return {Boolean}
     * @example
     * um.hasRedo();
     */
    UndoManagerModule.prototype.hasRedo = function () {
        return !!this.um.isAvailable('redo');
    };
    /**
     * Check if the entity (Model/Collection) to tracked
     * Note: New Components and CSSRules will be added automatically
     * @param {Model|Collection} entity Entity to track
     * @returns {Boolean}
     */
    UndoManagerModule.prototype.isRegistered = function (obj) {
        return !!this.getInstance().objectRegistry.isRegistered(obj);
    };
    /**
     * Get stack of changes
     * @return {Collection}
     * @example
     * const stack = um.getStack();
     * stack.each(item => ...);
     */
    UndoManagerModule.prototype.getStack = function () {
        return this.um.stack;
    };
    /**
     * Get grouped undo manager stack.
     * The difference between `getStack` is when you do multiple operations at a time,
     * like appending multiple components:
     * `editor.getWrapper().append('<div>C1</div><div>C2</div>');`
     * `getStack` will return a collection length of 2.
     *  `getStackGroup` instead will group them as a single operation (the first
     * inserted component will be returned in the list) by returning an array length of 1.
     * @return {Array}
     * @private
     */
    UndoManagerModule.prototype.getStackGroup = function () {
        var result = [];
        var inserted = [];
        this.getStack().forEach(function (item) {
            var index = item.get('magicFusionIndex');
            if (inserted.indexOf(index) < 0) {
                inserted.push(index);
                result.push(item);
            }
        });
        return result;
    };
    UndoManagerModule.prototype.skip = function (clb) {
        var isTracking = !!this.um.isTracking();
        isTracking && this.stop();
        clb();
        isTracking && this.start();
    };
    UndoManagerModule.prototype.getGroupedStack = function () {
        var result = {};
        var stack = this.getStack();
        var createItem = function (item, index) {
            var _a = item.attributes, type = _a.type, after = _a.after, before = _a.before, object = _a.object, _b = _a.options, options = _b === void 0 ? {} : _b;
            return { index: index, type: type, after: after, before: before, object: object, options: options };
        };
        stack.forEach(function (item, i) {
            var index = item.get('magicFusionIndex');
            var value = createItem(item, i);
            if (!result[index]) {
                result[index] = [value];
            }
            else {
                result[index].push(value);
            }
        });
        return Object.keys(result).map(function (index) {
            var actions = result[index];
            return {
                index: actions[actions.length - 1].index,
                actions: actions,
                labels: (0,index_all.unique)(actions.reduce(function (res, item) {
                    var _a;
                    var label = (_a = item.options) === null || _a === void 0 ? void 0 : _a.action;
                    label && res.push(label);
                    return res;
                }, [])),
            };
        });
    };
    UndoManagerModule.prototype.goToGroup = function (group) {
        var _this = this;
        if (!group)
            return;
        var current = this.getPointer();
        var goTo = group.index - current;
        (0,index_all.times)(Math.abs(goTo), function () {
            _this[goTo < 0 ? 'undo' : 'redo'](false);
        });
    };
    UndoManagerModule.prototype.getPointer = function () {
        // @ts-ignore
        return this.getStack().pointer;
    };
    /**
     * Clear the stack
     * @return {this}
     * @example
     * um.clear();
     */
    UndoManagerModule.prototype.clear = function () {
        this.um.clear();
        return this;
    };
    UndoManagerModule.prototype.getInstance = function () {
        return this.um;
    };
    UndoManagerModule.prototype.destroy = function () {
        this.clear().removeAll();
    };
    return UndoManagerModule;
}(abstract_Module));
/* harmony default export */ const undo_manager = (UndoManagerModule);

;// CONCATENATED MODULE: ./src/rich_text_editor/config/config.ts
var rich_text_editor_config_config_config = {
    stylePrefix: 'rte-',
    adjustToolbar: true,
    actions: ['bold', 'italic', 'underline', 'strikethrough', 'link', 'wrap'],
    custom: false,
};
/* harmony default export */ const rich_text_editor_config_config = (rich_text_editor_config_config_config);

;// CONCATENATED MODULE: ./src/rich_text_editor/model/RichTextEditor.ts
// The initial version of this RTE was borrowed from https://github.com/jaredreich/pell
// and adapted to the GrapesJS's need
var RichTextEditor_assign = (undefined && undefined.__assign) || function () {
    RichTextEditor_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return RichTextEditor_assign.apply(this, arguments);
};



var RichTextEditorActionState;
(function (RichTextEditorActionState) {
    RichTextEditorActionState[RichTextEditorActionState["ACTIVE"] = 1] = "ACTIVE";
    RichTextEditorActionState[RichTextEditorActionState["INACTIVE"] = 0] = "INACTIVE";
    RichTextEditorActionState[RichTextEditorActionState["DISABLED"] = -1] = "DISABLED";
})(RichTextEditorActionState || (RichTextEditorActionState = {}));
var RTE_KEY = '_rte';
var btnState = {
    ACTIVE: 1,
    INACTIVE: 0,
    DISABLED: -1,
};
var isValidTag = function (rte, tagName) {
    if (tagName === void 0) { tagName = 'A'; }
    var _a = rte.selection() || {}, anchorNode = _a.anchorNode, focusNode = _a.focusNode;
    var parentAnchor = anchorNode === null || anchorNode === void 0 ? void 0 : anchorNode.parentNode;
    var parentFocus = focusNode === null || focusNode === void 0 ? void 0 : focusNode.parentNode;
    return (parentAnchor === null || parentAnchor === void 0 ? void 0 : parentAnchor.nodeName) == tagName || (parentFocus === null || parentFocus === void 0 ? void 0 : parentFocus.nodeName) == tagName;
};
var customElAttr = 'data-selectme';
var defActions = {
    bold: {
        name: 'bold',
        icon: '<b>B</b>',
        attributes: { title: 'Bold' },
        result: function (rte) { return rte.exec('bold'); },
    },
    italic: {
        name: 'italic',
        icon: '<i>I</i>',
        attributes: { title: 'Italic' },
        result: function (rte) { return rte.exec('italic'); },
    },
    underline: {
        name: 'underline',
        icon: '<u>U</u>',
        attributes: { title: 'Underline' },
        result: function (rte) { return rte.exec('underline'); },
    },
    strikethrough: {
        name: 'strikethrough',
        icon: '<s>S</s>',
        attributes: { title: 'Strike-through' },
        result: function (rte) { return rte.exec('strikeThrough'); },
    },
    link: {
        icon: "<svg viewBox=\"0 0 24 24\">\n          <path fill=\"currentColor\" d=\"M3.9,12C3.9,10.29 5.29,8.9 7,8.9H11V7H7A5,5 0 0,0 2,12A5,5 0 0,0 7,17H11V15.1H7C5.29,15.1 3.9,13.71 3.9,12M8,13H16V11H8V13M17,7H13V8.9H17C18.71,8.9 20.1,10.29 20.1,12C20.1,13.71 18.71,15.1 17,15.1H13V17H17A5,5 0 0,0 22,12A5,5 0 0,0 17,7Z\" />\n        </svg>",
        name: 'link',
        attributes: {
            style: 'font-size:1.4rem;padding:0 4px 2px;',
            title: 'Link',
        },
        state: function (rte) {
            return rte && rte.selection() && isValidTag(rte) ? btnState.ACTIVE : btnState.INACTIVE;
        },
        result: function (rte) {
            if (isValidTag(rte)) {
                rte.exec('unlink');
            }
            else {
                rte.insertHTML("<a href=\"\" ".concat(customElAttr, ">").concat(rte.selection(), "</a>"), {
                    select: true,
                });
            }
        },
    },
    wrap: {
        name: 'wrap',
        icon: "<svg viewBox=\"0 0 24 24\">\n            <path fill=\"currentColor\" d=\"M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z\" />\n        </svg>",
        attributes: { title: 'Wrap for style' },
        state: function (rte) {
            return (rte === null || rte === void 0 ? void 0 : rte.selection()) && isValidTag(rte, 'SPAN') ? btnState.DISABLED : btnState.INACTIVE;
        },
        result: function (rte) {
            !isValidTag(rte, 'SPAN') &&
                rte.insertHTML("<span ".concat(customElAttr, ">").concat(rte.selection(), "</span>"), {
                    select: true,
                });
        },
    },
};
var RichTextEditor = /** @class */ (function () {
    function RichTextEditor(em, el, settings) {
        if (settings === void 0) { settings = {}; }
        var _this = this;
        this.em = em;
        this.settings = settings;
        if (el[RTE_KEY]) {
            return el[RTE_KEY];
        }
        el[RTE_KEY] = this;
        this.setEl(el);
        this.updateActiveActions = this.updateActiveActions.bind(this);
        this.__onKeydown = this.__onKeydown.bind(this);
        this.__onPaste = this.__onPaste.bind(this);
        var acts = (settings.actions || []).map(function (action) {
            var result = action;
            if ((0,index_all.isString)(action)) {
                result = RichTextEditor_assign({}, defActions[action]);
            }
            else if (defActions[action.name]) {
                result = RichTextEditor_assign(RichTextEditor_assign({}, defActions[action.name]), action);
            }
            return result;
        });
        var actions = acts.length ? acts : Object.keys(defActions).map(function (a) { return defActions[a]; });
        settings.classes = RichTextEditor_assign({ actionbar: 'actionbar', button: 'action', active: 'active', disabled: 'disabled', inactive: 'inactive' }, settings.classes);
        var classes = settings.classes;
        var actionbar = settings.actionbar;
        this.actionbar = actionbar;
        this.classes = classes;
        this.actions = actions;
        if (!actionbar) {
            if (!this.isCustom(settings.module)) {
                var actionbarCont = settings.actionbarContainer;
                actionbar = document.createElement('div');
                actionbar.className = classes.actionbar;
                actionbarCont === null || actionbarCont === void 0 ? void 0 : actionbarCont.appendChild(actionbar);
                this.actionbar = actionbar;
            }
            actions.forEach(function (action) { return _this.addAction(action); });
        }
        settings.styleWithCSS && this.exec('styleWithCSS');
        return this;
    }
    RichTextEditor.prototype.isCustom = function (module) {
        var rte = module || this.em.RichTextEditor;
        return !!((rte === null || rte === void 0 ? void 0 : rte.config.custom) || (rte === null || rte === void 0 ? void 0 : rte.customRte));
    };
    RichTextEditor.prototype.destroy = function () { };
    RichTextEditor.prototype.setEl = function (el) {
        this.el = el;
        this.doc = el.ownerDocument;
    };
    RichTextEditor.prototype.updateActiveActions = function () {
        var _this = this;
        var actions = this.getActions();
        actions.forEach(function (action) {
            var update = action.update, btn = action.btn;
            var _a = _this.classes, active = _a.active, inactive = _a.inactive, disabled = _a.disabled;
            var state = action.state;
            var name = action.name;
            var doc = _this.doc;
            var currentState = RichTextEditorActionState.INACTIVE;
            if (btn) {
                btn.className = btn.className.replace(active, '').trim();
                btn.className = btn.className.replace(inactive, '').trim();
                btn.className = btn.className.replace(disabled, '').trim();
            }
            // if there is a state function, which depicts the state,
            // i.e. `active`, `disabled`, then call it
            if (state) {
                var newState = state(_this, doc);
                currentState = newState;
                if (btn) {
                    switch (newState) {
                        case btnState.ACTIVE:
                            btn.className += " ".concat(active);
                            break;
                        case btnState.INACTIVE:
                            btn.className += " ".concat(inactive);
                            break;
                        case btnState.DISABLED:
                            btn.className += " ".concat(disabled);
                            break;
                    }
                }
            }
            else {
                // otherwise default to checking if the name command is supported & enabled
                if (doc.queryCommandSupported(name) && doc.queryCommandState(name)) {
                    btn && (btn.className += " ".concat(active));
                    currentState = RichTextEditorActionState.ACTIVE;
                }
            }
            action.currentState = currentState;
            update === null || update === void 0 ? void 0 : update(_this, action);
        });
        actions.length && this.em.RichTextEditor.__dbdTrgCustom();
    };
    RichTextEditor.prototype.enable = function (opts) {
        if (this.enabled)
            return this;
        return this.__toggleEffects(true, opts);
    };
    RichTextEditor.prototype.disable = function () {
        return this.__toggleEffects(false);
    };
    RichTextEditor.prototype.__toggleEffects = function (enable, opts) {
        if (enable === void 0) { enable = false; }
        if (opts === void 0) { opts = {}; }
        var method = enable ? dom.on : dom/* off */.S1;
        var _a = this, el = _a.el, doc = _a.doc;
        var actionbar = this.actionbarEl();
        actionbar && (actionbar.style.display = enable ? '' : 'none');
        el.contentEditable = "".concat(!!enable);
        method(el, 'mouseup keyup', this.updateActiveActions);
        method(doc, 'keydown', this.__onKeydown);
        method(doc, 'paste', this.__onPaste);
        this.enabled = enable;
        if (enable) {
            var event_1 = opts.event;
            this.syncActions();
            this.updateActiveActions();
            if (event_1) {
                var range = null;
                if (doc.caretRangeFromPoint) {
                    var poiner = (0,dom/* getPointerEvent */.VB)(event_1);
                    range = doc.caretRangeFromPoint(poiner.clientX, poiner.clientY);
                    // @ts-ignore
                }
                else if (event_1.rangeParent) {
                    range = doc.createRange();
                    // @ts-ignore
                    range.setStart(event_1.rangeParent, event_1.rangeOffset);
                }
                var sel = doc.getSelection();
                sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
                range && (sel === null || sel === void 0 ? void 0 : sel.addRange(range));
            }
            el.focus();
        }
        return this;
    };
    RichTextEditor.prototype.__onKeydown = function (event) {
        var ev = event;
        var doc = this.doc;
        var cmdList = ['insertOrderedList', 'insertUnorderedList'];
        if (ev.key === 'Enter' && !cmdList.some(function (cmd) { return doc.queryCommandState(cmd); })) {
            doc.execCommand('insertLineBreak');
            ev.preventDefault();
        }
    };
    RichTextEditor.prototype.__onPaste = function (ev) {
        // @ts-ignore
        var clipboardData = ev.clipboardData || window.clipboardData;
        var text = clipboardData.getData('text');
        var textHtml = clipboardData.getData('text/html');
        // Replace \n with <br> in case of plain text
        if (text && !textHtml) {
            ev.preventDefault();
            var html = text.replace(/(?:\r\n|\r|\n)/g, '<br/>');
            this.doc.execCommand('insertHTML', false, html);
        }
    };
    /**
     * Sync actions with the current RTE
     */
    RichTextEditor.prototype.syncActions = function () {
        var _this = this;
        this.getActions().forEach(function (action) {
            if (_this.actionbar) {
                if (!action.state || (action.state && action.state(_this, _this.doc) >= 0)) {
                    var event_2 = action.event || 'click';
                    var btn = action.btn;
                    if (btn) {
                        btn["on".concat(event_2)] = function () {
                            action.result(_this, action);
                            _this.updateActiveActions();
                        };
                    }
                }
            }
        });
    };
    /**
     * Add new action to the actionbar
     * @param {Object} action
     * @param {Object} [opts={}]
     */
    RichTextEditor.prototype.addAction = function (action, opts) {
        if (opts === void 0) { opts = {}; }
        var sync = opts.sync;
        var actionbar = this.actionbarEl();
        if (actionbar) {
            var icon = action.icon, _a = action.attributes, attr = _a === void 0 ? {} : _a;
            var btn = document.createElement('span');
            btn.className = this.classes.button;
            action.btn = btn;
            for (var key in attr) {
                btn.setAttribute(key, attr[key]);
            }
            if (typeof icon == 'string') {
                btn.innerHTML = icon;
            }
            else {
                btn.appendChild(icon);
            }
            actionbar.appendChild(btn);
        }
        if (sync) {
            this.actions.push(action);
            this.syncActions();
        }
    };
    /**
     * Get the array of current actions
     * @return {Array}
     */
    RichTextEditor.prototype.getActions = function () {
        return this.actions;
    };
    /**
     * Returns the Selection instance
     * @return {Selection}
     */
    RichTextEditor.prototype.selection = function () {
        return this.doc.getSelection();
    };
    /**
     * Wrapper around [execCommand](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand) to allow
     * you to perform operations like `insertText`
     * @param  {string} command Command name
     * @param  {any} [value=null Command's arguments
     */
    RichTextEditor.prototype.exec = function (command, value) {
        this.doc.execCommand(command, false, value);
    };
    /**
     * Get the actionbar element
     * @return {HTMLElement}
     */
    RichTextEditor.prototype.actionbarEl = function () {
        return this.actionbar;
    };
    /**
     * Set custom HTML to the selection, useful as the default 'insertHTML' command
     * doesn't work in the same way on all browsers
     * @param  {string} value HTML string
     */
    RichTextEditor.prototype.insertHTML = function (value, _a) {
        var _b = _a === void 0 ? {} : _a, select = _b.select;
        var _c = this, em = _c.em, doc = _c.doc, el = _c.el;
        var sel = doc.getSelection();
        if (sel && sel.rangeCount) {
            var model_1 = (0,mixins.getComponentModel)(el) || em.getSelected();
            var node = doc.createElement('div');
            var range_1 = sel.getRangeAt(0);
            range_1.deleteContents();
            if ((0,index_all.isString)(value)) {
                node.innerHTML = value;
            }
            else if (value) {
                node.appendChild(value);
            }
            Array.prototype.slice.call(node.childNodes).forEach(function (nd) {
                range_1.insertNode(nd);
            });
            sel.removeAllRanges();
            sel.addRange(range_1);
            el.focus();
            if (select && model_1) {
                model_1.once('rte:disable', function () {
                    var toSel = model_1.find("[".concat(customElAttr, "]"))[0];
                    if (!toSel)
                        return;
                    em.setSelected(toSel);
                    toSel.removeAttributes(customElAttr);
                });
                model_1.trigger('disable');
            }
        }
    };
    return RichTextEditor;
}());
/* harmony default export */ const model_RichTextEditor = (RichTextEditor);

;// CONCATENATED MODULE: ./src/rich_text_editor/index.ts
/**
 * This module allows to customize the built-in toolbar of the Rich Text Editor and use commands from the [HTML Editing APIs](https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand).
 * It's highly recommended to keep this toolbar as small as possible, especially from styling commands (eg. 'fontSize') and leave this task to the Style Manager
 *
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/rich_text_editor/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  richTextEditor: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('rte:enable', () => { ... });
 *
 * // Use the API
 * const rte = editor.RichTextEditor;
 * rte.add(...);
 * ```
 *
 * ## Available Events
 * * `rte:enable` - RTE enabled. The view, on which RTE is enabled, is passed as an argument
 * * `rte:disable` - RTE disabled. The view, on which RTE is disabled, is passed as an argument
 *
 * ## Methods
 * * [add](#add)
 * * [get](#get)
 * * [run](#run)
 * * [getAll](#getall)
 * * [remove](#remove)
 * * [getToolbarEl](#gettoolbarel)
 *
 * @module RichTextEditor
 */
var rich_text_editor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var rich_text_editor_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var rich_text_editor_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var rich_text_editor_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};







var eventsUp = 'change:canvasOffset frame:scroll component:update';
var evEnable = 'rte:enable';
var evDisable = 'rte:disable';
var rich_text_editor_evCustom = 'rte:custom';
var rich_text_editor_events = {
    enable: evEnable,
    disable: evDisable,
    custom: rich_text_editor_evCustom,
};
var RichTextEditorModule = /** @class */ (function (_super) {
    rich_text_editor_extends(RichTextEditorModule, _super);
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    function RichTextEditorModule(em) {
        var _this = _super.call(this, em, 'RichTextEditor', rich_text_editor_config_config) || this;
        _this.events = rich_text_editor_events;
        var config = _this.config;
        var ppfx = config.pStylePrefix;
        if (ppfx) {
            config.stylePrefix = ppfx + config.stylePrefix;
        }
        _this.pfx = config.stylePrefix;
        _this.actions = config.actions || [];
        var model = new common/* Model */.Hn();
        _this.model = model;
        model.on('change:currentView', _this.__trgCustom, _this);
        _this.__dbdTrgCustom = (0,index_all.debounce)(function () { return _this.__trgCustom(); }, 0);
        return _this;
    }
    RichTextEditorModule.prototype.onLoad = function () {
        if (!(0,mixins.hasWin)())
            return;
        var config = this.config;
        var ppfx = config.pStylePrefix;
        var isCustom = config.custom;
        var toolbar = (0,dom/* createEl */.ut)('div', {
            class: (0,dom.cx)("".concat(ppfx, "rte-toolbar"), !isCustom && "".concat(ppfx, "one-bg ").concat(ppfx, "rte-toolbar-ui")),
        });
        this.toolbar = toolbar;
        this.initRte((0,dom/* createEl */.ut)('div'));
        //Avoid closing on toolbar clicking
        (0,dom.on)(toolbar, 'mousedown', function (e) { return e.stopPropagation(); });
    };
    RichTextEditorModule.prototype.__trgCustom = function () {
        var _a = this, model = _a.model, em = _a.em, events = _a.events;
        em.trigger(events.custom, {
            enabled: !!model.get('currentView'),
            container: this.getToolbarEl(),
            actions: this.getAll(),
        });
    };
    RichTextEditorModule.prototype.destroy = function () {
        var _a, _b, _c;
        (_a = this.globalRte) === null || _a === void 0 ? void 0 : _a.destroy();
        (_c = (_b = this.customRte) === null || _b === void 0 ? void 0 : _b.destroy) === null || _c === void 0 ? void 0 : _c.call(_b);
        this.model.stopListening().clear({ silent: true });
        this.__dbdTrgCustom.cancel();
        (0,dom/* removeEl */.L_)(this.toolbar);
    };
    /**
     * Post render callback
     * @param  {View} ev
     * @private
     */
    RichTextEditorModule.prototype.postRender = function (ev) {
        var canvas = ev.model.get('Canvas');
        this.toolbar.style.pointerEvents = 'all';
        this.hideToolbar();
        canvas.getToolsEl().appendChild(this.toolbar);
    };
    /**
     * Init the built-in RTE
     * @param  {HTMLElement} el
     * @return {RichTextEditor}
     * @private
     */
    RichTextEditorModule.prototype.initRte = function (el) {
        var globalRte = this.globalRte;
        var _a = this, em = _a.em, pfx = _a.pfx, actionbar = _a.actionbar, config = _a.config;
        var actions = this.actions || rich_text_editor_spreadArray([], config.actions, true);
        var classes = {
            actionbar: "".concat(pfx, "actionbar"),
            button: "".concat(pfx, "action"),
            active: "".concat(pfx, "active"),
            inactive: "".concat(pfx, "inactive"),
            disabled: "".concat(pfx, "disabled"),
        };
        if (!globalRte) {
            globalRte = new model_RichTextEditor(em, el, {
                classes: classes,
                actions: actions,
                actionbar: actionbar,
                actionbarContainer: this.toolbar,
                module: this,
            });
            this.globalRte = globalRte;
        }
        else {
            globalRte.em = em;
            globalRte.setEl(el);
        }
        if (globalRte.actionbar) {
            this.actionbar = globalRte.actionbar;
        }
        if (globalRte.actions) {
            this.actions = globalRte.actions;
        }
        return globalRte;
    };
    /**
     * Add a new action to the built-in RTE toolbar
     * @param {string} name Action name
     * @param {Object} action Action options
     * @example
     * rte.add('bold', {
     *   icon: '<b>B</b>',
     *   attributes: {title: 'Bold'},
     *   result: rte => rte.exec('bold')
     * });
     * rte.add('link', {
     *   icon: document.getElementById('t'),
     *   attributes: { title: 'Link' },
     *   // Example on how to wrap selected content
     *   result: rte => rte.insertHTML(`<a href="#">${rte.selection()}</a>`)
     * });
     * // An example with fontSize
     * rte.add('fontSize', {
     *   icon: `<select class="gjs-field">
     *         <option>1</option>
     *         <option>4</option>
     *         <option>7</option>
     *       </select>`,
     *     // Bind the 'result' on 'change' listener
     *   event: 'change',
     *   result: (rte, action) => rte.exec('fontSize', action.btn.firstChild.value),
     *   // Callback on any input change (mousedown, keydown, etc..)
     *   update: (rte, action) => {
     *     const value = rte.doc.queryCommandValue(action.name);
     *     if (value != 'false') { // value is a string
     *       action.btn.firstChild.value = value;
     *     }
     *    }
     *   })
     * // An example with state
     * const isValidAnchor = (rte) => {
     *   // a utility function to help determine if the selected is a valid anchor node
     *   const anchor = rte.selection().anchorNode;
     *   const parentNode  = anchor && anchor.parentNode;
     *   const nextSibling = anchor && anchor.nextSibling;
     *   return (parentNode && parentNode.nodeName == 'A') || (nextSibling && nextSibling.nodeName == 'A')
     * }
     * rte.add('toggleAnchor', {
     *   icon: `<span style="transform:rotate(45deg)">&supdsub;</span>`,
     *   state: (rte, doc) => {
     *    if (rte && rte.selection()) {
     *      // `btnState` is a integer, -1 for disabled, 0 for inactive, 1 for active
     *      return isValidAnchor(rte) ? btnState.ACTIVE : btnState.INACTIVE;
     *    } else {
     *      return btnState.INACTIVE;
     *    }
     *   },
     *   result: (rte, action) => {
     *     if (isValidAnchor(rte)) {
     *       rte.exec('unlink');
     *     } else {
     *       rte.insertHTML(`<a class="link" href="">${rte.selection()}</a>`);
     *     }
     *   }
     * })
     */
    RichTextEditorModule.prototype.add = function (name, action) {
        var _a;
        if (action === void 0) { action = {}; }
        action.name = name;
        (_a = this.globalRte) === null || _a === void 0 ? void 0 : _a.addAction(action, { sync: true });
    };
    /**
     * Get the action by its name
     * @param {string} name Action name
     * @return {Object}
     * @example
     * const action = rte.get('bold');
     * // {name: 'bold', ...}
     */
    RichTextEditorModule.prototype.get = function (name) {
        var _a;
        var result;
        (_a = this.globalRte) === null || _a === void 0 ? void 0 : _a.getActions().forEach(function (action) {
            if (action.name == name) {
                result = action;
            }
        });
        return result;
    };
    /**
     * Get all actions
     * @return {Array}
     */
    RichTextEditorModule.prototype.getAll = function () {
        var _a;
        return ((_a = this.globalRte) === null || _a === void 0 ? void 0 : _a.getActions()) || [];
    };
    /**
     * Remove the action from the toolbar
     * @param  {string} name
     * @return {Object} Removed action
     * @example
     * const action = rte.remove('bold');
     * // {name: 'bold', ...}
     */
    RichTextEditorModule.prototype.remove = function (name) {
        var _a;
        var actions = this.getAll();
        var action = this.get(name);
        if (action) {
            var btn = action.btn;
            var index = actions.indexOf(action);
            (_a = btn === null || btn === void 0 ? void 0 : btn.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(btn);
            actions.splice(index, 1);
        }
        return action;
    };
    /**
     * Run action command.
     * @param action Action to run
     * @example
     * const action = rte.get('bold');
     * rte.run(action) // or rte.run('bold')
     */
    RichTextEditorModule.prototype.run = function (action) {
        var rte = this.globalRte;
        var actionRes = (0,index_all.isString)(action) ? this.get(action) : action;
        if (rte && actionRes) {
            actionRes.result(rte, actionRes);
            rte.updateActiveActions();
        }
    };
    /**
     * Get the toolbar element
     * @return {HTMLElement}
     */
    RichTextEditorModule.prototype.getToolbarEl = function () {
        return this.toolbar;
    };
    /**
     * Triggered when the offset of the editor is changed
     * @private
     */
    RichTextEditorModule.prototype.updatePosition = function () {
        var _a = this, em = _a.em, toolbar = _a.toolbar;
        var un = 'px';
        var canvas = em.Canvas;
        var style = toolbar.style;
        var pos = canvas.getTargetToElementFixed(this.lastEl, toolbar, {
            event: 'rteToolbarPosUpdate',
            left: 0,
        });
        ['top', 'left', 'bottom', 'right'].forEach(function (key) {
            var value = pos[key];
            if ((0,mixins.isDef)(value)) {
                style[key] = (0,index_all.isString)(value) ? value : (value || 0) + un;
            }
        });
    };
    /**
     * Enable rich text editor on the element
     * @param {View} view Component view
     * @param {Object} rte The instance of already defined RTE
     * @private
     * */
    RichTextEditorModule.prototype.enable = function (view, rte, opts) {
        if (opts === void 0) { opts = {}; }
        return rich_text_editor_awaiter(this, void 0, void 0, function () {
            var _a, customRte, em, el, rteInst;
            return rich_text_editor_generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        this.lastEl = view.el;
                        _a = this, customRte = _a.customRte, em = _a.em;
                        el = view.getChildrenContainer();
                        this.toolbar.style.display = '';
                        return [4 /*yield*/, (customRte ? customRte.enable(el, rte) : this.initRte(el).enable(opts))];
                    case 1:
                        rteInst = _b.sent();
                        if (em) {
                            setTimeout(this.updatePosition.bind(this), 0);
                            em.off(eventsUp, this.updatePosition, this);
                            em.on(eventsUp, this.updatePosition, this);
                            em.trigger('rte:enable', view, rteInst);
                        }
                        this.model.set({ currentView: view });
                        return [2 /*return*/, rteInst];
                }
            });
        });
    };
    RichTextEditorModule.prototype.getContent = function (view, rte) {
        return rich_text_editor_awaiter(this, void 0, void 0, function () {
            var customRte;
            return rich_text_editor_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        customRte = this.customRte;
                        if (!(customRte && rte && (0,index_all.isFunction)(customRte.getContent))) return [3 /*break*/, 2];
                        return [4 /*yield*/, customRte.getContent(view.el, rte)];
                    case 1: return [2 /*return*/, _a.sent()];
                    case 2: return [2 /*return*/, view.getChildrenContainer().innerHTML];
                }
            });
        });
    };
    RichTextEditorModule.prototype.hideToolbar = function () {
        var style = this.toolbar.style;
        var size = '-1000px';
        style.top = size;
        style.left = size;
        style.display = 'none';
    };
    /**
     * Unbind rich text editor from the element
     * @param {View} view
     * @param {Object} rte The instance of already defined RTE
     * @private
     * */
    RichTextEditorModule.prototype.disable = function (view, rte, opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var customRte = this.customRte;
        // @ts-ignore
        var el = view.getChildrenContainer();
        if (customRte) {
            customRte.disable(el, rte);
        }
        else {
            rte && rte.disable();
        }
        this.hideToolbar();
        if (em) {
            em.off(eventsUp, this.updatePosition, this);
            !opts.fromMove && em.trigger('rte:disable', view, rte);
        }
        this.model.unset('currentView');
    };
    return RichTextEditorModule;
}(abstract_Module));
/* harmony default export */ const rich_text_editor = (RichTextEditorModule);

;// CONCATENATED MODULE: ./src/style_manager/config/config.ts
/* harmony default export */ const style_manager_config_config = ({
    sectors: [
        {
            name: 'General',
            open: false,
            properties: ['display', 'float', 'position', 'top', 'right', 'left', 'bottom'],
        },
        {
            name: 'Flex',
            open: false,
            properties: [
                'flex-direction',
                'flex-wrap',
                'justify-content',
                'align-items',
                'align-content',
                'order',
                'flex-basis',
                'flex-grow',
                'flex-shrink',
                'align-self',
            ],
        },
        {
            name: 'Dimension',
            open: false,
            properties: ['width', 'height', 'max-width', 'min-height', 'margin', 'padding'],
        },
        {
            name: 'Typography',
            open: false,
            properties: [
                'font-family',
                'font-size',
                'font-weight',
                'letter-spacing',
                'color',
                'line-height',
                'text-align',
                'text-shadow',
            ],
        },
        {
            name: 'Decorations',
            open: false,
            properties: ['background-color', 'border-radius', 'border', 'box-shadow', 'background'],
        },
        {
            name: 'Extra',
            open: false,
            properties: ['opacity', 'transition', 'transform'],
        },
    ],
    appendTo: '',
    stylePrefix: 'sm-',
    custom: false,
    hideNotStylable: true,
    highlightChanged: true,
    highlightComputed: true,
    showComputed: true,
    clearProperties: true,
    avoidComputed: ['width', 'height'],
});

;// CONCATENATED MODULE: ./src/style_manager/model/Property.ts
var Property_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Property_assign = (undefined && undefined.__assign) || function () {
    Property_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Property_assign.apply(this, arguments);
};
var Property_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Property_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



/**
 * @typedef Property
 * @property {String} id Property id, eg. `my-property-id`.
 * @property {String} property Related CSS property name, eg. `text-align`.
 * @property {String} default Defaul value of the property.
 * @property {String} label Label to use in UI, eg. `Text Align`.
 * @property {Function} [onChange] Change callback.
 * \n
 * ```js
 *  onChange: ({ property, from, to }) => {
 *    console.log(`Changed property`, property.getName(), { from, to });
 *  }
 * ```
 *
 */
var Property = /** @class */ (function (_super) {
    Property_extends(Property, _super);
    function Property() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Property.getDefaults = function () {
        return (0,index_all.result)(this.prototype, 'defaults');
    };
    /**
     * @private
     * @ts-ignore */
    Property.prototype.defaults = function () {
        return {
            name: '',
            property: '',
            type: '',
            defaults: '',
            info: '',
            value: '',
            icon: '',
            functionName: '',
            status: '',
            visible: true,
            fixedValues: ['initial', 'inherit'],
            full: false,
            important: false,
            toRequire: false,
            requires: undefined,
            requiresParent: null,
            parentTarget: null,
        };
    };
    Property.prototype.initialize = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        this.em = opts.em;
        var id = this.getId() || '';
        var name = this.get('name') || this.get('label') || '';
        // @ts-ignore
        !this.get('property') && this.set('property', (name || id).replace(/ /g, '-'));
        var prop = this.get('property');
        !this.get('id') && this.set('id', prop);
        // @ts-ignore
        !name && this.set('name', (0,mixins.capitalize)(prop).replace(/-/g, ' '));
        this.on('change', this.__upTargets);
        // @ts-ignore
        Property.callInit(this, props, opts);
    };
    Property.prototype.__getParentProp = function () {
        var _a, _b;
        // @ts-ignore
        return (_b = (_a = this.collection) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.parentProp;
    };
    Property.prototype.__upTargets = function (p, opts) {
        var _a;
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var sm = em.Styles;
        var name = this.getName();
        var isClear = opts.__clear;
        var value = isClear ? '' : this.__getFullValue(opts);
        var parentProp = this.__getParentProp();
        var to = this.changedAttributes();
        var from = (0,index_all.keys)(to).reduce(function (a, i) {
            a[i] = _this.previous(i);
            return a;
        }, {});
        var kProps = Property_spreadArray(Property_spreadArray([], (0,index_all.keys)(this.__getClearProps()), true), ['__p'], false);
        var toProps = (0,index_all.keys)(to);
        var applyStyle = !opts.__up && !parentProp && (isClear || kProps.some(function (k) { return toProps.indexOf(k) >= 0; }));
        var onChange = this.get('onChange');
        var evOpts = { property: this, from: from, to: to, value: value, opts: opts };
        sm.__trgEv(sm.events.propertyUpdate, evOpts);
        onChange && onChange(evOpts);
        applyStyle && this.__upTargetsStyle((_a = {}, _a[name] = value, _a), opts);
    };
    Property.prototype.__upTargetsStyle = function (style, opts) {
        var _a;
        var sm = (_a = this.em) === null || _a === void 0 ? void 0 : _a.get('StyleManager');
        sm === null || sm === void 0 ? void 0 : sm.addStyleTargets(Property_assign(Property_assign({}, style), { __p: !!opts.avoidStore }), opts);
    };
    Property.prototype._up = function (props, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.noTarget)
            opts.__up = true;
        var partial = opts.partial, rest = Property_rest(opts, ["partial"]);
        // @ts-ignore
        props.__p = !!(rest.avoidStore || partial);
        return this.set(props, Property_assign(Property_assign({}, rest), { avoidStore: props.__p }));
    };
    Property.prototype.up = function (props, opts) {
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        this.set(props, Property_assign(Property_assign({}, opts), { __up: true }));
    };
    Property.prototype.init = function () { };
    /**
     * Get property id.
     * @returns {String}
     */
    Property.prototype.getId = function () {
        return this.get('id');
    };
    /**
     * Get the property type.
     * The type of the property is defined on property creation and based on its value the proper Property class is assigned.
     * The default type is `base`.
     * @returns {String}
     */
    Property.prototype.getType = function () {
        return this.get('type');
    };
    /**
     * Get name (the CSS property name).
     * @returns {String}
     */
    Property.prototype.getName = function () {
        return this.get('property');
    };
    /**
     * Get property label.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.locale=true] Use the locale string from i18n module
     * @returns {String}
     */
    Property.prototype.getLabel = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = opts.locale, locale = _b === void 0 ? true : _b;
        var id = this.getId();
        var name = this.get('name') || this.get('label');
        return (locale && ((_a = this.em) === null || _a === void 0 ? void 0 : _a.t("styleManager.properties.".concat(id)))) || name;
    };
    /**
     * Get property value.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.noDefault=false] Avoid returning the default value
     * @returns {String}
     */
    Property.prototype.getValue = function (opts) {
        if (opts === void 0) { opts = {}; }
        var noDefault = opts.noDefault;
        var val = this.get('value');
        return !this.hasValue() && !noDefault ? this.getDefaultValue() : val;
    };
    /**
     * Check if the property has value.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.noParent=false] Ignore the value if it comes from the parent target.
     * @returns {Boolean}
     */
    Property.prototype.hasValue = function (opts) {
        if (opts === void 0) { opts = {}; }
        var noParent = opts.noParent;
        var parentValue = noParent && this.getParentTarget();
        var val = this.get('value');
        return !(0,index_all.isUndefined)(val) && val !== '' && !parentValue;
    };
    /**
     * Indicates if the current value is coming from a parent target (eg. another CSSRule).
     * @returns {Boolean}
     */
    Property.prototype.hasValueParent = function () {
        return this.hasValue() && !this.hasValue({ noParent: true });
    };
    /**
     * Get the CSS style object of the property.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.camelCase] Return property name in camelCase.
     * @return {Object}
     * @example
     * // In case the property is `color` with a value of `red`.
     * console.log(property.getStyle());
     * // { color: 'red' };
     */
    Property.prototype.getStyle = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var name = this.getName();
        var key = opts.camelCase ? (0,mixins.camelCase)(name) : name;
        return _a = {}, _a[key] = this.__getFullValue(opts), _a;
    };
    /**
     * Get the default value.
     * @return {string}
     */
    Property.prototype.getDefaultValue = function () {
        var def = this.get('default');
        return "".concat(!(0,index_all.isUndefined)(def) ? def : this.get('defaults'));
    };
    /**
     * Update the value.
     * The change is also propagated to the selected targets (eg. CSS rule).
     * @param {String} value New value
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.partial=false] If `true` the update on targets won't be considered complete (not stored in UndoManager)
     * @param {Boolean} [opts.noTarget=false] If `true` the change won't be propagated to selected targets.
     */
    Property.prototype.upValue = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var parsed = value === null || value === '' ? this.__getClearProps() : this.__parseValue(value, opts);
        return this._up(parsed, opts);
    };
    /**
     * Check if the property is visible
     * @returns {Boolean}
     */
    Property.prototype.isVisible = function () {
        return !!this.get('visible');
    };
    /**
     * Clear the value.
     * The change is also propagated to the selected targets (eg. the css property is cleared).
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.noTarget=false] If `true` the change won't be propagated to selected targets.
     */
    Property.prototype.clear = function (opts) {
        if (opts === void 0) { opts = {}; }
        this._up(this.__getClearProps(), Property_assign(Property_assign({}, opts), { __clear: true }));
        return this;
    };
    /**
     * Indicates if the current value comes directly from the selected target and so can be cleared.
     * @returns {Boolean}
     */
    Property.prototype.canClear = function () {
        var parent = this.getParent();
        return parent ? parent.__canClearProp(this) : this.hasValue({ noParent: true });
    };
    /**
     * If the current property is a sub-property, this will return the parent Property.
     * @returns {[Property]|null}
     */
    Property.prototype.getParent = function () {
        return this.__getParentProp();
    };
    /**
     * Indicates if the property is full-width in UI.
     * @returns {Boolean}
     */
    Property.prototype.isFull = function () {
        return !!this.get('full');
    };
    Property.prototype.__parseValue = function (value, opts) {
        return this.parseValue(value, opts);
    };
    Property.prototype.__getClearProps = function () {
        return { value: '' };
    };
    /**
     * Update value
     * @param {any} value
     * @param {Boolen} [complete=true] Indicates if it's a final state
     * @param {Object} [opts={}] Options
     * @private
     */
    Property.prototype.setValue = function (value, complete, opts) {
        if (complete === void 0) { complete = true; }
        if (opts === void 0) { opts = {}; }
        var parsed = this.parseValue(value);
        var avoidStore = !complete;
        // @ts-ignore
        !avoidStore && this.set({ value: undefined }, { avoidStore: avoidStore, silent: true });
        this.set(parsed, Property_assign({ avoidStore: avoidStore }, opts));
    };
    /**
     * Like `setValue` but, in addition, prevents the update of the input element
     * as the changes should come from the input itself.
     * This method is useful with the definition of custom properties
     * @param {any} value
     * @param {Boolen} [complete=true] Indicates if it's a final state
     * @param {Object} [opts={}] Options
     * @private
     * @deprecated
     */
    Property.prototype.setValueFromInput = function (value, complete, opts) {
        if (opts === void 0) { opts = {}; }
        this.setValue(value, complete, Property_assign(Property_assign({}, opts), { fromInput: 1 }));
    };
    /**
     * Parse a raw value, generally fetched from the target, for this property
     * @param  {string} value Raw value string
     * @return {Object}
     * @private
     * @example
     * // example with an Input type
     * prop.parseValue('translateX(10deg)');
     * // -> { value: 10, unit: 'deg', functionName: 'translateX' }
     *
     */
    Property.prototype.parseValue = function (value, opts) {
        if (opts === void 0) { opts = {}; }
        var result = { value: value };
        var imp = '!important';
        var fn = this.get('functionName') || '';
        if ((0,index_all.isString)(value) && value.indexOf(imp) !== -1) {
            result.value = value.replace(imp, '').trim();
            result.important = true;
        }
        if (!fn && !opts.complete) {
            return result;
        }
        var args = [];
        var valueStr = "".concat(result.value).trim();
        var start = valueStr.indexOf('(') + 1;
        var functionName = fn || valueStr.substring(0, start - 1);
        if (functionName) {
            result.functionName = functionName;
        }
        if (!fn || valueStr.indexOf("".concat(fn, "(")) === 0) {
            var end = valueStr.lastIndexOf(')');
            args.push(start);
            // Will try even if the last closing parentheses is not found
            end >= 0 && args.push(end);
            result.value = String.prototype.substring.apply(valueStr, args);
        }
        if (opts.numeric) {
            var num = parseFloat(result.value);
            result.unit = result.value.replace(num, '');
            result.value = num;
        }
        return result;
    };
    /**
     * Helper function to safely split a string of values.
     * Useful when style values are inside functions
     * eg:
     * -> input: 'value(1,2,4), 123, value(4,5)' -- default separator: ','
     * -> output: ['value(1,2,4)', '123', 'value(4,5)']
     * @param {String} values Values to split
     * @param {String} [separator] Separator
     * @private
     */
    // splitValues(values, separator = ',') {
    //   const res = [];
    //   const op = '(';
    //   const cl = ')';
    //   let curr = '';
    //   let acc = 0;
    //   (values || '').split('').forEach(str => {
    //     if (str == op) {
    //       acc++;
    //       curr = curr + op;
    //     } else if (str == cl && acc > 0) {
    //       acc--;
    //       curr = curr + cl;
    //     } else if (str === separator && acc == 0) {
    //       res.push(curr);
    //       curr = '';
    //     } else {
    //       curr = curr + str;
    //     }
    //   });
    //   curr !== '' && res.push(curr);
    //   return res.map(i => i.trim());
    // }
    Property.prototype.__getFullValue = function (_a) {
        var _b = _a === void 0 ? {} : _a, withDefault = _b.withDefault;
        return !this.hasValue() && withDefault ? this.getDefaultValue() : this.getFullValue();
    };
    /**
     * Get a complete value of the property.
     * This probably will replace the getValue when all
     * properties models will be splitted
     * @param {String} val Custom value to replace the one on the model
     * @return {string}
     * @private
     */
    Property.prototype.getFullValue = function (val, opts) {
        if (opts === void 0) { opts = {}; }
        var fn = this.get('functionName');
        var def = this.getDefaultValue();
        var value = (0,index_all.isUndefined)(val) ? this.get('value') : val;
        var hasValue = !(0,index_all.isUndefined)(value) && value !== '';
        if (value && def && value === def) {
            return def;
        }
        if (fn && hasValue) {
            var fnParameter = fn === 'url' ? "'".concat(value.replace(/'|"/g, ''), "'") : value;
            value = "".concat(fn, "(").concat(fnParameter, ")");
        }
        if (hasValue && this.get('important') && !opts.skipImportant) {
            value = "".concat(value, " !important");
        }
        return value || '';
    };
    Property.prototype.__setParentTarget = function (parentTarget) {
        this.up({ parentTarget: parentTarget });
    };
    Property.prototype.getParentTarget = function () {
        return this.get('parentTarget') || null;
    };
    Property.prototype.__parseFn = function (input) {
        if (input === void 0) { input = ''; }
        var start = input.indexOf('(') + 1;
        var end = input.lastIndexOf(')');
        return {
            name: input.substring(0, start - 1).trim(),
            value: String.prototype.substring.apply(input, [start, end >= 0 ? end : undefined]).trim(),
        };
    };
    Property.prototype.__checkVisibility = function (_a) {
        var target = _a.target, component = _a.component, sectors = _a.sectors;
        var trg = component || target;
        if (!trg)
            return false;
        var id = this.getId();
        var property = this.getName();
        var toRequire = this.get('toRequire');
        var requires = this.get('requires');
        var requiresParent = this.get('requiresParent');
        var unstylable = trg.get('unstylable');
        var stylableReq = trg.get('stylable-require');
        var stylable = trg.get('stylable');
        // Stylable could also be an array indicating with which property
        // the target could be styled
        if ((0,index_all.isArray)(stylable)) {
            stylable = stylable.indexOf(property) >= 0;
        }
        // Check if the property was signed as unstylable
        if ((0,index_all.isArray)(unstylable)) {
            stylable = unstylable.indexOf(property) < 0;
        }
        // Check if the property is available only if requested
        if (toRequire) {
            stylable = !target || (stylableReq && (stylableReq.indexOf(id) >= 0 || stylableReq.indexOf(property) >= 0));
        }
        // Check if the property is available based on other property's values
        if (sectors && requires) {
            var properties_1 = (0,index_all.keys)(requires);
            sectors.forEach(function (sector) {
                sector.getProperties().forEach(function (model) {
                    if ((0,index_all.includes)(properties_1, model.id)) {
                        var values = requires[model.id];
                        stylable = stylable && (0,index_all.includes)(values, model.get('value'));
                    }
                });
            });
        }
        // Check if the property is available based on parent's property values
        if (requiresParent) {
            var parent_1 = component && component.parent();
            var parentEl = parent_1 && parent_1.getEl();
            if (parentEl) {
                var styles_1 = (0,mixins.hasWin)() ? window.getComputedStyle(parentEl) : {};
                (0,index_all.each)(requiresParent, function (values, property) {
                    stylable = stylable && styles_1[property] && (0,index_all.includes)(values, styles_1[property]);
                });
            }
            else {
                stylable = false;
            }
        }
        return !!stylable;
    };
    return Property;
}(common/* Model */.Hn));
/* harmony default export */ const model_Property = (Property);
// @ts-ignore
Property.callParentInit = function (property, ctx, props, opts) {
    if (opts === void 0) { opts = {}; }
    property.prototype.initialize.apply(ctx, [
        props,
        Property_assign(Property_assign({}, opts), { skipInit: 1 }),
    ]);
};
// @ts-ignore
Property.callInit = function (context, props, opts) {
    if (opts === void 0) { opts = {}; }
    !opts.skipInit && context.init(props, opts);
};

;// CONCATENATED MODULE: ./src/style_manager/model/Layer.ts
var Layer_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Layer_assign = (undefined && undefined.__assign) || function () {
    Layer_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Layer_assign.apply(this, arguments);
};


var Layer = /** @class */ (function (_super) {
    Layer_extends(Layer, _super);
    function Layer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Layer.prototype.defaults = function () {
        return {
            values: {},
        };
    };
    Layer.prototype.initialize = function () {
        var cl = this.collection;
        // @ts-ignore
        this.prop = cl === null || cl === void 0 ? void 0 : cl.prop;
    };
    /**
     * Get layer id.
     * @returns {String}
     */
    Layer.prototype.getId = function () {
        return this.cid;
    };
    /**
     * Get layer index.
     * @returns {Number}
     */
    Layer.prototype.getIndex = function () {
        var coll = this.collection;
        return coll ? coll.indexOf(this) : -1;
    };
    /**
     * Get layer values.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.camelCase] Return property names in camelCase.
     * @returns {Object}
     */
    Layer.prototype.getValues = function (opts) {
        if (opts === void 0) { opts = {}; }
        var values = this.get('values');
        return opts.camelCase
            ? Object.keys(values).reduce(function (res, key) {
                res[(0,mixins.camelCase)(key)] = values[key];
                return res;
            }, {})
            : values;
    };
    /**
     * Get layer label.
     * @returns {String}
     */
    Layer.prototype.getLabel = function () {
        var _a;
        return (_a = this.prop) === null || _a === void 0 ? void 0 : _a.getLayerLabel(this);
    };
    /**
     * Check if the layer is selected.
     * @returns {Boolean}
     */
    Layer.prototype.isSelected = function () {
        var _a;
        return ((_a = this.prop) === null || _a === void 0 ? void 0 : _a.getSelectedLayer()) === this;
    };
    /**
     * Select the layer.
     */
    Layer.prototype.select = function () {
        var _a;
        return (_a = this.prop) === null || _a === void 0 ? void 0 : _a.selectLayer(this);
    };
    /**
     * Remove the layer.
     */
    Layer.prototype.remove = function () {
        var _a;
        return (_a = this.prop) === null || _a === void 0 ? void 0 : _a.removeLayer(this);
    };
    /**
     * Move layer to a new index.
     * @param {Number} index New index
     */
    Layer.prototype.move = function (index) {
        var _a;
        return (_a = this.prop) === null || _a === void 0 ? void 0 : _a.moveLayer(this, index);
    };
    /**
     * Get style object for the preview.
     * @param {Object} [opts={}] Options. Same of `PropertyStack.getStyleFromLayer`
     * @returns {Object} Style object
     */
    Layer.prototype.getStylePreview = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        return (_a = this.prop) === null || _a === void 0 ? void 0 : _a.getStylePreview(this, opts);
    };
    /**
     * Check if the property has the preview enabled for this layer.
     * @returns {Boolean}
     */
    Layer.prototype.hasPreview = function () {
        var _a;
        return !!((_a = this.prop) === null || _a === void 0 ? void 0 : _a.get('preview'));
    };
    Layer.prototype.upValues = function (props) {
        if (props === void 0) { props = {}; }
        return this.set('values', Layer_assign(Layer_assign({}, this.getValues()), props));
    };
    return Layer;
}(common/* Model */.Hn));
/* harmony default export */ const model_Layer = (Layer);

;// CONCATENATED MODULE: ./src/style_manager/model/Layers.ts
var Layers_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var Layers = /** @class */ (function (_super) {
    Layers_extends(Layers, _super);
    function Layers() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Layers.prototype.initialize = function (p, opts) {
        if (opts === void 0) { opts = {}; }
        this.prop = opts.prop;
    };
    return Layers;
}(common/* Collection */.FE));
/* harmony default export */ const model_Layers = (Layers);
Layers.prototype.model = model_Layer;

;// CONCATENATED MODULE: ./src/style_manager/model/PropertyComposite.ts
var PropertyComposite_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyComposite_assign = (undefined && undefined.__assign) || function () {
    PropertyComposite_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyComposite_assign.apply(this, arguments);
};
var PropertyComposite_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};





var isNumberType = function (type) { return type === 'integer' || type === 'number'; };
/**
 *
 * [Property]: property.html
 *
 *
 * @typedef PropertyComposite
 * @property {Array<Object>} properties Array of sub properties, eg. `[{ type: 'number', property: 'margin-top' }, ...]`
 * @property {Boolean} [detached=false] Indicate if the final CSS property is splitted (detached: `margin-top: X; margin-right: Y; ...`) or combined (not detached: `margin: X Y ...;`)
 * @property {String|RegExp} [separator=' '] Value used to split property values, default `" "`.
 * @property {String} [join=' '] Value used to join property values, default `" "`.
 * @property {Function} [fromStyle] Custom logic for getting property values from the target style object.
 * \n
 * ```js
 *  fromStyle: (style) => {
 *    const margins = parseMarginShorthand(style.margin);
 *    return {
 *      'margin-top': margins.top,
 *      // ...
 *    };
 *  }
 * ```
 * @property {Function} [toStyle] Custom logic for creating the CSS style object to apply on selected targets.
 * \n
 * ```js
 *  toStyle: (values) => {
 *    const top = values['margin-top'] || 0;
 *    const right = values['margin-right'] || 0;
 *    // ...
 *    return {
 *      margin: `${top} ${right} ...`,
 *    };
 *  }
 * ```
 */
var PropertyComposite = /** @class */ (function (_super) {
    PropertyComposite_extends(PropertyComposite, _super);
    function PropertyComposite() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyComposite.prototype.defaults = function () {
        return PropertyComposite_assign(PropertyComposite_assign({}, model_Property.getDefaults()), { detached: false, properties: [], separator: ' ', join: null, fromStyle: null, toStyle: null, full: true });
    };
    PropertyComposite.prototype.initialize = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        model_Property.callParentInit(model_Property, this, props, opts);
        var em = this.em;
        var properties = new model_Properties(this.get('properties') || [], {
            em: em,
            parentProp: this,
        });
        this.set('properties', properties, { silent: true });
        this.listenTo(properties, 'change', this.__upProperties);
        // @ts-ignore
        model_Property.callInit(this, props, opts);
    };
    Object.defineProperty(PropertyComposite.prototype, "properties", {
        get: function () {
            // @ts-ignore
            return this.get('properties') || [];
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get properties.
     * @returns {Array<[Property]>}
     */
    PropertyComposite.prototype.getProperties = function () {
        // @ts-ignore
        return PropertyComposite_spreadArray([], this.get('properties').models, true);
    };
    /**
     * Get property by id.
     * @param  {String} id Property id.
     * @returns {[Property]|null}
     */
    PropertyComposite.prototype.getProperty = function (id) {
        return this.properties.filter(function (prop) { return prop.getId() === id || prop.getName() === id; })[0];
    };
    /**
     * Get property at index.
     * @param  {Number} index
     * @returns {[Property]|null}
     */
    PropertyComposite.prototype.getPropertyAt = function (index) {
        // @ts-ignore
        return this.get('properties').at(index);
    };
    /**
     * Check if the property is detached.
     * @returns {Boolean}
     */
    PropertyComposite.prototype.isDetached = function () {
        return !!this.get('detached');
    };
    /**
     * Get current values of properties.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.byName=false] Use property names as a key instead of the id.
     * @returns {Object}
     * @example
     * // In case the property is `margin` with sub properties like `margin-top`, `margin-right`, etc.
     * console.log(property.getValues());
     * // { 'margin-top': '10px', 'margin-right': '20px', ... };
     */
    PropertyComposite.prototype.getValues = function (_a) {
        var _b = _a === void 0 ? {} : _a, byName = _b.byName;
        return this.getProperties().reduce(function (res, prop) {
            var key = byName ? prop.getName() : prop.getId();
            res[key] = "".concat(prop.__getFullValue());
            return res;
        }, {});
    };
    /**
     * Get property separator.
     * @returns {RegExp}
     */
    PropertyComposite.prototype.getSeparator = function () {
        return this.getSplitSeparator();
    };
    /**
     * Get the join value.
     * @returns {String}
     */
    PropertyComposite.prototype.getJoin = function () {
        return this.__getJoin();
    };
    /**
     * Get style object from current properties
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.camelCase] Return property names in camelCase.
     * @returns {Object} Style object
     * @private
     */
    PropertyComposite.prototype.getStyleFromProps = function (opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var name = this.getName();
        var join = this.__getJoin();
        var toStyle = this.get('toStyle');
        var values = this.getValues();
        var style = {};
        if (toStyle) {
            style = toStyle(values, { join: join, name: name, property: this });
        }
        else {
            values = this.getValues({ byName: true });
            if (this.isDetached()) {
                style = values;
            }
            else {
                var value = this.getProperties()
                    .map(function (p) { return p.__getFullValue({ withDefault: 1 }); })
                    .filter(Boolean)
                    .join(join);
                style = (_a = {}, _a[name] = value, _a);
            }
        }
        if (this.isDetached()) {
            style[name] = '';
        }
        else {
            style[name] = style[name] || '';
            style = PropertyComposite_assign(PropertyComposite_assign({}, style), this.getProperties().reduce(function (acc, prop) {
                acc[prop.getName()] = '';
                return acc;
            }, {}));
        }
        return opts.camelCase
            ? Object.keys(style).reduce(function (res, key) {
                res[(0,mixins.camelCase)(key)] = style[key];
                return res;
            }, {})
            : style;
    };
    PropertyComposite.prototype.getSplitSeparator = function () {
        return new RegExp("".concat(this.get('separator'), "(?![^\\(]*\\))"));
    };
    PropertyComposite.prototype.__upProperties = function (p, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.__up || opts.__clearIn)
            return;
        var parentProp = this.__getParentProp();
        if (parentProp)
            return parentProp.__upProperties(this, opts);
        this.__upTargetsStyleProps(opts, p);
    };
    PropertyComposite.prototype.__upTargetsStyleProps = function (opts, prop) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var style = this.getStyleFromProps();
        if (this.isDetached() && prop) {
            var name_1 = prop.getName();
            style = (_a = {}, _a[name_1] = style[name_1], _a);
        }
        this.__upTargetsStyle(style, opts);
    };
    PropertyComposite.prototype._up = function (props, opts) {
        if (opts === void 0) { opts = {}; }
        this.__setProperties(this.__getSplitValue(props.value), opts);
        model_Property.prototype._up.call(this, props, opts);
        return this;
    };
    PropertyComposite.prototype.getStyle = function (opts) {
        return this.getStyleFromProps(opts);
    };
    PropertyComposite.prototype.__getFullValue = function (opts) {
        if (opts === void 0) { opts = {}; }
        if (this.isDetached() || opts.__clear)
            return '';
        var result = this.getStyleFromProps()[this.getName()] || '';
        return getLastStyleValue(result);
    };
    PropertyComposite.prototype.__getJoin = function () {
        var join = this.get('join');
        return (0,index_all.isString)(join) ? join : this.get('separator');
    };
    PropertyComposite.prototype.__styleHasProps = function (style) {
        if (style === void 0) { style = {}; }
        var name = this.getName();
        var props = this.getProperties();
        var nameProps = props.map(function (prop) { return prop.getName(); });
        var allNameProps = PropertyComposite_spreadArray([name], nameProps, true);
        return allNameProps.some(function (prop) { return !(0,index_all.isUndefined)(style[prop]) && style[prop] !== ''; });
    };
    PropertyComposite.prototype.__splitValue = function (value, sep) {
        return getLastStyleValue(value)
            .split(sep)
            .map(function (value) { return value.trim(); })
            .filter(Boolean);
    };
    PropertyComposite.prototype.__splitStyleName = function (style, name, sep) {
        return this.__splitValue(style[name] || '', sep);
    };
    PropertyComposite.prototype.__getSplitValue = function (value, _a) {
        if (value === void 0) { value = ''; }
        var _b = _a === void 0 ? {} : _a, byName = _b.byName;
        var props = this.getProperties();
        var props4Nums = props.length === 4 && props.every(function (prop) { return isNumberType(prop.getType()); });
        var values = this.__splitValue(value, this.getSplitSeparator());
        var result = {};
        props.forEach(function (prop, i) {
            var value = values[i];
            var res = !(0,index_all.isUndefined)(value) ? value : ''; // : prop.getDefaultValue();
            if (props4Nums) {
                // Try to get value from a shorthand:
                // 11px -> 11px 11px 11px 11xp
                // 11px 22px -> 11px 22px 11px 22xp
                var len = values.length;
                res = values[i] || values[(i % len) + (len != 1 && len % 2 ? 1 : 0)] || res;
            }
            var key = byName ? prop.getName() : prop.getId();
            result[key] = res || '';
        });
        return result;
    };
    PropertyComposite.prototype.__getPropsFromStyle = function (style, opts) {
        if (style === void 0) { style = {}; }
        if (opts === void 0) { opts = {}; }
        if (!this.__styleHasProps(style))
            return null;
        var byName = opts.byName;
        var name = this.getName();
        var props = this.getProperties();
        var sep = this.getSplitSeparator();
        var fromStyle = this.get('fromStyle');
        var result = fromStyle ? fromStyle(style, { property: this, name: name, separator: sep }) : {};
        if (!fromStyle) {
            // Get props from the main property
            result = this.__getSplitValue(style[name] || '', { byName: byName });
            // Get props from the inner properties
            props.forEach(function (prop) {
                var value = style[prop.getName()];
                var key = byName ? prop.getName() : prop.getId();
                if (!(0,index_all.isUndefined)(value) && value !== '')
                    result[key] = value;
            });
        }
        return result;
    };
    PropertyComposite.prototype.__setProperties = function (values, opts) {
        if (values === void 0) { values = {}; }
        if (opts === void 0) { opts = {}; }
        this.getProperties().forEach(function (prop) {
            var value = values[prop.getId()];
            prop.__getFullValue() !== value && prop.upValue(value, opts);
        });
        // Keep track of the values, otherwise clear() will not trigger changes.
        var valuesStr = (0,index_all.keys)(values)
            .map(function (k) { return values[k]; })
            .join(' ');
        this.set('value', valuesStr, { silent: true });
    };
    PropertyComposite.prototype.clear = function () {
        var _this = this;
        this.getProperties().map(function (p) { return p.clear({ __clearIn: !_this.isDetached() }); });
        model_Property.prototype.clear.call(this);
        return this;
    };
    PropertyComposite.prototype.hasValue = function (opts) {
        return this.getProperties().some(function (prop) { return prop.hasValue(opts); });
    };
    PropertyComposite.prototype.getFullValue = function () {
        return this.__getFullValue();
    };
    PropertyComposite.prototype.__canClearProp = function (prop) {
        return this.isDetached() && prop.hasValue({ noParent: true });
    };
    return PropertyComposite;
}(model_Property));
/* harmony default export */ const model_PropertyComposite = (PropertyComposite);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertyStack.ts
var PropertyStack_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyStack_assign = (undefined && undefined.__assign) || function () {
    PropertyStack_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyStack_assign.apply(this, arguments);
};
var PropertyStack_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};






var VALUES_REG = /,(?![^\(]*\))/;
var PARTS_REG = /\s(?![^(]*\))/;
/**
 *
 * [Layer]: layer.html
 *
 *
 * @typedef PropertyStack
 * @property {Boolean} [preview=false] Indicate if the layer should display a preview.
 * @property {String|RegExp} [layerSeparator=', '] The separator used to split layer values.
 * @property {String} [layerJoin=', '] Value used to join layer values.
 * @property {Function} [layerLabel] Custom logic for creating layer labels.
 * \n
 * ```js
 *  layerLabel: (layer) => {
 *    const values = layer.getValues();
 *    return `A: ${values['prop-a']} B: ${values['prop-b']}`;
 *  }
 *  ```
 *
 */
var PropertyStack = /** @class */ (function (_super) {
    PropertyStack_extends(PropertyStack, _super);
    function PropertyStack() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyStack.prototype.defaults = function () {
        return PropertyStack_assign(PropertyStack_assign({}, model_PropertyComposite.getDefaults()), { layers: [], layerSeparator: ', ', layerJoin: '', prepend: 0, preview: false, layerLabel: null, selectedLayer: null });
    };
    PropertyStack.prototype.initialize = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        model_PropertyComposite.callParentInit(model_PropertyComposite, this, props, opts);
        var layers = this.get('layers');
        var layersColl = new model_Layers(layers, { prop: this });
        // @ts-ignore
        layersColl.property = this;
        // @ts-ignore
        layersColl.properties = this.get('properties');
        this.set('layers', layersColl, { silent: true });
        this.on('change:selectedLayer', this.__upSelected);
        this.listenTo(layersColl, 'add remove', this.__upLayers);
        // @ts-ignore
        model_PropertyComposite.callInit(this, props, opts);
    };
    /**
     * Get all available layers.
     * @returns {Array<[Layer]>}
     */
    PropertyStack.prototype.getLayers = function () {
        return this.__getLayers().models;
    };
    PropertyStack.prototype.__getLayers = function () {
        return this.get('layers');
    };
    /**
     * Get layer by index.
     * @param {Number} [index=0] Layer index position.
     * @returns {[Layer]|null}
     * @example
     * // Get the first layer
     * const layerFirst = property.getLayer(0);
     * // Get the last layer
     * const layers = this.getLayers();
     * const layerLast = property.getLayer(layers.length - 1);
     */
    PropertyStack.prototype.getLayer = function (index) {
        if (index === void 0) { index = 0; }
        return this.__getLayers().at(index) || undefined;
    };
    /**
     * Get selected layer.
     * @returns {[Layer] | undefined}
     */
    PropertyStack.prototype.getSelectedLayer = function () {
        var layer = this.get('selectedLayer');
        return layer && layer.getIndex() >= 0 ? layer : undefined;
    };
    /**
     * Select layer.
     * Without a selected layer any update made on inner properties has no effect.
     * @param {[Layer]} layer Layer to select
     * @example
     * const layer = property.getLayer(0);
     * property.selectLayer(layer);
     */
    PropertyStack.prototype.selectLayer = function (layer) {
        return this.set('selectedLayer', layer, { __select: true });
    };
    /**
     * Select layer by index.
     * @param {Number} index Index of the layer to select.
     * @example
     * property.selectLayerAt(1);
     */
    PropertyStack.prototype.selectLayerAt = function (index) {
        if (index === void 0) { index = 0; }
        var layer = this.getLayer(index);
        return layer && this.selectLayer(layer);
    };
    /**
     * Move layer by index.
     * @param {[Layer]} layer Layer to move.
     * @param {Number} index New layer index.
     * @example
     * const layer = property.getLayer(1);
     * property.moveLayer(layer, 0);
     */
    PropertyStack.prototype.moveLayer = function (layer, index) {
        if (index === void 0) { index = 0; }
        var currIndex = layer ? layer.getIndex() : -1;
        if (currIndex >= 0 && (0,index_all.isNumber)(index) && index >= 0 && index < this.getLayers().length && currIndex !== index) {
            this.removeLayer(layer);
            this.__getLayers().add(layer, { at: index });
        }
    };
    /**
     * Add new layer to the stack.
     * @param {Object} [props={}] Custom property values to use in a new layer.
     * @param {Object} [opts={}] Options
     * @param {Number} [opts.at] Position index (by default the layer will be appended at the end).
     * @returns {[Layer]} Added layer.
     * @example
     * // Add new layer at the beginning of the stack with custom values
     * property.addLayer({ 'sub-prop1': 'value1', 'sub-prop2': 'value2' }, { at: 0 });
     */
    PropertyStack.prototype.addLayer = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        var values = {};
        this.getProperties().forEach(function (prop) {
            var key = prop.getId();
            var value = props[key];
            values[key] = (0,index_all.isUndefined)(value) ? prop.getDefaultValue() : value;
        });
        var layer = this.__getLayers().push({ values: values }, opts);
        return layer;
    };
    /**
     * Remove layer.
     * @param {[Layer]} layer Layer to remove.
     * @returns {[Layer]} Removed layer
     * @example
     * const layer = property.getLayer(0);
     * property.removeLayer(layer);
     */
    PropertyStack.prototype.removeLayer = function (layer) {
        return this.__getLayers().remove(layer);
    };
    /**
     * Remove layer by index.
     * @param {Number} index Index of the layer to remove
     * @returns {[Layer]|null} Removed layer
     * @example
     * property.removeLayerAt(0);
     */
    PropertyStack.prototype.removeLayerAt = function (index) {
        if (index === void 0) { index = 0; }
        var layer = this.getLayer(index);
        return layer ? this.removeLayer(layer) : null;
    };
    /**
     * Get the layer label. The label can be customized with the `layerLabel` property.
     * @param {[Layer]} layer
     * @returns {String}
     * @example
     * const layer = this.getLayer(1);
     * const label = this.getLayerLabel(layer);
     */
    PropertyStack.prototype.getLayerLabel = function (layer) {
        var result = '';
        if (layer) {
            var layerLabel = this.get('layerLabel');
            var values_1 = layer.getValues();
            var index = layer.getIndex();
            if (layerLabel) {
                result = layerLabel(layer, { index: index, values: values_1, property: this });
            }
            else {
                var parts_1 = [];
                this.getProperties().map(function (prop) {
                    parts_1.push(values_1[prop.getId()]);
                });
                result = parts_1.filter(Boolean).join(' ');
            }
        }
        return result;
    };
    /**
     * Get style object from the layer.
     * @param {[Layer]} layer
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.camelCase] Return property names in camelCase.
     * @param {Object} [opts.number] Limit the result of the number types, eg. `number: { min: -3, max: 3 }`
     * @returns {Object} Style object
     */
    PropertyStack.prototype.getStyleFromLayer = function (layer, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var join = this.__getJoin();
        var joinLayers = this.__getJoinLayers();
        var toStyle = this.get('toStyle');
        var name = this.getName();
        var values = layer.getValues();
        var style;
        if (toStyle) {
            style = toStyle(values, {
                join: join,
                joinLayers: joinLayers,
                name: name,
                layer: layer,
                property: this,
            });
        }
        else {
            var result = this.getProperties().map(function (prop) {
                var name = prop.getName();
                var val = values[prop.getId()];
                var value = (0,index_all.isUndefined)(val) ? prop.getDefaultValue() : val;
                // Limit number values if necessary (useful for previews)
                if (opts.number && isNumberType(prop.getType())) {
                    var newVal = prop.parseValue(val, opts.number);
                    value = "".concat(newVal.value).concat(newVal.unit);
                }
                return { name: name, value: value };
            });
            style = this.isDetached()
                ? result.reduce(function (acc, item) {
                    acc[item.name] = item.value;
                    return acc;
                }, {})
                : (_a = {},
                    _a[this.getName()] = result.map(function (r) { return r.value; }).join(join),
                    _a);
        }
        return opts.camelCase
            ? Object.keys(style).reduce(function (res, key) {
                res[(0,mixins.camelCase)(key)] = style[key];
                return res;
            }, {})
            : style;
    };
    /**
     * Get preview style object from the layer.
     * If the property has `preview: false` the returned object will be empty.
     * @param {[Layer]} layer
     * @param {Object} [opts={}] Options. Same of `getStyleFromLayer`
     * @returns {Object} Style object
     */
    PropertyStack.prototype.getStylePreview = function (layer, opts) {
        if (opts === void 0) { opts = {}; }
        var result = {};
        var preview = this.get('preview');
        if (preview) {
            result = this.getStyleFromLayer(layer, opts);
        }
        return result;
    };
    /**
     * Get layer separator.
     * @return {RegExp}
     */
    PropertyStack.prototype.getLayerSeparator = function () {
        var sep = this.get('layerSeparator');
        return (0,index_all.isString)(sep) ? new RegExp("".concat(sep, "(?![^\\(]*\\))")) : sep;
    };
    PropertyStack.prototype.__upProperties = function (prop, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var layer = this.getSelectedLayer();
        if (!layer)
            return;
        layer.upValues((_a = {}, _a[prop.getId()] = prop.__getFullValue(), _a));
        if (opts.__up)
            return;
        this.__upTargetsStyleProps(opts);
    };
    PropertyStack.prototype.__upLayers = function (m, c, o) {
        this.__upTargetsStyleProps(o || c);
    };
    PropertyStack.prototype.__upTargets = function (p, opts) {
        if (opts === void 0) { opts = {}; }
        if (opts.__select)
            return;
        return model_Property.prototype.__upTargets.call(this, p, opts);
    };
    PropertyStack.prototype.__upTargetsStyleProps = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.__upTargetsStyle(this.getStyleFromLayers(), opts);
    };
    PropertyStack.prototype.__upTargetsStyle = function (style, opts) {
        return model_Property.prototype.__upTargetsStyle.call(this, style, opts);
    };
    PropertyStack.prototype.__upSelected = function (_a, opts) {
        var _b = _a === void 0 ? {} : _a, noEvent = _b.noEvent;
        if (opts === void 0) { opts = {}; }
        var sm = this.em.Styles;
        var selected = this.getSelectedLayer();
        var values = selected === null || selected === void 0 ? void 0 : selected.getValues();
        // Update properties by layer value
        values &&
            this.getProperties().forEach(function (prop) {
                var _a;
                var value = (_a = values[prop.getId()]) !== null && _a !== void 0 ? _a : '';
                prop.__getFullValue() !== value && prop.upValue(value, PropertyStack_assign(PropertyStack_assign({}, opts), { __up: true }));
            });
        !noEvent && sm.__trgEv(sm.events.layerSelect, { property: this });
    };
    // @ts-ignore
    PropertyStack.prototype._up = function (props, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = props.__layers, __layers = _a === void 0 ? [] : _a, rest = PropertyStack_rest(props, ["__layers"]);
        // Detached props will update their layers later in sm.__upProp
        !this.isDetached() && this.__setLayers(__layers);
        this.__upSelected({ noEvent: true }, opts);
        model_Property.prototype._up.call(this, rest, opts);
        return this;
    };
    PropertyStack.prototype.__setLayers = function (newLayers) {
        if (newLayers === void 0) { newLayers = []; }
        var layers = this.__getLayers();
        var layersNew = newLayers.map(function (values) { return ({ values: values }); });
        if (layers.length === layersNew.length) {
            layersNew.map(function (layer, n) { var _a; return (_a = layers.at(n)) === null || _a === void 0 ? void 0 : _a.upValues(layer.values); });
        }
        else {
            this.__getLayers().reset(layersNew);
        }
        this.__upSelected({ noEvent: true });
    };
    PropertyStack.prototype.__parseValue = function (value) {
        var _this = this;
        var result = this.parseValue(value);
        result.__layers = value
            .split(VALUES_REG)
            .map(function (v) { return v.trim(); })
            .map(function (v) { return _this.__parseLayer(v); })
            .filter(Boolean);
        return result;
    };
    PropertyStack.prototype.__parseLayer = function (value) {
        var parseFn = this.get('parseLayer');
        var values = value.split(PARTS_REG);
        var properties = this.getProperties();
        return parseFn
            ? parseFn({ value: value, values: values })
            : properties.reduce(function (acc, prop, i) {
                var value = values[i];
                acc[prop.getId()] = !(0,index_all.isUndefined)(value) ? value : prop.getDefaultValue();
                return acc;
            }, {});
    };
    PropertyStack.prototype.__getLayersFromStyle = function (style) {
        var _this = this;
        if (style === void 0) { style = {}; }
        if (!this.__styleHasProps(style))
            return null;
        var name = this.getName();
        var props = this.getProperties();
        var sep = this.getLayerSeparator();
        var fromStyle = this.get('fromStyle');
        var result = fromStyle ? fromStyle(style, { property: this, name: name, separatorLayers: sep }) : [];
        if (!fromStyle) {
            // Get layers from the main property
            var layers_1 = this.__splitStyleName(style, name, sep)
                .map(function (value) { return value.split(_this.getSplitSeparator()); })
                .map(function (parts) {
                var result = {};
                props.forEach(function (prop, i) {
                    var value = parts[i];
                    result[prop.getId()] = !(0,index_all.isUndefined)(value) ? value : prop.getDefaultValue();
                });
                return result;
            });
            // Get layers from the inner properties
            props.forEach(function (prop) {
                var id = prop.getId();
                _this.__splitStyleName(style, prop.getName(), sep)
                    .map(function (value) {
                    var _a;
                    return (_a = {}, _a[id] = value || prop.getDefaultValue(), _a);
                })
                    .forEach(function (inLayer, i) {
                    layers_1[i] = layers_1[i] ? PropertyStack_assign(PropertyStack_assign({}, layers_1[i]), inLayer) : inLayer;
                });
            });
            result = layers_1;
        }
        return (0,index_all.isArray)(result) ? result : [result];
    };
    PropertyStack.prototype.getStyle = function (opts) {
        if (opts === void 0) { opts = {}; }
        return this.getStyleFromLayers(opts);
    };
    PropertyStack.prototype.getStyleFromLayers = function (opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var result = {};
        var name = this.getName();
        var layers = this.getLayers();
        var props = this.getProperties();
        var styles = layers.map(function (l) { return _this.getStyleFromLayer(l, opts); });
        styles.forEach(function (style) {
            (0,index_all.keys)(style).map(function (key) {
                if (!result[key]) {
                    // @ts-ignore
                    result[key] = [];
                }
                // @ts-ignore
                result[key].push(style[key]);
            });
        });
        (0,index_all.keys)(result).map(function (key) {
            // @ts-ignore
            result[key] = result[key].join(_this.__getJoinLayers());
        });
        if (this.isDetached()) {
            result[name] = '';
            !layers.length &&
                props.map(function (prop) {
                    result[prop.getName()] = '';
                });
        }
        else {
            var style = props.reduce(function (acc, prop) {
                acc[prop.getName()] = '';
                return acc;
            }, {});
            result[name] = result[name] || '';
            result = PropertyStack_assign(PropertyStack_assign({}, result), style);
        }
        return result;
    };
    PropertyStack.prototype.__getJoinLayers = function () {
        var join = this.get('layerJoin');
        var sep = this.get('layerSeparator');
        return join || ((0,index_all.isString)(sep) ? sep : join);
    };
    PropertyStack.prototype.__getFullValue = function () {
        if (this.get('detached'))
            return '';
        var style = this.getStyleFromLayers();
        return getLastStyleValue(style[this.getName()]);
    };
    /**
     * Extended
     * @private
     */
    PropertyStack.prototype.hasValue = function (opts) {
        if (opts === void 0) { opts = {}; }
        var noParent = opts.noParent;
        var parentValue = noParent && this.getParentTarget();
        return this.getLayers().length > 0 && !parentValue;
    };
    /**
     * Extended
     * @private
     */
    PropertyStack.prototype.clear = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.__getLayers().reset();
        this.__upTargetsStyleProps(opts);
        model_Property.prototype.clear.call(this);
        return this;
    };
    PropertyStack.prototype.__canClearProp = function () {
        return false;
    };
    return PropertyStack;
}(model_PropertyComposite));
/* harmony default export */ const model_PropertyStack = (PropertyStack);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyView.ts
var PropertyView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyView_assign = (undefined && undefined.__assign) || function () {
    PropertyView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyView_assign.apply(this, arguments);
};
var PropertyView_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var PropertyView_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



var clearProp = 'data-clear-style';
var PropertyView = /** @class */ (function (_super) {
    PropertyView_extends(PropertyView, _super);
    function PropertyView(o) {
        if (o === void 0) { o = {}; }
        var _this = _super.call(this, o) || this;
        (0,index_all.bindAll)(_this, '__change', '__updateStyle');
        // @ts-ignore
        var config = o.config || {};
        var em = config.em;
        _this.config = config;
        _this.em = em;
        _this.pfx = config.stylePrefix || '';
        _this.ppfx = config.pStylePrefix || '';
        _this.__destroyFn = _this.destroy ? _this.destroy.bind(_this) : function () { };
        var model = _this.model;
        // @ts-ignore
        model.view = _this;
        // Put a sligh delay on debounce in order to execute the update
        // post styleManager.__upProps trigger.
        _this.onValueChange = (0,index_all.debounce)(_this.onValueChange.bind(_this), 10);
        _this.updateStatus = (0,index_all.debounce)(_this.updateStatus.bind(_this), 0);
        _this.listenTo(model, 'destroy remove', _this.remove);
        _this.listenTo(model, 'change:visible', _this.updateVisibility);
        _this.listenTo(model, 'change:name change:className change:full', _this.render);
        _this.listenTo(model, 'change:value', _this.onValueChange);
        _this.listenTo(model, 'change:parentTarget', _this.updateStatus);
        _this.listenTo(em, 'change:device', _this.onValueChange);
        // @ts-ignore
        var init = _this.init && _this.init.bind(_this);
        init && init();
        return _this;
    }
    PropertyView.prototype.events = function () {
        var _a;
        return _a = {
                change: 'inputValueChanged'
            },
            _a["click [".concat(clearProp, "]")] = 'clear',
            _a;
    };
    PropertyView.prototype.template = function (model) {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx;
        return "\n      <div class=\"".concat(pfx, "label\" data-sm-label></div>\n      <div class=\"").concat(ppfx, "fields\" data-sm-fields></div>\n    ");
    };
    PropertyView.prototype.templateLabel = function (model) {
        var _a = this, pfx = _a.pfx, em = _a.em;
        var parent = model.parent;
        var _b = model.attributes, _c = _b.icon, icon = _c === void 0 ? '' : _c, _d = _b.info, info = _d === void 0 ? '' : _d;
        var icons = em === null || em === void 0 ? void 0 : em.getConfig().icons;
        var iconClose = (icons === null || icons === void 0 ? void 0 : icons.close) || '';
        return "\n      <span class=\"".concat(pfx, "icon ").concat(icon, "\" title=\"").concat(info, "\">\n        ").concat(model.getLabel(), "\n      </span>\n      ").concat(!parent ? "<div class=\"".concat(pfx, "clear\" style=\"display: none\" ").concat(clearProp, ">").concat(iconClose, "</div>") : '', "\n    ");
    };
    PropertyView.prototype.templateInput = function (model) {
        return "\n      <div class=\"".concat(this.ppfx, "field\">\n        <input placeholder=\"").concat(model.getDefaultValue(), "\"/>\n      </div>\n    ");
    };
    PropertyView.prototype.remove = function () {
        var _this = this;
        common/* View */.G7.prototype.remove.apply(this, arguments);
        // @ts-ignore
        ['em', 'input', '$input', 'view'].forEach(function (i) { return (_this[i] = null); });
        this.__destroyFn(this._getClbOpts());
        return this;
    };
    /**
     * Triggers when the status changes. The status indicates if the value of
     * the proprerty is changed or inherited
     * @private
     */
    PropertyView.prototype.updateStatus = function () {
        var _a;
        var _b = this, model = _b.model, pfx = _b.pfx, ppfx = _b.ppfx, config = _b.config;
        var updatedCls = "".concat(ppfx, "four-color");
        var computedCls = "".concat(ppfx, "color-warn");
        var labelEl = this.$el.children(".".concat(pfx, "label"));
        var clearStyleEl = this.getClearEl();
        var clearStyle = clearStyleEl ? clearStyleEl.style : {};
        labelEl.removeClass("".concat(updatedCls, " ").concat(computedCls));
        clearStyle.display = 'none';
        if (model.hasValue({ noParent: true }) && config.highlightChanged) {
            labelEl.addClass(updatedCls);
            config.clearProperties && (clearStyle.display = '');
        }
        else if (model.hasValue() && config.highlightComputed) {
            labelEl.addClass(computedCls);
        }
        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.updateStatus();
    };
    /**
     * Clear the property from the target
     */
    PropertyView.prototype.clear = function (ev) {
        ev && ev.stopPropagation();
        this.model.clear();
    };
    /**
     * Get clear element
     * @return {HTMLElement}
     */
    PropertyView.prototype.getClearEl = function () {
        if (!this.clearEl) {
            this.clearEl = this.el.querySelector("[".concat(clearProp, "]"));
        }
        return this.clearEl;
    };
    /**
     * Triggers when the value of element input/s is changed, so have to update
     * the value of the model which will propogate those changes to the target
     */
    PropertyView.prototype.inputValueChanged = function (ev) {
        ev && ev.stopPropagation();
        // Skip the default update in case a custom emit method is defined
        if (this.emit)
            return;
        this.model.upValue(ev.target.value);
    };
    PropertyView.prototype.onValueChange = function (m, val, opt) {
        if (opt === void 0) { opt = {}; }
        this.setValue(this.model.getFullValue(undefined, { skipImportant: true }));
        this.updateStatus();
    };
    /**
     * Update the element input.
     * Usually the value is a result of `model.getFullValue()`
     * @param {String} value The value from the model
     * */
    PropertyView.prototype.setValue = function (value) {
        var model = this.model;
        var result = (0,index_all.isUndefined)(value) || value === '' ? model.getDefaultValue() : value;
        if (this.update)
            return this.__update(result);
        this.__setValueInput(result);
    };
    PropertyView.prototype.__setValueInput = function (value) {
        var input = this.getInputEl();
        input && (input.value = value);
    };
    PropertyView.prototype.getInputEl = function () {
        if (!this.input) {
            this.input = this.el.querySelector('input');
        }
        return this.input;
    };
    PropertyView.prototype.updateVisibility = function () {
        this.el.style.display = this.model.isVisible() ? '' : 'none';
    };
    PropertyView.prototype.clearCached = function () {
        delete this.clearEl;
        delete this.input;
        delete this.$input;
    };
    PropertyView.prototype.__unset = function () {
        var unset = this.unset && this.unset.bind(this);
        unset && unset(this._getClbOpts());
    };
    PropertyView.prototype.__update = function (value) {
        var update = this.update && this.update.bind(this);
        update &&
            update(PropertyView_assign(PropertyView_assign({}, this._getClbOpts()), { value: value }));
    };
    PropertyView.prototype.__change = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var emit = this.emit && this.emit.bind(this);
        emit && emit.apply(void 0, PropertyView_spreadArray([this._getClbOpts()], args, false));
    };
    PropertyView.prototype.__updateStyle = function (value, _a) {
        if (_a === void 0) { _a = {}; }
        var complete = _a.complete, partial = _a.partial, opts = PropertyView_rest(_a, ["complete", "partial"]);
        var model = this.model;
        var final = complete !== false && partial !== true;
        if ((0,mixins.isObject)(value)) {
            model.__upTargetsStyle(value, { avoidStore: !final });
        }
        else {
            model.upValue(value, { partial: !final });
        }
    };
    PropertyView.prototype._getClbOpts = function () {
        var _a = this, model = _a.model, el = _a.el, createdEl = _a.createdEl;
        return {
            el: el,
            createdEl: createdEl,
            property: model,
            props: model.attributes,
            change: this.__change,
            updateStyle: this.__updateStyle,
        };
    };
    PropertyView.prototype.render = function () {
        this.clearCached();
        var _a = this, pfx = _a.pfx, model = _a.model, el = _a.el, $el = _a.$el;
        var name = model.getName();
        var type = model.getType();
        var cls = model.get('className') || '';
        var className = "".concat(pfx, "property");
        // Support old integer classname
        var clsType = type === 'number' ? "".concat(pfx).concat(type, " ").concat(pfx, "integer") : "".concat(pfx).concat(type);
        this.createdEl && this.__destroyFn(this._getClbOpts());
        $el.empty().append(this.template(model));
        $el.find('[data-sm-label]').append(this.templateLabel(model));
        var create = this.create && this.create.bind(this);
        this.createdEl = create && create(this._getClbOpts());
        $el.find('[data-sm-fields]').append(this.createdEl || this.templateInput(model));
        el.className = "".concat(className, " ").concat(clsType, " ").concat(className, "__").concat(name, " ").concat(cls).trim();
        el.className += model.isFull() ? " ".concat(className, "--full") : '';
        var onRender = this.onRender && this.onRender.bind(this);
        onRender && onRender();
        this.setValue(model.getValue());
        return this;
    };
    PropertyView.prototype.onRender = function () { };
    return PropertyView;
}(common/* View */.G7));
/* harmony default export */ const view_PropertyView = (PropertyView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertiesView.ts
var PropertiesView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PropertiesView = /** @class */ (function (_super) {
    PropertiesView_extends(PropertiesView, _super);
    function PropertiesView(o) {
        var _this = _super.call(this, o) || this;
        _this.config = o.config || {};
        _this.pfx = _this.config.stylePrefix || '';
        _this.properties = [];
        _this.parent = o.parent;
        var coll = _this.collection;
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset', _this.render);
        return _this;
    }
    PropertiesView.prototype.addTo = function (model, coll, opts) {
        this.add(model, null, opts);
    };
    PropertiesView.prototype.add = function (model, frag, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, parent = _a.parent, config = _a.config;
        var appendTo = frag || this.el;
        var view = new model.typeView({ model: model, config: config });
        parent && (view.parent = parent);
        view.render();
        var rendered = view.el;
        this.properties.push(view);
        (0,dom/* appendAtIndex */.$Q)(appendTo, rendered, opts.at);
    };
    PropertiesView.prototype.remove = function () {
        common/* View */.G7.prototype.remove.apply(this, arguments);
        this.clearItems();
        return this;
    };
    PropertiesView.prototype.clearItems = function () {
        this.properties.forEach(function (item) { return item.remove(); });
        this.properties = [];
    };
    PropertiesView.prototype.render = function () {
        var _this = this;
        var _a = this, $el = _a.$el, pfx = _a.pfx;
        this.clearItems();
        var fragment = document.createDocumentFragment();
        this.collection.forEach(function (model) { return _this.add(model, fragment); });
        $el.empty();
        $el.append(fragment);
        $el.attr('class', "".concat(pfx, "properties"));
        return this;
    };
    return PropertiesView;
}(common/* View */.G7));
/* harmony default export */ const view_PropertiesView = (PropertiesView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyCompositeView.ts
var PropertyCompositeView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyCompositeView_assign = (undefined && undefined.__assign) || function () {
    PropertyCompositeView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyCompositeView_assign.apply(this, arguments);
};


var PropertyCompositeView = /** @class */ (function (_super) {
    PropertyCompositeView_extends(PropertyCompositeView, _super);
    function PropertyCompositeView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyCompositeView.prototype.templateInput = function () {
        var pfx = this.pfx;
        return "\n      <div class=\"".concat(pfx, "field ").concat(pfx, "composite\">\n        <span id=\"").concat(pfx, "input-holder\"></span>\n      </div>\n    ");
    };
    PropertyCompositeView.prototype.remove = function () {
        var _a;
        (_a = this.props) === null || _a === void 0 ? void 0 : _a.remove();
        view_PropertyView.prototype.remove.apply(this, arguments);
        return this;
    };
    PropertyCompositeView.prototype.onValueChange = function () { };
    PropertyCompositeView.prototype.onRender = function () {
        var pfx = this.pfx;
        var model = this.model;
        var props = model.get('properties');
        if (props.length && !this.props) {
            var detached = model.isDetached();
            var propsView = new view_PropertiesView({
                config: PropertyCompositeView_assign(PropertyCompositeView_assign({}, this.config), { highlightComputed: detached, highlightChanged: detached }),
                // @ts-ignore
                collection: props,
                parent: this,
            });
            propsView.render();
            this.$el.find("#".concat(pfx, "input-holder")).append(propsView.el);
            this.props = propsView;
        }
    };
    PropertyCompositeView.prototype.clearCached = function () {
        view_PropertyView.prototype.clearCached.apply(this, arguments);
        delete this.props;
    };
    return PropertyCompositeView;
}(view_PropertyView));
/* harmony default export */ const view_PropertyCompositeView = (PropertyCompositeView);

;// CONCATENATED MODULE: ./src/style_manager/view/LayerView.ts
var LayerView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var LayerView_LayerView = /** @class */ (function (_super) {
    LayerView_extends(LayerView, _super);
    function LayerView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LayerView.prototype.events = function () {
        return {
            click: 'select',
            'click [data-close-layer]': 'removeItem',
            'mousedown [data-move-layer]': 'initSorter',
            'touchstart [data-move-layer]': 'initSorter',
        };
    };
    LayerView.prototype.template = function () {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx, em = _a.em;
        var icons = em === null || em === void 0 ? void 0 : em.getConfig().icons;
        var iconClose = (icons === null || icons === void 0 ? void 0 : icons.close) || '';
        var iconMove = (icons === null || icons === void 0 ? void 0 : icons.move) || '';
        return "\n      <div class=\"".concat(pfx, "label-wrp\">\n        <div id=\"").concat(pfx, "move\" class=\"").concat(ppfx, "no-touch-actions\" data-move-layer>\n          ").concat(iconMove, "\n        </div>\n        <div id=\"").concat(pfx, "label\" data-label></div>\n        <div id=\"").concat(pfx, "preview-box\" class=\"").concat(pfx, "layer-preview\" style=\"display: none\" data-preview-box>\n          <div id=\"").concat(pfx, "preview\" class=\"").concat(pfx, "layer-preview-cnt\" data-preview></div>\n        </div>\n        <div id=\"").concat(pfx, "close-layer\" class=\"").concat(pfx, "btn-close\" data-close-layer>\n          ").concat(iconClose, "\n        </div>\n      </div>\n      <div id=\"").concat(pfx, "inputs\" data-properties></div>\n    ");
    };
    LayerView.prototype.initialize = function (o) {
        if (o === void 0) { o = {}; }
        var model = this.model;
        var config = o.config || {};
        this.em = config.em;
        this.config = config;
        this.sorter = o.sorter;
        this.pfx = config.stylePrefix || '';
        this.ppfx = config.pStylePrefix || '';
        this.propertyView = o.propertyView;
        var pModel = this.propertyView.model;
        this.listenTo(model, 'destroy remove', this.remove);
        this.listenTo(model, 'change:values', this.updateLabel);
        this.listenTo(pModel, 'change:selectedLayer', this.updateVisibility);
        // For the sorter
        model.view = this;
        // @ts-ignore
        model.set({ droppable: 0, draggable: 1 });
        this.$el.data('model', model);
    };
    LayerView.prototype.initSorter = function () {
        var _a;
        (_a = this.sorter) === null || _a === void 0 ? void 0 : _a.startSort(this.el);
    };
    LayerView.prototype.removeItem = function (ev) {
        ev && ev.stopPropagation();
        this.model.remove();
    };
    LayerView.prototype.select = function () {
        this.model.select();
    };
    LayerView.prototype.getPropertiesWrapper = function () {
        if (!this.propsWrapEl)
            this.propsWrapEl = this.el.querySelector('[data-properties]');
        return this.propsWrapEl;
    };
    LayerView.prototype.getPreviewEl = function () {
        if (!this.previewEl)
            this.previewEl = this.el.querySelector('[data-preview]');
        return this.previewEl;
    };
    LayerView.prototype.getLabelEl = function () {
        if (!this.labelEl)
            this.labelEl = this.el.querySelector('[data-label]');
        return this.labelEl;
    };
    LayerView.prototype.updateLabel = function () {
        var model = this.model;
        var label = model.getLabel();
        this.getLabelEl().innerHTML = label;
        if (model.hasPreview()) {
            var prvEl = this.getPreviewEl();
            var style_1 = model.getStylePreview({ number: { min: -3, max: 3 } });
            var styleStr = (0,index_all.keys)(style_1)
                .map(function (k) { return "".concat(k, ":").concat(style_1[k]); })
                .join(';');
            prvEl.setAttribute('style', styleStr);
        }
    };
    LayerView.prototype.updateVisibility = function () {
        var _a;
        var _b = this, pfx = _b.pfx, model = _b.model, propertyView = _b.propertyView;
        var wrapEl = this.getPropertiesWrapper();
        var isSelected = model.isSelected();
        wrapEl.style.display = isSelected ? '' : 'none';
        this.$el[isSelected ? 'addClass' : 'removeClass']("".concat(pfx, "active"));
        isSelected && wrapEl.appendChild((_a = propertyView.props) === null || _a === void 0 ? void 0 : _a.el);
    };
    LayerView.prototype.render = function () {
        var _a = this, el = _a.el, pfx = _a.pfx, model = _a.model;
        el.innerHTML = this.template();
        el.className = "".concat(pfx, "layer");
        if (model.hasPreview()) {
            el.querySelector('[data-preview-box]').style.display = '';
        }
        this.updateLabel();
        this.updateVisibility();
        return this;
    };
    return LayerView;
}(common/* View */.G7));
/* harmony default export */ const view_LayerView = (LayerView_LayerView);

;// CONCATENATED MODULE: ./src/style_manager/view/LayersView.ts
var LayersView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var LayersView = /** @class */ (function (_super) {
    LayersView_extends(LayersView, _super);
    function LayersView(o) {
        var _this = _super.call(this, o) || this;
        var coll = _this.collection;
        var config = o.config || {};
        var em = config.em;
        var pfx = config.stylePrefix || '';
        var ppfx = config.pStylePrefix || '';
        _this.config = config;
        _this.pfx = pfx;
        _this.ppfx = ppfx;
        _this.propertyView = o.propertyView;
        _this.className = "".concat(pfx, "layers ").concat(ppfx, "field");
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset', _this.reset);
        _this.items = [];
        // For the Sorter
        var utils = em === null || em === void 0 ? void 0 : em.Utils;
        _this.sorter = utils
            ? new utils.Sorter({
                // @ts-ignore
                container: _this.el,
                ignoreViewChildren: 1,
                containerSel: ".".concat(pfx, "layers"),
                itemSel: ".".concat(pfx, "layer"),
                pfx: config.pStylePrefix,
                em: em,
            })
            : '';
        // @ts-ignore
        coll.view = _this;
        _this.$el.data('model', coll);
        _this.$el.data('collection', coll);
        return _this;
    }
    LayersView.prototype.addTo = function (model) {
        var i = this.collection.indexOf(model);
        this.addToCollection(model, null, i);
    };
    LayersView.prototype.addToCollection = function (model, fragmentEl, index) {
        var fragment = fragmentEl || null;
        var _a = this, propertyView = _a.propertyView, config = _a.config, sorter = _a.sorter, $el = _a.$el;
        var view = new view_LayerView({
            model: model,
            // @ts-ignore
            config: config,
            sorter: sorter,
            propertyView: propertyView,
        });
        var rendered = view.render().el;
        this.items.push(view);
        if (fragment) {
            fragment.appendChild(rendered);
        }
        else {
            if (typeof index != 'undefined') {
                var method = 'before';
                if ($el.children().length === index) {
                    index--;
                    method = 'after';
                }
                if (index < 0) {
                    $el.append(rendered);
                }
                else {
                    // @ts-ignore
                    $el.children().eq(index)[method](rendered);
                }
            }
            else {
                $el.append(rendered);
            }
        }
        return rendered;
    };
    LayersView.prototype.reset = function (coll, opts) {
        this.clearItems();
        this.render();
    };
    LayersView.prototype.remove = function () {
        this.clearItems();
        common/* View */.G7.prototype.remove.apply(this, arguments);
        return this;
    };
    LayersView.prototype.clearItems = function () {
        this.items.forEach(function (item) { return item.remove(); });
        this.items = [];
    };
    LayersView.prototype.render = function () {
        var _this = this;
        var _a = this, $el = _a.$el, sorter = _a.sorter;
        var frag = document.createDocumentFragment();
        $el.empty();
        this.collection.forEach(function (m) { return _this.addToCollection(m, frag); });
        $el.append(frag);
        $el.attr('class', this.className);
        if (sorter)
            sorter.plh = null;
        return this;
    };
    return LayersView;
}(common/* View */.G7));
/* harmony default export */ const view_LayersView = (LayersView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyStackView.ts
var PropertyStackView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyStackView_assign = (undefined && undefined.__assign) || function () {
    PropertyStackView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyStackView_assign.apply(this, arguments);
};



var PropertyStackView = /** @class */ (function (_super) {
    PropertyStackView_extends(PropertyStackView, _super);
    function PropertyStackView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyStackView.prototype.events = function () {
        return PropertyStackView_assign(PropertyStackView_assign({}, view_PropertyCompositeView.prototype.events()), { 'click [data-add-layer]': 'addLayer', change: '' });
    };
    PropertyStackView.prototype.templateInput = function () {
        var _a = this, pfx = _a.pfx, em = _a.em;
        var icons = em === null || em === void 0 ? void 0 : em.getConfig().icons;
        var iconPlus = (icons === null || icons === void 0 ? void 0 : icons.plus) || '+';
        return "\n      <div class=\"".concat(pfx, "field ").concat(pfx, "stack\">\n        <button type=\"button\" id=\"").concat(pfx, "add\" data-add-layer>\n          ").concat(iconPlus, "\n        </button>\n        <div data-layers-wrapper></div>\n      </div>\n    ");
    };
    PropertyStackView.prototype.init = function () {
        var model = this.model;
        this.listenTo(model.__getLayers(), 'change reset', this.updateStatus);
    };
    PropertyStackView.prototype.addLayer = function () {
        this.model.addLayer({}, { at: 0 });
    };
    /**
     * There is no need to handle input update by the property itself,
     * this will be done by layers
     * @private
     */
    PropertyStackView.prototype.setValue = function () { };
    PropertyStackView.prototype.remove = function () {
        var _a;
        (_a = this.layersView) === null || _a === void 0 ? void 0 : _a.remove();
        view_PropertyCompositeView.prototype.remove.apply(this, arguments);
        return this;
    };
    PropertyStackView.prototype.clearCached = function () {
        view_PropertyCompositeView.prototype.clearCached.apply(this, arguments);
        delete this.layersView;
    };
    PropertyStackView.prototype.onRender = function () {
        var _a = this, model = _a.model, el = _a.el, config = _a.config;
        var props = model.get('properties');
        if (props.length && !this.props) {
            var propsView = new view_PropertiesView({
                config: PropertyStackView_assign(PropertyStackView_assign({}, config), { highlightComputed: false, highlightChanged: false }),
                // @ts-ignore
                collection: props,
                parent: this,
            });
            propsView.render();
            var layersView = new view_LayersView({
                collection: model.__getLayers(),
                // @ts-ignore
                config: config,
                propertyView: this,
            });
            layersView.render();
            var fieldEl = el.querySelector('[data-layers-wrapper]');
            fieldEl.appendChild(layersView.el);
            this.props = propsView;
            this.layersView = layersView;
        }
    };
    return PropertyStackView;
}(view_PropertyCompositeView));
/* harmony default export */ const view_PropertyStackView = (PropertyStackView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyFileView.ts
var PropertyFileView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyFileView_assign = (undefined && undefined.__assign) || function () {
    PropertyFileView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyFileView_assign.apply(this, arguments);
};


var PropertyFileView = /** @class */ (function (_super) {
    PropertyFileView_extends(PropertyFileView, _super);
    function PropertyFileView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyFileView.prototype.events = function () {
        return PropertyFileView_assign(PropertyFileView_assign({}, view_PropertyView.prototype.events()), { 'click [data-clear-asset]': 'clear', 'click [data-open-assets]': 'openAssetManager' });
    };
    PropertyFileView.prototype.templateInput = function () {
        var _a;
        var _b = this, pfx = _b.pfx, em = _b.em;
        var icons = (_a = this.em) === null || _a === void 0 ? void 0 : _a.getConfig().icons;
        var iconClose = icons === null || icons === void 0 ? void 0 : icons.close;
        return "\n      <div class=\"".concat(pfx, "field ").concat(pfx, "file\">\n        <div id='").concat(pfx, "input-holder'>\n          <div class=\"").concat(pfx, "btn-c\">\n            <button class=\"").concat(pfx, "btn\" id=\"").concat(pfx, "images\" type=\"button\" data-open-assets>\n              ").concat(em.t('styleManager.fileButton'), "\n            </button>\n          </div>\n          <div style=\"clear:both;\"></div>\n        </div>\n        <div id=\"").concat(pfx, "preview-box\" class=\"").concat(pfx, "preview-file\" data-preview-box>\n          <div id=\"").concat(pfx, "preview-file\" class=\"").concat(pfx, "preview-file-cnt\" data-preview></div>\n          <div id=\"").concat(pfx, "close\" class=\"").concat(pfx, "preview-file-close\" data-clear-asset>").concat(iconClose, "</div>\n        </div>\n      </div>\n    ");
    };
    PropertyFileView.prototype.__setValueInput = function (value) {
        var _a = this, model = _a.model, el = _a.el;
        var valueDef = model.getDefaultValue();
        var prvBoxEl = el.querySelector('[data-preview-box]');
        var prvEl = el.querySelector('[data-preview]');
        prvBoxEl.style.display = !value || value === valueDef ? 'none' : '';
        prvEl.style.backgroundImage = value || model.getDefaultValue();
    };
    PropertyFileView.prototype.openAssetManager = function () {
        var _this = this;
        var _a;
        var am = (_a = this.em) === null || _a === void 0 ? void 0 : _a.Assets;
        am === null || am === void 0 ? void 0 : am.open({
            select: function (asset, complete) {
                var url = (0,index_all.isString)(asset) ? asset : asset.get('src');
                _this.model.upValue(url, { partial: !complete });
                complete && am.close();
            },
            types: ['image'],
            accept: 'image/*',
        });
    };
    return PropertyFileView;
}(view_PropertyView));
/* harmony default export */ const view_PropertyFileView = (PropertyFileView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyNumberView.ts
var PropertyNumberView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PropertyNumberView = /** @class */ (function (_super) {
    PropertyNumberView_extends(PropertyNumberView, _super);
    function PropertyNumberView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyNumberView.prototype.templateInput = function (m) {
        return '';
    };
    PropertyNumberView.prototype.init = function () {
        var model = this.model;
        this.listenTo(model, 'change:unit', this.onValueChange);
        this.listenTo(model, 'change:units', this.render);
    };
    PropertyNumberView.prototype.setValue = function (v) {
        // handled by this.inputInst
    };
    PropertyNumberView.prototype.onRender = function () {
        var _a = this, ppfx = _a.ppfx, model = _a.model, el = _a.el;
        if (!this.inputInst) {
            var input = model.input;
            input.ppfx = ppfx;
            input.render();
            var fields = el.querySelector(".".concat(ppfx, "fields"));
            fields.appendChild(input.el);
            this.input = input.inputEl.get(0);
            this.inputInst = input;
        }
    };
    PropertyNumberView.prototype.clearCached = function () {
        view_PropertyView.prototype.clearCached.apply(this, arguments);
        this.inputInst = null;
    };
    return PropertyNumberView;
}(view_PropertyView));
/* harmony default export */ const view_PropertyNumberView = (PropertyNumberView);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyColorView.ts
var PropertyColorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var PropertyColorView = /** @class */ (function (_super) {
    PropertyColorView_extends(PropertyColorView, _super);
    function PropertyColorView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyColorView.prototype.setValue = function (value) {
        var _a;
        (_a = this.inputInst) === null || _a === void 0 ? void 0 : _a.setValue(value, {
            fromTarget: 1,
            def: this.model.getDefaultValue(),
        });
    };
    PropertyColorView.prototype.remove = function () {
        var _this = this;
        view_PropertyNumberView.prototype.remove.apply(this, arguments);
        var inp = this.inputInst;
        inp && inp.remove && inp.remove();
        // @ts-ignore
        ['inputInst', '$color'].forEach(function (i) { return (_this[i] = null); });
        return this;
    };
    PropertyColorView.prototype.__handleChange = function (value, partial) {
        this.model.upValue(value, { partial: partial });
    };
    PropertyColorView.prototype.onRender = function () {
        var _a;
        if (!this.inputInst) {
            this.__handleChange = this.__handleChange.bind(this);
            var _b = this, ppfx = _b.ppfx, model = _b.model, em = _b.em, el = _b.el;
            var inputColor = new ui_InputColor({
                target: em,
                model: model,
                ppfx: ppfx,
                onChange: this.__handleChange,
            });
            var input = inputColor.render();
            el.querySelector(".".concat(ppfx, "fields")).appendChild(input.el);
            this.input = (_a = input.inputEl) === null || _a === void 0 ? void 0 : _a.get(0);
            this.inputInst = input;
        }
    };
    return PropertyColorView;
}(view_PropertyNumberView));
/* harmony default export */ const view_PropertyColorView = (PropertyColorView);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertySelect.ts
var PropertySelect_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertySelect_assign = (undefined && undefined.__assign) || function () {
    PropertySelect_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertySelect_assign.apply(this, arguments);
};
var PropertySelect_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



/**
 * @typedef PropertySelect
 * @property {Array<Object>} options Array of option definitions.
 * \n
 * ```js
 * options: [
 *  { id: '100', label: 'Set 100' },
 *  { id: '200', label: 'Set 200' },
 * ]
 * ```
 */
var PropertySelect = /** @class */ (function (_super) {
    PropertySelect_extends(PropertySelect, _super);
    function PropertySelect() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertySelect.prototype.defaults = function () {
        return PropertySelect_assign(PropertySelect_assign({}, model_Property.getDefaults()), { options: [], full: 0 });
    };
    /**
     * Get available options.
     * @returns {Array<Object>} Array of options
     */
    PropertySelect.prototype.getOptions = function () {
        // support old list property
        var _a = this.attributes, options = _a.options, list = _a.list;
        return (options && options.length ? options : list) || [];
    };
    /**
     * Get current selected option or by id.
     * @param {String} [id] Option id.
     * @returns {Object | null}
     */
    PropertySelect.prototype.getOption = function (id) {
        var _this = this;
        var idSel = (0,mixins.isDef)(id) ? id : this.getValue();
        return this.getOptions().filter(function (o) { return _this.getOptionId(o) === idSel; })[0] || null;
    };
    /**
     * Update options.
     * @param {Array<Object>} value New array of options, eg. `[{ id: 'val-1', label: 'Value 1' }]`
     */
    PropertySelect.prototype.setOptions = function (value) {
        if (value === void 0) { value = []; }
        this.set('options', value);
        return this;
    };
    /**
     * Add new option.
     * @param {Object} value Option object, eg. `{ id: 'val-1', label: 'Value 1' }`
     */
    PropertySelect.prototype.addOption = function (value) {
        if (value) {
            var opts = this.getOptions();
            this.setOptions(PropertySelect_spreadArray(PropertySelect_spreadArray([], opts, true), [value], false));
        }
        return this;
    };
    /**
     * Get the option id from the option object.
     * @param {Object} option Option object
     * @returns {String} Option id
     */
    PropertySelect.prototype.getOptionId = function (option) {
        return (0,mixins.isDef)(option.id) ? option.id : option.value;
    };
    /**
     * Get option label.
     * @param {String|Object} id Option id or the option object
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.locale=true] Use the locale string from i18n module
     * @returns {String} Option label
     */
    PropertySelect.prototype.getOptionLabel = function (id, opts) {
        var _a;
        if (opts === void 0) { opts = {}; }
        var _b = opts.locale, locale = _b === void 0 ? true : _b;
        var option = ((0,index_all.isString)(id) ? this.getOption(id) : id) || {};
        var optId = this.getOptionId(option);
        var label = option.label || option.name || optId;
        var propId = opts.property || this.getId();
        return (locale && ((_a = this.em) === null || _a === void 0 ? void 0 : _a.t("styleManager.options.".concat(propId, ".").concat(optId)))) || label;
    };
    PropertySelect.prototype.initialize = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        model_Property.prototype.initialize.apply(this, args);
        this.listenTo(this, 'change:options', this.__onOptionChange);
    };
    PropertySelect.prototype.__onOptionChange = function () {
        this.set('list', this.get('options'));
    };
    return PropertySelect;
}(model_Property));
/* harmony default export */ const model_PropertySelect = (PropertySelect);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertySelectView.ts
var PropertySelectView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PropertySelectView = /** @class */ (function (_super) {
    PropertySelectView_extends(PropertySelectView, _super);
    function PropertySelectView(o) {
        var _this = _super.call(this, o) || this;
        _this.listenTo(_this.model, 'change:options', _this.updateOptions);
        return _this;
    }
    PropertySelectView.prototype.templateInput = function () {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx;
        return "\n      <div class=\"".concat(ppfx, "field ").concat(ppfx, "select\">\n        <span id=\"").concat(pfx, "input-holder\"></span>\n        <div class=\"").concat(ppfx, "sel-arrow\">\n          <div class=\"").concat(ppfx, "d-s-arrow\"></div>\n        </div>\n      </div>\n    ");
    };
    PropertySelectView.prototype.updateOptions = function () {
        delete this.input;
        this.onRender();
    };
    PropertySelectView.prototype.onRender = function () {
        var pfx = this.pfx;
        var model = this.model;
        var options = model.getOptions();
        if (!this.input) {
            var optionsRes_1 = [];
            options.forEach(function (option) {
                var id = model.getOptionId(option);
                var name = model.getOptionLabel(id);
                var style = option.style ? option.style.replace(/"/g, '&quot;') : '';
                var styleAttr = style ? "style=\"".concat(style, "\"") : '';
                var value = id.replace(/"/g, '&quot;');
                optionsRes_1.push("<option value=\"".concat(value, "\" ").concat(styleAttr, ">").concat(name, "</option>"));
            });
            var inputH = this.el.querySelector("#".concat(pfx, "input-holder"));
            inputH.innerHTML = "<select>".concat(optionsRes_1.join(''), "</select>");
            this.input = inputH.firstChild;
        }
    };
    PropertySelectView.prototype.__setValueInput = function (value) {
        var model = this.model;
        var input = this.getInputEl();
        var firstOpt = model.getOptions()[0];
        var firstId = firstOpt ? model.getOptionId(firstOpt) : '';
        input && (input.value = value || firstId);
    };
    return PropertySelectView;
}(view_PropertyView));
/* harmony default export */ const view_PropertySelectView = (PropertySelectView);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertyRadio.ts
var PropertyRadio_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyRadio_assign = (undefined && undefined.__assign) || function () {
    PropertyRadio_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyRadio_assign.apply(this, arguments);
};

var PropertyRadio = /** @class */ (function (_super) {
    PropertyRadio_extends(PropertyRadio, _super);
    function PropertyRadio() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyRadio.prototype.defaults = function () {
        return PropertyRadio_assign(PropertyRadio_assign({}, model_PropertySelect.getDefaults()), { full: 1 });
    };
    return PropertyRadio;
}(model_PropertySelect));
/* harmony default export */ const model_PropertyRadio = (PropertyRadio);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertyRadioView.ts
var PropertyRadioView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();

var PropertyRadioView = /** @class */ (function (_super) {
    PropertyRadioView_extends(PropertyRadioView, _super);
    function PropertyRadioView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyRadioView.prototype.templateInput = function () {
        var ppfx = this.ppfx;
        return "<div class=\"".concat(ppfx, "field ").concat(ppfx, "field-radio\"></div>");
    };
    PropertyRadioView.prototype.onRender = function () {
        var _a = this, pfx = _a.pfx, ppfx = _a.ppfx;
        var model = this.model;
        var itemCls = "".concat(ppfx, "radio-item-label");
        var prop = model.getName();
        var options = model.getOptions();
        var clsInput = "".concat(pfx, "radio ").concat(pfx, "radio-").concat(prop);
        var cid = model.cid;
        if (!this.input) {
            var optionsRes_1 = [];
            options.forEach(function (opt) {
                var cls = opt.className ? "".concat(opt.className, " ").concat(pfx, "icon ").concat(itemCls) : '';
                var id = model.getOptionId(opt);
                var elId = "".concat(prop, "-").concat(id, "-").concat(cid);
                var labelEl = cls ? '' : model.getOptionLabel(id);
                var titleAttr = opt.title ? "title=\"".concat(opt.title, "\"") : '';
                var checked = model.getValue() === id ? 'checked' : '';
                optionsRes_1.push("\n          <div class=\"".concat(ppfx, "radio-item\">\n            <input type=\"radio\" class=\"").concat(clsInput, "\" id=\"").concat(elId, "\" name=\"").concat(prop, "-").concat(cid, "\" value=\"").concat(id, "\" ").concat(checked, "/>\n            <label class=\"").concat(cls || itemCls, "\" ").concat(titleAttr, " for=\"").concat(elId, "\">").concat(labelEl, "</label>\n          </div>\n        "));
            });
            var inputHld = this.el.querySelector(".".concat(ppfx, "field"));
            inputHld.innerHTML = "<div class=\"".concat(ppfx, "radio-items\">").concat(optionsRes_1.join(''), "</div>");
            this.input = inputHld.firstChild;
        }
    };
    PropertyRadioView.prototype.__setValueInput = function (value) {
        var _a;
        var model = this.model;
        var id = value || model.getDefaultValue();
        var inputIn = (_a = this.getInputEl()) === null || _a === void 0 ? void 0 : _a.querySelector("[value=\"".concat(id, "\"]"));
        inputIn && (inputIn.checked = true);
    };
    return PropertyRadioView;
}(view_PropertySelectView));
/* harmony default export */ const view_PropertyRadioView = (PropertyRadioView);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertyNumber.ts
var PropertyNumber_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertyNumber_assign = (undefined && undefined.__assign) || function () {
    PropertyNumber_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyNumber_assign.apply(this, arguments);
};




/**
 * @typedef PropertyNumber
 * @property {Array<String>} units Array of units, eg. `['px', '%']`
 * @property {Number} min Minimum value.
 * @property {Number} max Maximum value.
 * @property {Number} step Step value.
 *
 */
var PropertyNumber = /** @class */ (function (_super) {
    PropertyNumber_extends(PropertyNumber, _super);
    function PropertyNumber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertyNumber.prototype.defaults = function () {
        return PropertyNumber_assign(PropertyNumber_assign({}, model_Property.getDefaults()), { units: [], unit: '', min: '', max: '', step: 1 });
    };
    /**
     * Get property units.
     * @returns {Array<String>}
     */
    PropertyNumber.prototype.getUnits = function () {
        return this.get('units') || [];
    };
    /**
     * Get property unit value.
     * @returns {String}
     */
    PropertyNumber.prototype.getUnit = function () {
        return this.get('unit');
    };
    /**
     * Get min value.
     * @returns {Number}
     */
    PropertyNumber.prototype.getMin = function () {
        return this.get('min');
    };
    /**
     * Get max value.
     * @returns {Number}
     */
    PropertyNumber.prototype.getMax = function () {
        return this.get('max');
    };
    /**
     * Get step value.
     * @returns {Number}
     */
    PropertyNumber.prototype.getStep = function () {
        return this.get('step');
    };
    /**
     * Update property unit value.
     * The change is also propagated to the selected targets.
     * @param {String} unit New unit value
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.noTarget=false] If `true` the change won't be propagated to selected targets.
     * @returns {String}
     */
    PropertyNumber.prototype.upUnit = function (unit, opts) {
        if (opts === void 0) { opts = {}; }
        return this._up({ unit: unit }, opts);
    };
    PropertyNumber.prototype.initialize = function (props, opts) {
        if (props === void 0) { props = {}; }
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        model_Property.callParentInit(model_Property, this, props, opts);
        var unit = this.get('unit');
        var units = this.getUnits();
        this.input = (0,mixins.hasWin)() ? new ui_InputNumber({ model: this }) : undefined;
        if (units.length && !unit) {
            this.set('unit', units[0], { silent: true });
        }
        // @ts-ignore
        model_Property.callInit(this, props, opts);
    };
    PropertyNumber.prototype.__getClearProps = function () {
        return PropertyNumber_assign(PropertyNumber_assign({}, model_Property.prototype.__getClearProps()), { unit: '' });
    };
    PropertyNumber.prototype.parseValue = function (val, opts) {
        if (opts === void 0) { opts = {}; }
        var parsed = model_Property.prototype.parseValue.apply(this, arguments);
        var _a = this.input.validateInputValue(parsed.value, PropertyNumber_assign({ deepCheck: 1 }, opts)), value = _a.value, unit = _a.unit;
        parsed.value = value;
        parsed.unit = unit;
        return parsed;
    };
    PropertyNumber.prototype.getFullValue = function () {
        var valueProp = this.get('value');
        var unitProp = this.get('unit');
        var value = !(0,index_all.isUndefined)(valueProp) ? "".concat(valueProp) : '';
        var unit = !(0,index_all.isUndefined)(unitProp) && value ? unitProp : '';
        var result = "".concat(value).concat(unit);
        return model_Property.prototype.getFullValue.apply(this, [result]);
    };
    return PropertyNumber;
}(model_Property));
/* harmony default export */ const model_PropertyNumber = (PropertyNumber);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertySlider.ts
var PropertySlider_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertySlider_assign = (undefined && undefined.__assign) || function () {
    PropertySlider_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertySlider_assign.apply(this, arguments);
};

var PropertySlider = /** @class */ (function (_super) {
    PropertySlider_extends(PropertySlider, _super);
    function PropertySlider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertySlider.prototype.defaults = function () {
        return PropertySlider_assign(PropertySlider_assign({}, model_PropertyNumber.getDefaults()), { showInput: 1 });
    };
    return PropertySlider;
}(model_PropertyNumber));
/* harmony default export */ const model_PropertySlider = (PropertySlider);

;// CONCATENATED MODULE: ./src/style_manager/view/PropertySliderView.ts
var PropertySliderView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var PropertySliderView_assign = (undefined && undefined.__assign) || function () {
    PropertySliderView_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertySliderView_assign.apply(this, arguments);
};

var PropertySliderView = /** @class */ (function (_super) {
    PropertySliderView_extends(PropertySliderView, _super);
    function PropertySliderView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PropertySliderView.prototype.events = function () {
        return PropertySliderView_assign(PropertySliderView_assign({}, view_PropertyNumberView.prototype.events()), { 'change [type=range]': 'inputValueChanged', 'input [type=range]': 'inputValueChangedSoft', change: '' });
    };
    PropertySliderView.prototype.templateInput = function (model) {
        var ppfx = this.ppfx;
        return "\n      <div class=\"".concat(ppfx, "field ").concat(ppfx, "field-range\">\n        <input type=\"range\" min=\"").concat(model.get('min'), "\" max=\"").concat(model.get('max'), "\" step=\"").concat(model.get('step'), "\"/>\n      </div>\n    ");
    };
    PropertySliderView.prototype.getSliderEl = function () {
        if (!this.slider) {
            this.slider = this.el.querySelector('input[type=range]');
        }
        return this.slider;
    };
    PropertySliderView.prototype.inputValueChanged = function (ev) {
        ev.stopPropagation();
        this.model.upValue(this.getSliderEl().value);
    };
    PropertySliderView.prototype.inputValueChangedSoft = function (ev) {
        ev.stopPropagation();
        this.model.upValue(this.getSliderEl().value, { partial: true });
    };
    PropertySliderView.prototype.setValue = function (value) {
        var model = this.model;
        var parsed = model.parseValue(value);
        // @ts-ignore
        this.getSliderEl().value = value === '' ? model.getDefaultValue() : parseFloat(parsed.value);
        view_PropertyNumberView.prototype.setValue.apply(this, arguments);
    };
    PropertySliderView.prototype.onRender = function () {
        view_PropertyNumberView.prototype.onRender.apply(this, arguments);
        // @ts-ignore
        if (!this.model.get('showInput')) {
            this.inputInst.el.style.display = 'none';
        }
    };
    PropertySliderView.prototype.clearCached = function () {
        view_PropertyNumberView.prototype.clearCached.apply(this, arguments);
        delete this.slider;
    };
    return PropertySliderView;
}(view_PropertyNumberView));
/* harmony default export */ const view_PropertySliderView = (PropertySliderView);

;// CONCATENATED MODULE: ./src/style_manager/model/Properties.ts


















var Properties_TypeableCollectionExt = common/* Collection */.FE.extend(model_TypeableCollection);
var Properties = Properties_TypeableCollectionExt.extend({
    extendViewApi: 1,
    init: function () {
        var _a = this, opts = _a.opts, em = _a.em;
        var sm = opts.module || (em === null || em === void 0 ? void 0 : em.get('StyleManager'));
        if (sm) {
            sm.__listenAdd(this, sm.events.propertyAdd);
            sm.__listenRemove(this, sm.events.propertyRemove);
        }
    },
    types: [
        {
            id: 'stack',
            model: model_PropertyStack,
            view: view_PropertyStackView,
            isType: function (value) {
                if (value && value.type == 'stack') {
                    return value;
                }
            },
        },
        {
            id: 'composite',
            model: model_PropertyComposite,
            view: view_PropertyCompositeView,
            isType: function (value) {
                if (value && value.type == 'composite') {
                    return value;
                }
            },
        },
        {
            id: 'file',
            model: model_Property,
            view: view_PropertyFileView,
            isType: function (value) {
                if (value && value.type == 'file') {
                    return value;
                }
            },
        },
        {
            id: 'color',
            model: model_Property,
            view: view_PropertyColorView,
            isType: function (value) {
                if (value && value.type == 'color') {
                    return value;
                }
            },
        },
        {
            id: 'select',
            model: model_PropertySelect,
            view: view_PropertySelectView,
            isType: function (value) {
                if (value && value.type == 'select') {
                    return value;
                }
            },
        },
        {
            id: 'radio',
            model: model_PropertyRadio,
            view: view_PropertyRadioView,
            isType: function (value) {
                if (value && value.type == 'radio') {
                    return value;
                }
            },
        },
        {
            id: 'slider',
            model: model_PropertySlider,
            view: view_PropertySliderView,
            isType: function (value) {
                if (value && value.type == 'slider') {
                    return value;
                }
            },
        },
        {
            id: 'integer',
            model: model_PropertyNumber,
            view: view_PropertyNumberView,
            isType: function (value) {
                if (value && value.type == 'integer') {
                    return value;
                }
            },
        },
        {
            id: 'number',
            model: model_PropertyNumber,
            view: view_PropertyNumberView,
            isType: function (value) {
                if (value && value.type == 'number') {
                    return value;
                }
            },
        },
        {
            id: 'base',
            model: model_Property,
            view: view_PropertyView,
            isType: function (value) {
                value.type = 'base';
                return value;
            },
        },
    ],
});
/* harmony default export */ const model_Properties = (Properties);

;// CONCATENATED MODULE: ./src/style_manager/model/Sector.ts
var Sector_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Sector_assign = (undefined && undefined.__assign) || function () {
    Sector_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Sector_assign.apply(this, arguments);
};
var Sector_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Sector_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};



/**
 *
 * [Property]: property.html
 *
 * @typedef Sector
 * @property {String} id Sector id, eg. `typography`
 * @property {String} name Sector name, eg. `Typography`
 * @property {Boolean} [open=true] Indicates the open state.
 * @property {Array<Object>} [properties=[]] Indicate an array of Property defintions.
 */
var Sector = /** @class */ (function (_super) {
    Sector_extends(Sector, _super);
    /**
     * @hideconstructor
     */
    function Sector(prp, opts) {
        if (opts === void 0) { opts = {}; }
        var _this = _super.call(this, prp) || this;
        var em = opts.em;
        _this.em = em;
        var o = prp || {};
        var builded = _this.buildProperties(o.buildProps);
        var name = _this.get('name') || '';
        var props = [];
        !_this.get('id') && _this.set('id', name.replace(/ /g, '_').toLowerCase());
        if (!builded) {
            props = _this.get('properties')
                .map(function (prop) { return ((0,index_all.isString)(prop) ? _this.buildProperties(prop)[0] : prop); })
                .filter(Boolean);
        }
        else {
            props = _this.extendProperties(builded);
        }
        props = props.map(function (prop) { return _this.checkExtend(prop); });
        var propsModel = new model_Properties(props, { em: em });
        propsModel.sector = _this;
        _this.set('properties', propsModel);
        return _this;
    }
    Sector.prototype.defaults = function () {
        return {
            id: '',
            name: '',
            open: true,
            visible: true,
            extendBuilded: true,
            properties: [],
        };
    };
    Object.defineProperty(Sector.prototype, "properties", {
        get: function () {
            return this.get('properties');
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get sector id.
     * @returns {String}
     */
    Sector.prototype.getId = function () {
        return this.get('id');
    };
    /**
     * Get sector name.
     * @returns {String}
     */
    Sector.prototype.getName = function () {
        var _a;
        var id = this.getId();
        return ((_a = this.em) === null || _a === void 0 ? void 0 : _a.t("styleManager.sectors.".concat(id))) || this.get('name');
    };
    /**
     * Update sector name.
     * @param {String} value New sector name
     */
    Sector.prototype.setName = function (value) {
        return this.set('name', value);
    };
    /**
     * Check if the sector is open
     * @returns {Boolean}
     */
    Sector.prototype.isOpen = function () {
        return !!this.get('open');
    };
    /**
     * Update Sector open state
     * @param {Boolean} value
     */
    Sector.prototype.setOpen = function (value) {
        return this.set('open', value);
    };
    /**
     * Check if the sector is visible
     * @returns {Boolean}
     */
    Sector.prototype.isVisible = function () {
        return !!this.get('visible');
    };
    /**
     * Get sector properties.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.withValue=false] Get only properties with value
     * @param {Boolean} [opts.withParentValue=false] Get only properties with parent value
     * @returns {Array<[Property]>}
     */
    Sector.prototype.getProperties = function (opts) {
        if (opts === void 0) { opts = {}; }
        var props = this.get('properties');
        var res = (props.models ? Sector_spreadArray([], props.models, true) : props);
        return res.filter(function (prop) {
            var result = true;
            if (opts.withValue) {
                result = prop.hasValue({ noParent: true });
            }
            if (opts.withParentValue) {
                var hasVal = prop.hasValue({ noParent: true });
                result = !hasVal && prop.hasValue();
            }
            return result;
        });
    };
    Sector.prototype.getProperty = function (id) {
        return this.getProperties().filter(function (prop) { return prop.get('id') === id; })[0] || undefined;
    };
    Sector.prototype.addProperty = function (property, opts) {
        // @ts-ignore
        return this.get('properties').add(this.checkExtend(property), opts);
    };
    /**
     * Extend properties
     * @param {Array<Object>} props Start properties
     * @param {Array<Object>} moProps Model props
     * @param {Boolean} ex Returns the same amount of passed model props
     * @return {Array<Object>} Final props
     * @private
     */
    Sector.prototype.extendProperties = function (props, moProps, ex) {
        if (ex === void 0) { ex = false; }
        var pLen = props.length;
        var mProps = moProps || this.get('properties');
        var ext = this.get('extendBuilded');
        var isolated = [];
        for (var i = 0, len = mProps.length; i < len; i++) {
            var mProp = mProps[i];
            var found = 0;
            for (var j = 0; j < pLen; j++) {
                var prop = props[j];
                if (mProp.property == prop.property || mProp.id == prop.property) {
                    // @ts-ignore Check for nested properties
                    var mPProps = mProp.properties;
                    if (mPProps && mPProps.length) {
                        // @ts-ignore
                        mProp.properties = this.extendProperties(prop.properties || [], mPProps, 1);
                    }
                    props[j] = ext ? (0,index_all.extend)(prop, mProp) : mProp;
                    isolated[j] = props[j];
                    found = 1;
                    continue;
                }
            }
            if (!found) {
                props.push(mProp);
                isolated.push(mProp);
            }
        }
        return ex ? isolated.filter(function (i) { return i; }) : props;
    };
    Sector.prototype.checkExtend = function (prop) {
        var _a = ((0,index_all.isString)(prop) ? { extend: prop } : prop) || {}, extend = _a.extend, rest = Sector_rest(_a, ["extend"]);
        if (extend) {
            return Sector_assign(Sector_assign({}, (this.buildProperties([extend])[0] || {})), rest);
        }
        else {
            return prop;
        }
    };
    /**
     * Build properties
     * @param {Array<string>} propr Array of props as sting
     * @return {Array<Object>}
     * @private
     */
    Sector.prototype.buildProperties = function (props) {
        var _a;
        var buildP = props || [];
        if (!buildP.length)
            return [];
        var builtIn = (_a = this.em) === null || _a === void 0 ? void 0 : _a.get('StyleManager').builtIn;
        return builtIn === null || builtIn === void 0 ? void 0 : builtIn.build(buildP);
    };
    return Sector;
}(common/* Model */.Hn));
/* harmony default export */ const model_Sector = (Sector);

;// CONCATENATED MODULE: ./src/style_manager/model/Sectors.ts
var Sectors_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Sectors_assign = (undefined && undefined.__assign) || function () {
    Sectors_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Sectors_assign.apply(this, arguments);
};


var Sectors = /** @class */ (function (_super) {
    Sectors_extends(Sectors, _super);
    function Sectors() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Sectors.prototype.initialize = function (prop, opts) {
        if (opts === void 0) { opts = {}; }
        var module = opts.module, em = opts.em;
        this.em = em;
        this.module = module;
        this.listenTo(this, 'reset', this.onReset);
    };
    /** @ts-ignore */
    Sectors.prototype.model = function (props, opts) {
        if (opts === void 0) { opts = {}; }
        // @ts-ignore
        var em = opts.collection.em;
        return new model_Sector(props, Sectors_assign(Sectors_assign({}, opts), { em: em }));
    };
    Sectors.prototype.onReset = function (models, opts) {
        if (opts === void 0) { opts = {}; }
        var prev = opts.previousModels || [];
        // @ts-ignore
        prev.forEach(function (sect) { return sect.get('properties').reset(); });
    };
    return Sectors;
}(common/* Collection */.FE));
/* harmony default export */ const model_Sectors = (Sectors);

;// CONCATENATED MODULE: ./src/style_manager/model/PropertyFactory.ts
var PropertyFactory_assign = (undefined && undefined.__assign) || function () {
    PropertyFactory_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return PropertyFactory_assign.apply(this, arguments);
};
var PropertyFactory_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var PropertyFactory_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};

var getOptions = function (items) { return items.map(function (item) { return ({ id: item }); }); };
var PropertyFactory = /** @class */ (function () {
    function PropertyFactory() {
        this.props = {};
        this.typeNumber = 'number';
        this.typeColor = 'color';
        this.typeRadio = 'radio';
        this.typeSelect = 'select';
        this.typeFile = 'file';
        this.typeSlider = 'slider';
        this.typeComposite = 'composite';
        this.typeStack = 'stack';
        this.unitsSize = ['px', '%', 'em', 'rem', 'vh', 'vw'];
        this.unitsSizeNoPerc = ['px', 'em', 'rem', 'vh', 'vw'];
        this.unitsTime = ['s', 'ms'];
        this.unitsAngle = ['deg', 'rad', 'grad'];
        this.fixedValues = ['initial', 'inherit', 'auto'];
        var ss = ', sans-serif';
        var optsFlex = ['flex-start', 'flex-end', 'center'];
        var optsFlexAlign = PropertyFactory_spreadArray(PropertyFactory_spreadArray([], optsFlex, true), ['baseline', 'stretch'], false);
        this.optsBgSize = getOptions(['auto', 'cover', 'contain']);
        this.optsBgAttach = getOptions(['scroll', 'fixed', 'local']);
        this.optsBgRepeat = getOptions(['repeat', 'repeat-x', 'repeat-y', 'no-repeat']);
        this.optsWrap = getOptions(['nowrap', 'wrap', 'wrap-reverse']);
        this.optsOverflow = getOptions(['visible', 'hidden', 'scroll', 'auto']);
        this.optsDir = getOptions(['row', 'row-reverse', 'column', 'column-reverse']);
        this.opstDisplay = getOptions(['block', 'inline', 'inline-block', 'flex', 'none']);
        this.optsTransitFn = getOptions(['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out']);
        this.optsCursor = getOptions(['auto', 'pointer', 'copy', 'crosshair', 'grab', 'grabbing', 'help', 'move', 'text']);
        this.optsFloat = getOptions(['none', 'left', 'right']);
        this.optsPos = getOptions(['static', 'relative', 'absolute', 'fixed']);
        this.optsTextAlign = getOptions(['left', 'center', 'right', 'justify']);
        this.optsFlexAlign = getOptions(optsFlexAlign);
        this.optsJustCont = getOptions(PropertyFactory_spreadArray(PropertyFactory_spreadArray([], optsFlex, true), ['space-between', 'space-around', 'space-evenly'], false));
        this.optsAlignCont = getOptions(PropertyFactory_spreadArray(PropertyFactory_spreadArray([], optsFlex, true), ['space-between', 'space-around', 'stretch'], false));
        this.optsAlignSelf = getOptions(PropertyFactory_spreadArray(['auto'], optsFlexAlign, true));
        this.optsTransitProp = getOptions([
            'all',
            'width',
            'height',
            'background-color',
            'transform',
            'box-shadow',
            'opacity',
        ]);
        this.optsBorderStyle = getOptions([
            'none',
            'solid',
            'dotted',
            'dashed',
            'double',
            'groove',
            'ridge',
            'inset',
            'outset',
        ]);
        this.optsBgPos = getOptions([
            'left top',
            'left center',
            'left bottom',
            'right top',
            'right center',
            'right bottom',
            'center top',
            'center center',
            'center bottom',
        ]);
        this.optsWeight = [
            { id: '100', label: 'Thin' },
            { id: '200', label: 'Extra-Light' },
            { id: '300', label: 'Light' },
            { id: '400', label: 'Normal' },
            { id: '500', label: 'Medium' },
            { id: '600', label: 'Semi-Bold' },
            { id: '700', label: 'Bold' },
            { id: '800', label: 'Extra-Bold' },
            { id: '900', label: 'Ultra-Bold' },
        ];
        this.optsShadowType = [
            { id: '', label: 'Outside' },
            { id: 'inset', label: 'Inside' },
        ];
        this.optsFonts = [
            'Arial, Helvetica' + ss,
            'Arial Black, Gadget' + ss,
            'Brush Script MT' + ss,
            'Comic Sans MS, cursive' + ss,
            'Courier New, Courier, monospace',
            'Georgia, serif',
            'Helvetica' + ss,
            'Impact, Charcoal' + ss,
            'Lucida Sans Unicode, Lucida Grande' + ss,
            'Tahoma, Geneva' + ss,
            'Times New Roman, Times, serif',
            'Trebuchet MS, Helvetica' + ss,
            'Verdana, Geneva' + ss,
        ].map(function (font) {
            return { id: font, label: font.split(',')[0] };
        });
        // Fixed values
        this.fixedFontSizes = [
            'medium',
            'xx-small',
            'x-small',
            'small',
            'large',
            'x-large',
            'xx-large',
            'smaller',
            'larger',
            'length',
            'initial',
            'inherit',
        ];
        this.fixedLetSpace = ['normal', 'initial', 'inherit'];
        this.requireFlex = { display: ['flex'] };
        this.init();
    }
    PropertyFactory.prototype.__sub = function (items) {
        var _this = this;
        return function () {
            return items.map(function (p) {
                if ((0,index_all.isString)(p))
                    return _this.get(p);
                var extend = p.extend, rest = PropertyFactory_rest(p, ["extend"]);
                return PropertyFactory_assign(PropertyFactory_assign({}, _this.get(extend)), rest);
            });
        };
    };
    PropertyFactory.prototype.init = function () {
        var _this = this;
        var _a = this, fixedValues = _a.fixedValues, requireFlex = _a.requireFlex, typeNumber = _a.typeNumber;
        this.props = {};
        // Build default built-in properties (the order, in the array here below, matters)
        // [propertyName, propertyDefinition, extendFromProperty]
        var propsToCreate = [
            // Number types
            ['text-shadow-h', { type: typeNumber, default: '0', units: this.unitsSizeNoPerc }],
            ['top', { default: 'auto', units: this.unitsSize, fixedValues: fixedValues }, 'text-shadow-h'],
            ['right', {}, 'top'],
            ['bottom', {}, 'top'],
            ['left', {}, 'top'],
            ['margin-top', { default: '0' }, 'top'],
            ['margin-right', {}, 'margin-top'],
            ['margin-bottom', {}, 'margin-top'],
            ['margin-left', {}, 'margin-top'],
            ['padding-top', { min: 0 }, 'margin-top'],
            ['padding-right', {}, 'padding-top'],
            ['padding-bottom', {}, 'padding-top'],
            ['padding-left', {}, 'padding-top'],
            ['width', { min: 0 }, 'top'],
            ['min-width', {}, 'width'],
            ['max-width', {}, 'width'],
            ['height', {}, 'width'],
            ['min-height', {}, 'width'],
            ['max-height', {}, 'width'],
            ['flex-basis', { requiresParent: requireFlex }, 'width'],
            ['font-size', { default: 'medium', fixedValues: this.fixedFontSizes }, 'width'],
            ['letter-spacing', { default: 'normal', fixedValues: this.fixedLetSpace }, 'top'],
            ['line-height', {}, 'letter-spacing'],
            ['text-shadow-v', {}, 'text-shadow-h'],
            ['text-shadow-blur', { min: 0 }, 'text-shadow-h'],
            ['border-radius-c', { property: 'border-radius', fixedValues: undefined }, 'padding-top'],
            ['border-top-left-radius', {}, 'border-radius-c'],
            ['border-top-right-radius', {}, 'border-radius-c'],
            ['border-bottom-left-radius', {}, 'border-radius-c'],
            ['border-bottom-right-radius', {}, 'border-radius-c'],
            ['border-width', { units: this.unitsSizeNoPerc }, 'border-radius-c'],
            ['box-shadow-h', {}, 'text-shadow-h'],
            ['box-shadow-v', {}, 'text-shadow-h'],
            ['box-shadow-blur', { default: '5px' }, 'text-shadow-blur'],
            ['box-shadow-spread', {}, 'text-shadow-h'],
            ['transition-duration', { default: '2s', units: this.unitsTime }, 'border-radius-c'],
            ['perspective', {}, 'border-radius-c'],
            ['order', { type: typeNumber, default: '0', requiresParent: requireFlex }],
            ['flex-grow', {}, 'order'],
            ['flex-shrink', { default: '1' }, 'order'],
            // Radio types
            ['float', { type: this.typeRadio, default: 'none', options: this.optsFloat }],
            ['position', { default: 'static', options: this.optsPos }, 'float'],
            ['text-align', { default: 'left', options: this.optsTextAlign }, 'float'],
            // Color types
            ['color', { type: this.typeColor, default: 'black', full: true }],
            ['text-shadow-color', {}, 'color'],
            ['border-color', {}, 'color'],
            ['box-shadow-color', {}, 'color'],
            ['background-color', { default: 'none' }, 'color'],
            // File type
            [
                'background-image',
                {
                    type: this.typeFile,
                    functionName: 'url',
                    default: 'none',
                    full: true,
                },
            ],
            // Slider type
            ['opacity', { type: this.typeSlider, default: '1', min: 0, max: 1, step: 0.01, full: true }],
            // Select types
            ['display', { type: this.typeSelect, default: 'block', options: this.opstDisplay }],
            ['flex-direction', { default: 'row', options: this.optsDir, requires: requireFlex }, 'display'],
            ['flex-wrap', { default: 'nowrap', options: this.optsWrap }, 'flex-direction'],
            ['justify-content', { default: 'flex-start', options: this.optsJustCont }, 'flex-wrap'],
            ['align-items', { default: 'stretch', options: this.optsFlexAlign }, 'flex-wrap'],
            ['align-content', { options: this.optsAlignCont }, 'align-items'],
            [
                'align-self',
                {
                    default: 'auto',
                    options: this.optsAlignSelf,
                    requiresParent: requireFlex,
                },
                'display',
            ],
            ['font-family', { default: 'Arial, Helvetica, sans-serif', options: this.optsFonts }, 'display'],
            ['font-weight', { default: '400', options: this.optsWeight }, 'display'],
            ['border-style', { default: 'solid', options: this.optsBorderStyle }, 'display'],
            ['box-shadow-type', { default: '', options: this.optsShadowType }, 'display'],
            ['background-repeat', { default: 'repeat', options: this.optsBgRepeat }, 'display'],
            ['background-position', { default: 'left top', options: this.optsBgPos }, 'display'],
            ['background-attachment', { default: 'scroll', options: this.optsBgAttach }, 'display'],
            ['background-size', { default: 'auto', options: this.optsBgSize }, 'display'],
            ['transition-property', { default: 'width', options: this.optsTransitProp }, 'display'],
            ['transition-timing-function', { default: 'ease', options: this.optsTransitFn }, 'display'],
            ['cursor', { default: 'auto', options: this.optsCursor }, 'display'],
            ['overflow', { default: 'visible', options: this.optsOverflow }, 'display'],
            ['overflow-x', {}, 'overflow'],
            ['overflow-y', {}, 'overflow'],
            // Composite types
            [
                'margin',
                {
                    type: this.typeComposite,
                    properties: this.__sub([
                        { extend: 'margin-top', id: 'margin-top-sub' },
                        { extend: 'margin-right', id: 'margin-right-sub' },
                        { extend: 'margin-bottom', id: 'margin-bottom-sub' },
                        { extend: 'margin-left', id: 'margin-left-sub' },
                    ]),
                },
            ],
            [
                'padding',
                {
                    properties: this.__sub([
                        { extend: 'padding-top', id: 'padding-top-sub' },
                        { extend: 'padding-right', id: 'padding-right-sub' },
                        { extend: 'padding-bottom', id: 'padding-bottom-sub' },
                        { extend: 'padding-left', id: 'padding-left-sub' },
                    ]),
                },
                'margin',
            ],
            [
                'border',
                {
                    properties: this.__sub([
                        { extend: 'border-width', id: 'border-width-sub' },
                        { extend: 'border-style', id: 'border-style-sub' },
                        { extend: 'border-color', id: 'border-color-sub' },
                    ]),
                },
                'margin',
            ],
            [
                'border-radius',
                {
                    properties: this.__sub([
                        {
                            extend: 'border-top-left-radius',
                            id: 'border-top-left-radius-sub',
                        },
                        {
                            extend: 'border-top-right-radius',
                            id: 'border-top-right-radius-sub',
                        },
                        {
                            extend: 'border-bottom-right-radius',
                            id: 'border-bottom-right-radius-sub',
                        },
                        {
                            extend: 'border-bottom-left-radius',
                            id: 'border-bottom-left-radius-sub',
                        },
                    ]),
                },
                'margin',
            ],
            // Stack types
            [
                'transition',
                {
                    type: this.typeStack,
                    properties: this.__sub([
                        { extend: 'transition-property', id: 'transition-property-sub' },
                        { extend: 'transition-duration', id: 'transition-duration-sub' },
                        {
                            extend: 'transition-timing-function',
                            id: 'transition-timing-function-sub',
                        },
                    ]),
                },
            ],
            [
                'box-shadow',
                {
                    preview: true,
                    layerLabel: function (l, _a) {
                        var values = _a.values;
                        var x = values['box-shadow-h'];
                        var y = values['box-shadow-v'];
                        var blur = values['box-shadow-blur'];
                        var spread = values['box-shadow-spread'];
                        return "".concat(x, " ").concat(y, " ").concat(blur, " ").concat(spread);
                    },
                    properties: this.__sub([
                        'box-shadow-h',
                        'box-shadow-v',
                        'box-shadow-blur',
                        'box-shadow-spread',
                        'box-shadow-color',
                        'box-shadow-type',
                    ]),
                },
                'transition',
            ],
            [
                'text-shadow',
                {
                    default: 'none',
                    layerLabel: function (l, _a) {
                        var values = _a.values;
                        var x = values['text-shadow-h'];
                        var y = values['text-shadow-v'];
                        var blur = values['text-shadow-blur'];
                        return "".concat(x, " ").concat(y, " ").concat(blur);
                    },
                    properties: this.__sub(['text-shadow-h', 'text-shadow-v', 'text-shadow-blur', 'text-shadow-color']),
                },
                'box-shadow',
            ],
            [
                'background',
                {
                    detached: true,
                    layerLabel: function (l, _a) {
                        var values = _a.values;
                        var repeat = values['background-repeat-sub'] || '';
                        var pos = values['background-position-sub'] || '';
                        var att = values['background-attachment-sub'] || '';
                        var size = values['background-size-sub'] || '';
                        return [repeat, pos, att, size].join(' ');
                    },
                    properties: this.__sub([
                        { extend: 'background-image', id: 'background-image-sub' },
                        { extend: 'background-repeat', id: 'background-repeat-sub' },
                        { extend: 'background-position', id: 'background-position-sub' },
                        {
                            extend: 'background-attachment',
                            id: 'background-attachment-sub',
                        },
                        { extend: 'background-size', id: 'background-size-sub' },
                    ]),
                },
                'box-shadow',
            ],
            [
                'transform',
                {
                    type: 'stack',
                    layerSeparator: ' ',
                    fromStyle: function (style, _a) {
                        var property = _a.property, name = _a.name;
                        var filter = (style[name] || '');
                        var sep = property.getLayerSeparator();
                        return filter
                            ? filter.split(sep).map(function (input) {
                                var _a = property.__parseFn(input), name = _a.name, value = _a.value;
                                return {
                                    'transform-type': name,
                                    'transform-value': value,
                                };
                            })
                            : [];
                    },
                    toStyle: function (values, _a) {
                        var _b;
                        var name = _a.name;
                        return _b = {}, _b[name] = "".concat(values['transform-type'], "(").concat(values['transform-value'], ")"), _b;
                    },
                    properties: [
                        {
                            property: 'transform-type',
                            name: 'Type',
                            type: this.typeSelect,
                            default: 'rotateZ',
                            full: true,
                            options: [
                                { id: 'scaleX', propValue: { units: [''], step: 0.01 } },
                                { id: 'scaleY', propValue: { units: [''], step: 0.01 } },
                                { id: 'scaleZ', propValue: { units: [''], step: 0.01 } },
                                {
                                    id: 'rotateX',
                                    propValue: { units: this.unitsAngle, step: 1 },
                                },
                                {
                                    id: 'rotateY',
                                    propValue: { units: this.unitsAngle, step: 1 },
                                },
                                {
                                    id: 'rotateZ',
                                    propValue: { units: this.unitsAngle, step: 1 },
                                },
                                {
                                    id: 'translateX',
                                    propValue: { units: this.unitsSize, step: 1 },
                                },
                                {
                                    id: 'translateY',
                                    propValue: { units: this.unitsSize, step: 1 },
                                },
                            ],
                            onChange: function (_a) {
                                var property = _a.property, to = _a.to;
                                if (to.value) {
                                    var option = property.getOption();
                                    var props = PropertyFactory_assign({}, (option.propValue || {}));
                                    var propToUp = property.getParent().getProperty('transform-value');
                                    var unit = propToUp.getUnit();
                                    if (!unit || (props === null || props === void 0 ? void 0 : props.units.indexOf(unit)) < 0) {
                                        props.unit = (props === null || props === void 0 ? void 0 : props.units[0]) || '';
                                    }
                                    propToUp.up(props);
                                }
                            },
                        },
                        {
                            property: 'transform-value',
                            type: this.typeNumber,
                            default: '0',
                            full: true,
                        },
                    ],
                },
            ],
        ];
        propsToCreate.forEach(function (_a) {
            var prop = _a[0], def = _a[1], from = _a[2];
            _this.add(prop, def || {}, { from: from });
        });
        return this;
    };
    PropertyFactory.prototype.add = function (property, def, opts) {
        if (def === void 0) { def = {}; }
        if (opts === void 0) { opts = {}; }
        var from = opts.from || '';
        var fromRes = this.props[from || property] || {};
        var result = PropertyFactory_assign(PropertyFactory_assign(PropertyFactory_assign({}, fromRes), { property: property }), def);
        if (result.properties && (0,index_all.isFunction)(result.properties)) {
            result.properties = result.properties();
        }
        this.props[property] = result;
        return result;
    };
    PropertyFactory.prototype.get = function (prop) {
        return this.props[prop];
    };
    /**
     * Build props object by their name
     * @param  {Array<string>|string} props Array of properties name
     * @return {Array<Object>}
     */
    PropertyFactory.prototype.build = function (props) {
        var _this = this;
        var result = [];
        var propsArr = (0,index_all.isString)(props) ? [props] : props;
        propsArr.forEach(function (prop) {
            result.push(_this.get(prop) || { property: prop });
        });
        return result;
    };
    return PropertyFactory;
}());
/* harmony default export */ const model_PropertyFactory = (PropertyFactory);

;// CONCATENATED MODULE: ./src/style_manager/view/SectorView.ts
var SectorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var SectorView_makeTemplateObject = (undefined && undefined.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};



var SectorView = /** @class */ (function (_super) {
    SectorView_extends(SectorView, _super);
    function SectorView(o) {
        var _this = _super.call(this, o) || this;
        var config = o.config || {};
        var model = _this.model;
        // @ts-ignore
        var em = config.em;
        _this.config = config;
        _this.em = em;
        _this.pfx = config.stylePrefix || '';
        _this.listenTo(model, 'destroy remove', _this.remove);
        _this.listenTo(model, 'change:open', _this.updateOpen);
        _this.listenTo(model, 'change:visible', _this.updateVisibility);
        return _this;
    }
    SectorView.prototype.template = function (_a) {
        var _b;
        var pfx = _a.pfx, label = _a.label;
        var icons = (_b = this.em) === null || _b === void 0 ? void 0 : _b.getConfig().icons;
        var iconCaret = (icons === null || icons === void 0 ? void 0 : icons.caret) || '';
        var clsPfx = "".concat(pfx, "sector-");
        return html(SectorView_templateObject_1 || (SectorView_templateObject_1 = SectorView_makeTemplateObject(["\n      <div class=\"", "title\" data-sector-title>\n        <div class=\"", "caret\">$", "</div>\n        <div class=\"", "label\">", "</div>\n      </div>\n    "], ["\n      <div class=\"", "title\" data-sector-title>\n        <div class=\"", "caret\">$", "</div>\n        <div class=\"", "label\">", "</div>\n      </div>\n    "])), clsPfx, clsPfx, iconCaret, clsPfx, label);
    };
    SectorView.prototype.events = function () {
        return {
            'click [data-sector-title]': 'toggle',
        };
    };
    SectorView.prototype.updateOpen = function () {
        var _a = this, $el = _a.$el, model = _a.model, pfx = _a.pfx;
        var isOpen = model.isOpen();
        $el[isOpen ? 'addClass' : 'removeClass']("".concat(pfx, "open"));
        this.getPropertiesEl().style.display = isOpen ? '' : 'none';
    };
    SectorView.prototype.updateVisibility = function () {
        this.el.style.display = this.model.isVisible() ? '' : 'none';
    };
    SectorView.prototype.getPropertiesEl = function () {
        var _a = this, $el = _a.$el, pfx = _a.pfx;
        return $el.find(".".concat(pfx, "properties")).get(0);
    };
    SectorView.prototype.toggle = function () {
        var model = this.model;
        model.setOpen(!model.get('open'));
    };
    SectorView.prototype.renderProperties = function () {
        var _a = this, model = _a.model, config = _a.config;
        var objs = model.get('properties');
        if (objs) {
            // @ts-ignore
            var view = new view_PropertiesView({ collection: objs, config: config });
            this.$el.append(view.render().el);
        }
    };
    SectorView.prototype.render = function () {
        var _a = this, pfx = _a.pfx, model = _a.model, $el = _a.$el;
        var id = model.getId();
        var label = model.getName();
        $el.html(this.template({ pfx: pfx, label: label }));
        this.renderProperties();
        $el.attr('class', "".concat(pfx, "sector ").concat(pfx, "sector__").concat(id, " no-select"));
        this.updateOpen();
        return this;
    };
    return SectorView;
}(common/* View */.G7));
/* harmony default export */ const view_SectorView = (SectorView);
var SectorView_templateObject_1;

;// CONCATENATED MODULE: ./src/style_manager/view/SectorsView.ts
var SectorsView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var SectorsView = /** @class */ (function (_super) {
    SectorsView_extends(SectorsView, _super);
    function SectorsView(o) {
        if (o === void 0) { o = {}; }
        // @ts-ignore
        var _this = _super.call(this, o) || this;
        var module = o.module, config = o.config;
        var coll = _this.collection;
        _this.pfx = (config === null || config === void 0 ? void 0 : config.stylePrefix) || '';
        _this.ppfx = (config === null || config === void 0 ? void 0 : config.pStylePrefix) || '';
        _this.config = config;
        _this.module = module;
        _this.listenTo(coll, 'add', _this.addTo);
        _this.listenTo(coll, 'reset', _this.render);
        return _this;
    }
    SectorsView.prototype.remove = function () {
        var _this = this;
        common/* View */.G7.prototype.remove.apply(this, arguments);
        ['config', 'module', 'em'].forEach(function (i) {
            // @ts-ignore
            return (_this[i] = {});
        });
        return this;
    };
    SectorsView.prototype.addTo = function (model, c, opts) {
        if (opts === void 0) { opts = {}; }
        this.addToCollection(model, null, opts);
    };
    SectorsView.prototype.addToCollection = function (model, fragmentEl, opts) {
        if (opts === void 0) { opts = {}; }
        var _a = this, config = _a.config, el = _a.el;
        var appendTo = fragmentEl || el;
        var rendered = new view_SectorView({ model: model, config: config }).render().el;
        (0,dom/* appendAtIndex */.$Q)(appendTo, rendered, opts.at);
        return rendered;
    };
    SectorsView.prototype.render = function () {
        var _this = this;
        var _a = this, $el = _a.$el, pfx = _a.pfx, ppfx = _a.ppfx;
        $el.empty();
        var frag = document.createDocumentFragment();
        this.collection.each(function (model) { return _this.addToCollection(model, frag); });
        $el.append(frag);
        $el.addClass("".concat(pfx, "sectors ").concat(ppfx, "one-bg ").concat(ppfx, "two-color"));
        return this;
    };
    return SectorsView;
}(common/* View */.G7));
/* harmony default export */ const view_SectorsView = (SectorsView);

;// CONCATENATED MODULE: ./src/style_manager/index.ts
/**
 * With Style Manager you build categories (called sectors) of CSS properties which could be used to customize the style of components.
 * You can customize the initial state of the module from the editor initialization, by passing the following [Configuration Object](https://github.com/GrapesJS/grapesjs/blob/master/src/style_manager/config/config.ts)
 * ```js
 * const editor = grapesjs.init({
 *  styleManager: {
 *    // options
 *  }
 * })
 * ```
 *
 * Once the editor is instantiated you can use its API and listen to its events. Before using these methods, you should get the module from the instance.
 *
 * ```js
 * // Listen to events
 * editor.on('style:sector:add', (sector) => { ... });
 *
 * // Use the API
 * const styleManager = editor.StyleManager;
 * styleManager.addSector(...);
 * ```
 * ## Available Events
 * * `style:sector:add` - Sector added. The [Sector] is passed as an argument to the callback.
 * * `style:sector:remove` - Sector removed. The [Sector] is passed as an argument to the callback.
 * * `style:sector:update` - Sector updated. The [Sector] and the object containing changes are passed as arguments to the callback.
 * * `style:property:add` - Property added. The [Property] is passed as an argument to the callback.
 * * `style:property:remove` - Property removed. The [Property] is passed as an argument to the callback.
 * * `style:property:update` - Property updated. The [Property] and the object containing changes are passed as arguments to the callback.
 * * `style:target` - Target selection changed. The target (or `null` in case the target is deselected) is passed as an argument to the callback.
 * <!--
 * * `styleManager:update:target` - The target (Component or CSSRule) is changed
 * * `styleManager:change` - Triggered on style property change from new selected component, the view of the property is passed as an argument to the callback
 * * `styleManager:change:{propertyName}` - As above but for a specific style property
 * -->
 *
 * ## Methods
 * * [getConfig](#getconfig)
 * * [addSector](#addsector)
 * * [getSector](#getsector)
 * * [getSectors](#getsectors)
 * * [removeSector](#removesector)
 * * [addProperty](#addproperty)
 * * [getProperty](#getproperty)
 * * [getProperties](#getproperties)
 * * [removeProperty](#removeproperty)
 * * [select](#select)
 * * [getSelected](#getselected)
 * * [getSelectedAll](#getselectedall)
 * * [getSelectedParents](#getselectedparents)
 * * [addStyleTargets](#addstyletargets)
 * * [getBuiltIn](#getbuiltin)
 * * [getBuiltInAll](#getbuiltinall)
 * * [addBuiltIn](#addbuiltin)
 * * [addType](#addtype)
 * * [getType](#gettype)
 * * [getTypes](#gettypes)
 *
 * [Sector]: sector.html
 * [CssRule]: css_rule.html
 * [Component]: component.html
 * [Property]: property.html
 *
 * @module docsjs.StyleManager
 */
var style_manager_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var style_manager_assign = (undefined && undefined.__assign) || function () {
    style_manager_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return style_manager_assign.apply(this, arguments);
};
var style_manager_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};










var style_manager_evAll = 'style';
var style_manager_evPfx = "".concat(style_manager_evAll, ":");
var evSector = "".concat(style_manager_evPfx, "sector");
var evSectorAdd = "".concat(evSector, ":add");
var evSectorRemove = "".concat(evSector, ":remove");
var evSectorUpdate = "".concat(evSector, ":update");
var evProp = "".concat(style_manager_evPfx, "property");
var evPropAdd = "".concat(evProp, ":add");
var evPropRemove = "".concat(evProp, ":remove");
var evPropUp = "".concat(evProp, ":update");
var evLayerSelect = "".concat(style_manager_evPfx, "layer:select");
var evTarget = "".concat(style_manager_evPfx, "target");
var style_manager_evCustom = "".concat(style_manager_evPfx, "custom");
var propDef = function (value) { return value || value === 0; };
var stylesEvents = {
    all: style_manager_evAll,
    sectorAdd: evSectorAdd,
    sectorRemove: evSectorRemove,
    sectorUpdate: evSectorUpdate,
    propertyAdd: evPropAdd,
    propertyRemove: evPropRemove,
    propertyUpdate: evPropUp,
    layerSelect: evLayerSelect,
    target: evTarget,
    custom: style_manager_evCustom,
};
var StyleManager = /** @class */ (function (_super) {
    style_manager_extends(StyleManager, _super);
    /**
     * Get configuration object
     * @name getConfig
     * @function
     * @return {Object}
     */
    /**
     * Initialize module. Automatically called with a new instance of the editor
     * @param {Object} config Configurations
     * @private
     */
    function StyleManager(em) {
        var _this = _super.call(this, em, 'StyleManager', new model_Sectors([], { em: em }), stylesEvents, style_manager_config_config) || this;
        _this.Sector = model_Sector;
        _this.storageKey = '';
        (0,index_all.bindAll)(_this, '__clearStateTarget');
        var c = _this.config;
        var ppfx = c.pStylePrefix;
        if (ppfx)
            c.stylePrefix = ppfx + c.stylePrefix;
        _this.builtIn = new model_PropertyFactory();
        _this.properties = new model_Properties([], { em: em, module: _this });
        _this.sectors = _this.all; // TODO check if (module: this) is required
        var model = new common/* Model */.Hn({ targets: [] });
        _this.model = model;
        // Triggers for the selection refresh and properties
        var ev = 'component:toggled component:update:classes change:state change:device frame:resized selector:type';
        _this.upAll = (0,index_all.debounce)(function () { return _this.__upSel(); }, 0);
        model.listenTo(em, ev, _this.upAll);
        // Clear state target on any component selection change, without debounce (#4208)
        model.listenTo(em, 'component:toggled', _this.__clearStateTarget);
        // Triggers only for properties (avoid selection refresh)
        var upProps = (0,index_all.debounce)(function () {
            _this.__upProps();
            _this.__trgCustom();
        }, 0);
        model.listenTo(em, 'styleable:change undo redo', upProps);
        // Triggers only custom event
        var trgCustom = (0,index_all.debounce)(function () { return _this.__trgCustom(); }, 0);
        model.listenTo(em, "".concat(evLayerSelect, " ").concat(evTarget), trgCustom);
        // Other listeners
        model.on('change:lastTarget', function () { return em.trigger(evTarget, _this.getSelected()); });
        return _this;
    }
    StyleManager.prototype.__upSel = function () {
        this.select(this.em.getSelectedAll());
    };
    StyleManager.prototype.__trgCustom = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.__ctn = this.__ctn || opts.container;
        this.em.trigger(this.events.custom, { container: this.__ctn });
    };
    StyleManager.prototype.__trgEv = function (event) {
        var _a;
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            data[_i - 1] = arguments[_i];
        }
        (_a = this.em).trigger.apply(_a, style_manager_spreadArray([event], data, false));
    };
    StyleManager.prototype.__clearStateTarget = function () {
        var _this = this;
        var em = this.em;
        var stateTarget = this.__getStateTarget();
        stateTarget &&
            (em === null || em === void 0 ? void 0 : em.skip(function () {
                em.Css.remove(stateTarget);
                _this.model.set({ stateTarget: null });
            }));
    };
    StyleManager.prototype.onLoad = function () {
        // Use silent as sectors' view will be created and rendered on StyleManager.render
        this.sectors.add(this.config.sectors, { silent: true });
    };
    StyleManager.prototype.postRender = function () {
        this.__appendTo();
    };
    /**
     * Add new sector. If the sector with the same id already exists, that one will be returned.
     * @param {String} id Sector id
     * @param {Object} sector Sector definition. Check the [available properties](sector.html#properties)
     * @param {Object} [options={}] Options
     * @param {Number} [options.at] Position index (by default, will be appended at the end).
     * @returns {[Sector]} Added Sector
     * @example
     * const sector = styleManager.addSector('mySector',{
     *   name: 'My sector',
     *   open: true,
     *   properties: [{ name: 'My property'}]
     * }, { at: 0 });
     * // With `at: 0` we place the new sector at the beginning of the list
     * */
    StyleManager.prototype.addSector = function (id, sector, options) {
        if (options === void 0) { options = {}; }
        var result = this.getSector(id);
        if (!result) {
            sector.id = id;
            result = this.sectors.add(sector, options);
        }
        return result;
    };
    /**
     * Get sector by id.
     * @param {String} id  Sector id
     * @returns {[Sector]|null}
     * @example
     * const sector = styleManager.getSector('mySector');
     * */
    StyleManager.prototype.getSector = function (id, opts) {
        if (opts === void 0) { opts = {}; }
        var res = this.sectors.where({ id: id })[0];
        !res && opts.warn && this._logNoSector(id);
        return res || null;
    };
    /**
     * Get all sectors.
     * @param {Object} [opts={}] Options
     * @param {Boolean} [opts.visible] Returns only visible sectors
     * @returns {Array<[Sector]>}
     * @example
     * const sectors = styleManager.getSectors();
     * */
    StyleManager.prototype.getSectors = function (opts) {
        if (opts === void 0) { opts = {}; }
        var sectors = this.sectors;
        var res = sectors && sectors.models ? (opts.array ? style_manager_spreadArray([], sectors.models, true) : sectors) : [];
        return (opts.visible ? res.filter(function (s) { return s.isVisible(); }) : res);
    };
    /**
     * Remove sector by id.
     * @param  {String} id Sector id
     * @returns {[Sector]} Removed sector
     * @example
     * const removed = styleManager.removeSector('mySector');
     */
    StyleManager.prototype.removeSector = function (id) {
        return this.getSectors().remove(this.getSector(id, { warn: true }));
    };
    /**
     * Add new property to the sector.
     * @param {String} sectorId Sector id.
     * @param {Object} property Property definition. Check the [base available properties](property.html#properties) + others based on the `type` of your property.
     * @param {Object} [opts={}] Options
     * @param {Number} [opts.at] Position index (by default, will be appended at the end).
     * @returns {[Property]|null} Added property or `null` in case the sector doesn't exist.
     * @example
     * const property = styleManager.addProperty('mySector', {
     *   label: 'Minimum height',
     *   property: 'min-height',
     *   type: 'select',
     *   default: '100px',
     *   options: [
     *    { id: '100px', label: '100' },
     *    { id: '200px', label: '200' },
     *   ],
     * }, { at: 0 });
     */
    StyleManager.prototype.addProperty = function (sectorId, property, opts) {
        if (opts === void 0) { opts = {}; }
        var sector = this.getSector(sectorId, { warn: true });
        var prop = null;
        if (sector)
            prop = sector.addProperty(property, opts);
        return prop;
    };
    /**
     * Get the property.
     * @param {String} sectorId Sector id.
     * @param {String} id Property id.
     * @returns {[Property]|undefined}
     * @example
     * const property = styleManager.getProperty('mySector', 'min-height');
     */
    StyleManager.prototype.getProperty = function (sectorId, id) {
        var sector = this.getSector(sectorId, { warn: true });
        var prop;
        if (sector) {
            prop = sector.properties.filter(function (prop) { return prop.get('property') === id || prop.get('id') === id; })[0];
        }
        return prop;
    };
    /**
     * Get all properties of the sector.
     * @param {String} sectorId Sector id.
     * @returns {Collection<[Property]>|undefined} Collection of properties
     * @example
     * const properties = styleManager.getProperties('mySector');
     */
    StyleManager.prototype.getProperties = function (sectorId) {
        var props;
        var sector = this.getSector(sectorId, { warn: true });
        if (sector)
            props = sector.properties;
        return props;
    };
    /**
     * Remove the property.
     * @param {String} sectorId Sector id.
     * @param {String} id Property id.
     * @returns {[Property]|null} Removed property
     * @example
     * const property = styleManager.removeProperty('mySector', 'min-height');
     */
    StyleManager.prototype.removeProperty = function (sectorId, id) {
        var props = this.getProperties(sectorId);
        return props ? props.remove(this.getProperty(sectorId, id)) : null;
    };
    /**
     * Select new target.
     * The target could be a Component, CSSRule, or a CSS selector string.
     * @param {[Component]|[CSSRule]|String} target
     * @returns {Array<[Component]|[CSSRule]>} Array containing selected Components or CSSRules
     * @example
     * // Select the first button in the current page
     * const wrapperCmp = editor.Pages.getSelected().getMainComponent();
     * const btnCmp = wrapperCmp.find('button')[0];
     * btnCmp && styleManager.select(btnCmp);
     *
     * // Set as a target the CSS selector
     * styleManager.select('.btn > span');
     */
    StyleManager.prototype.select = function (target, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        var trgs = (0,index_all.isArray)(target) ? target : [target];
        var stylable = opts.stylable;
        var cssc = em.Css;
        var targets = [];
        trgs.filter(Boolean).forEach(function (target) {
            var model = target;
            if ((0,index_all.isString)(target)) {
                var rule = cssc.getRule(target) || cssc.setRule(target);
                !(0,index_all.isUndefined)(stylable) && rule.set({ stylable: stylable });
                model = rule;
            }
            targets.push(model);
        });
        var component = opts.component || targets.filter(function (t) { return (0,mixins.isComponent)(t); }).reverse()[0];
        targets = targets.map(function (t) { return _this.getModelToStyle(t); });
        var state = em.getState();
        var lastTarget = targets.slice().reverse()[0];
        var lastTargetParents = this.getParentRules(lastTarget, {
            state: state,
            // @ts-ignore
            component: component,
        });
        var stateTarget = this.__getStateTarget();
        // Handle the creation and update of the state rule, if enabled.
        em.skip(function () {
            var _a;
            // @ts-ignore
            if (state && ((_a = lastTarget === null || lastTarget === void 0 ? void 0 : lastTarget.getState) === null || _a === void 0 ? void 0 : _a.call(lastTarget))) {
                var style = lastTarget.getStyle();
                if (!stateTarget) {
                    stateTarget = cssc.getAll().add({
                        selectors: 'gjs-selected',
                        style: style,
                        shallow: true,
                        important: true,
                    });
                }
                else {
                    stateTarget.setStyle(style);
                }
            }
            else if (stateTarget) {
                cssc.remove(stateTarget);
                stateTarget = undefined;
            }
        });
        this.model.set({
            targets: targets,
            lastTarget: lastTarget,
            lastTargetParents: lastTargetParents,
            stateTarget: stateTarget,
            component: component,
        });
        this.__upProps(opts);
        return targets;
    };
    /**
     * Get the last selected target.
     * By default, the Style Manager shows styles of the last selected target.
     * @returns {[Component]|[CSSRule]|null}
     */
    StyleManager.prototype.getSelected = function () {
        return this.model.get('lastTarget');
    };
    /**
     * Get the array of selected targets.
     * @returns {Array<[Component]|[CSSRule]>}
     */
    StyleManager.prototype.getSelectedAll = function () {
        return this.model.get('targets');
    };
    /**
     * Get parent rules of the last selected target.
     * @returns {Array<[CSSRule]>}
     */
    StyleManager.prototype.getSelectedParents = function () {
        return this.model.get('lastTargetParents') || [];
    };
    StyleManager.prototype.__getStateTarget = function () {
        return this.model.get('stateTarget');
    };
    /**
     * Update selected targets with a custom style.
     * @param {Object} style Style object
     * @param {Object} [opts={}] Options
     * @example
     * styleManager.addStyleTargets({ color: 'red' });
     */
    StyleManager.prototype.addStyleTargets = function (style, opts) {
        this.getSelectedAll().map(function (t) { return t.addStyle(style, opts); });
        var target = this.getSelected();
        // Trigger style changes on selected components
        target && this.__emitCmpStyleUpdate(style);
        // Update state rule
        var targetState = this.__getStateTarget();
        target && (targetState === null || targetState === void 0 ? void 0 : targetState.setStyle(target.getStyle(), opts));
    };
    /**
     * Return built-in property definition
     * @param {String} prop Property name.
     * @returns {Object|null} Property definition.
     * @example
     * const widthPropDefinition = styleManager.getBuiltIn('width');
     */
    StyleManager.prototype.getBuiltIn = function (prop) {
        return this.builtIn.get(prop);
    };
    /**
     * Get all the available built-in property definitions.
     * @returns {Object}
     */
    StyleManager.prototype.getBuiltInAll = function () {
        return this.builtIn.props;
    };
    /**
     * Add built-in property definition.
     * If the property exists already, it will extend it.
     * @param {String} prop Property name.
     * @param {Object} definition Property definition.
     * @returns {Object} Added property definition.
     * @example
     * const sector = styleManager.addBuiltIn('new-property', {
     *  type: 'select',
     *  default: 'value1',
     *  options: [{ id: 'value1', label: 'Some label' }, ...],
     * })
     */
    StyleManager.prototype.addBuiltIn = function (prop, definition) {
        return this.builtIn.add(prop, definition);
    };
    /**
     * Get what to style inside Style Manager. If you select the component
     * without classes the entity is the Component itself and all changes will
     * go inside its 'style' property. Otherwise, if the selected component has
     * one or more classes, the function will return the corresponding CSS Rule
     * @param  {Model} model
     * @return {Model}
     * @private
     */
    StyleManager.prototype.getModelToStyle = function (model, options) {
        if (options === void 0) { options = {}; }
        var em = this.em;
        var skipAdd = options.skipAdd;
        if (em && (model === null || model === void 0 ? void 0 : model.toHTML)) {
            var config_1 = em.getConfig();
            var um = em.UndoManager;
            var cssC_1 = em.Css;
            var sm = em.Selectors;
            var smConf = sm ? sm.getConfig() : {};
            var state_1 = !config_1.devicePreviewMode ? em.get('state') : '';
            var classes = model.get('classes');
            var valid_1 = classes.getStyleable();
            var hasClasses_1 = valid_1.length;
            var useClasses_1 = !smConf.componentFirst || options.useClasses;
            var addOpts_1 = { noCount: 1 };
            var opts_1 = { state: state_1, addOpts: addOpts_1 };
            // Skipping undo manager here as after adding the CSSRule (generally after
            // selecting the component) and calling undo() it will remove the rule from
            // the collection, therefore updating it in style manager will not affect it
            // #268
            um.skip(function () {
                var rule;
                if (hasClasses_1 && useClasses_1) {
                    var deviceW = em.getCurrentMedia();
                    rule = cssC_1.get(valid_1, state_1, deviceW);
                    if (!rule && !skipAdd) {
                        rule = cssC_1.add(valid_1, state_1, deviceW, {}, addOpts_1);
                    }
                }
                else if (config_1.avoidInlineStyle) {
                    var id = model.getId();
                    rule = cssC_1.getIdRule(id, opts_1);
                    !rule && !skipAdd && (rule = cssC_1.setIdRule(id, {}, opts_1));
                    if (model.is('wrapper')) {
                        // @ts-ignore
                        rule.set('wrapper', 1, addOpts_1);
                    }
                }
                rule && (model = rule);
            });
        }
        return model;
    };
    StyleManager.prototype.getParentRules = function (target, _a) {
        var _b = _a === void 0 ? {} : _a, state = _b.state, component = _b.component;
        var em = this.em;
        var result = [];
        if (em && target) {
            var sel = component;
            var cssC_2 = em.Css;
            var cssGen = em.CodeManager.getGenerator('css');
            // @ts-ignore
            var cmp = target.toHTML ? target : target.getComponent();
            var optsSel = { array: true };
            var cmpRules = [];
            var otherRules = [];
            var rules = [];
            var rulesBySelectors = function (values) {
                return cssC_2.getRules().filter(function (rule) {
                    var rSels = rule.getSelectors().map(function (s) { return s.getFullName(); });
                    return rSels.every(function (rSel) { return values.indexOf(rSel) >= 0; });
                });
            };
            // Componente related rule
            if (cmp) {
                cmpRules = cssC_2.getRules("#".concat(cmp.getId()));
                otherRules = sel ? rulesBySelectors(sel.getSelectors().getFullName(optsSel)) : [];
                rules = otherRules.concat(cmpRules);
            }
            else {
                cmpRules = sel ? cssC_2.getRules("#".concat(sel.getId())) : [];
                otherRules = rulesBySelectors(target.getSelectors().getFullName(optsSel));
                rules = cmpRules.concat(otherRules);
            }
            var all = rules
                .filter(function (rule) { return (!(0,index_all.isUndefined)(state) ? rule.get('state') === state : 1); })
                .sort(cssGen.sortRules)
                .reverse();
            // Slice removes rules not related to the current device
            result = all.slice(all.indexOf(target) + 1);
        }
        return result;
    };
    /**
     * Add new property type
     * @param {string} id Type ID
     * @param {Object} definition Definition of the type.
     * @example
     * styleManager.addType('my-custom-prop', {
     *    // Create UI
     *    create({ props, change }) {
     *      const el = document.createElement('div');
     *      el.innerHTML = '<input type="range" class="my-input" min="10" max="50"/>';
     *      const inputEl = el.querySelector('.my-input');
     *      inputEl.addEventListener('change', event => change({ event }));
     *      inputEl.addEventListener('input', event => change({ event, partial: true }));
     *      return el;
     *    },
     *    // Propagate UI changes up to the targets
     *    emit({ props, updateStyle }, { event, partial }) {
     *      const { value } = event.target;
     *      updateStyle(`${value}px`, { partial });
     *    },
     *    // Update UI (eg. when the target is changed)
     *    update({ value, el }) {
     *      el.querySelector('.my-input').value = parseInt(value, 10);
     *    },
     *    // Clean the memory from side effects if necessary (eg. global event listeners, etc.)
     *    destroy() {}
     *})
     */
    StyleManager.prototype.addType = function (id, definition) {
        this.properties.addType(id, definition);
    };
    /**
     * Get type
     * @param {string} id Type ID
     * @return {Object} Type definition
     */
    StyleManager.prototype.getType = function (id) {
        return this.properties.getType(id);
    };
    /**
     * Get all types
     * @return {Array}
     */
    StyleManager.prototype.getTypes = function () {
        return this.properties.getTypes();
    };
    /**
     * Create new UI property from type (Experimental)
     * @param {string} id Type ID
     * @param  {Object} [options={}] Options
     * @param  {Object} [options.model={}] Custom model object
     * @param  {Object} [options.view={}] Custom view object
     * @return {PropertyView}
     * @private
     * @example
     * const propView = styleManager.createType('number', {
     *  model: {units: ['px', 'rem']}
     * });
     * propView.render();
     * propView.model.on('change:value', ...);
     * someContainer.appendChild(propView.el);
     */
    StyleManager.prototype.createType = function (id, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.model, model = _c === void 0 ? {} : _c, _d = _b.view, view = _d === void 0 ? {} : _d;
        var config = this.config;
        var type = this.getType(id);
        if (type) {
            return new type.view(style_manager_assign({ model: new type.model(model), config: config }, view));
        }
    };
    /**
     * Render sectors and properties
     * @return  {HTMLElement}
     * @private
     * */
    StyleManager.prototype.render = function () {
        var _a = this, config = _a.config, em = _a.em, SectView = _a.SectView;
        var el = SectView && SectView.el;
        this.SectView = new view_SectorsView({
            el: el,
            em: em,
            config: config,
            module: this,
            collection: this.sectors,
        });
        return this.SectView.render().el;
    };
    StyleManager.prototype._logNoSector = function (sectorId) {
        var em = this.em;
        em && em.logWarning("'".concat(sectorId, "' sector not found"));
    };
    StyleManager.prototype.__emitCmpStyleUpdate = function (style, opts) {
        if (opts === void 0) { opts = {}; }
        var em = this.em;
        // Ignore partial updates
        if (!style.__p) {
            var allSel_1 = this.getSelectedAll();
            var cmp = opts.components || em.getSelectedAll();
            var cmps = Array.isArray(cmp) ? cmp : [cmp];
            var newStyles_1 = style_manager_assign({}, style);
            delete newStyles_1.__p;
            cmps.forEach(function (cmp) {
                // if cmp is part of selected, the event should already been triggered
                return !allSel_1.includes(cmp) && cmp.__onStyleChange(newStyles_1);
            });
        }
    };
    StyleManager.prototype.__upProps = function (opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var lastTarget = this.getSelected();
        if (!lastTarget)
            return;
        var sectors = this.sectors;
        var component = this.model.get('component');
        var lastTargetParents = this.getSelectedParents();
        var style = lastTarget.getStyle();
        var parentStyles = lastTargetParents.map(function (p) { return ({
            target: p,
            style: p.getStyle(),
        }); });
        sectors.map(function (sector) {
            sector.getProperties().map(function (prop) {
                _this.__upProp(prop, style, parentStyles, opts);
            });
        });
        // Update sectors/properties visibility
        sectors.forEach(function (sector) {
            var props = sector.getProperties();
            props.forEach(function (prop) {
                var isVisible = prop.__checkVisibility({
                    target: lastTarget,
                    component: component,
                    // @ts-ignore
                    sectors: sectors,
                });
                prop.set('visible', isVisible);
            });
            var sectorVisible = props.some(function (p) { return p.isVisible(); });
            sector.set('visible', sectorVisible);
        });
    };
    StyleManager.prototype.__upProp = function (prop, style, parentStyles, opts) {
        var _this = this;
        var name = prop.getName();
        var value = style[name];
        var hasVal = propDef(value);
        var isStack = prop.getType() === 'stack';
        var isComposite = prop.getType() === 'composite';
        var opt = style_manager_assign(style_manager_assign({}, opts), { __up: true });
        var canUpdate = !isComposite && !isStack;
        var newLayers = isStack ? prop.__getLayersFromStyle(style) : [];
        var newProps = isComposite ? prop.__getPropsFromStyle(style) : {};
        var newValue = hasVal ? value : null;
        var parentTarget = null;
        if ((isStack && newLayers === null) || (isComposite && newProps === null)) {
            var method_1 = isStack ? '__getLayersFromStyle' : '__getPropsFromStyle';
            var parentItem = parentStyles.filter(function (p) { return prop[method_1](p.style) !== null; })[0];
            if (parentItem) {
                newValue = parentItem.style[name];
                parentTarget = parentItem.target;
                var val = prop[method_1](parentItem.style);
                if (isStack) {
                    newLayers = val;
                }
                else {
                    newProps = val;
                }
            }
        }
        else if (!hasVal) {
            newValue = null;
            var parentItem = parentStyles.filter(function (p) { return propDef(p.style[name]); })[0];
            if (parentItem) {
                newValue = parentItem.style[name];
                parentTarget = parentItem.target;
            }
        }
        prop.__setParentTarget(parentTarget);
        canUpdate && prop.__getFullValue() !== newValue && prop.upValue(newValue, opt);
        isStack && prop.__setLayers(newLayers || []);
        if (isComposite) {
            var props = prop.getProperties();
            // Detached has to be treathed as separate properties
            if (prop.isDetached()) {
                var newStyle_1 = prop.__getPropsFromStyle(style, { byName: true }) || {};
                var newParentStyles_1 = parentStyles.map(function (p) { return (style_manager_assign(style_manager_assign({}, p), { style: prop.__getPropsFromStyle(p.style, { byName: true }) || {} })); });
                props.map(function (pr) { return _this.__upProp(pr, newStyle_1, newParentStyles_1, opts); });
            }
            else {
                prop.__setProperties(newProps || {}, opt);
                prop.getProperties().map(function (pr) { return pr.__setParentTarget(parentTarget); });
            }
        }
    };
    StyleManager.prototype.destroy = function () {
        var _a;
        [this.properties, this.sectors].forEach(function (coll) {
            coll.reset();
            coll.stopListening();
        });
        (_a = this.SectView) === null || _a === void 0 ? void 0 : _a.remove();
        this.model.stopListening();
        this.upAll.cancel();
    };
    return StyleManager;
}(ItemManagerModule));
/* harmony default export */ const style_manager = (StyleManager);

;// CONCATENATED MODULE: ./src/editor/model/Editor.ts
var Editor_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Editor_assign = (undefined && undefined.__assign) || function () {
    Editor_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return Editor_assign.apply(this, arguments);
};
var Editor_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var Editor_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var Editor_rest = (undefined && undefined.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var Editor_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};






























(backbone_default()).$ = cash_dom["default"];
var deps = [
    utils,
    i18n,
    keymaps,
    undo_manager,
    storage_manager,
    device_manager,
    src_parser,
    style_manager,
    selector_manager,
    modal_dialog,
    code_manager,
    src_panels,
    rich_text_editor,
    trait_manager,
    src_navigator,
    canvas,
    commands,
    block_manager,
];
var storableDeps = [
    asset_manager,
    css_composer,
    pages,
    dom_components,
];
extender({ $: cash_dom["default"] });
var logs = {
    debug: console.log,
    info: console.info,
    warning: console.warn,
    error: console.error,
};
var EditorModel = /** @class */ (function (_super) {
    Editor_extends(EditorModel, _super);
    function EditorModel(conf) {
        if (conf === void 0) { conf = {}; }
        var _this = _super.call(this) || this;
        _this.__skip = false;
        _this.defaultRunning = false;
        _this.destroyed = false;
        _this._config = conf;
        var config = _this.config;
        _this.set('Config', conf);
        _this.set('modules', []);
        _this.set('toLoad', []);
        _this.set('storables', []);
        _this.set('selected', new model_Selected());
        _this.set('dmode', config.dragMode);
        var el = config.el, log = config.log;
        var toLog = log === true ? (0,index_all.keys)(logs) : (0,index_all.isArray)(log) ? log : [];
        (0,index_all.bindAll)(_this, 'initBaseColorPicker');
        if (el && config.fromElement) {
            config.components = el.innerHTML;
        }
        _this.attrsOrig = el
            ? (0,index_all.toArray)(el.attributes).reduce(function (res, next) {
                res[next.nodeName] = next.nodeValue;
                return res;
            }, {})
            : '';
        // Move components to pages
        if (config.components && !config.pageManager) {
            config.pageManager = { pages: [{ component: config.components }] };
        }
        // Load modules
        deps.forEach(function (constr) { return _this.loadModule(constr); });
        storableDeps.forEach(function (constr) { return _this.loadStorableModule(constr); });
        _this.on('change:componentHovered', _this.componentHovered, _this);
        _this.on('change:changesCount', _this.updateChanges, _this);
        _this.on('change:readyLoad change:readyCanvas', _this._checkReady, _this);
        toLog.forEach(function (e) { return _this.listenLog(e); });
        // Deprecations
        [{ from: 'change:selectedComponent', to: 'component:toggled' }].forEach(function (event) {
            var eventFrom = event.from;
            var eventTo = event.to;
            _this.listenTo(_this, eventFrom, function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                _this.trigger.apply(_this, Editor_spreadArray([eventTo], args, false));
                _this.logWarning("The event '".concat(eventFrom, "' is deprecated, replace it with '").concat(eventTo, "'"));
            });
        });
        return _this;
    }
    EditorModel.prototype.defaults = function () {
        return {
            editing: 0,
            selected: 0,
            clipboard: null,
            dmode: 0,
            componentHovered: null,
            previousModel: null,
            changesCount: 0,
            storables: [],
            modules: [],
            toLoad: [],
            opened: {},
            device: '',
        };
    };
    Object.defineProperty(EditorModel.prototype, "storables", {
        get: function () {
            return this.get('storables');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "modules", {
        get: function () {
            return this.get('modules');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "toLoad", {
        get: function () {
            return this.get('toLoad');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "selected", {
        get: function () {
            return this.get('selected');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "shallow", {
        get: function () {
            return this.get('shallow');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "I18n", {
        get: function () {
            return this.get('I18n');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Utils", {
        get: function () {
            return this.get('Utils');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Commands", {
        get: function () {
            return this.get('Commands');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Keymaps", {
        get: function () {
            return this.get('Keymaps');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Modal", {
        get: function () {
            return this.get('Modal');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Panels", {
        get: function () {
            return this.get('Panels');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "CodeManager", {
        get: function () {
            return this.get('CodeManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "UndoManager", {
        get: function () {
            return this.get('UndoManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "RichTextEditor", {
        get: function () {
            return this.get('RichTextEditor');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Canvas", {
        get: function () {
            return this.get('Canvas');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Editor", {
        get: function () {
            return this.get('Editor');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Components", {
        get: function () {
            return this.get('DomComponents');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Css", {
        get: function () {
            return this.get('CssComposer');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Blocks", {
        get: function () {
            return this.get('BlockManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Selectors", {
        get: function () {
            return this.get('SelectorManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Storage", {
        get: function () {
            return this.get('StorageManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Traits", {
        get: function () {
            return this.get('TraitManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Parser", {
        get: function () {
            return this.get('Parser');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Layers", {
        get: function () {
            return this.get('LayerManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Assets", {
        get: function () {
            return this.get('AssetManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Devices", {
        get: function () {
            return this.get('DeviceManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Pages", {
        get: function () {
            return this.get('PageManager');
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(EditorModel.prototype, "Styles", {
        get: function () {
            return this.get('StyleManager');
        },
        enumerable: false,
        configurable: true
    });
    EditorModel.prototype._checkReady = function () {
        if (this.get('readyLoad') && this.get('readyCanvas') && !this.get('ready')) {
            this.set('ready', true);
        }
    };
    EditorModel.prototype.getContainer = function () {
        return this.config.el;
    };
    EditorModel.prototype.listenLog = function (event) {
        //@ts-ignore
        this.listenTo(this, "log:".concat(event), logs[event]);
    };
    Object.defineProperty(EditorModel.prototype, "config", {
        get: function () {
            return this._config;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get configurations
     * @param  {string} [prop] Property name
     * @return {any} Returns the configuration object or
     *  the value of the specified property
     */
    EditorModel.prototype.getConfig = function (prop) {
        var config = this.config;
        // @ts-ignore
        return (0,index_all.isUndefined)(prop) ? config : config[prop];
    };
    /**
     * Should be called once all modules and plugins are loaded
     * @private
     */
    EditorModel.prototype.loadOnStart = function () {
        var _this = this;
        var _a = this.config, projectData = _a.projectData, headless = _a.headless;
        var sm = this.Storage;
        // In `onLoad`, the module will try to load the data from its configurations.
        this.toLoad.reverse().forEach(function (mdl) { return mdl.onLoad(); });
        // Stuff to do post load
        var postLoad = function () {
            _this.modules.forEach(function (mdl) { return mdl.postLoad && mdl.postLoad(_this); });
            _this.set('readyLoad', 1);
        };
        if (headless) {
            projectData && this.loadData(projectData);
            postLoad();
        }
        else {
            // Defer for storage load events.
            this._storageTimeout = setTimeout(function () { return Editor_awaiter(_this, void 0, void 0, function () {
                var error_1;
                return Editor_generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!projectData) return [3 /*break*/, 1];
                            this.loadData(projectData);
                            return [3 /*break*/, 5];
                        case 1:
                            if (!(sm === null || sm === void 0 ? void 0 : sm.canAutoload())) return [3 /*break*/, 5];
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.load()];
                        case 3:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            error_1 = _a.sent();
                            this.logError(error_1);
                            return [3 /*break*/, 5];
                        case 5:
                            postLoad();
                            return [2 /*return*/];
                    }
                });
            }); });
        }
        // Create shallow editor.
        // Here we can create components/styles without altering/triggering the main EditorModel
        var shallow = new EditorModel({
            noticeOnUnload: false,
            storageManager: false,
            undoManager: false,
        });
        // We only need to load a few modules
        shallow.Pages.onLoad();
        shallow.Canvas.postLoad();
        this.set('shallow', shallow);
    };
    /**
     * Set the alert before unload in case it's requested
     * and there are unsaved changes
     * @private
     */
    EditorModel.prototype.updateChanges = function (m, v, opts) {
        var _this = this;
        var stm = this.Storage;
        var changes = this.getDirtyCount();
        if (!opts.isClear) {
            this.updateItr && clearTimeout(this.updateItr);
            this.updateItr = setTimeout(function () { return _this.trigger('update'); });
        }
        if (this.config.noticeOnUnload) {
            window.onbeforeunload = changes ? function () { return true; } : null;
        }
        if (stm.isAutosave() && changes >= stm.getStepsBeforeSave()) {
            this.store().catch(function (err) { return _this.logError(err); });
        }
    };
    /**
     * Load generic module
     */
    EditorModel.prototype.loadModule = function (InitModule) {
        var Mod = new InitModule(this);
        this.set(Mod.name, Mod);
        Mod.onLoad && this.toLoad.push(Mod);
        this.modules.push(Mod);
        return Mod;
    };
    EditorModel.prototype.loadStorableModule = function (InitModule) {
        var Mod = this.loadModule(InitModule);
        this.storables.push(Mod);
        return Mod;
    };
    /**
     * Initialize editor model and set editor instance
     * @param {Editor} editor Editor instance
     * @return {this}
     * @public
     */
    EditorModel.prototype.init = function (editor, opts) {
        if (opts === void 0) { opts = {}; }
        if (this.destroyed) {
            this.initialize(opts);
            this.destroyed = false;
        }
        this.set('Editor', editor);
    };
    EditorModel.prototype.getEditor = function () {
        return this.get('Editor');
    };
    /**
     * This method handles updates on the editor and tries to store them
     * if requested and if the changesCount is exceeded
     * @param  {Object} model
     * @param  {any} val  Value
     * @param  {Object} opt  Options
     * @private
     * */
    EditorModel.prototype.handleUpdates = function (model, val, opt) {
        var _this = this;
        if (opt === void 0) { opt = {}; }
        // Component has been added temporarily - do not update storage or record changes
        if (this.__skip || opt.temporary || opt.noCount || opt.avoidStore || !this.get('ready')) {
            return;
        }
        this.timedInterval && clearTimeout(this.timedInterval);
        this.timedInterval = setTimeout(function () {
            var curr = _this.getDirtyCount() || 0;
            var unset = opt.unset, opts = Editor_rest(opt, ["unset"]);
            _this.set('changesCount', curr + 1, opts);
        }, 0);
    };
    EditorModel.prototype.changesUp = function (opts) {
        this.handleUpdates(0, 0, opts);
    };
    /**
     * Callback on component hover
     * @param   {Object}   Model
     * @param   {Mixed}   New value
     * @param   {Object}   Options
     * @private
     * */
    EditorModel.prototype.componentHovered = function (editor, component, options) {
        var prev = this.previous('componentHovered');
        prev && this.trigger('component:unhovered', prev, options);
        component && this.trigger('component:hovered', component, options);
    };
    /**
     * Returns model of the selected component
     * @return {Component|null}
     * @public
     */
    EditorModel.prototype.getSelected = function () {
        return this.selected.lastComponent();
    };
    /**
     * Returns an array of all selected components
     * @return {Array}
     * @public
     */
    EditorModel.prototype.getSelectedAll = function () {
        return this.selected.allComponents();
    };
    /**
     * Select a component
     * @param  {Component} el Component to select
     * @param  {Object} [opts={}] Options, optional
     * @public
     */
    EditorModel.prototype.setSelected = function (el, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var event = opts.event;
        var ctrlKey = event && (event.ctrlKey || event.metaKey);
        var shiftKey = (event || {}).shiftKey;
        var models = ((0,index_all.isArray)(el) ? el : [el])
            .map(function (cmp) { var _a, _b; return ((_b = (_a = cmp === null || cmp === void 0 ? void 0 : cmp.delegate) === null || _a === void 0 ? void 0 : _a.select) === null || _b === void 0 ? void 0 : _b.call(_a, cmp)) || cmp; })
            .filter(Boolean);
        var selected = this.getSelectedAll();
        var mltSel = this.getConfig().multipleSelection;
<<<<<<< HEAD
        // If an array is passed remove all selected
        // expect those yet to be selected
        var multiple = (0,index_all.isArray)(el);
        multiple && this.removeSelected(selected.filter(function (s) { return !(0,index_all.contains)(models, s); }));
=======
        var multiple = (0,index_all.isArray)(el);
        if (multiple || !el) {
            this.removeSelected(selected.filter(function (s) { return !(0,index_all.contains)(models, s); }));
        }
>>>>>>> script-module
        models.forEach(function (model) {
            if (model) {
                _this.trigger('component:select:before', model, opts);
                // Check for valid selectable
                if (!model.get('selectable') || opts.abort) {
                    if (opts.useValid) {
                        var parent_1 = model.parent();
                        while (parent_1 && !parent_1.get('selectable'))
                            parent_1 = parent_1.parent();
                        model = parent_1;
                    }
                    else {
                        return;
                    }
                }
            }
            // Hanlde multiple selection
            if (ctrlKey && mltSel) {
                return _this.toggleSelected(model);
            }
            else if (shiftKey && mltSel) {
                _this.clearSelection(_this.Canvas.getWindow());
                var coll_1 = model.collection;
                var index_1 = model.index();
                var min_1, max_1;
                // Fin min and max siblings
                _this.getSelectedAll().forEach(function (sel) {
                    var selColl = sel.collection;
                    var selIndex = sel.index();
                    if (selColl === coll_1) {
                        if (selIndex < index_1) {
                            // First model BEFORE the selected one
                            min_1 = (0,index_all.isUndefined)(min_1) ? selIndex : Math.max(min_1, selIndex);
                        }
                        else if (selIndex > index_1) {
                            // First model AFTER the selected one
                            max_1 = (0,index_all.isUndefined)(max_1) ? selIndex : Math.min(max_1, selIndex);
                        }
                    }
                });
                if (!(0,index_all.isUndefined)(min_1)) {
                    while (min_1 !== index_1) {
                        _this.addSelected(coll_1.at(min_1));
                        min_1++;
                    }
                }
                if (!(0,index_all.isUndefined)(max_1)) {
                    while (max_1 !== index_1) {
                        _this.addSelected(coll_1.at(max_1));
                        max_1--;
                    }
                }
                return _this.addSelected(model);
            }
            !multiple && _this.removeSelected(selected.filter(function (s) { return s !== model; }));
            _this.addSelected(model, opts);
        });
    };
    /**
     * Add component to selection
     * @param  {Component|Array<Component>} component Component to select
     * @param  {Object} [opts={}] Options, optional
     * @public
     */
    EditorModel.prototype.addSelected = function (component, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var models = (0,index_all.isArray)(component) ? component : [component];
        models.forEach(function (model) {
            var selected = _this.selected;
            if (!model ||
                !model.get('selectable') ||
                // Avoid selecting children of selected components
                model.parents().some(function (parent) { return selected.hasComponent(parent); })) {
                return;
            }
            opts.forceChange && _this.removeSelected(model, opts);
            // Remove from selection, children of the component to select
            var toDeselect = selected.allComponents().filter(function (cmp) { return (0,index_all.contains)(cmp.parents(), model); });
            toDeselect.forEach(function (cmp) { return _this.removeSelected(cmp, opts); });
            selected.addComponent(model, opts);
            _this.trigger('component:select', model, opts);
            _this.Canvas.addSpot({
                type: CanvasSpot/* CanvasSpotBuiltInTypes */.q.Select,
                component: model,
            });
        });
    };
    /**
     * Remove component from selection
     * @param  {Component|Array<Component>} component Component to select
     * @param  {Object} [opts={}] Options, optional
     * @public
     */
    EditorModel.prototype.removeSelected = function (component, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        this.selected.removeComponent(component, opts);
        var cmps = (0,index_all.isArray)(component) ? component : [component];
        cmps.forEach(function (component) {
            return _this.Canvas.removeSpots({
                type: CanvasSpot/* CanvasSpotBuiltInTypes */.q.Select,
                component: component,
            });
        });
    };
    /**
     * Toggle component selection
     * @param  {Component|Array<Component>} component Component to select
     * @param  {Object} [opts={}] Options, optional
     * @public
     */
    EditorModel.prototype.toggleSelected = function (component, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var models = (0,index_all.isArray)(component) ? component : [component];
        models.forEach(function (model) {
            if (_this.selected.hasComponent(model)) {
                _this.removeSelected(model, opts);
            }
            else {
                _this.addSelected(model, opts);
            }
        });
    };
    /**
     * Hover a component
     * @param  {Component|Array<Component>} cmp Component to select
     * @param  {Object} [opts={}] Options, optional
     * @private
     */
    EditorModel.prototype.setHovered = function (cmp, opts) {
        var _this = this;
        if (opts === void 0) { opts = {}; }
        var upHovered = function (cmp, opts) {
            var _a = _this, config = _a.config, Canvas = _a.Canvas;
            var current = _this.getHovered();
            var selectedAll = _this.getSelectedAll();
            var typeHover = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Hover;
            var typeSpacing = CanvasSpot/* CanvasSpotBuiltInTypes */.q.Spacing;
            _this.set('componentHovered', cmp || null, opts);
            if (current) {
                Canvas.removeSpots({ type: typeHover, component: current });
                Canvas.removeSpots({ type: typeSpacing, component: current });
            }
            if (cmp) {
                Canvas.addSpot({ type: typeHover, component: cmp });
                if (!selectedAll.includes(cmp) || config.showOffsetsSelected) {
                    Canvas.addSpot({ type: typeSpacing, component: cmp });
                }
            }
        };
        if (!cmp) {
            return upHovered();
        }
        var ev = 'component:hover';
        opts.forceChange && upHovered();
        this.trigger("".concat(ev, ":before"), cmp, opts);
        // Check for valid hoverable
        if (!cmp.get('hoverable')) {
            if (opts.useValid && !opts.abort) {
                var parent_2 = cmp.parent();
                while (parent_2 && !parent_2.get('hoverable'))
                    parent_2 = parent_2.parent();
                cmp = parent_2;
            }
            else {
                return;
            }
        }
        if (!opts.abort) {
            upHovered(cmp, opts);
            this.trigger(ev, cmp, opts);
        }
    };
    EditorModel.prototype.getHovered = function () {
        return this.get('componentHovered');
    };
    /**
     * Set components inside editor's canvas. This method overrides actual components
     * @param {Object|string} components HTML string or components model
     * @param {Object} opt the options object to be used by the [setComponents]{@link setComponents} method
     * @return {this}
     * @public
     */
    EditorModel.prototype.setComponents = function (components, opt) {
        if (opt === void 0) { opt = {}; }
        return this.Components.setComponents(components, opt);
    };
    /**
     * Returns components model from the editor's canvas
     * @return {Components}
     * @private
     */
    EditorModel.prototype.getComponents = function () {
        var cmp = this.Components;
        var cm = this.CodeManager;
        if (!cmp || !cm)
            return;
        var wrp = cmp.getComponents();
        return cm.getCode(wrp, 'json');
    };
    /**
     * Set style inside editor's canvas. This method overrides actual style
     * @param {Object|string} style CSS string or style model
     * @param {Object} opt the options object to be used by the `CssRules.add` method
     * @return {this}
     * @public
     */
    EditorModel.prototype.setStyle = function (style, opt) {
        if (opt === void 0) { opt = {}; }
        var cssc = this.Css;
        cssc.clear(opt);
        cssc.getAll().add(style, opt);
        return this;
    };
    /**
     * Add styles to the editor
     * @param {Array<Object>|Object|string} style CSS string or style model
     * @returns {Array<CssRule>}
     * @public
     */
    EditorModel.prototype.addStyle = function (style, opts) {
        if (opts === void 0) { opts = {}; }
        var res = this.getStyle().add(style, opts);
        return (0,index_all.isArray)(res) ? res : [res];
    };
    /**
     * Returns rules/style model from the editor's canvas
     * @return {Rules}
     * @private
     */
    EditorModel.prototype.getStyle = function () {
        return this.Css.getAll();
    };
    /**
     * Change the selector state
     * @param {String} value State value
     * @returns {this}
     */
    EditorModel.prototype.setState = function (value) {
        this.set('state', value);
        return this;
    };
    /**
     * Get the current selector state
     * @returns {String}
     */
    EditorModel.prototype.getState = function () {
        return this.get('state') || '';
    };
    /**
     * Returns HTML built inside canvas
     * @param {Object} [opts={}] Options
     * @returns {string} HTML string
     * @public
     */
    EditorModel.prototype.getHtml = function (opts) {
        if (opts === void 0) { opts = {}; }
        var config = this.config;
        var optsHtml = config.optsHtml;
        var js = config.jsInHtml ? this.getJs(opts) : '';
        var cmp = opts.component || this.Components.getComponent();
        var html = cmp
            ? this.CodeManager.getCode(cmp, 'html', Editor_assign(Editor_assign({}, optsHtml), opts))
            : '';
        html += js ? "<script>".concat(js, "</script>") : '';
        return html;
    };
    /**
     * Returns CSS built inside canvas
     * @param {Object} [opts={}] Options
     * @returns {string} CSS string
     * @public
     */
    EditorModel.prototype.getCss = function (opts) {
        if (opts === void 0) { opts = {}; }
        var config = this.config;
        var optsCss = config.optsCss;
        var avoidProt = opts.avoidProtected;
        var keepUnusedStyles = !(0,index_all.isUndefined)(opts.keepUnusedStyles) ? opts.keepUnusedStyles : config.keepUnusedStyles;
        var cssc = this.Css;
        var wrp = opts.component || this.Components.getComponent();
        var protCss = !avoidProt ? config.protectedCss : '';
        var css = wrp &&
            this.CodeManager.getCode(wrp, 'css', Editor_assign(Editor_assign({ cssc: cssc, keepUnusedStyles: keepUnusedStyles }, optsCss), opts));
        return wrp ? (opts.json ? css : protCss + css) : '';
    };
    /**
     * Returns JS of all components
     * @return {string} JS string
     * @public
     */
    EditorModel.prototype.getJs = function (opts) {
        if (opts === void 0) { opts = {}; }
        var wrp = opts.component || this.Components.getWrapper();
        return wrp ? this.CodeManager.getCode(wrp, 'js').trim() : '';
    };
    /**
     * Store data to the current storage.
     * @public
     */
    EditorModel.prototype.store = function (options) {
        return Editor_awaiter(this, void 0, void 0, function () {
            var data;
            return Editor_generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        data = this.storeData();
                        return [4 /*yield*/, this.Storage.store(data, options)];
                    case 1:
                        _a.sent();
                        this.clearDirtyCount();
                        return [2 /*return*/, data];
                }
            });
        });
    };
    /**
     * Load data from the current storage.
     * @public
     */
    EditorModel.prototype.load = function (options, loadOptions) {
        if (loadOptions === void 0) { loadOptions = {}; }
        return Editor_awaiter(this, void 0, void 0, function () {
            var result;
            return Editor_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.Storage.load(options)];
                    case 1:
                        result = _a.sent();
                        this.loadData(result);
                        // Wait in order to properly update the dirty counter (#5385)
                        return [4 /*yield*/, (0,mixins.wait)()];
                    case 2:
                        // Wait in order to properly update the dirty counter (#5385)
                        _a.sent();
                        if (loadOptions.clear) {
                            this.UndoManager.clear();
                            this.clearDirtyCount();
                        }
                        return [2 /*return*/, result];
                }
            });
        });
    };
    EditorModel.prototype.storeData = function () {
        var result = {};
        // Sync content if there is an active RTE
        var editingCmp = this.getEditing();
        editingCmp && editingCmp.trigger('sync:content', { noCount: true });
        this.storables.forEach(function (m) {
            result = Editor_assign(Editor_assign({}, result), m.store(1));
        });
        return JSON.parse(JSON.stringify(result));
    };
    EditorModel.prototype.loadData = function (data) {
        if (data === void 0) { data = {}; }
        if (!(0,mixins.isEmptyObj)(data)) {
            this.storables.forEach(function (module) { return module.clear(); });
            this.storables.forEach(function (module) { return module.load(data); });
        }
        return data;
    };
    /**
     * Returns device model by name
     * @return {Device|null}
     * @private
     */
    EditorModel.prototype.getDeviceModel = function () {
        var name = this.get('device');
        return this.Devices.get(name);
    };
    /**
     * Run default command if setted
     * @param {Object} [opts={}] Options
     * @private
     */
    EditorModel.prototype.runDefault = function (opts) {
        if (opts === void 0) { opts = {}; }
        var command = this.get('Commands').get(this.config.defaultCommand);
        if (!command || this.defaultRunning)
            return;
        command.stop(this, this, opts);
        command.run(this, this, opts);
        this.defaultRunning = true;
    };
    /**
     * Stop default command
     * @param {Object} [opts={}] Options
     * @private
     */
    EditorModel.prototype.stopDefault = function (opts) {
        if (opts === void 0) { opts = {}; }
        var commands = this.get('Commands');
        var command = commands.get(this.config.defaultCommand);
        if (!command || !this.defaultRunning)
            return;
        command.stop(this, this, opts);
        this.defaultRunning = false;
    };
    /**
     * Update canvas dimensions and refresh data useful for tools positioning
     * @public
     */
    EditorModel.prototype.refreshCanvas = function (opts) {
        if (opts === void 0) { opts = {}; }
        this.set('canvasOffset', null);
        this.set('canvasOffset', this.Canvas.getOffset());
        opts.tools && this.trigger('canvas:updateTools');
    };
    /**
     * Clear all selected stuf inside the window, sometimes is useful to call before
     * doing some dragging opearation
     * @param {Window} win If not passed the current one will be used
     * @private
     */
    EditorModel.prototype.clearSelection = function (win) {
        var _a;
        var w = win || window;
        (_a = w.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
    };
    /**
     * Get the current media text
     * @return {string}
     */
    EditorModel.prototype.getCurrentMedia = function () {
        var config = this.config;
        var device = this.getDeviceModel();
        var condition = config.mediaCondition;
        var preview = config.devicePreviewMode;
        var width = device && device.get('widthMedia');
        return device && width && !preview ? "(".concat(condition, ": ").concat(width, ")") : '';
    };
    /**
     * Return the component wrapper
     * @return {Component}
     */
    EditorModel.prototype.getWrapper = function () {
        return this.Components.getWrapper();
    };
    EditorModel.prototype.setCurrentFrame = function (frameView) {
        return this.set('currentFrame', frameView);
    };
    EditorModel.prototype.getCurrentFrame = function () {
        return this.get('currentFrame');
    };
    EditorModel.prototype.getCurrentFrameModel = function () {
        var _a;
        return (_a = (this.getCurrentFrame() || {})) === null || _a === void 0 ? void 0 : _a.model;
    };
    EditorModel.prototype.getIcon = function (icon) {
        var icons = this.config.icons || {};
        return icons[icon] || '';
    };
    /**
     * Return the count of changes made to the content and not yet stored.
     * This count resets at any `store()`
     * @return {number}
     */
    EditorModel.prototype.getDirtyCount = function () {
        return this.get('changesCount');
    };
    EditorModel.prototype.clearDirtyCount = function () {
        return this.set({ changesCount: 0 }, { isClear: true });
    };
    EditorModel.prototype.getZoomDecimal = function () {
        return this.Canvas.getZoomDecimal();
    };
    EditorModel.prototype.getZoomMultiplier = function () {
        return this.Canvas.getZoomMultiplier();
    };
    EditorModel.prototype.setDragMode = function (value) {
        return this.set('dmode', value);
    };
    EditorModel.prototype.getDragMode = function (component) {
        var mode = (component === null || component === void 0 ? void 0 : component.getDragMode()) || this.get('dmode');
        return mode || '';
    };
    EditorModel.prototype.t = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var i18n = this.get('I18n');
        return i18n === null || i18n === void 0 ? void 0 : i18n.t.apply(i18n, args);
    };
    /**
     * Returns true if the editor is in absolute mode
     * @returns {Boolean}
     */
    EditorModel.prototype.inAbsoluteMode = function (component) {
        return this.getDragMode(component) === 'absolute';
    };
    /**
     * Destroy editor
     */
    EditorModel.prototype.destroyAll = function () {
        var _this = this;
        var _a = this, config = _a.config, view = _a.view;
        var editor = this.getEditor();
        // @ts-ignore
        var _b = (config.grapesjs || {}).editors, editors = _b === void 0 ? [] : _b;
        var shallow = this.get('shallow');
        this._storageTimeout && clearTimeout(this._storageTimeout);
        shallow === null || shallow === void 0 ? void 0 : shallow.destroyAll();
        this.stopListening();
        this.stopDefault();
        this.modules
            .slice()
            .reverse()
            .forEach(function (mod) { return mod.destroy(); });
        view && view.remove();
        this.clear({ silent: true });
        this.destroyed = true;
        ['_config', 'view', '_previousAttributes', '_events', '_listeners'].forEach(
        //@ts-ignore
        function (i) { return (_this[i] = {}); });
        editors.splice(editors.indexOf(editor), 1);
        //@ts-ignore
        (0,mixins.hasWin)() && (0,cash_dom["default"])(config.el).empty().attr(this.attrsOrig);
    };
    EditorModel.prototype.getEditing = function () {
        var res = this.get('editing');
        return (res && res.model) || undefined;
    };
    EditorModel.prototype.setEditing = function (value) {
        this.set('editing', value);
        return this;
    };
    EditorModel.prototype.isEditing = function () {
        return !!this.get('editing');
    };
    EditorModel.prototype.log = function (msg, opts) {
        if (opts === void 0) { opts = {}; }
        var ns = opts.ns, _a = opts.level, level = _a === void 0 ? 'debug' : _a;
        this.trigger('log', msg, opts);
        level && this.trigger("log:".concat(level), msg, opts);
        if (ns) {
            var logNs = "log-".concat(ns);
            this.trigger(logNs, msg, opts);
            level && this.trigger("".concat(logNs, ":").concat(level), msg, opts);
        }
    };
    EditorModel.prototype.logInfo = function (msg, opts) {
        this.log(msg, Editor_assign(Editor_assign({}, opts), { level: 'info' }));
    };
    EditorModel.prototype.logWarning = function (msg, opts) {
        this.log(msg, Editor_assign(Editor_assign({}, opts), { level: 'warning' }));
    };
    EditorModel.prototype.logError = function (msg, opts) {
        this.log(msg, Editor_assign(Editor_assign({}, opts), { level: 'error' }));
    };
    EditorModel.prototype.initBaseColorPicker = function (el, opts) {
        if (opts === void 0) { opts = {}; }
        var config = this.config;
        var _a = config.colorPicker, colorPicker = _a === void 0 ? {} : _a;
        var elToAppend = config.el;
        var ppfx = config.stylePrefix;
        //@ts-ignore
        return (0,cash_dom["default"])(el).spectrum(Editor_assign(Editor_assign({ containerClassName: "".concat(ppfx, "one-bg ").concat(ppfx, "two-color"), appendTo: elToAppend || 'body', maxSelectionSize: 8, showPalette: true, palette: [], showAlpha: true, chooseText: 'Ok', cancelText: '⨯' }, opts), colorPicker));
    };
    /**
     * Execute actions without triggering the storage and undo manager.
     * @param  {Function} clb
     * @private
     */
    EditorModel.prototype.skip = function (clb) {
        this.__skip = true;
        var um = this.UndoManager;
        um ? um.skip(clb) : clb();
        this.__skip = false;
    };
    /**
     * Set/get data from the HTMLElement
     * @param  {HTMLElement} el
     * @param  {string} name Data name
     * @param  {any} value Date value
     * @return {any}
     * @private
     */
    EditorModel.prototype.data = function (el, name, value) {
        var varName = '_gjs-data';
        if (!el[varName]) {
            el[varName] = {};
        }
        if ((0,index_all.isUndefined)(value)) {
            return el[varName][name];
        }
        else {
            el[varName][name] = value;
        }
    };
    return EditorModel;
}(common/* Model */.Hn));
/* harmony default export */ const model_Editor = (EditorModel);

;// CONCATENATED MODULE: ./src/editor/view/EditorView.ts
var view_EditorView_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var EditorView_EditorView = /** @class */ (function (_super) {
    view_EditorView_extends(EditorView, _super);
    function EditorView(model) {
        var _this = _super.call(this, { model: model }) || this;
        //const { model } = this;
        var _a = model.attributes, Panels = _a.Panels, UndoManager = _a.UndoManager;
        model.view = _this;
        model.once('change:ready', function () {
            Panels.active();
            Panels.disableButtons();
            UndoManager.clear();
            setTimeout(function () {
                model.trigger('load', model.get('Editor'));
                model.clearDirtyCount();
            });
        });
        return _this;
    }
    EditorView.prototype.render = function () {
        var _this = this;
        var _a = this, $el = _a.$el, model = _a.model;
        var _b = model.attributes, Panels = _b.Panels, Canvas = _b.Canvas;
        var config = model.config, modules = model.modules;
        var pfx = config.stylePrefix;
        var classNames = ["".concat(pfx, "editor")];
        !config.customUI && classNames.push("".concat(pfx, "one-bg ").concat(pfx, "two-color"));
        // @ts-ignore
        var contEl = (0,cash_dom["default"])(config.el || "body ".concat(config.container));
        config.cssIcons && (0,mixins.appendStyles)(config.cssIcons, { unique: true, prepand: true });
        $el.empty();
        // @ts-ignore
        if (config.width)
            contEl.css('width', config.width);
        // @ts-ignore
        if (config.height)
            contEl.css('height', config.height);
        $el.append(Canvas.render());
        $el.append(Panels.render());
        // Load shallow editor
        var shallow = model.get('shallow');
        var shallowCanvasEl = shallow.get('Canvas').render();
        shallowCanvasEl.style.display = 'none';
        $el.append(shallowCanvasEl);
        $el.attr('class', classNames.join(' '));
        // @ts-ignore
        contEl.addClass("".concat(pfx, "editor-cont")).empty().append($el);
        modules.forEach(function (md) { return md.postRender && md.postRender(_this); });
        return this;
    };
    return EditorView;
}(common/* View */.G7));
/* harmony default export */ const editor_view_EditorView = (EditorView_EditorView);

;// CONCATENATED MODULE: ./src/editor/index.ts
var editor_assign = (undefined && undefined.__assign) || function () {
    editor_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return editor_assign.apply(this, arguments);
};
var editor_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var editor_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var editor_spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};




var Editor = /** @class */ (function () {
    function Editor(config, opts) {
        if (config === void 0) { config = {}; }
        if (opts === void 0) { opts = {}; }
        var _a;
        /**
         * Print safe HTML by using ES6 tagged template strings.
         * @param {Array<String>} literals
         * @param  {Array<String>} substs
         * @returns {String}
         * @example
         * const unsafeStr = '<script>....</script>';
         * const safeStr = '<b>Hello</b>';
         * // Use `$${var}` to avoid escaping
         * const strHtml = editor.html`Escaped ${unsafeStr} unescaped $${safeStr}`;
         */
        this.html = html;
        this.config = editor_assign(editor_assign(editor_assign({}, config_config), config), { pStylePrefix: (_a = config.stylePrefix) !== null && _a !== void 0 ? _a : config_config.stylePrefix });
        this.em = new model_Editor(this.config);
        this.$ = opts.$;
        this.em.init(this);
        this.editor = this.em;
    }
    Object.defineProperty(Editor.prototype, "Config", {
        get: function () {
            return this.em.config;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "I18n", {
        get: function () {
            return this.em.I18n;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Utils", {
        get: function () {
            return this.em.Utils;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Commands", {
        get: function () {
            return this.em.Commands;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Keymaps", {
        get: function () {
            return this.em.Keymaps;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Modal", {
        get: function () {
            return this.em.Modal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Panels", {
        get: function () {
            return this.em.Panels;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Canvas", {
        get: function () {
            return this.em.Canvas;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Parser", {
        get: function () {
            return this.em.Parser;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "CodeManager", {
        get: function () {
            return this.em.CodeManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "UndoManager", {
        get: function () {
            return this.em.UndoManager;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "RichTextEditor", {
        get: function () {
            return this.em.RichTextEditor;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Pages", {
        get: function () {
            return this.em.Pages;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Components", {
        get: function () {
            return this.em.Components;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "DomComponents", {
        get: function () {
            return this.em.Components;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Layers", {
        get: function () {
            return this.em.Layers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "LayerManager", {
        get: function () {
            return this.em.Layers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Css", {
        get: function () {
            return this.em.Css;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "CssComposer", {
        get: function () {
            return this.em.Css;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Storage", {
        get: function () {
            return this.em.Storage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "StorageManager", {
        get: function () {
            return this.em.Storage;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Assets", {
        get: function () {
            return this.em.Assets;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "AssetManager", {
        get: function () {
            return this.em.Assets;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Blocks", {
        get: function () {
            return this.em.Blocks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "BlockManager", {
        get: function () {
            return this.em.Blocks;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Traits", {
        get: function () {
            return this.em.Traits;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "TraitManager", {
        get: function () {
            return this.em.Traits;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Selectors", {
        get: function () {
            return this.em.Selectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "SelectorManager", {
        get: function () {
            return this.em.Selectors;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Styles", {
        get: function () {
            return this.em.Styles;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "StyleManager", {
        get: function () {
            return this.em.Styles;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "Devices", {
        get: function () {
            return this.em.Devices;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "DeviceManager", {
        get: function () {
            return this.em.Devices;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Editor.prototype, "EditorModel", {
        get: function () {
            return this.em;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Returns configuration object
     * @returns {any} Returns the configuration object or the value of the specified property
     */
    Editor.prototype.getConfig = function (prop) {
        return this.em.getConfig(prop);
    };
    /**
     * Returns HTML built inside canvas
     * @param {Object} [opts={}] Options
     * @param {Component} [opts.component] Return the HTML of a specific Component
     * @param {Boolean} [opts.cleanId=false] Remove unnecessary IDs (eg. those created automatically)
     * @returns {string} HTML string
     */
    Editor.prototype.getHtml = function (opts) {
        return this.em.getHtml(opts);
    };
    /**
     * Returns CSS built inside canvas
     * @param {Object} [opts={}] Options
     * @param {Component} [opts.component] Return the CSS of a specific Component
     * @param {Boolean} [opts.json=false] Return an array of CssRules instead of the CSS string
     * @param {Boolean} [opts.avoidProtected=false] Don't include protected CSS
     * @param {Boolean} [opts.onlyMatched=false] Return only rules matched by the passed component.
     * @param {Boolean} [opts.keepUnusedStyles=false] Force keep all defined rules. Toggle on in case output looks different inside/outside of the editor.
     * @returns {String|Array<CssRule>} CSS string or array of CssRules
     */
    Editor.prototype.getCss = function (opts) {
        return this.em.getCss(opts);
    };
    /**
     * Returns JS of all components
     * @param {Object} [opts={}] Options
     * @param {Component} [opts.component] Get the JS of a specific component
     * @returns {String} JS string
     */
    Editor.prototype.getJs = function (opts) {
        return this.em.getJs(opts);
    };
    /**
     * Return the complete tree of components. Use `getWrapper` to include also the wrapper
     * @return {Components}
     */
    Editor.prototype.getComponents = function () {
        return this.Components.getComponents();
    };
    /**
     * Return the wrapper and its all components
     * @return {Component}
     */
    Editor.prototype.getWrapper = function () {
        return this.Components.getWrapper();
    };
    /**
     * Set components inside editor's canvas. This method overrides actual components
     * @param {Array<Object>|Object|string} components HTML string or components model
     * @param {Object} opt the options object to be used by the [setComponents]{@link em#setComponents} method
     * @return {this}
     * @example
     * editor.setComponents('<div class="cls">New component</div>');
     * // or
     * editor.setComponents({
     *  type: 'text',
     *   classes:['cls'],
     *   content: 'New component'
     * });
     */
    Editor.prototype.setComponents = function (components, opt) {
        if (opt === void 0) { opt = {}; }
        this.em.setComponents(components, opt);
        return this;
    };
    /**
     * Add components
     * @param {Array<Object>|Object|string} components HTML string or components model
     * @param {Object} opts Options
     * @param {Boolean} [opts.avoidUpdateStyle=false] If the HTML string contains styles,
     * by default, they will be created and, if already exist, updated. When this option
     * is true, styles already created will not be updated.
     * @return {Array<Component>}
     * @example
     * editor.addComponents('<div class="cls">New component</div>');
     * // or
     * editor.addComponents({
     *  type: 'text',
     *   classes:['cls'],
     *   content: 'New component'
     * });
     */
    Editor.prototype.addComponents = function (components, opts) {
        return this.getWrapper().append(components, opts);
    };
    /**
     * Returns style in JSON format object
     * @return {Object}
     */
    Editor.prototype.getStyle = function () {
        return this.em.Css.getAll();
    };
    /**
     * Set style inside editor's canvas. This method overrides actual style
     * @param {Array<Object>|Object|string} style CSS string or style model
     * @return {this}
     * @example
     * editor.setStyle('.cls{color: red}');
     * //or
     * editor.setStyle({
     *   selectors: ['cls'],
     *   style: { color: 'red' }
     * });
     */
    Editor.prototype.setStyle = function (style, opt) {
        if (opt === void 0) { opt = {}; }
        this.em.setStyle(style, opt);
        return this;
    };
    /**
     * Add styles to the editor
     * @param {Array<Object>|Object|string} style CSS string or style model
     * @returns {Array<CssRule>} Array of created CssRule instances
     * @example
     * editor.addStyle('.cls{color: red}');
     */
    Editor.prototype.addStyle = function (style, opts) {
        if (opts === void 0) { opts = {}; }
        return this.em.addStyle(style, opts);
    };
    /**
     * Returns the last selected component, if there is one
     * @return {Model}
     */
    Editor.prototype.getSelected = function () {
        return this.em.getSelected();
    };
    /**
     * Returns an array of all selected components
     * @return {Array}
     */
    Editor.prototype.getSelectedAll = function () {
        return this.em.getSelectedAll();
    };
    /**
     * Get a stylable entity from the selected component.
     * If you select a component without classes the entity is the Component
     * itself and all changes will go inside its 'style' attribute. Otherwise,
     * if the selected component has one or more classes, the function will
     * return the corresponding CSS Rule
     * @return {Model}
     */
    Editor.prototype.getSelectedToStyle = function () {
        var selected = this.em.getSelected();
        if (selected) {
            return this.StyleManager.getModelToStyle(selected);
        }
    };
    /**
     * Select a component
     * @param  {Component|HTMLElement} el Component to select
     * @param  {Object} [opts] Options
     * @param  {Boolean} [opts.scroll] Scroll canvas to the selected element
     * @return {this}
     * @example
     * // Select dropped block
     * editor.on('block:drag:stop', function(model) {
     *  editor.select(model);
     * });
     */
    Editor.prototype.select = function (el, opts) {
        this.em.setSelected(el, opts);
        return this;
    };
    /**
     * Add component to selection
     * @param  {Component|HTMLElement|Array} el Component to select
     * @return {this}
     * @example
     * editor.selectAdd(model);
     */
    // selectAdd(el: Parameters<EditorModel['addSelected']>[0]) {
    Editor.prototype.selectAdd = function (el) {
        this.em.addSelected(el);
        return this;
    };
    /**
     * Remove component from selection
     * @param  {Component|HTMLElement|Array} el Component to select
     * @return {this}
     * @example
     * editor.selectRemove(model);
     */
    Editor.prototype.selectRemove = function (el) {
        this.em.removeSelected(el);
        return this;
    };
    /**
     * Toggle component selection
     * @param  {Component|HTMLElement|Array} el Component to select
     * @return {this}
     * @example
     * editor.selectToggle(model);
     */
    Editor.prototype.selectToggle = function (el) {
        this.em.toggleSelected(el);
        return this;
    };
    /**
     * Returns, if active, the Component enabled in rich text editing mode.
     * @returns {Component|null}
     * @example
     * const textComp = editor.getEditing();
     * if (textComp) {
     *  console.log('HTML: ', textComp.toHTML());
     * }
     */
    Editor.prototype.getEditing = function () {
        return this.em.getEditing();
    };
    /**
     * Set device to the editor. If the device exists it will
     * change the canvas to the proper width
     * @param {string} name Name of the device
     * @return {this}
     * @example
     * editor.setDevice('Tablet');
     */
    Editor.prototype.setDevice = function (name) {
        this.em.set('device', name);
        return this;
    };
    /**
     * Return the actual active device
     * @return {string} Device name
     * @example
     * var device = editor.getDevice();
     * console.log(device);
     * // 'Tablet'
     */
    Editor.prototype.getDevice = function () {
        return this.em.get('device');
    };
    /**
     * Execute command
     * @param {string} id Command ID
     * @param {Object} options Custom options
     * @return {*} The return is defined by the command
     * @example
     * editor.runCommand('myCommand', {someValue: 1});
     */
    Editor.prototype.runCommand = function (id, options) {
        if (options === void 0) { options = {}; }
        return this.Commands.run(id, options);
    };
    /**
     * Stop the command if stop method was provided
     * @param {string} id Command ID
     * @param {Object} options Custom options
     * @return {*} The return is defined by the command
     * @example
     * editor.stopCommand('myCommand', {someValue: 1});
     */
    Editor.prototype.stopCommand = function (id, options) {
        if (options === void 0) { options = {}; }
        return this.Commands.stop(id, options);
    };
    /**
     * Store data to the current storage.
     * This will reset the counter of changes (`editor.getDirtyCount()`).
     * @param {Object} [options] Storage options.
     * @returns {Object} Stored data.
     * @example
     * const storedData = await editor.store();
     */
    Editor.prototype.store = function (options) {
        return editor_awaiter(this, void 0, void 0, function () {
            return editor_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.em.store(options)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Load data from the current storage.
     * @param {Object} [options] Storage options.
     * @param {Object} [loadOptions={}] Load options.
     * @param {Boolean} [loadOptions.clear=false] Clear the editor state (eg. dirty counter, undo manager, etc.).
     * @returns {Object} Loaded data.
     * @example
     * const data = await editor.load();
     */
    Editor.prototype.load = function (options, loadOptions) {
        if (loadOptions === void 0) { loadOptions = {}; }
        return editor_awaiter(this, void 0, void 0, function () {
            return editor_generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.em.load(options, loadOptions)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Get the JSON project data, which could be stored and loaded back with `editor.loadProjectData(json)`
     * @returns {Object}
     * @example
     * console.log(editor.getProjectData());
     * // { pages: [...], styles: [...], ... }
     */
    Editor.prototype.getProjectData = function () {
        return this.em.storeData();
    };
    /**
     * Load data from the JSON project
     * @param {Object} data Project to load
     * @example
     * editor.loadProjectData({ pages: [...], styles: [...], ... })
     */
    Editor.prototype.loadProjectData = function (data) {
        return this.em.loadData(data);
    };
    Editor.prototype.storeData = function () {
        return this.em.storeData();
    };
    Editor.prototype.loadData = function (data) {
        return this.em.loadData(data);
    };
    /**
     * Returns container element. The one which was indicated as 'container'
     * on init method
     * @return {HTMLElement}
     */
    Editor.prototype.getContainer = function () {
        return this.config.el;
    };
    /**
     * Return the count of changes made to the content and not yet stored.
     * This count resets at any `store()`
     * @return {number}
     */
    Editor.prototype.getDirtyCount = function () {
        return this.em.getDirtyCount();
    };
    /**
     * Reset the counter of changes.
     */
    Editor.prototype.clearDirtyCount = function () {
        return this.em.clearDirtyCount();
    };
    /**
     * Update editor dimension offsets
     *
     * This method could be useful when you update, for example, some position
     * of the editor element (eg. canvas, panels, etc.) with CSS, where without
     * refresh you'll get misleading position of tools
     * @param {Object} [options] Options
     * @param {Boolean} [options.tools=false] Update the position of tools (eg. rich text editor, component highlighter, etc.)
     */
    Editor.prototype.refresh = function (opts) {
        this.em.refreshCanvas(opts);
    };
    /**
     * Replace the built-in Rich Text Editor with a custom one.
     * @param {Object} obj Custom RTE Interface
     * @example
     * editor.setCustomRte({
     *   // Function for enabling custom RTE
     *   // el is the HTMLElement of the double clicked Text Component
     *   // rte is the same instance you have returned the first time you call
     *   // enable(). This is useful if need to check if the RTE is already enabled so
     *   // ion this case you'll need to return the RTE and the end of the function
     *   enable: function(el, rte) {
     *     rte = new MyCustomRte(el, {}); // this depends on the Custom RTE API
     *     ...
     *     return rte; // return the RTE instance
     *   }
     *
     *   // Disable the editor, called for example when you unfocus the Text Component
     *  disable: function(el, rte) {
     *     rte.blur(); // this depends on the Custom RTE API
     *  }
     *
     * // Called when the Text Component is focused again. If you returned the RTE instance
     * // from the enable function, the enable won't be called again instead will call focus,
     * // in this case to avoid double binding of the editor
     *  focus: function (el, rte) {
     *   rte.focus(); // this depends on the Custom RTE API
     *  }
     * });
     */
    Editor.prototype.setCustomRte = function (obj) {
        this.RichTextEditor.customRte = obj;
    };
    /**
     * Replace the default CSS parser with a custom one.
     * The parser function receives a CSS string as a parameter and expects
     * an array of CSSRule objects as a result. If you need to remove the
     * custom parser, pass `null` as the argument
     * @param {Function|null} parser Parser function
     * @return {this}
     * @example
     * editor.setCustomParserCss(css => {
     *  const result = [];
     *  // ... parse the CSS string
     *  result.push({
     *    selectors: '.someclass, div .otherclass',
     *    style: { color: 'red' }
     *  })
     *  // ...
     *  return result;
     * });
     */
    Editor.prototype.setCustomParserCss = function (parser) {
        this.Parser.getConfig().parserCss = parser;
        return this;
    };
    /**
     * Change the global drag mode of components.
     * To get more about this feature read: https://github.com/GrapesJS/grapesjs/issues/1936
     * @param {String} value Drag mode, options: 'absolute' | 'translate'
     * @returns {this}
     */
    Editor.prototype.setDragMode = function (value) {
        this.em.setDragMode(value);
        return this;
    };
    /**
     * Trigger event log message
     * @param  {*} msg Message to log
     * @param  {Object} [opts={}] Custom options
     * @param  {String} [opts.ns=''] Namespace of the log (eg. to use in plugins)
     * @param  {String} [opts.level='debug'] Level of the log, `debug`, `info`, `warning`, `error`
     * @return {this}
     * @example
     * editor.log('Something done!', { ns: 'from-plugin-x', level: 'info' });
     * // This will trigger following events
     * // `log`, `log:info`, `log-from-plugin-x`, `log-from-plugin-x:info`
     * // Callbacks of those events will always receive the message and
     * // options, as arguments, eg:
     * // editor.on('log:info', (msg, opts) => console.info(msg, opts))
     */
    Editor.prototype.log = function (msg, opts) {
        if (opts === void 0) { opts = {}; }
        this.em.log(msg, opts);
        return this;
    };
    /**
     * Translate label
     * @param {String} key Label to translate
     * @param {Object} [opts] Options for the translation
     * @param {Object} [opts.params] Params for the translation
     * @param {Boolean} [opts.noWarn] Avoid warnings in case of missing resources
     * @returns {String}
     * @example
     * editor.t('msg');
     * // use params
     * editor.t('msg2', { params: { test: 'hello' } });
     * // custom local
     * editor.t('msg2', { params: { test: 'hello' } l: 'it' });
     */
    Editor.prototype.t = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = this.em).t.apply(_a, args);
    };
    /**
     * Attach event
     * @param  {string} event Event name
     * @param  {Function} callback Callback function
     * @return {this}
     */
    Editor.prototype.on = function (event, callback) {
        this.em.on(event, callback);
        return this;
    };
    /**
     * Attach event and detach it after the first run
     * @param  {string} event Event name
     * @param  {Function} callback Callback function
     * @return {this}
     */
    Editor.prototype.once = function (event, callback) {
        this.em.once(event, callback);
        return this;
    };
    /**
     * Detach event
     * @param  {string} event Event name
     * @param  {Function} callback Callback function
     * @return {this}
     */
    Editor.prototype.off = function (event, callback) {
        this.em.off(event, callback);
        return this;
    };
    /**
     * Trigger event
     * @param  {string} event Event to trigger
     * @return {this}
     */
    Editor.prototype.trigger = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.em.trigger.apply(this.em, editor_spreadArray([event], args, true));
        return this;
    };
    /**
     * Destroy the editor
     */
    Editor.prototype.destroy = function () {
        if (!this.em)
            return;
        this.em.destroyAll();
        this.editorView = undefined;
    };
    /**
     * Returns editor element
     * @return {HTMLElement}
     * @private
     */
    Editor.prototype.getEl = function () {
        var _a;
        return (_a = this.editorView) === null || _a === void 0 ? void 0 : _a.el;
    };
    /**
     * Returns editor model
     * @return {Model}
     * @private
     */
    Editor.prototype.getModel = function () {
        return this.em;
    };
    /**
     * Render editor
     * @return {HTMLElement}
     */
    Editor.prototype.render = function () {
        var _a;
        (_a = this.editorView) === null || _a === void 0 ? void 0 : _a.remove();
        this.editorView = new editor_view_EditorView(this.em);
        return this.editorView.render().el;
    };
    /**
     * Trigger a callback once the editor is loaded and rendered.
     * The callback will be executed immediately if the method is called on the already rendered editor.
     * @param  {Function} clb Callback to trigger
     * @example
     * editor.onReady(() => {
     *   // perform actions
     * });
     */
    Editor.prototype.onReady = function (clb) {
        this.em.get('ready') ? clb(this) : this.em.on('load', clb);
    };
    return Editor;
}());
/* harmony default export */ const src_editor = (Editor);

;// CONCATENATED MODULE: ./src/plugin_manager/index.ts


var getPluginById = function (pluginId, plugins) {
    var result = plugins.get(pluginId);
    // Try to search in global context
    if (!result) {
        var wplg = (0,mixins.getGlobal)()[pluginId];
        result = (wplg === null || wplg === void 0 ? void 0 : wplg.default) || wplg;
    }
    return result;
};
var getPlugin = function (plugin, plugins) {
    return (0,index_all.isString)(plugin)
        ? getPluginById(plugin, plugins)
        : (plugin === null || plugin === void 0 ? void 0 : plugin.default) || plugin;
};
var logPluginWarn = function (editor, plugin) {
    editor.getModel().logWarning("Plugin ".concat(plugin, " not found"), {
        context: 'plugins',
        plugin: plugin,
    });
};
var PluginManager = /** @class */ (function () {
    function PluginManager() {
        this.plugins = {};
    }
    /**
     * Add new plugin. Plugins could not be overwritten
     * @param {string} id Plugin ID
     * @param {Function} plugin Function which contains all plugin logic
     * @return {Function} The plugin function
     * @deprecated Don't use named plugins, create plugins as simple functions. More about [Plugins](https://grapesjs.com/docs/modules/Plugins.html)
     * @example
     * PluginManager.add('some-plugin', function(editor) {
     *   editor.Commands.add('new-command', {
     *     run:  function(editor, senderBtn){
     *       console.log('Executed new-command');
     *     }
     *   })
     * });
     */
    PluginManager.prototype.add = function (id, plugin) {
        var plg = this.get(id);
        if (plg) {
            return plg;
        }
        // @ts-ignore
        this.plugins[id] = plugin;
        return plugin;
    };
    /**
     * Returns plugin by ID
     * @param  {string} id Plugin ID
     * @return {Function|undefined} Plugin
     * @example
     * var plugin = PluginManager.get('some-plugin');
     * plugin(editor);
     */
    PluginManager.prototype.get = function (id) {
        return this.plugins[id];
    };
    /**
     * Returns object with all plugins
     */
    PluginManager.prototype.getAll = function () {
        return this.plugins;
    };
    return PluginManager;
}());
/* harmony default export */ const plugin_manager = (PluginManager);

;// CONCATENATED MODULE: ./src/utils/polyfills.ts
/**
 * File made for IE/Edge support
 * https://github.com/GrapesJS/grapesjs/issues/214
 */

/* harmony default export */ const polyfills = (function () {
    /**
     * Check if IE/Edge
     * @return {Boolean}
     */
    var isIE = function () {
        var match;
        var agent = window.navigator.userAgent;
        var rules = [
            ['edge', /Edge\/([0-9\._]+)/],
            ['ie', /MSIE\s(7\.0)/],
            ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
            ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ];
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            match = rule[1].exec(agent);
            if (match)
                break;
        }
        return !!match;
    };
    if ((0,mixins.hasWin)() && isIE()) {
        var originalCreateHTMLDocument_1 = DOMImplementation.prototype.createHTMLDocument;
        DOMImplementation.prototype.createHTMLDocument = function (title) {
            if (!title)
                title = '';
            return originalCreateHTMLDocument_1.apply(document.implementation, [title]);
        };
    }
});

;// CONCATENATED MODULE: ./src/index.ts
var src_assign = (undefined && undefined.__assign) || function () {
    src_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return src_assign.apply(this, arguments);
};





polyfills();
var plugins = new plugin_manager();
var editors = [];
var usePlugin = function (plugin, opts) {
    var pluginResult = getPlugin(plugin, plugins);
    return function (editor) {
        if (pluginResult) {
            pluginResult(editor, opts || {});
        }
        else {
            logPluginWarn(editor, plugin);
        }
    };
};
var grapesjs = {
    $: cash_dom["default"],
    editors: editors,
    plugins: plugins,
    usePlugin: usePlugin,
    // @ts-ignore Will be replaced on build
    version: '0.21.8',
    /**
     * Initialize the editor with passed options
     * @param {Object} config Configuration object
     * @param {string|HTMLElement} config.container Selector which indicates where render the editor
     * @param {Boolean} [config.autorender=true] If true, auto-render the content
     * @param {Array} [config.plugins=[]] Array of plugins to execute on start
     * @param {Object} [config.pluginsOpts={}] Custom options for plugins
     * @param {Boolean} [config.headless=false] Init headless editor
     * @return {Editor} Editor instance
     * @example
     * var editor = grapesjs.init({
     *   container: '#myeditor',
     *   components: '<article class="hello">Hello world</article>',
     *   style: '.hello{color: red}',
     * })
     */
    init: function (config) {
        if (config === void 0) { config = {}; }
        var headless = config.headless;
        var els = config.container;
        if (!els && !headless)
            throw new Error("'container' is required");
        var initConfig = src_assign(src_assign({ autorender: true, plugins: [], pluginsOpts: {} }, config), { grapesjs: this, el: headless ? undefined : (0,index_all.isElement)(els) ? els : document.querySelector(els) });
        var editor = new src_editor(initConfig, { $: cash_dom["default"] });
        var em = editor.getModel();
        // Load plugins
        initConfig.plugins.forEach(function (pluginId) {
            var plugin = getPlugin(pluginId, plugins);
            var plgOptions = initConfig.pluginsOpts[pluginId] || {};
            if (plugin) {
                plugin(editor, plgOptions);
            }
            else {
                logPluginWarn(editor, pluginId);
            }
        });
        // Execute `onLoad` on modules once all plugins are initialized.
        // A plugin might have extended/added some custom type so this
        // is a good point to load stuff like components, css rules, etc.
        em.loadOnStart();
        initConfig.autorender && !headless && editor.render();
        editors.push(editor);
        return editor;
    },
};
/* harmony default export */ const src_0 = (grapesjs);

})();

var __webpack_exports__default = __webpack_exports__.ZP;
var __webpack_exports__grapesjs = __webpack_exports__.kr;
var __webpack_exports__usePlugin = __webpack_exports__.j7;
export { __webpack_exports__default as default, __webpack_exports__grapesjs as grapesjs, __webpack_exports__usePlugin as usePlugin };

//# sourceMappingURL=grapes.mjs.map